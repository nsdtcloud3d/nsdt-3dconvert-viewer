var dN = Object.defineProperty;
var pN = (i, t, e) => t in i ? dN(i, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : i[t] = e;
var U = (i, t, e) => (pN(i, typeof t != "symbol" ? t + "" : t, e), e);
/**
 * @license
 * Copyright 2010-2023 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const wv = "149";
const Ms = "srgb", Zd = "srgb-linear";
const $w = "300 es";
let Ga = class {
  addEventListener(i, t) {
    this._listeners === void 0 && (this._listeners = {});
    const e = this._listeners;
    e[i] === void 0 && (e[i] = []), e[i].indexOf(t) === -1 && e[i].push(t);
  }
  hasEventListener(i, t) {
    if (this._listeners === void 0)
      return !1;
    const e = this._listeners;
    return e[i] !== void 0 && e[i].indexOf(t) !== -1;
  }
  removeEventListener(i, t) {
    if (this._listeners === void 0)
      return;
    const e = this._listeners[i];
    if (e !== void 0) {
      const n = e.indexOf(t);
      n !== -1 && e.splice(n, 1);
    }
  }
  dispatchEvent(i) {
    if (this._listeners === void 0)
      return;
    const t = this._listeners[i.type];
    if (t !== void 0) {
      i.target = this;
      const e = t.slice(0);
      for (let n = 0, r = e.length; n < r; n++)
        e[n].call(this, i);
      i.target = null;
    }
  }
};
const Vr = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
let wT = 1234567;
const Vl = Math.PI / 180, qd = 180 / Math.PI;
function Vi() {
  const i = 4294967295 * Math.random() | 0, t = 4294967295 * Math.random() | 0, e = 4294967295 * Math.random() | 0, n = 4294967295 * Math.random() | 0;
  return (Vr[255 & i] + Vr[i >> 8 & 255] + Vr[i >> 16 & 255] + Vr[i >> 24 & 255] + "-" + Vr[255 & t] + Vr[t >> 8 & 255] + "-" + Vr[t >> 16 & 15 | 64] + Vr[t >> 24 & 255] + "-" + Vr[63 & e | 128] + Vr[e >> 8 & 255] + "-" + Vr[e >> 16 & 255] + Vr[e >> 24 & 255] + Vr[255 & n] + Vr[n >> 8 & 255] + Vr[n >> 16 & 255] + Vr[n >> 24 & 255]).toLowerCase();
}
function rr(i, t, e) {
  return Math.max(t, Math.min(e, i));
}
function Qw(i, t) {
  return (i % t + t) % t;
}
function Pd(i, t, e) {
  return (1 - e) * i + e * t;
}
function tx(i) {
  return (i & i - 1) == 0 && i !== 0;
}
function vI(i) {
  return Math.pow(2, Math.ceil(Math.log(i) / Math.LN2));
}
function xv(i) {
  return Math.pow(2, Math.floor(Math.log(i) / Math.LN2));
}
function Na(i, t) {
  switch (t.constructor) {
    case Float32Array:
      return i;
    case Uint16Array:
      return i / 65535;
    case Uint8Array:
      return i / 255;
    case Int16Array:
      return Math.max(i / 32767, -1);
    case Int8Array:
      return Math.max(i / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function vn(i, t) {
  switch (t.constructor) {
    case Float32Array:
      return i;
    case Uint16Array:
      return Math.round(65535 * i);
    case Uint8Array:
      return Math.round(255 * i);
    case Int16Array:
      return Math.round(32767 * i);
    case Int8Array:
      return Math.round(127 * i);
    default:
      throw new Error("Invalid component type.");
  }
}
var Hl = Object.freeze({ __proto__: null, DEG2RAD: Vl, RAD2DEG: qd, ceilPowerOfTwo: vI, clamp: rr, damp: function(i, t, e, n) {
  return Pd(i, t, 1 - Math.exp(-e * n));
}, degToRad: function(i) {
  return i * Vl;
}, denormalize: Na, euclideanModulo: Qw, floorPowerOfTwo: xv, generateUUID: Vi, inverseLerp: function(i, t, e) {
  return i !== t ? (e - i) / (t - i) : 0;
}, isPowerOfTwo: tx, lerp: Pd, mapLinear: function(i, t, e, n, r) {
  return n + (i - t) * (r - n) / (e - t);
}, normalize: vn, pingpong: function(i, t = 1) {
  return t - Math.abs(Qw(i, 2 * t) - t);
}, radToDeg: function(i) {
  return i * qd;
}, randFloat: function(i, t) {
  return i + Math.random() * (t - i);
}, randFloatSpread: function(i) {
  return i * (0.5 - Math.random());
}, randInt: function(i, t) {
  return i + Math.floor(Math.random() * (t - i + 1));
}, seededRandom: function(i) {
  i !== void 0 && (wT = i);
  let t = wT += 1831565813;
  return t = Math.imul(t ^ t >>> 15, 1 | t), t ^= t + Math.imul(t ^ t >>> 7, 61 | t), ((t ^ t >>> 14) >>> 0) / 4294967296;
}, setQuaternionFromProperEuler: function(i, t, e, n, r) {
  const s = Math.cos, a = Math.sin, o = s(e / 2), l = a(e / 2), c = s((t + n) / 2), u = a((t + n) / 2), h = s((t - n) / 2), p = a((t - n) / 2), f = s((n - t) / 2), v = a((n - t) / 2);
  switch (r) {
    case "XYX":
      i.set(o * u, l * h, l * p, o * c);
      break;
    case "YZY":
      i.set(l * p, o * u, l * h, o * c);
      break;
    case "ZXZ":
      i.set(l * h, l * p, o * u, o * c);
      break;
    case "XZX":
      i.set(o * u, l * v, l * f, o * c);
      break;
    case "YXY":
      i.set(l * f, o * u, l * v, o * c);
      break;
    case "ZYZ":
      i.set(l * v, l * f, o * u, o * c);
      break;
    default:
      console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + r);
  }
}, smootherstep: function(i, t, e) {
  return i <= t ? 0 : i >= e ? 1 : (i = (i - t) / (e - t)) * i * i * (i * (6 * i - 15) + 10);
}, smoothstep: function(i, t, e) {
  return i <= t ? 0 : i >= e ? 1 : (i = (i - t) / (e - t)) * i * (3 - 2 * i);
} });
class wt {
  constructor(t = 0, e = 0) {
    wt.prototype.isVector2 = !0, this.x = t, this.y = e;
  }
  get width() {
    return this.x;
  }
  set width(t) {
    this.x = t;
  }
  get height() {
    return this.y;
  }
  set height(t) {
    this.y = t;
  }
  set(t, e) {
    return this.x = t, this.y = e, this;
  }
  setScalar(t) {
    return this.x = t, this.y = t, this;
  }
  setX(t) {
    return this.x = t, this;
  }
  setY(t) {
    return this.y = t, this;
  }
  setComponent(t, e) {
    switch (t) {
      case 0:
        this.x = e;
        break;
      case 1:
        this.y = e;
        break;
      default:
        throw new Error("index is out of range: " + t);
    }
    return this;
  }
  getComponent(t) {
    switch (t) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + t);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(t) {
    return this.x = t.x, this.y = t.y, this;
  }
  add(t) {
    return this.x += t.x, this.y += t.y, this;
  }
  addScalar(t) {
    return this.x += t, this.y += t, this;
  }
  addVectors(t, e) {
    return this.x = t.x + e.x, this.y = t.y + e.y, this;
  }
  addScaledVector(t, e) {
    return this.x += t.x * e, this.y += t.y * e, this;
  }
  sub(t) {
    return this.x -= t.x, this.y -= t.y, this;
  }
  subScalar(t) {
    return this.x -= t, this.y -= t, this;
  }
  subVectors(t, e) {
    return this.x = t.x - e.x, this.y = t.y - e.y, this;
  }
  multiply(t) {
    return this.x *= t.x, this.y *= t.y, this;
  }
  multiplyScalar(t) {
    return this.x *= t, this.y *= t, this;
  }
  divide(t) {
    return this.x /= t.x, this.y /= t.y, this;
  }
  divideScalar(t) {
    return this.multiplyScalar(1 / t);
  }
  applyMatrix3(t) {
    const e = this.x, n = this.y, r = t.elements;
    return this.x = r[0] * e + r[3] * n + r[6], this.y = r[1] * e + r[4] * n + r[7], this;
  }
  min(t) {
    return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this;
  }
  max(t) {
    return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this;
  }
  clamp(t, e) {
    return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this;
  }
  clampScalar(t, e) {
    return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this;
  }
  clampLength(t, e) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
  }
  roundToZero() {
    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this;
  }
  dot(t) {
    return this.x * t.x + this.y * t.y;
  }
  cross(t) {
    return this.x * t.y - this.y * t.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  distanceTo(t) {
    return Math.sqrt(this.distanceToSquared(t));
  }
  distanceToSquared(t) {
    const e = this.x - t.x, n = this.y - t.y;
    return e * e + n * n;
  }
  manhattanDistanceTo(t) {
    return Math.abs(this.x - t.x) + Math.abs(this.y - t.y);
  }
  setLength(t) {
    return this.normalize().multiplyScalar(t);
  }
  lerp(t, e) {
    return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this;
  }
  lerpVectors(t, e, n) {
    return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this;
  }
  equals(t) {
    return t.x === this.x && t.y === this.y;
  }
  fromArray(t, e = 0) {
    return this.x = t[e], this.y = t[e + 1], this;
  }
  toArray(t = [], e = 0) {
    return t[e] = this.x, t[e + 1] = this.y, t;
  }
  fromBufferAttribute(t, e) {
    return this.x = t.getX(e), this.y = t.getY(e), this;
  }
  rotateAround(t, e) {
    const n = Math.cos(e), r = Math.sin(e), s = this.x - t.x, a = this.y - t.y;
    return this.x = s * n - a * r + t.x, this.y = s * r + a * n + t.y, this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
}
class hi {
  constructor() {
    hi.prototype.isMatrix3 = !0, this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1];
  }
  set(t, e, n, r, s, a, o, l, c) {
    const u = this.elements;
    return u[0] = t, u[1] = r, u[2] = o, u[3] = e, u[4] = s, u[5] = l, u[6] = n, u[7] = a, u[8] = c, this;
  }
  identity() {
    return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
  }
  copy(t) {
    const e = this.elements, n = t.elements;
    return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], this;
  }
  extractBasis(t, e, n) {
    return t.setFromMatrix3Column(this, 0), e.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this;
  }
  setFromMatrix4(t) {
    const e = t.elements;
    return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this;
  }
  multiply(t) {
    return this.multiplyMatrices(this, t);
  }
  premultiply(t) {
    return this.multiplyMatrices(t, this);
  }
  multiplyMatrices(t, e) {
    const n = t.elements, r = e.elements, s = this.elements, a = n[0], o = n[3], l = n[6], c = n[1], u = n[4], h = n[7], p = n[2], f = n[5], v = n[8], m = r[0], y = r[3], _ = r[6], w = r[1], b = r[4], T = r[7], M = r[2], A = r[5], C = r[8];
    return s[0] = a * m + o * w + l * M, s[3] = a * y + o * b + l * A, s[6] = a * _ + o * T + l * C, s[1] = c * m + u * w + h * M, s[4] = c * y + u * b + h * A, s[7] = c * _ + u * T + h * C, s[2] = p * m + f * w + v * M, s[5] = p * y + f * b + v * A, s[8] = p * _ + f * T + v * C, this;
  }
  multiplyScalar(t) {
    const e = this.elements;
    return e[0] *= t, e[3] *= t, e[6] *= t, e[1] *= t, e[4] *= t, e[7] *= t, e[2] *= t, e[5] *= t, e[8] *= t, this;
  }
  determinant() {
    const t = this.elements, e = t[0], n = t[1], r = t[2], s = t[3], a = t[4], o = t[5], l = t[6], c = t[7], u = t[8];
    return e * a * u - e * o * c - n * s * u + n * o * l + r * s * c - r * a * l;
  }
  invert() {
    const t = this.elements, e = t[0], n = t[1], r = t[2], s = t[3], a = t[4], o = t[5], l = t[6], c = t[7], u = t[8], h = u * a - o * c, p = o * l - u * s, f = c * s - a * l, v = e * h + n * p + r * f;
    if (v === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const m = 1 / v;
    return t[0] = h * m, t[1] = (r * c - u * n) * m, t[2] = (o * n - r * a) * m, t[3] = p * m, t[4] = (u * e - r * l) * m, t[5] = (r * s - o * e) * m, t[6] = f * m, t[7] = (n * l - c * e) * m, t[8] = (a * e - n * s) * m, this;
  }
  transpose() {
    let t;
    const e = this.elements;
    return t = e[1], e[1] = e[3], e[3] = t, t = e[2], e[2] = e[6], e[6] = t, t = e[5], e[5] = e[7], e[7] = t, this;
  }
  getNormalMatrix(t) {
    return this.setFromMatrix4(t).invert().transpose();
  }
  transposeIntoArray(t) {
    const e = this.elements;
    return t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8], this;
  }
  setUvTransform(t, e, n, r, s, a, o) {
    const l = Math.cos(s), c = Math.sin(s);
    return this.set(n * l, n * c, -n * (l * a + c * o) + a + t, -r * c, r * l, -r * (-c * a + l * o) + o + e, 0, 0, 1), this;
  }
  scale(t, e) {
    return this.premultiply(Wy.makeScale(t, e)), this;
  }
  rotate(t) {
    return this.premultiply(Wy.makeRotation(-t)), this;
  }
  translate(t, e) {
    return this.premultiply(Wy.makeTranslation(t, e)), this;
  }
  makeTranslation(t, e) {
    return this.set(1, 0, t, 0, 1, e, 0, 0, 1), this;
  }
  makeRotation(t) {
    const e = Math.cos(t), n = Math.sin(t);
    return this.set(e, -n, 0, n, e, 0, 0, 0, 1), this;
  }
  makeScale(t, e) {
    return this.set(t, 0, 0, 0, e, 0, 0, 0, 1), this;
  }
  equals(t) {
    const e = this.elements, n = t.elements;
    for (let r = 0; r < 9; r++)
      if (e[r] !== n[r])
        return !1;
    return !0;
  }
  fromArray(t, e = 0) {
    for (let n = 0; n < 9; n++)
      this.elements[n] = t[n + e];
    return this;
  }
  toArray(t = [], e = 0) {
    const n = this.elements;
    return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t;
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
const Wy = new hi();
function yI(i) {
  for (let t = i.length - 1; t >= 0; --t)
    if (i[t] >= 65535)
      return !0;
  return !1;
}
const fN = { Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array };
function _h(i, t) {
  return new fN[i](t);
}
function Xd(i) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", i);
}
function jl(i) {
  return i < 0.04045 ? 0.0773993808 * i : Math.pow(0.9478672986 * i + 0.0521327014, 2.4);
}
function Qg(i) {
  return i < 31308e-7 ? 12.92 * i : 1.055 * Math.pow(i, 0.41666) - 0.055;
}
const Zy = { [Ms]: { [Zd]: jl }, [Zd]: { [Ms]: Qg } }, qr = { legacyMode: !0, get workingColorSpace() {
  return Zd;
}, set workingColorSpace(i) {
  console.warn("THREE.ColorManagement: .workingColorSpace is readonly.");
}, convert: function(i, t, e) {
  if (this.legacyMode || t === e || !t || !e)
    return i;
  if (Zy[t] && Zy[t][e] !== void 0) {
    const n = Zy[t][e];
    return i.r = n(i.r), i.g = n(i.g), i.b = n(i.b), i;
  }
  throw new Error("Unsupported color space conversion.");
}, fromWorkingColorSpace: function(i, t) {
  return this.convert(i, this.workingColorSpace, t);
}, toWorkingColorSpace: function(i, t) {
  return this.convert(i, t, this.workingColorSpace);
} }, _I = { aliceblue: 15792383, antiquewhite: 16444375, aqua: 65535, aquamarine: 8388564, azure: 15794175, beige: 16119260, bisque: 16770244, black: 0, blanchedalmond: 16772045, blue: 255, blueviolet: 9055202, brown: 10824234, burlywood: 14596231, cadetblue: 6266528, chartreuse: 8388352, chocolate: 13789470, coral: 16744272, cornflowerblue: 6591981, cornsilk: 16775388, crimson: 14423100, cyan: 65535, darkblue: 139, darkcyan: 35723, darkgoldenrod: 12092939, darkgray: 11119017, darkgreen: 25600, darkgrey: 11119017, darkkhaki: 12433259, darkmagenta: 9109643, darkolivegreen: 5597999, darkorange: 16747520, darkorchid: 10040012, darkred: 9109504, darksalmon: 15308410, darkseagreen: 9419919, darkslateblue: 4734347, darkslategray: 3100495, darkslategrey: 3100495, darkturquoise: 52945, darkviolet: 9699539, deeppink: 16716947, deepskyblue: 49151, dimgray: 6908265, dimgrey: 6908265, dodgerblue: 2003199, firebrick: 11674146, floralwhite: 16775920, forestgreen: 2263842, fuchsia: 16711935, gainsboro: 14474460, ghostwhite: 16316671, gold: 16766720, goldenrod: 14329120, gray: 8421504, green: 32768, greenyellow: 11403055, grey: 8421504, honeydew: 15794160, hotpink: 16738740, indianred: 13458524, indigo: 4915330, ivory: 16777200, khaki: 15787660, lavender: 15132410, lavenderblush: 16773365, lawngreen: 8190976, lemonchiffon: 16775885, lightblue: 11393254, lightcoral: 15761536, lightcyan: 14745599, lightgoldenrodyellow: 16448210, lightgray: 13882323, lightgreen: 9498256, lightgrey: 13882323, lightpink: 16758465, lightsalmon: 16752762, lightseagreen: 2142890, lightskyblue: 8900346, lightslategray: 7833753, lightslategrey: 7833753, lightsteelblue: 11584734, lightyellow: 16777184, lime: 65280, limegreen: 3329330, linen: 16445670, magenta: 16711935, maroon: 8388608, mediumaquamarine: 6737322, mediumblue: 205, mediumorchid: 12211667, mediumpurple: 9662683, mediumseagreen: 3978097, mediumslateblue: 8087790, mediumspringgreen: 64154, mediumturquoise: 4772300, mediumvioletred: 13047173, midnightblue: 1644912, mintcream: 16121850, mistyrose: 16770273, moccasin: 16770229, navajowhite: 16768685, navy: 128, oldlace: 16643558, olive: 8421376, olivedrab: 7048739, orange: 16753920, orangered: 16729344, orchid: 14315734, palegoldenrod: 15657130, palegreen: 10025880, paleturquoise: 11529966, palevioletred: 14381203, papayawhip: 16773077, peachpuff: 16767673, peru: 13468991, pink: 16761035, plum: 14524637, powderblue: 11591910, purple: 8388736, rebeccapurple: 6697881, red: 16711680, rosybrown: 12357519, royalblue: 4286945, saddlebrown: 9127187, salmon: 16416882, sandybrown: 16032864, seagreen: 3050327, seashell: 16774638, sienna: 10506797, silver: 12632256, skyblue: 8900331, slateblue: 6970061, slategray: 7372944, slategrey: 7372944, snow: 16775930, springgreen: 65407, steelblue: 4620980, tan: 13808780, teal: 32896, thistle: 14204888, tomato: 16737095, turquoise: 4251856, violet: 15631086, wheat: 16113331, white: 16777215, whitesmoke: 16119285, yellow: 16776960, yellowgreen: 10145074 }, fr = { r: 0, g: 0, b: 0 }, ms = { h: 0, s: 0, l: 0 }, Hf = { h: 0, s: 0, l: 0 };
function qy(i, t, e) {
  return e < 0 && (e += 1), e > 1 && (e -= 1), e < 1 / 6 ? i + 6 * (t - i) * e : e < 0.5 ? t : e < 2 / 3 ? i + 6 * (t - i) * (2 / 3 - e) : i;
}
function jf(i, t) {
  return t.r = i.r, t.g = i.g, t.b = i.b, t;
}
class Ht {
  constructor(t, e, n) {
    return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, e === void 0 && n === void 0 ? this.set(t) : this.setRGB(t, e, n);
  }
  set(t) {
    return t && t.isColor ? this.copy(t) : typeof t == "number" ? this.setHex(t) : typeof t == "string" && this.setStyle(t), this;
  }
  setScalar(t) {
    return this.r = t, this.g = t, this.b = t, this;
  }
  setHex(t, e = Ms) {
    return t = Math.floor(t), this.r = (t >> 16 & 255) / 255, this.g = (t >> 8 & 255) / 255, this.b = (255 & t) / 255, qr.toWorkingColorSpace(this, e), this;
  }
  setRGB(t, e, n, r = qr.workingColorSpace) {
    return this.r = t, this.g = e, this.b = n, qr.toWorkingColorSpace(this, r), this;
  }
  setHSL(t, e, n, r = qr.workingColorSpace) {
    if (t = Qw(t, 1), e = rr(e, 0, 1), n = rr(n, 0, 1), e === 0)
      this.r = this.g = this.b = n;
    else {
      const s = n <= 0.5 ? n * (1 + e) : n + e - n * e, a = 2 * n - s;
      this.r = qy(a, s, t + 1 / 3), this.g = qy(a, s, t), this.b = qy(a, s, t - 1 / 3);
    }
    return qr.toWorkingColorSpace(this, r), this;
  }
  setStyle(t, e = Ms) {
    function n(s) {
      s !== void 0 && parseFloat(s) < 1 && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.");
    }
    let r;
    if (r = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(t)) {
      let s;
      const a = r[1], o = r[2];
      switch (a) {
        case "rgb":
        case "rgba":
          if (s = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))
            return this.r = Math.min(255, parseInt(s[1], 10)) / 255, this.g = Math.min(255, parseInt(s[2], 10)) / 255, this.b = Math.min(255, parseInt(s[3], 10)) / 255, qr.toWorkingColorSpace(this, e), n(s[4]), this;
          if (s = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))
            return this.r = Math.min(100, parseInt(s[1], 10)) / 100, this.g = Math.min(100, parseInt(s[2], 10)) / 100, this.b = Math.min(100, parseInt(s[3], 10)) / 100, qr.toWorkingColorSpace(this, e), n(s[4]), this;
          break;
        case "hsl":
        case "hsla":
          if (s = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o)) {
            const l = parseFloat(s[1]) / 360, c = parseFloat(s[2]) / 100, u = parseFloat(s[3]) / 100;
            return n(s[4]), this.setHSL(l, c, u, e);
          }
      }
    } else if (r = /^\#([A-Fa-f\d]+)$/.exec(t)) {
      const s = r[1], a = s.length;
      if (a === 3)
        return this.r = parseInt(s.charAt(0) + s.charAt(0), 16) / 255, this.g = parseInt(s.charAt(1) + s.charAt(1), 16) / 255, this.b = parseInt(s.charAt(2) + s.charAt(2), 16) / 255, qr.toWorkingColorSpace(this, e), this;
      if (a === 6)
        return this.r = parseInt(s.charAt(0) + s.charAt(1), 16) / 255, this.g = parseInt(s.charAt(2) + s.charAt(3), 16) / 255, this.b = parseInt(s.charAt(4) + s.charAt(5), 16) / 255, qr.toWorkingColorSpace(this, e), this;
    }
    return t && t.length > 0 ? this.setColorName(t, e) : this;
  }
  setColorName(t, e = Ms) {
    const n = _I[t.toLowerCase()];
    return n !== void 0 ? this.setHex(n, e) : console.warn("THREE.Color: Unknown color " + t), this;
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(t) {
    return this.r = t.r, this.g = t.g, this.b = t.b, this;
  }
  copySRGBToLinear(t) {
    return this.r = jl(t.r), this.g = jl(t.g), this.b = jl(t.b), this;
  }
  copyLinearToSRGB(t) {
    return this.r = Qg(t.r), this.g = Qg(t.g), this.b = Qg(t.b), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  getHex(t = Ms) {
    return qr.fromWorkingColorSpace(jf(this, fr), t), rr(255 * fr.r, 0, 255) << 16 ^ rr(255 * fr.g, 0, 255) << 8 ^ rr(255 * fr.b, 0, 255) << 0;
  }
  getHexString(t = Ms) {
    return ("000000" + this.getHex(t).toString(16)).slice(-6);
  }
  getHSL(t, e = qr.workingColorSpace) {
    qr.fromWorkingColorSpace(jf(this, fr), e);
    const n = fr.r, r = fr.g, s = fr.b, a = Math.max(n, r, s), o = Math.min(n, r, s);
    let l, c;
    const u = (o + a) / 2;
    if (o === a)
      l = 0, c = 0;
    else {
      const h = a - o;
      switch (c = u <= 0.5 ? h / (a + o) : h / (2 - a - o), a) {
        case n:
          l = (r - s) / h + (r < s ? 6 : 0);
          break;
        case r:
          l = (s - n) / h + 2;
          break;
        case s:
          l = (n - r) / h + 4;
      }
      l /= 6;
    }
    return t.h = l, t.s = c, t.l = u, t;
  }
  getRGB(t, e = qr.workingColorSpace) {
    return qr.fromWorkingColorSpace(jf(this, fr), e), t.r = fr.r, t.g = fr.g, t.b = fr.b, t;
  }
  getStyle(t = Ms) {
    return qr.fromWorkingColorSpace(jf(this, fr), t), t !== Ms ? `color(${t} ${fr.r} ${fr.g} ${fr.b})` : `rgb(${255 * fr.r | 0},${255 * fr.g | 0},${255 * fr.b | 0})`;
  }
  offsetHSL(t, e, n) {
    return this.getHSL(ms), ms.h += t, ms.s += e, ms.l += n, this.setHSL(ms.h, ms.s, ms.l), this;
  }
  add(t) {
    return this.r += t.r, this.g += t.g, this.b += t.b, this;
  }
  addColors(t, e) {
    return this.r = t.r + e.r, this.g = t.g + e.g, this.b = t.b + e.b, this;
  }
  addScalar(t) {
    return this.r += t, this.g += t, this.b += t, this;
  }
  sub(t) {
    return this.r = Math.max(0, this.r - t.r), this.g = Math.max(0, this.g - t.g), this.b = Math.max(0, this.b - t.b), this;
  }
  multiply(t) {
    return this.r *= t.r, this.g *= t.g, this.b *= t.b, this;
  }
  multiplyScalar(t) {
    return this.r *= t, this.g *= t, this.b *= t, this;
  }
  lerp(t, e) {
    return this.r += (t.r - this.r) * e, this.g += (t.g - this.g) * e, this.b += (t.b - this.b) * e, this;
  }
  lerpColors(t, e, n) {
    return this.r = t.r + (e.r - t.r) * n, this.g = t.g + (e.g - t.g) * n, this.b = t.b + (e.b - t.b) * n, this;
  }
  lerpHSL(t, e) {
    this.getHSL(ms), t.getHSL(Hf);
    const n = Pd(ms.h, Hf.h, e), r = Pd(ms.s, Hf.s, e), s = Pd(ms.l, Hf.l, e);
    return this.setHSL(n, r, s), this;
  }
  equals(t) {
    return t.r === this.r && t.g === this.g && t.b === this.b;
  }
  fromArray(t, e = 0) {
    return this.r = t[e], this.g = t[e + 1], this.b = t[e + 2], this;
  }
  toArray(t = [], e = 0) {
    return t[e] = this.r, t[e + 1] = this.g, t[e + 2] = this.b, t;
  }
  fromBufferAttribute(t, e) {
    return this.r = t.getX(e), this.g = t.getY(e), this.b = t.getZ(e), this;
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r, yield this.g, yield this.b;
  }
}
let Ec;
Ht.NAMES = _I;
class kb {
  static getDataURL(t) {
    if (/^data:/i.test(t.src) || typeof HTMLCanvasElement > "u")
      return t.src;
    let e;
    if (t instanceof HTMLCanvasElement)
      e = t;
    else {
      Ec === void 0 && (Ec = Xd("canvas")), Ec.width = t.width, Ec.height = t.height;
      const n = Ec.getContext("2d");
      t instanceof ImageData ? n.putImageData(t, 0, 0) : n.drawImage(t, 0, 0, t.width, t.height), e = Ec;
    }
    return e.width > 2048 || e.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", t), e.toDataURL("image/jpeg", 0.6)) : e.toDataURL("image/png");
  }
  static sRGBToLinear(t) {
    if (typeof HTMLImageElement < "u" && t instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && t instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && t instanceof ImageBitmap) {
      const e = Xd("canvas");
      e.width = t.width, e.height = t.height;
      const n = e.getContext("2d");
      n.drawImage(t, 0, 0, t.width, t.height);
      const r = n.getImageData(0, 0, t.width, t.height), s = r.data;
      for (let a = 0; a < s.length; a++)
        s[a] = 255 * jl(s[a] / 255);
      return n.putImageData(r, 0, 0), e;
    }
    if (t.data) {
      const e = t.data.slice(0);
      for (let n = 0; n < e.length; n++)
        e instanceof Uint8Array || e instanceof Uint8ClampedArray ? e[n] = Math.floor(255 * jl(e[n] / 255)) : e[n] = jl(e[n]);
      return { data: e, width: t.width, height: t.height };
    }
    return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), t;
  }
}
class Dl {
  constructor(t = null) {
    this.isSource = !0, this.uuid = Vi(), this.data = t, this.version = 0;
  }
  set needsUpdate(t) {
    t === !0 && this.version++;
  }
  toJSON(t) {
    const e = t === void 0 || typeof t == "string";
    if (!e && t.images[this.uuid] !== void 0)
      return t.images[this.uuid];
    const n = { uuid: this.uuid, url: "" }, r = this.data;
    if (r !== null) {
      let s;
      if (Array.isArray(r)) {
        s = [];
        for (let a = 0, o = r.length; a < o; a++)
          r[a].isDataTexture ? s.push(Xy(r[a].image)) : s.push(Xy(r[a]));
      } else
        s = Xy(r);
      n.url = s;
    }
    return e || (t.images[this.uuid] = n), n;
  }
}
function Xy(i) {
  return typeof HTMLImageElement < "u" && i instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && i instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && i instanceof ImageBitmap ? kb.getDataURL(i) : i.data ? { data: Array.from(i.data), width: i.width, height: i.height, type: i.data.constructor.name } : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
}
let mN = 0;
class Yn extends Ga {
  constructor(t = Yn.DEFAULT_IMAGE, e = Yn.DEFAULT_MAPPING, n = 1001, r = 1001, s = 1006, a = 1008, o = 1023, l = 1009, c = Yn.DEFAULT_ANISOTROPY, u = 3e3) {
    super(), this.isTexture = !0, Object.defineProperty(this, "id", { value: mN++ }), this.uuid = Vi(), this.name = "", this.source = new Dl(t), this.mipmaps = [], this.mapping = e, this.wrapS = n, this.wrapT = r, this.magFilter = s, this.minFilter = a, this.anisotropy = c, this.format = o, this.internalFormat = null, this.type = l, this.offset = new wt(0, 0), this.repeat = new wt(1, 1), this.center = new wt(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new hi(), this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = u, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.needsPMREMUpdate = !1;
  }
  get image() {
    return this.source.data;
  }
  set image(t) {
    this.source.data = t;
  }
  updateMatrix() {
    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(t) {
    return this.name = t.name, this.source = t.source, this.mipmaps = t.mipmaps.slice(0), this.mapping = t.mapping, this.wrapS = t.wrapS, this.wrapT = t.wrapT, this.magFilter = t.magFilter, this.minFilter = t.minFilter, this.anisotropy = t.anisotropy, this.format = t.format, this.internalFormat = t.internalFormat, this.type = t.type, this.offset.copy(t.offset), this.repeat.copy(t.repeat), this.center.copy(t.center), this.rotation = t.rotation, this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrix.copy(t.matrix), this.generateMipmaps = t.generateMipmaps, this.premultiplyAlpha = t.premultiplyAlpha, this.flipY = t.flipY, this.unpackAlignment = t.unpackAlignment, this.encoding = t.encoding, this.userData = JSON.parse(JSON.stringify(t.userData)), this.needsUpdate = !0, this;
  }
  toJSON(t) {
    const e = t === void 0 || typeof t == "string";
    if (!e && t.textures[this.uuid] !== void 0)
      return t.textures[this.uuid];
    const n = { metadata: { version: 4.5, type: "Texture", generator: "Texture.toJSON" }, uuid: this.uuid, name: this.name, image: this.source.toJSON(t).uuid, mapping: this.mapping, repeat: [this.repeat.x, this.repeat.y], offset: [this.offset.x, this.offset.y], center: [this.center.x, this.center.y], rotation: this.rotation, wrap: [this.wrapS, this.wrapT], format: this.format, type: this.type, encoding: this.encoding, minFilter: this.minFilter, magFilter: this.magFilter, anisotropy: this.anisotropy, flipY: this.flipY, generateMipmaps: this.generateMipmaps, premultiplyAlpha: this.premultiplyAlpha, unpackAlignment: this.unpackAlignment };
    return Object.keys(this.userData).length > 0 && (n.userData = this.userData), e || (t.textures[this.uuid] = n), n;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(t) {
    if (this.mapping !== 300)
      return t;
    if (t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1)
      switch (this.wrapS) {
        case 1e3:
          t.x = t.x - Math.floor(t.x);
          break;
        case 1001:
          t.x = t.x < 0 ? 0 : 1;
          break;
        case 1002:
          Math.abs(Math.floor(t.x) % 2) === 1 ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x);
      }
    if (t.y < 0 || t.y > 1)
      switch (this.wrapT) {
        case 1e3:
          t.y = t.y - Math.floor(t.y);
          break;
        case 1001:
          t.y = t.y < 0 ? 0 : 1;
          break;
        case 1002:
          Math.abs(Math.floor(t.y) % 2) === 1 ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y);
      }
    return this.flipY && (t.y = 1 - t.y), t;
  }
  set needsUpdate(t) {
    t === !0 && (this.version++, this.source.needsUpdate = !0);
  }
}
Yn.DEFAULT_IMAGE = null, Yn.DEFAULT_MAPPING = 300, Yn.DEFAULT_ANISOTROPY = 1;
class ze {
  constructor(t = 0, e = 0, n = 0, r = 1) {
    ze.prototype.isVector4 = !0, this.x = t, this.y = e, this.z = n, this.w = r;
  }
  get width() {
    return this.z;
  }
  set width(t) {
    this.z = t;
  }
  get height() {
    return this.w;
  }
  set height(t) {
    this.w = t;
  }
  set(t, e, n, r) {
    return this.x = t, this.y = e, this.z = n, this.w = r, this;
  }
  setScalar(t) {
    return this.x = t, this.y = t, this.z = t, this.w = t, this;
  }
  setX(t) {
    return this.x = t, this;
  }
  setY(t) {
    return this.y = t, this;
  }
  setZ(t) {
    return this.z = t, this;
  }
  setW(t) {
    return this.w = t, this;
  }
  setComponent(t, e) {
    switch (t) {
      case 0:
        this.x = e;
        break;
      case 1:
        this.y = e;
        break;
      case 2:
        this.z = e;
        break;
      case 3:
        this.w = e;
        break;
      default:
        throw new Error("index is out of range: " + t);
    }
    return this;
  }
  getComponent(t) {
    switch (t) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + t);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(t) {
    return this.x = t.x, this.y = t.y, this.z = t.z, this.w = t.w !== void 0 ? t.w : 1, this;
  }
  add(t) {
    return this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this;
  }
  addScalar(t) {
    return this.x += t, this.y += t, this.z += t, this.w += t, this;
  }
  addVectors(t, e) {
    return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this.w = t.w + e.w, this;
  }
  addScaledVector(t, e) {
    return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this.w += t.w * e, this;
  }
  sub(t) {
    return this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this;
  }
  subScalar(t) {
    return this.x -= t, this.y -= t, this.z -= t, this.w -= t, this;
  }
  subVectors(t, e) {
    return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this.w = t.w - e.w, this;
  }
  multiply(t) {
    return this.x *= t.x, this.y *= t.y, this.z *= t.z, this.w *= t.w, this;
  }
  multiplyScalar(t) {
    return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this;
  }
  applyMatrix4(t) {
    const e = this.x, n = this.y, r = this.z, s = this.w, a = t.elements;
    return this.x = a[0] * e + a[4] * n + a[8] * r + a[12] * s, this.y = a[1] * e + a[5] * n + a[9] * r + a[13] * s, this.z = a[2] * e + a[6] * n + a[10] * r + a[14] * s, this.w = a[3] * e + a[7] * n + a[11] * r + a[15] * s, this;
  }
  divideScalar(t) {
    return this.multiplyScalar(1 / t);
  }
  setAxisAngleFromQuaternion(t) {
    this.w = 2 * Math.acos(t.w);
    const e = Math.sqrt(1 - t.w * t.w);
    return e < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = t.x / e, this.y = t.y / e, this.z = t.z / e), this;
  }
  setAxisAngleFromRotationMatrix(t) {
    let e, n, r, s;
    const l = t.elements, c = l[0], u = l[4], h = l[8], p = l[1], f = l[5], v = l[9], m = l[2], y = l[6], _ = l[10];
    if (Math.abs(u - p) < 0.01 && Math.abs(h - m) < 0.01 && Math.abs(v - y) < 0.01) {
      if (Math.abs(u + p) < 0.1 && Math.abs(h + m) < 0.1 && Math.abs(v + y) < 0.1 && Math.abs(c + f + _ - 3) < 0.1)
        return this.set(1, 0, 0, 0), this;
      e = Math.PI;
      const b = (c + 1) / 2, T = (f + 1) / 2, M = (_ + 1) / 2, A = (u + p) / 4, C = (h + m) / 4, I = (v + y) / 4;
      return b > T && b > M ? b < 0.01 ? (n = 0, r = 0.707106781, s = 0.707106781) : (n = Math.sqrt(b), r = A / n, s = C / n) : T > M ? T < 0.01 ? (n = 0.707106781, r = 0, s = 0.707106781) : (r = Math.sqrt(T), n = A / r, s = I / r) : M < 0.01 ? (n = 0.707106781, r = 0.707106781, s = 0) : (s = Math.sqrt(M), n = C / s, r = I / s), this.set(n, r, s, e), this;
    }
    let w = Math.sqrt((y - v) * (y - v) + (h - m) * (h - m) + (p - u) * (p - u));
    return Math.abs(w) < 1e-3 && (w = 1), this.x = (y - v) / w, this.y = (h - m) / w, this.z = (p - u) / w, this.w = Math.acos((c + f + _ - 1) / 2), this;
  }
  min(t) {
    return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this.w = Math.min(this.w, t.w), this;
  }
  max(t) {
    return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this.w = Math.max(this.w, t.w), this;
  }
  clamp(t, e) {
    return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this.w = Math.max(t.w, Math.min(e.w, this.w)), this;
  }
  clampScalar(t, e) {
    return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this.w = Math.max(t, Math.min(e, this.w)), this;
  }
  clampLength(t, e) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
  }
  roundToZero() {
    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
  }
  dot(t) {
    return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(t) {
    return this.normalize().multiplyScalar(t);
  }
  lerp(t, e) {
    return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this.w += (t.w - this.w) * e, this;
  }
  lerpVectors(t, e, n) {
    return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this.z = t.z + (e.z - t.z) * n, this.w = t.w + (e.w - t.w) * n, this;
  }
  equals(t) {
    return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w;
  }
  fromArray(t, e = 0) {
    return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this.w = t[e + 3], this;
  }
  toArray(t = [], e = 0) {
    return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t[e + 3] = this.w, t;
  }
  fromBufferAttribute(t, e) {
    return this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this.w = t.getW(e), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z, yield this.w;
  }
}
class ir extends Ga {
  constructor(t = 1, e = 1, n = {}) {
    super(), this.isWebGLRenderTarget = !0, this.width = t, this.height = e, this.depth = 1, this.scissor = new ze(0, 0, t, e), this.scissorTest = !1, this.viewport = new ze(0, 0, t, e);
    const r = { width: t, height: e, depth: 1 };
    this.texture = new Yn(r, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.encoding), this.texture.isRenderTargetTexture = !0, this.texture.flipY = !1, this.texture.generateMipmaps = n.generateMipmaps !== void 0 && n.generateMipmaps, this.texture.internalFormat = n.internalFormat !== void 0 ? n.internalFormat : null, this.texture.minFilter = n.minFilter !== void 0 ? n.minFilter : 1006, this.depthBuffer = n.depthBuffer === void 0 || n.depthBuffer, this.stencilBuffer = n.stencilBuffer !== void 0 && n.stencilBuffer, this.depthTexture = n.depthTexture !== void 0 ? n.depthTexture : null, this.samples = n.samples !== void 0 ? n.samples : 0;
  }
  setSize(t, e, n = 1) {
    this.width === t && this.height === e && this.depth === n || (this.width = t, this.height = e, this.depth = n, this.texture.image.width = t, this.texture.image.height = e, this.texture.image.depth = n, this.dispose()), this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(t) {
    this.width = t.width, this.height = t.height, this.depth = t.depth, this.viewport.copy(t.viewport), this.texture = t.texture.clone(), this.texture.isRenderTargetTexture = !0;
    const e = Object.assign({}, t.texture.image);
    return this.texture.source = new Dl(e), this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, t.depthTexture !== null && (this.depthTexture = t.depthTexture.clone()), this.samples = t.samples, this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class bv extends Yn {
  constructor(t = null, e = 1, n = 1, r = 1) {
    super(null), this.isDataArrayTexture = !0, this.image = { data: t, width: e, height: n, depth: r }, this.magFilter = 1003, this.minFilter = 1003, this.wrapR = 1001, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
  }
}
class ex extends Yn {
  constructor(t = null, e = 1, n = 1, r = 1) {
    super(null), this.isData3DTexture = !0, this.image = { data: t, width: e, height: n, depth: r }, this.magFilter = 1003, this.minFilter = 1003, this.wrapR = 1001, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
  }
}
class kn {
  constructor(t = 0, e = 0, n = 0, r = 1) {
    this.isQuaternion = !0, this._x = t, this._y = e, this._z = n, this._w = r;
  }
  static slerpFlat(t, e, n, r, s, a, o) {
    let l = n[r + 0], c = n[r + 1], u = n[r + 2], h = n[r + 3];
    const p = s[a + 0], f = s[a + 1], v = s[a + 2], m = s[a + 3];
    if (o === 0)
      return t[e + 0] = l, t[e + 1] = c, t[e + 2] = u, void (t[e + 3] = h);
    if (o === 1)
      return t[e + 0] = p, t[e + 1] = f, t[e + 2] = v, void (t[e + 3] = m);
    if (h !== m || l !== p || c !== f || u !== v) {
      let y = 1 - o;
      const _ = l * p + c * f + u * v + h * m, w = _ >= 0 ? 1 : -1, b = 1 - _ * _;
      if (b > Number.EPSILON) {
        const M = Math.sqrt(b), A = Math.atan2(M, _ * w);
        y = Math.sin(y * A) / M, o = Math.sin(o * A) / M;
      }
      const T = o * w;
      if (l = l * y + p * T, c = c * y + f * T, u = u * y + v * T, h = h * y + m * T, y === 1 - o) {
        const M = 1 / Math.sqrt(l * l + c * c + u * u + h * h);
        l *= M, c *= M, u *= M, h *= M;
      }
    }
    t[e] = l, t[e + 1] = c, t[e + 2] = u, t[e + 3] = h;
  }
  static multiplyQuaternionsFlat(t, e, n, r, s, a) {
    const o = n[r], l = n[r + 1], c = n[r + 2], u = n[r + 3], h = s[a], p = s[a + 1], f = s[a + 2], v = s[a + 3];
    return t[e] = o * v + u * h + l * f - c * p, t[e + 1] = l * v + u * p + c * h - o * f, t[e + 2] = c * v + u * f + o * p - l * h, t[e + 3] = u * v - o * h - l * p - c * f, t;
  }
  get x() {
    return this._x;
  }
  set x(t) {
    this._x = t, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(t) {
    this._y = t, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(t) {
    this._z = t, this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(t) {
    this._w = t, this._onChangeCallback();
  }
  set(t, e, n, r) {
    return this._x = t, this._y = e, this._z = n, this._w = r, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(t) {
    return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this._onChangeCallback(), this;
  }
  setFromEuler(t, e) {
    const n = t._x, r = t._y, s = t._z, a = t._order, o = Math.cos, l = Math.sin, c = o(n / 2), u = o(r / 2), h = o(s / 2), p = l(n / 2), f = l(r / 2), v = l(s / 2);
    switch (a) {
      case "XYZ":
        this._x = p * u * h + c * f * v, this._y = c * f * h - p * u * v, this._z = c * u * v + p * f * h, this._w = c * u * h - p * f * v;
        break;
      case "YXZ":
        this._x = p * u * h + c * f * v, this._y = c * f * h - p * u * v, this._z = c * u * v - p * f * h, this._w = c * u * h + p * f * v;
        break;
      case "ZXY":
        this._x = p * u * h - c * f * v, this._y = c * f * h + p * u * v, this._z = c * u * v + p * f * h, this._w = c * u * h - p * f * v;
        break;
      case "ZYX":
        this._x = p * u * h - c * f * v, this._y = c * f * h + p * u * v, this._z = c * u * v - p * f * h, this._w = c * u * h + p * f * v;
        break;
      case "YZX":
        this._x = p * u * h + c * f * v, this._y = c * f * h + p * u * v, this._z = c * u * v - p * f * h, this._w = c * u * h - p * f * v;
        break;
      case "XZY":
        this._x = p * u * h - c * f * v, this._y = c * f * h - p * u * v, this._z = c * u * v + p * f * h, this._w = c * u * h + p * f * v;
        break;
      default:
        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + a);
    }
    return e !== !1 && this._onChangeCallback(), this;
  }
  setFromAxisAngle(t, e) {
    const n = e / 2, r = Math.sin(n);
    return this._x = t.x * r, this._y = t.y * r, this._z = t.z * r, this._w = Math.cos(n), this._onChangeCallback(), this;
  }
  setFromRotationMatrix(t) {
    const e = t.elements, n = e[0], r = e[4], s = e[8], a = e[1], o = e[5], l = e[9], c = e[2], u = e[6], h = e[10], p = n + o + h;
    if (p > 0) {
      const f = 0.5 / Math.sqrt(p + 1);
      this._w = 0.25 / f, this._x = (u - l) * f, this._y = (s - c) * f, this._z = (a - r) * f;
    } else if (n > o && n > h) {
      const f = 2 * Math.sqrt(1 + n - o - h);
      this._w = (u - l) / f, this._x = 0.25 * f, this._y = (r + a) / f, this._z = (s + c) / f;
    } else if (o > h) {
      const f = 2 * Math.sqrt(1 + o - n - h);
      this._w = (s - c) / f, this._x = (r + a) / f, this._y = 0.25 * f, this._z = (l + u) / f;
    } else {
      const f = 2 * Math.sqrt(1 + h - n - o);
      this._w = (a - r) / f, this._x = (s + c) / f, this._y = (l + u) / f, this._z = 0.25 * f;
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(t, e) {
    let n = t.dot(e) + 1;
    return n < Number.EPSILON ? (n = 0, Math.abs(t.x) > Math.abs(t.z) ? (this._x = -t.y, this._y = t.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -t.z, this._z = t.y, this._w = n)) : (this._x = t.y * e.z - t.z * e.y, this._y = t.z * e.x - t.x * e.z, this._z = t.x * e.y - t.y * e.x, this._w = n), this.normalize();
  }
  angleTo(t) {
    return 2 * Math.acos(Math.abs(rr(this.dot(t), -1, 1)));
  }
  rotateTowards(t, e) {
    const n = this.angleTo(t);
    if (n === 0)
      return this;
    const r = Math.min(1, e / n);
    return this.slerp(t, r), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
  }
  dot(t) {
    return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w;
  }
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }
  normalize() {
    let t = this.length();
    return t === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (t = 1 / t, this._x = this._x * t, this._y = this._y * t, this._z = this._z * t, this._w = this._w * t), this._onChangeCallback(), this;
  }
  multiply(t) {
    return this.multiplyQuaternions(this, t);
  }
  premultiply(t) {
    return this.multiplyQuaternions(t, this);
  }
  multiplyQuaternions(t, e) {
    const n = t._x, r = t._y, s = t._z, a = t._w, o = e._x, l = e._y, c = e._z, u = e._w;
    return this._x = n * u + a * o + r * c - s * l, this._y = r * u + a * l + s * o - n * c, this._z = s * u + a * c + n * l - r * o, this._w = a * u - n * o - r * l - s * c, this._onChangeCallback(), this;
  }
  slerp(t, e) {
    if (e === 0)
      return this;
    if (e === 1)
      return this.copy(t);
    const n = this._x, r = this._y, s = this._z, a = this._w;
    let o = a * t._w + n * t._x + r * t._y + s * t._z;
    if (o < 0 ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t._z, o = -o) : this.copy(t), o >= 1)
      return this._w = a, this._x = n, this._y = r, this._z = s, this;
    const l = 1 - o * o;
    if (l <= Number.EPSILON) {
      const f = 1 - e;
      return this._w = f * a + e * this._w, this._x = f * n + e * this._x, this._y = f * r + e * this._y, this._z = f * s + e * this._z, this.normalize(), this._onChangeCallback(), this;
    }
    const c = Math.sqrt(l), u = Math.atan2(c, o), h = Math.sin((1 - e) * u) / c, p = Math.sin(e * u) / c;
    return this._w = a * h + this._w * p, this._x = n * h + this._x * p, this._y = r * h + this._y * p, this._z = s * h + this._z * p, this._onChangeCallback(), this;
  }
  slerpQuaternions(t, e, n) {
    return this.copy(t).slerp(e, n);
  }
  random() {
    const t = Math.random(), e = Math.sqrt(1 - t), n = Math.sqrt(t), r = 2 * Math.PI * Math.random(), s = 2 * Math.PI * Math.random();
    return this.set(e * Math.cos(r), n * Math.sin(s), n * Math.cos(s), e * Math.sin(r));
  }
  equals(t) {
    return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w;
  }
  fromArray(t, e = 0) {
    return this._x = t[e], this._y = t[e + 1], this._z = t[e + 2], this._w = t[e + 3], this._onChangeCallback(), this;
  }
  toArray(t = [], e = 0) {
    return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._w, t;
  }
  fromBufferAttribute(t, e) {
    return this._x = t.getX(e), this._y = t.getY(e), this._z = t.getZ(e), this._w = t.getW(e), this;
  }
  _onChange(t) {
    return this._onChangeCallback = t, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._w;
  }
}
let D = class wI {
  constructor(t = 0, e = 0, n = 0) {
    wI.prototype.isVector3 = !0, this.x = t, this.y = e, this.z = n;
  }
  set(t, e, n) {
    return n === void 0 && (n = this.z), this.x = t, this.y = e, this.z = n, this;
  }
  setScalar(t) {
    return this.x = t, this.y = t, this.z = t, this;
  }
  setX(t) {
    return this.x = t, this;
  }
  setY(t) {
    return this.y = t, this;
  }
  setZ(t) {
    return this.z = t, this;
  }
  setComponent(t, e) {
    switch (t) {
      case 0:
        this.x = e;
        break;
      case 1:
        this.y = e;
        break;
      case 2:
        this.z = e;
        break;
      default:
        throw new Error("index is out of range: " + t);
    }
    return this;
  }
  getComponent(t) {
    switch (t) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + t);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(t) {
    return this.x = t.x, this.y = t.y, this.z = t.z, this;
  }
  add(t) {
    return this.x += t.x, this.y += t.y, this.z += t.z, this;
  }
  addScalar(t) {
    return this.x += t, this.y += t, this.z += t, this;
  }
  addVectors(t, e) {
    return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this;
  }
  addScaledVector(t, e) {
    return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this;
  }
  sub(t) {
    return this.x -= t.x, this.y -= t.y, this.z -= t.z, this;
  }
  subScalar(t) {
    return this.x -= t, this.y -= t, this.z -= t, this;
  }
  subVectors(t, e) {
    return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this;
  }
  multiply(t) {
    return this.x *= t.x, this.y *= t.y, this.z *= t.z, this;
  }
  multiplyScalar(t) {
    return this.x *= t, this.y *= t, this.z *= t, this;
  }
  multiplyVectors(t, e) {
    return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this;
  }
  applyEuler(t) {
    return this.applyQuaternion(xT.setFromEuler(t));
  }
  applyAxisAngle(t, e) {
    return this.applyQuaternion(xT.setFromAxisAngle(t, e));
  }
  applyMatrix3(t) {
    const e = this.x, n = this.y, r = this.z, s = t.elements;
    return this.x = s[0] * e + s[3] * n + s[6] * r, this.y = s[1] * e + s[4] * n + s[7] * r, this.z = s[2] * e + s[5] * n + s[8] * r, this;
  }
  applyNormalMatrix(t) {
    return this.applyMatrix3(t).normalize();
  }
  applyMatrix4(t) {
    const e = this.x, n = this.y, r = this.z, s = t.elements, a = 1 / (s[3] * e + s[7] * n + s[11] * r + s[15]);
    return this.x = (s[0] * e + s[4] * n + s[8] * r + s[12]) * a, this.y = (s[1] * e + s[5] * n + s[9] * r + s[13]) * a, this.z = (s[2] * e + s[6] * n + s[10] * r + s[14]) * a, this;
  }
  applyQuaternion(t) {
    const e = this.x, n = this.y, r = this.z, s = t.x, a = t.y, o = t.z, l = t.w, c = l * e + a * r - o * n, u = l * n + o * e - s * r, h = l * r + s * n - a * e, p = -s * e - a * n - o * r;
    return this.x = c * l + p * -s + u * -o - h * -a, this.y = u * l + p * -a + h * -s - c * -o, this.z = h * l + p * -o + c * -a - u * -s, this;
  }
  project(t) {
    return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix);
  }
  unproject(t) {
    return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld);
  }
  transformDirection(t) {
    const e = this.x, n = this.y, r = this.z, s = t.elements;
    return this.x = s[0] * e + s[4] * n + s[8] * r, this.y = s[1] * e + s[5] * n + s[9] * r, this.z = s[2] * e + s[6] * n + s[10] * r, this.normalize();
  }
  divide(t) {
    return this.x /= t.x, this.y /= t.y, this.z /= t.z, this;
  }
  divideScalar(t) {
    return this.multiplyScalar(1 / t);
  }
  min(t) {
    return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this;
  }
  max(t) {
    return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this;
  }
  clamp(t, e) {
    return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this;
  }
  clampScalar(t, e) {
    return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this;
  }
  clampLength(t, e) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
  }
  roundToZero() {
    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
  }
  dot(t) {
    return this.x * t.x + this.y * t.y + this.z * t.z;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(t) {
    return this.normalize().multiplyScalar(t);
  }
  lerp(t, e) {
    return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this;
  }
  lerpVectors(t, e, n) {
    return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this.z = t.z + (e.z - t.z) * n, this;
  }
  cross(t) {
    return this.crossVectors(this, t);
  }
  crossVectors(t, e) {
    const n = t.x, r = t.y, s = t.z, a = e.x, o = e.y, l = e.z;
    return this.x = r * l - s * o, this.y = s * a - n * l, this.z = n * o - r * a, this;
  }
  projectOnVector(t) {
    const e = t.lengthSq();
    if (e === 0)
      return this.set(0, 0, 0);
    const n = t.dot(this) / e;
    return this.copy(t).multiplyScalar(n);
  }
  projectOnPlane(t) {
    return Yy.copy(this).projectOnVector(t), this.sub(Yy);
  }
  reflect(t) {
    return this.sub(Yy.copy(t).multiplyScalar(2 * this.dot(t)));
  }
  angleTo(t) {
    const e = Math.sqrt(this.lengthSq() * t.lengthSq());
    if (e === 0)
      return Math.PI / 2;
    const n = this.dot(t) / e;
    return Math.acos(rr(n, -1, 1));
  }
  distanceTo(t) {
    return Math.sqrt(this.distanceToSquared(t));
  }
  distanceToSquared(t) {
    const e = this.x - t.x, n = this.y - t.y, r = this.z - t.z;
    return e * e + n * n + r * r;
  }
  manhattanDistanceTo(t) {
    return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z);
  }
  setFromSpherical(t) {
    return this.setFromSphericalCoords(t.radius, t.phi, t.theta);
  }
  setFromSphericalCoords(t, e, n) {
    const r = Math.sin(e) * t;
    return this.x = r * Math.sin(n), this.y = Math.cos(e) * t, this.z = r * Math.cos(n), this;
  }
  setFromCylindrical(t) {
    return this.setFromCylindricalCoords(t.radius, t.theta, t.y);
  }
  setFromCylindricalCoords(t, e, n) {
    return this.x = t * Math.sin(e), this.y = n, this.z = t * Math.cos(e), this;
  }
  setFromMatrixPosition(t) {
    const e = t.elements;
    return this.x = e[12], this.y = e[13], this.z = e[14], this;
  }
  setFromMatrixScale(t) {
    const e = this.setFromMatrixColumn(t, 0).length(), n = this.setFromMatrixColumn(t, 1).length(), r = this.setFromMatrixColumn(t, 2).length();
    return this.x = e, this.y = n, this.z = r, this;
  }
  setFromMatrixColumn(t, e) {
    return this.fromArray(t.elements, 4 * e);
  }
  setFromMatrix3Column(t, e) {
    return this.fromArray(t.elements, 3 * e);
  }
  setFromEuler(t) {
    return this.x = t._x, this.y = t._y, this.z = t._z, this;
  }
  equals(t) {
    return t.x === this.x && t.y === this.y && t.z === this.z;
  }
  fromArray(t, e = 0) {
    return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this;
  }
  toArray(t = [], e = 0) {
    return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t;
  }
  fromBufferAttribute(t, e) {
    return this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
  }
  randomDirection() {
    const t = 2 * (Math.random() - 0.5), e = Math.random() * Math.PI * 2, n = Math.sqrt(1 - t ** 2);
    return this.x = n * Math.cos(e), this.y = n * Math.sin(e), this.z = t, this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
};
const Yy = new D(), xT = new kn();
class ke {
  constructor(t = new D(1 / 0, 1 / 0, 1 / 0), e = new D(-1 / 0, -1 / 0, -1 / 0)) {
    this.isBox3 = !0, this.min = t, this.max = e;
  }
  set(t, e) {
    return this.min.copy(t), this.max.copy(e), this;
  }
  setFromArray(t) {
    let e = 1 / 0, n = 1 / 0, r = 1 / 0, s = -1 / 0, a = -1 / 0, o = -1 / 0;
    for (let l = 0, c = t.length; l < c; l += 3) {
      const u = t[l], h = t[l + 1], p = t[l + 2];
      u < e && (e = u), h < n && (n = h), p < r && (r = p), u > s && (s = u), h > a && (a = h), p > o && (o = p);
    }
    return this.min.set(e, n, r), this.max.set(s, a, o), this;
  }
  setFromBufferAttribute(t) {
    let e = 1 / 0, n = 1 / 0, r = 1 / 0, s = -1 / 0, a = -1 / 0, o = -1 / 0;
    for (let l = 0, c = t.count; l < c; l++) {
      const u = t.getX(l), h = t.getY(l), p = t.getZ(l);
      u < e && (e = u), h < n && (n = h), p < r && (r = p), u > s && (s = u), h > a && (a = h), p > o && (o = p);
    }
    return this.min.set(e, n, r), this.max.set(s, a, o), this;
  }
  setFromPoints(t) {
    this.makeEmpty();
    for (let e = 0, n = t.length; e < n; e++)
      this.expandByPoint(t[e]);
    return this;
  }
  setFromCenterAndSize(t, e) {
    const n = il.copy(e).multiplyScalar(0.5);
    return this.min.copy(t).sub(n), this.max.copy(t).add(n), this;
  }
  setFromObject(t, e = !1) {
    return this.makeEmpty(), this.expandByObject(t, e);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(t) {
    return this.min.copy(t.min), this.max.copy(t.max), this;
  }
  makeEmpty() {
    return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  }
  getCenter(t) {
    return this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(t) {
    return this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min);
  }
  expandByPoint(t) {
    return this.min.min(t), this.max.max(t), this;
  }
  expandByVector(t) {
    return this.min.sub(t), this.max.add(t), this;
  }
  expandByScalar(t) {
    return this.min.addScalar(-t), this.max.addScalar(t), this;
  }
  expandByObject(t, e = !1) {
    t.updateWorldMatrix(!1, !1);
    const n = t.geometry;
    if (n !== void 0)
      if (e && n.attributes != null && n.attributes.position !== void 0) {
        const s = n.attributes.position;
        for (let a = 0, o = s.count; a < o; a++)
          il.fromBufferAttribute(s, a).applyMatrix4(t.matrixWorld), this.expandByPoint(il);
      } else
        n.boundingBox === null && n.computeBoundingBox(), Jy.copy(n.boundingBox), Jy.applyMatrix4(t.matrixWorld), this.union(Jy);
    const r = t.children;
    for (let s = 0, a = r.length; s < a; s++)
      this.expandByObject(r[s], e);
    return this;
  }
  containsPoint(t) {
    return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z);
  }
  containsBox(t) {
    return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z;
  }
  getParameter(t, e) {
    return e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z));
  }
  intersectsBox(t) {
    return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z);
  }
  intersectsSphere(t) {
    return this.clampPoint(t.center, il), il.distanceToSquared(t.center) <= t.radius * t.radius;
  }
  intersectsPlane(t) {
    let e, n;
    return t.normal.x > 0 ? (e = t.normal.x * this.min.x, n = t.normal.x * this.max.x) : (e = t.normal.x * this.max.x, n = t.normal.x * this.min.x), t.normal.y > 0 ? (e += t.normal.y * this.min.y, n += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y, n += t.normal.y * this.min.y), t.normal.z > 0 ? (e += t.normal.z * this.min.z, n += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z, n += t.normal.z * this.min.z), e <= -t.constant && n >= -t.constant;
  }
  intersectsTriangle(t) {
    if (this.isEmpty())
      return !1;
    this.getCenter(Lu), Gf.subVectors(this.max, Lu), Ac.subVectors(t.a, Lu), Cc.subVectors(t.b, Lu), Pc.subVectors(t.c, Lu), ho.subVectors(Cc, Ac), uo.subVectors(Pc, Cc), sl.subVectors(Ac, Pc);
    let e = [0, -ho.z, ho.y, 0, -uo.z, uo.y, 0, -sl.z, sl.y, ho.z, 0, -ho.x, uo.z, 0, -uo.x, sl.z, 0, -sl.x, -ho.y, ho.x, 0, -uo.y, uo.x, 0, -sl.y, sl.x, 0];
    return !!Ky(e, Ac, Cc, Pc, Gf) && (e = [1, 0, 0, 0, 1, 0, 0, 0, 1], !!Ky(e, Ac, Cc, Pc, Gf) && (Wf.crossVectors(ho, uo), e = [Wf.x, Wf.y, Wf.z], Ky(e, Ac, Cc, Pc, Gf)));
  }
  clampPoint(t, e) {
    return e.copy(t).clamp(this.min, this.max);
  }
  distanceToPoint(t) {
    return il.copy(t).clamp(this.min, this.max).sub(t).length();
  }
  getBoundingSphere(t) {
    return this.getCenter(t.center), t.radius = 0.5 * this.getSize(il).length(), t;
  }
  intersect(t) {
    return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this;
  }
  union(t) {
    return this.min.min(t.min), this.max.max(t.max), this;
  }
  applyMatrix4(t) {
    return this.isEmpty() || (ma[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t), ma[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t), ma[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t), ma[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t), ma[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t), ma[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t), ma[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t), ma[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t), this.setFromPoints(ma)), this;
  }
  translate(t) {
    return this.min.add(t), this.max.add(t), this;
  }
  equals(t) {
    return t.min.equals(this.min) && t.max.equals(this.max);
  }
}
const ma = [new D(), new D(), new D(), new D(), new D(), new D(), new D(), new D()], il = new D(), Jy = new ke(), Ac = new D(), Cc = new D(), Pc = new D(), ho = new D(), uo = new D(), sl = new D(), Lu = new D(), Gf = new D(), Wf = new D(), al = new D();
function Ky(i, t, e, n, r) {
  for (let s = 0, a = i.length - 3; s <= a; s += 3) {
    al.fromArray(i, s);
    const o = r.x * Math.abs(al.x) + r.y * Math.abs(al.y) + r.z * Math.abs(al.z), l = t.dot(al), c = e.dot(al), u = n.dot(al);
    if (Math.max(-Math.max(l, c, u), Math.min(l, c, u)) > o)
      return !1;
  }
  return !0;
}
const gN = new ke(), Bu = new D(), $y = new D();
class Mi {
  constructor(t = new D(), e = -1) {
    this.center = t, this.radius = e;
  }
  set(t, e) {
    return this.center.copy(t), this.radius = e, this;
  }
  setFromPoints(t, e) {
    const n = this.center;
    e !== void 0 ? n.copy(e) : gN.setFromPoints(t).getCenter(n);
    let r = 0;
    for (let s = 0, a = t.length; s < a; s++)
      r = Math.max(r, n.distanceToSquared(t[s]));
    return this.radius = Math.sqrt(r), this;
  }
  copy(t) {
    return this.center.copy(t.center), this.radius = t.radius, this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), this.radius = -1, this;
  }
  containsPoint(t) {
    return t.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(t) {
    return t.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(t) {
    const e = this.radius + t.radius;
    return t.center.distanceToSquared(this.center) <= e * e;
  }
  intersectsBox(t) {
    return t.intersectsSphere(this);
  }
  intersectsPlane(t) {
    return Math.abs(t.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(t, e) {
    const n = this.center.distanceToSquared(t);
    return e.copy(t), n > this.radius * this.radius && (e.sub(this.center).normalize(), e.multiplyScalar(this.radius).add(this.center)), e;
  }
  getBoundingBox(t) {
    return this.isEmpty() ? (t.makeEmpty(), t) : (t.set(this.center, this.center), t.expandByScalar(this.radius), t);
  }
  applyMatrix4(t) {
    return this.center.applyMatrix4(t), this.radius = this.radius * t.getMaxScaleOnAxis(), this;
  }
  translate(t) {
    return this.center.add(t), this;
  }
  expandByPoint(t) {
    if (this.isEmpty())
      return this.center.copy(t), this.radius = 0, this;
    Bu.subVectors(t, this.center);
    const e = Bu.lengthSq();
    if (e > this.radius * this.radius) {
      const n = Math.sqrt(e), r = 0.5 * (n - this.radius);
      this.center.addScaledVector(Bu, r / n), this.radius += r;
    }
    return this;
  }
  union(t) {
    return t.isEmpty() ? this : this.isEmpty() ? (this.copy(t), this) : (this.center.equals(t.center) === !0 ? this.radius = Math.max(this.radius, t.radius) : ($y.subVectors(t.center, this.center).setLength(t.radius), this.expandByPoint(Bu.copy(t.center).add($y)), this.expandByPoint(Bu.copy(t.center).sub($y))), this);
  }
  equals(t) {
    return t.center.equals(this.center) && t.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const ga = new D(), Qy = new D(), Zf = new D(), po = new D(), t_ = new D(), qf = new D(), e_ = new D();
class Uo {
  constructor(t = new D(), e = new D(0, 0, -1)) {
    this.origin = t, this.direction = e;
  }
  set(t, e) {
    return this.origin.copy(t), this.direction.copy(e), this;
  }
  copy(t) {
    return this.origin.copy(t.origin), this.direction.copy(t.direction), this;
  }
  at(t, e) {
    return e.copy(this.direction).multiplyScalar(t).add(this.origin);
  }
  lookAt(t) {
    return this.direction.copy(t).sub(this.origin).normalize(), this;
  }
  recast(t) {
    return this.origin.copy(this.at(t, ga)), this;
  }
  closestPointToPoint(t, e) {
    e.subVectors(t, this.origin);
    const n = e.dot(this.direction);
    return n < 0 ? e.copy(this.origin) : e.copy(this.direction).multiplyScalar(n).add(this.origin);
  }
  distanceToPoint(t) {
    return Math.sqrt(this.distanceSqToPoint(t));
  }
  distanceSqToPoint(t) {
    const e = ga.subVectors(t, this.origin).dot(this.direction);
    return e < 0 ? this.origin.distanceToSquared(t) : (ga.copy(this.direction).multiplyScalar(e).add(this.origin), ga.distanceToSquared(t));
  }
  distanceSqToSegment(t, e, n, r) {
    Qy.copy(t).add(e).multiplyScalar(0.5), Zf.copy(e).sub(t).normalize(), po.copy(this.origin).sub(Qy);
    const s = 0.5 * t.distanceTo(e), a = -this.direction.dot(Zf), o = po.dot(this.direction), l = -po.dot(Zf), c = po.lengthSq(), u = Math.abs(1 - a * a);
    let h, p, f, v;
    if (u > 0)
      if (h = a * l - o, p = a * o - l, v = s * u, h >= 0)
        if (p >= -v)
          if (p <= v) {
            const m = 1 / u;
            h *= m, p *= m, f = h * (h + a * p + 2 * o) + p * (a * h + p + 2 * l) + c;
          } else
            p = s, h = Math.max(0, -(a * p + o)), f = -h * h + p * (p + 2 * l) + c;
        else
          p = -s, h = Math.max(0, -(a * p + o)), f = -h * h + p * (p + 2 * l) + c;
      else
        p <= -v ? (h = Math.max(0, -(-a * s + o)), p = h > 0 ? -s : Math.min(Math.max(-s, -l), s), f = -h * h + p * (p + 2 * l) + c) : p <= v ? (h = 0, p = Math.min(Math.max(-s, -l), s), f = p * (p + 2 * l) + c) : (h = Math.max(0, -(a * s + o)), p = h > 0 ? s : Math.min(Math.max(-s, -l), s), f = -h * h + p * (p + 2 * l) + c);
    else
      p = a > 0 ? -s : s, h = Math.max(0, -(a * p + o)), f = -h * h + p * (p + 2 * l) + c;
    return n && n.copy(this.direction).multiplyScalar(h).add(this.origin), r && r.copy(Zf).multiplyScalar(p).add(Qy), f;
  }
  intersectSphere(t, e) {
    ga.subVectors(t.center, this.origin);
    const n = ga.dot(this.direction), r = ga.dot(ga) - n * n, s = t.radius * t.radius;
    if (r > s)
      return null;
    const a = Math.sqrt(s - r), o = n - a, l = n + a;
    return o < 0 && l < 0 ? null : o < 0 ? this.at(l, e) : this.at(o, e);
  }
  intersectsSphere(t) {
    return this.distanceSqToPoint(t.center) <= t.radius * t.radius;
  }
  distanceToPlane(t) {
    const e = t.normal.dot(this.direction);
    if (e === 0)
      return t.distanceToPoint(this.origin) === 0 ? 0 : null;
    const n = -(this.origin.dot(t.normal) + t.constant) / e;
    return n >= 0 ? n : null;
  }
  intersectPlane(t, e) {
    const n = this.distanceToPlane(t);
    return n === null ? null : this.at(n, e);
  }
  intersectsPlane(t) {
    const e = t.distanceToPoint(this.origin);
    return e === 0 ? !0 : t.normal.dot(this.direction) * e < 0;
  }
  intersectBox(t, e) {
    let n, r, s, a, o, l;
    const c = 1 / this.direction.x, u = 1 / this.direction.y, h = 1 / this.direction.z, p = this.origin;
    return c >= 0 ? (n = (t.min.x - p.x) * c, r = (t.max.x - p.x) * c) : (n = (t.max.x - p.x) * c, r = (t.min.x - p.x) * c), u >= 0 ? (s = (t.min.y - p.y) * u, a = (t.max.y - p.y) * u) : (s = (t.max.y - p.y) * u, a = (t.min.y - p.y) * u), n > a || s > r ? null : ((s > n || isNaN(n)) && (n = s), (a < r || isNaN(r)) && (r = a), h >= 0 ? (o = (t.min.z - p.z) * h, l = (t.max.z - p.z) * h) : (o = (t.max.z - p.z) * h, l = (t.min.z - p.z) * h), n > l || o > r ? null : ((o > n || n != n) && (n = o), (l < r || r != r) && (r = l), r < 0 ? null : this.at(n >= 0 ? n : r, e)));
  }
  intersectsBox(t) {
    return this.intersectBox(t, ga) !== null;
  }
  intersectTriangle(t, e, n, r, s) {
    t_.subVectors(e, t), qf.subVectors(n, t), e_.crossVectors(t_, qf);
    let a, o = this.direction.dot(e_);
    if (o > 0) {
      if (r)
        return null;
      a = 1;
    } else {
      if (!(o < 0))
        return null;
      a = -1, o = -o;
    }
    po.subVectors(this.origin, t);
    const l = a * this.direction.dot(qf.crossVectors(po, qf));
    if (l < 0)
      return null;
    const c = a * this.direction.dot(t_.cross(po));
    if (c < 0 || l + c > o)
      return null;
    const u = -a * po.dot(e_);
    return u < 0 ? null : this.at(u / o, s);
  }
  applyMatrix4(t) {
    return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this;
  }
  equals(t) {
    return t.origin.equals(this.origin) && t.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class Vt {
  constructor() {
    Vt.prototype.isMatrix4 = !0, this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
  }
  set(t, e, n, r, s, a, o, l, c, u, h, p, f, v, m, y) {
    const _ = this.elements;
    return _[0] = t, _[4] = e, _[8] = n, _[12] = r, _[1] = s, _[5] = a, _[9] = o, _[13] = l, _[2] = c, _[6] = u, _[10] = h, _[14] = p, _[3] = f, _[7] = v, _[11] = m, _[15] = y, this;
  }
  identity() {
    return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  clone() {
    return new Vt().fromArray(this.elements);
  }
  copy(t) {
    const e = this.elements, n = t.elements;
    return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], e[9] = n[9], e[10] = n[10], e[11] = n[11], e[12] = n[12], e[13] = n[13], e[14] = n[14], e[15] = n[15], this;
  }
  copyPosition(t) {
    const e = this.elements, n = t.elements;
    return e[12] = n[12], e[13] = n[13], e[14] = n[14], this;
  }
  setFromMatrix3(t) {
    const e = t.elements;
    return this.set(e[0], e[3], e[6], 0, e[1], e[4], e[7], 0, e[2], e[5], e[8], 0, 0, 0, 0, 1), this;
  }
  extractBasis(t, e, n) {
    return t.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this;
  }
  makeBasis(t, e, n) {
    return this.set(t.x, e.x, n.x, 0, t.y, e.y, n.y, 0, t.z, e.z, n.z, 0, 0, 0, 0, 1), this;
  }
  extractRotation(t) {
    const e = this.elements, n = t.elements, r = 1 / Dc.setFromMatrixColumn(t, 0).length(), s = 1 / Dc.setFromMatrixColumn(t, 1).length(), a = 1 / Dc.setFromMatrixColumn(t, 2).length();
    return e[0] = n[0] * r, e[1] = n[1] * r, e[2] = n[2] * r, e[3] = 0, e[4] = n[4] * s, e[5] = n[5] * s, e[6] = n[6] * s, e[7] = 0, e[8] = n[8] * a, e[9] = n[9] * a, e[10] = n[10] * a, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this;
  }
  makeRotationFromEuler(t) {
    const e = this.elements, n = t.x, r = t.y, s = t.z, a = Math.cos(n), o = Math.sin(n), l = Math.cos(r), c = Math.sin(r), u = Math.cos(s), h = Math.sin(s);
    if (t.order === "XYZ") {
      const p = a * u, f = a * h, v = o * u, m = o * h;
      e[0] = l * u, e[4] = -l * h, e[8] = c, e[1] = f + v * c, e[5] = p - m * c, e[9] = -o * l, e[2] = m - p * c, e[6] = v + f * c, e[10] = a * l;
    } else if (t.order === "YXZ") {
      const p = l * u, f = l * h, v = c * u, m = c * h;
      e[0] = p + m * o, e[4] = v * o - f, e[8] = a * c, e[1] = a * h, e[5] = a * u, e[9] = -o, e[2] = f * o - v, e[6] = m + p * o, e[10] = a * l;
    } else if (t.order === "ZXY") {
      const p = l * u, f = l * h, v = c * u, m = c * h;
      e[0] = p - m * o, e[4] = -a * h, e[8] = v + f * o, e[1] = f + v * o, e[5] = a * u, e[9] = m - p * o, e[2] = -a * c, e[6] = o, e[10] = a * l;
    } else if (t.order === "ZYX") {
      const p = a * u, f = a * h, v = o * u, m = o * h;
      e[0] = l * u, e[4] = v * c - f, e[8] = p * c + m, e[1] = l * h, e[5] = m * c + p, e[9] = f * c - v, e[2] = -c, e[6] = o * l, e[10] = a * l;
    } else if (t.order === "YZX") {
      const p = a * l, f = a * c, v = o * l, m = o * c;
      e[0] = l * u, e[4] = m - p * h, e[8] = v * h + f, e[1] = h, e[5] = a * u, e[9] = -o * u, e[2] = -c * u, e[6] = f * h + v, e[10] = p - m * h;
    } else if (t.order === "XZY") {
      const p = a * l, f = a * c, v = o * l, m = o * c;
      e[0] = l * u, e[4] = -h, e[8] = c * u, e[1] = p * h + m, e[5] = a * u, e[9] = f * h - v, e[2] = v * h - f, e[6] = o * u, e[10] = m * h + p;
    }
    return e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this;
  }
  makeRotationFromQuaternion(t) {
    return this.compose(vN, t, yN);
  }
  lookAt(t, e, n) {
    const r = this.elements;
    return Ri.subVectors(t, e), Ri.lengthSq() === 0 && (Ri.z = 1), Ri.normalize(), fo.crossVectors(n, Ri), fo.lengthSq() === 0 && (Math.abs(n.z) === 1 ? Ri.x += 1e-4 : Ri.z += 1e-4, Ri.normalize(), fo.crossVectors(n, Ri)), fo.normalize(), Xf.crossVectors(Ri, fo), r[0] = fo.x, r[4] = Xf.x, r[8] = Ri.x, r[1] = fo.y, r[5] = Xf.y, r[9] = Ri.y, r[2] = fo.z, r[6] = Xf.z, r[10] = Ri.z, this;
  }
  multiply(t) {
    return this.multiplyMatrices(this, t);
  }
  premultiply(t) {
    return this.multiplyMatrices(t, this);
  }
  multiplyMatrices(t, e) {
    const n = t.elements, r = e.elements, s = this.elements, a = n[0], o = n[4], l = n[8], c = n[12], u = n[1], h = n[5], p = n[9], f = n[13], v = n[2], m = n[6], y = n[10], _ = n[14], w = n[3], b = n[7], T = n[11], M = n[15], A = r[0], C = r[4], I = r[8], k = r[12], R = r[1], L = r[5], E = r[9], q = r[13], it = r[2], rt = r[6], ft = r[10], nt = r[14], vt = r[3], $ = r[7], W = r[11], ct = r[15];
    return s[0] = a * A + o * R + l * it + c * vt, s[4] = a * C + o * L + l * rt + c * $, s[8] = a * I + o * E + l * ft + c * W, s[12] = a * k + o * q + l * nt + c * ct, s[1] = u * A + h * R + p * it + f * vt, s[5] = u * C + h * L + p * rt + f * $, s[9] = u * I + h * E + p * ft + f * W, s[13] = u * k + h * q + p * nt + f * ct, s[2] = v * A + m * R + y * it + _ * vt, s[6] = v * C + m * L + y * rt + _ * $, s[10] = v * I + m * E + y * ft + _ * W, s[14] = v * k + m * q + y * nt + _ * ct, s[3] = w * A + b * R + T * it + M * vt, s[7] = w * C + b * L + T * rt + M * $, s[11] = w * I + b * E + T * ft + M * W, s[15] = w * k + b * q + T * nt + M * ct, this;
  }
  multiplyScalar(t) {
    const e = this.elements;
    return e[0] *= t, e[4] *= t, e[8] *= t, e[12] *= t, e[1] *= t, e[5] *= t, e[9] *= t, e[13] *= t, e[2] *= t, e[6] *= t, e[10] *= t, e[14] *= t, e[3] *= t, e[7] *= t, e[11] *= t, e[15] *= t, this;
  }
  determinant() {
    const t = this.elements, e = t[0], n = t[4], r = t[8], s = t[12], a = t[1], o = t[5], l = t[9], c = t[13], u = t[2], h = t[6], p = t[10], f = t[14];
    return t[3] * (+s * l * h - r * c * h - s * o * p + n * c * p + r * o * f - n * l * f) + t[7] * (+e * l * f - e * c * p + s * a * p - r * a * f + r * c * u - s * l * u) + t[11] * (+e * c * h - e * o * f - s * a * h + n * a * f + s * o * u - n * c * u) + t[15] * (-r * o * u - e * l * h + e * o * p + r * a * h - n * a * p + n * l * u);
  }
  transpose() {
    const t = this.elements;
    let e;
    return e = t[1], t[1] = t[4], t[4] = e, e = t[2], t[2] = t[8], t[8] = e, e = t[6], t[6] = t[9], t[9] = e, e = t[3], t[3] = t[12], t[12] = e, e = t[7], t[7] = t[13], t[13] = e, e = t[11], t[11] = t[14], t[14] = e, this;
  }
  setPosition(t, e, n) {
    const r = this.elements;
    return t.isVector3 ? (r[12] = t.x, r[13] = t.y, r[14] = t.z) : (r[12] = t, r[13] = e, r[14] = n), this;
  }
  invert() {
    const t = this.elements, e = t[0], n = t[1], r = t[2], s = t[3], a = t[4], o = t[5], l = t[6], c = t[7], u = t[8], h = t[9], p = t[10], f = t[11], v = t[12], m = t[13], y = t[14], _ = t[15], w = h * y * c - m * p * c + m * l * f - o * y * f - h * l * _ + o * p * _, b = v * p * c - u * y * c - v * l * f + a * y * f + u * l * _ - a * p * _, T = u * m * c - v * h * c + v * o * f - a * m * f - u * o * _ + a * h * _, M = v * h * l - u * m * l - v * o * p + a * m * p + u * o * y - a * h * y, A = e * w + n * b + r * T + s * M;
    if (A === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const C = 1 / A;
    return t[0] = w * C, t[1] = (m * p * s - h * y * s - m * r * f + n * y * f + h * r * _ - n * p * _) * C, t[2] = (o * y * s - m * l * s + m * r * c - n * y * c - o * r * _ + n * l * _) * C, t[3] = (h * l * s - o * p * s - h * r * c + n * p * c + o * r * f - n * l * f) * C, t[4] = b * C, t[5] = (u * y * s - v * p * s + v * r * f - e * y * f - u * r * _ + e * p * _) * C, t[6] = (v * l * s - a * y * s - v * r * c + e * y * c + a * r * _ - e * l * _) * C, t[7] = (a * p * s - u * l * s + u * r * c - e * p * c - a * r * f + e * l * f) * C, t[8] = T * C, t[9] = (v * h * s - u * m * s - v * n * f + e * m * f + u * n * _ - e * h * _) * C, t[10] = (a * m * s - v * o * s + v * n * c - e * m * c - a * n * _ + e * o * _) * C, t[11] = (u * o * s - a * h * s - u * n * c + e * h * c + a * n * f - e * o * f) * C, t[12] = M * C, t[13] = (u * m * r - v * h * r + v * n * p - e * m * p - u * n * y + e * h * y) * C, t[14] = (v * o * r - a * m * r - v * n * l + e * m * l + a * n * y - e * o * y) * C, t[15] = (a * h * r - u * o * r + u * n * l - e * h * l - a * n * p + e * o * p) * C, this;
  }
  scale(t) {
    const e = this.elements, n = t.x, r = t.y, s = t.z;
    return e[0] *= n, e[4] *= r, e[8] *= s, e[1] *= n, e[5] *= r, e[9] *= s, e[2] *= n, e[6] *= r, e[10] *= s, e[3] *= n, e[7] *= r, e[11] *= s, this;
  }
  getMaxScaleOnAxis() {
    const t = this.elements, e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2], n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6], r = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
    return Math.sqrt(Math.max(e, n, r));
  }
  makeTranslation(t, e, n) {
    return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1), this;
  }
  makeRotationX(t) {
    const e = Math.cos(t), n = Math.sin(t);
    return this.set(1, 0, 0, 0, 0, e, -n, 0, 0, n, e, 0, 0, 0, 0, 1), this;
  }
  makeRotationY(t) {
    const e = Math.cos(t), n = Math.sin(t);
    return this.set(e, 0, n, 0, 0, 1, 0, 0, -n, 0, e, 0, 0, 0, 0, 1), this;
  }
  makeRotationZ(t) {
    const e = Math.cos(t), n = Math.sin(t);
    return this.set(e, -n, 0, 0, n, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  makeRotationAxis(t, e) {
    const n = Math.cos(e), r = Math.sin(e), s = 1 - n, a = t.x, o = t.y, l = t.z, c = s * a, u = s * o;
    return this.set(c * a + n, c * o - r * l, c * l + r * o, 0, c * o + r * l, u * o + n, u * l - r * a, 0, c * l - r * o, u * l + r * a, s * l * l + n, 0, 0, 0, 0, 1), this;
  }
  makeScale(t, e, n) {
    return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this;
  }
  makeShear(t, e, n, r, s, a) {
    return this.set(1, n, s, 0, t, 1, a, 0, e, r, 1, 0, 0, 0, 0, 1), this;
  }
  compose(t, e, n) {
    const r = this.elements, s = e._x, a = e._y, o = e._z, l = e._w, c = s + s, u = a + a, h = o + o, p = s * c, f = s * u, v = s * h, m = a * u, y = a * h, _ = o * h, w = l * c, b = l * u, T = l * h, M = n.x, A = n.y, C = n.z;
    return r[0] = (1 - (m + _)) * M, r[1] = (f + T) * M, r[2] = (v - b) * M, r[3] = 0, r[4] = (f - T) * A, r[5] = (1 - (p + _)) * A, r[6] = (y + w) * A, r[7] = 0, r[8] = (v + b) * C, r[9] = (y - w) * C, r[10] = (1 - (p + m)) * C, r[11] = 0, r[12] = t.x, r[13] = t.y, r[14] = t.z, r[15] = 1, this;
  }
  decompose(t, e, n) {
    const r = this.elements;
    let s = Dc.set(r[0], r[1], r[2]).length();
    const a = Dc.set(r[4], r[5], r[6]).length(), o = Dc.set(r[8], r[9], r[10]).length();
    this.determinant() < 0 && (s = -s), t.x = r[12], t.y = r[13], t.z = r[14], gs.copy(this);
    const l = 1 / s, c = 1 / a, u = 1 / o;
    return gs.elements[0] *= l, gs.elements[1] *= l, gs.elements[2] *= l, gs.elements[4] *= c, gs.elements[5] *= c, gs.elements[6] *= c, gs.elements[8] *= u, gs.elements[9] *= u, gs.elements[10] *= u, e.setFromRotationMatrix(gs), n.x = s, n.y = a, n.z = o, this;
  }
  makePerspective(t, e, n, r, s, a) {
    const o = this.elements, l = 2 * s / (e - t), c = 2 * s / (n - r), u = (e + t) / (e - t), h = (n + r) / (n - r), p = -(a + s) / (a - s), f = -2 * a * s / (a - s);
    return o[0] = l, o[4] = 0, o[8] = u, o[12] = 0, o[1] = 0, o[5] = c, o[9] = h, o[13] = 0, o[2] = 0, o[6] = 0, o[10] = p, o[14] = f, o[3] = 0, o[7] = 0, o[11] = -1, o[15] = 0, this;
  }
  makeOrthographic(t, e, n, r, s, a) {
    const o = this.elements, l = 1 / (e - t), c = 1 / (n - r), u = 1 / (a - s), h = (e + t) * l, p = (n + r) * c, f = (a + s) * u;
    return o[0] = 2 * l, o[4] = 0, o[8] = 0, o[12] = -h, o[1] = 0, o[5] = 2 * c, o[9] = 0, o[13] = -p, o[2] = 0, o[6] = 0, o[10] = -2 * u, o[14] = -f, o[3] = 0, o[7] = 0, o[11] = 0, o[15] = 1, this;
  }
  equals(t) {
    const e = this.elements, n = t.elements;
    for (let r = 0; r < 16; r++)
      if (e[r] !== n[r])
        return !1;
    return !0;
  }
  fromArray(t, e = 0) {
    for (let n = 0; n < 16; n++)
      this.elements[n] = t[n + e];
    return this;
  }
  toArray(t = [], e = 0) {
    const n = this.elements;
    return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t[e + 9] = n[9], t[e + 10] = n[10], t[e + 11] = n[11], t[e + 12] = n[12], t[e + 13] = n[13], t[e + 14] = n[14], t[e + 15] = n[15], t;
  }
}
const Dc = new D(), gs = new Vt(), vN = new D(0, 0, 0), yN = new D(1, 1, 1), fo = new D(), Xf = new D(), Ri = new D(), bT = new Vt(), ST = new kn();
class nu {
  constructor(t = 0, e = 0, n = 0, r = nu.DEFAULT_ORDER) {
    this.isEuler = !0, this._x = t, this._y = e, this._z = n, this._order = r;
  }
  get x() {
    return this._x;
  }
  set x(t) {
    this._x = t, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(t) {
    this._y = t, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(t) {
    this._z = t, this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(t) {
    this._order = t, this._onChangeCallback();
  }
  set(t, e, n, r = this._order) {
    return this._x = t, this._y = e, this._z = n, this._order = r, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(t) {
    return this._x = t._x, this._y = t._y, this._z = t._z, this._order = t._order, this._onChangeCallback(), this;
  }
  setFromRotationMatrix(t, e = this._order, n = !0) {
    const r = t.elements, s = r[0], a = r[4], o = r[8], l = r[1], c = r[5], u = r[9], h = r[2], p = r[6], f = r[10];
    switch (e) {
      case "XYZ":
        this._y = Math.asin(rr(o, -1, 1)), Math.abs(o) < 0.9999999 ? (this._x = Math.atan2(-u, f), this._z = Math.atan2(-a, s)) : (this._x = Math.atan2(p, c), this._z = 0);
        break;
      case "YXZ":
        this._x = Math.asin(-rr(u, -1, 1)), Math.abs(u) < 0.9999999 ? (this._y = Math.atan2(o, f), this._z = Math.atan2(l, c)) : (this._y = Math.atan2(-h, s), this._z = 0);
        break;
      case "ZXY":
        this._x = Math.asin(rr(p, -1, 1)), Math.abs(p) < 0.9999999 ? (this._y = Math.atan2(-h, f), this._z = Math.atan2(-a, c)) : (this._y = 0, this._z = Math.atan2(l, s));
        break;
      case "ZYX":
        this._y = Math.asin(-rr(h, -1, 1)), Math.abs(h) < 0.9999999 ? (this._x = Math.atan2(p, f), this._z = Math.atan2(l, s)) : (this._x = 0, this._z = Math.atan2(-a, c));
        break;
      case "YZX":
        this._z = Math.asin(rr(l, -1, 1)), Math.abs(l) < 0.9999999 ? (this._x = Math.atan2(-u, c), this._y = Math.atan2(-h, s)) : (this._x = 0, this._y = Math.atan2(o, f));
        break;
      case "XZY":
        this._z = Math.asin(-rr(a, -1, 1)), Math.abs(a) < 0.9999999 ? (this._x = Math.atan2(p, c), this._y = Math.atan2(o, s)) : (this._x = Math.atan2(-u, f), this._y = 0);
        break;
      default:
        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + e);
    }
    return this._order = e, n === !0 && this._onChangeCallback(), this;
  }
  setFromQuaternion(t, e, n) {
    return bT.makeRotationFromQuaternion(t), this.setFromRotationMatrix(bT, e, n);
  }
  setFromVector3(t, e = this._order) {
    return this.set(t.x, t.y, t.z, e);
  }
  reorder(t) {
    return ST.setFromEuler(this), this.setFromQuaternion(ST, t);
  }
  equals(t) {
    return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order;
  }
  fromArray(t) {
    return this._x = t[0], this._y = t[1], this._z = t[2], t[3] !== void 0 && (this._order = t[3]), this._onChangeCallback(), this;
  }
  toArray(t = [], e = 0) {
    return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._order, t;
  }
  _onChange(t) {
    return this._onChangeCallback = t, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._order;
  }
}
nu.DEFAULT_ORDER = "XYZ";
class $v {
  constructor() {
    this.mask = 1;
  }
  set(t) {
    this.mask = (1 << t | 0) >>> 0;
  }
  enable(t) {
    this.mask |= 1 << t | 0;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(t) {
    this.mask ^= 1 << t | 0;
  }
  disable(t) {
    this.mask &= ~(1 << t | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(t) {
    return (this.mask & t.mask) != 0;
  }
  isEnabled(t) {
    return (this.mask & (1 << t | 0)) != 0;
  }
}
let _N = 0;
const MT = new D(), Rc = new kn(), va = new Vt(), Yf = new D(), zu = new D(), wN = new D(), xN = new kn(), TT = new D(1, 0, 0), ET = new D(0, 1, 0), AT = new D(0, 0, 1), bN = { type: "added" }, CT = { type: "removed" };
class Ue extends Ga {
  constructor() {
    super(), this.isObject3D = !0, Object.defineProperty(this, "id", { value: _N++ }), this.uuid = Vi(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = Ue.DEFAULT_UP.clone();
    const t = new D(), e = new nu(), n = new kn(), r = new D(1, 1, 1);
    e._onChange(function() {
      n.setFromEuler(e, !1);
    }), n._onChange(function() {
      e.setFromQuaternion(n, void 0, !1);
    }), Object.defineProperties(this, { position: { configurable: !0, enumerable: !0, value: t }, rotation: { configurable: !0, enumerable: !0, value: e }, quaternion: { configurable: !0, enumerable: !0, value: n }, scale: { configurable: !0, enumerable: !0, value: r }, modelViewMatrix: { value: new Vt() }, normalMatrix: { value: new hi() } }), this.matrix = new Vt(), this.matrixWorld = new Vt(), this.matrixAutoUpdate = Ue.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldNeedsUpdate = !1, this.matrixWorldAutoUpdate = Ue.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.layers = new $v(), this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {};
  }
  onBeforeRender() {
  }
  onAfterRender() {
  }
  applyMatrix4(t) {
    this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(t), this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(t) {
    return this.quaternion.premultiply(t), this;
  }
  setRotationFromAxisAngle(t, e) {
    this.quaternion.setFromAxisAngle(t, e);
  }
  setRotationFromEuler(t) {
    this.quaternion.setFromEuler(t, !0);
  }
  setRotationFromMatrix(t) {
    this.quaternion.setFromRotationMatrix(t);
  }
  setRotationFromQuaternion(t) {
    this.quaternion.copy(t);
  }
  rotateOnAxis(t, e) {
    return Rc.setFromAxisAngle(t, e), this.quaternion.multiply(Rc), this;
  }
  rotateOnWorldAxis(t, e) {
    return Rc.setFromAxisAngle(t, e), this.quaternion.premultiply(Rc), this;
  }
  rotateX(t) {
    return this.rotateOnAxis(TT, t);
  }
  rotateY(t) {
    return this.rotateOnAxis(ET, t);
  }
  rotateZ(t) {
    return this.rotateOnAxis(AT, t);
  }
  translateOnAxis(t, e) {
    return MT.copy(t).applyQuaternion(this.quaternion), this.position.add(MT.multiplyScalar(e)), this;
  }
  translateX(t) {
    return this.translateOnAxis(TT, t);
  }
  translateY(t) {
    return this.translateOnAxis(ET, t);
  }
  translateZ(t) {
    return this.translateOnAxis(AT, t);
  }
  localToWorld(t) {
    return this.updateWorldMatrix(!0, !1), t.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(t) {
    return this.updateWorldMatrix(!0, !1), t.applyMatrix4(va.copy(this.matrixWorld).invert());
  }
  lookAt(t, e, n) {
    t.isVector3 ? Yf.copy(t) : Yf.set(t, e, n);
    const r = this.parent;
    this.updateWorldMatrix(!0, !1), zu.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? va.lookAt(zu, Yf, this.up) : va.lookAt(Yf, zu, this.up), this.quaternion.setFromRotationMatrix(va), r && (va.extractRotation(r.matrixWorld), Rc.setFromRotationMatrix(va), this.quaternion.premultiply(Rc.invert()));
  }
  add(t) {
    if (arguments.length > 1) {
      for (let e = 0; e < arguments.length; e++)
        this.add(arguments[e]);
      return this;
    }
    return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t), this) : (t && t.isObject3D ? (t.parent !== null && t.parent.remove(t), t.parent = this, this.children.push(t), t.dispatchEvent(bN)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t), this);
  }
  remove(t) {
    if (arguments.length > 1) {
      for (let n = 0; n < arguments.length; n++)
        this.remove(arguments[n]);
      return this;
    }
    const e = this.children.indexOf(t);
    return e !== -1 && (t.parent = null, this.children.splice(e, 1), t.dispatchEvent(CT)), this;
  }
  removeFromParent() {
    const t = this.parent;
    return t !== null && t.remove(this), this;
  }
  clear() {
    for (let t = 0; t < this.children.length; t++) {
      const e = this.children[t];
      e.parent = null, e.dispatchEvent(CT);
    }
    return this.children.length = 0, this;
  }
  attach(t) {
    return this.updateWorldMatrix(!0, !1), va.copy(this.matrixWorld).invert(), t.parent !== null && (t.parent.updateWorldMatrix(!0, !1), va.multiply(t.parent.matrixWorld)), t.applyMatrix4(va), this.add(t), t.updateWorldMatrix(!1, !0), this;
  }
  getObjectById(t) {
    return this.getObjectByProperty("id", t);
  }
  getObjectByName(t) {
    return this.getObjectByProperty("name", t);
  }
  getObjectByProperty(t, e) {
    if (this[t] === e)
      return this;
    for (let n = 0, r = this.children.length; n < r; n++) {
      const s = this.children[n].getObjectByProperty(t, e);
      if (s !== void 0)
        return s;
    }
  }
  getObjectsByProperty(t, e) {
    let n = [];
    this[t] === e && n.push(this);
    for (let r = 0, s = this.children.length; r < s; r++) {
      const a = this.children[r].getObjectsByProperty(t, e);
      a.length > 0 && (n = n.concat(a));
    }
    return n;
  }
  getWorldPosition(t) {
    return this.updateWorldMatrix(!0, !1), t.setFromMatrixPosition(this.matrixWorld);
  }
  getWorldQuaternion(t) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(zu, t, wN), t;
  }
  getWorldScale(t) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(zu, xN, t), t;
  }
  getWorldDirection(t) {
    this.updateWorldMatrix(!0, !1);
    const e = this.matrixWorld.elements;
    return t.set(e[8], e[9], e[10]).normalize();
  }
  raycast() {
  }
  traverse(t) {
    t(this);
    const e = this.children;
    for (let n = 0, r = e.length; n < r; n++)
      e[n].traverse(t);
  }
  traverseVisible(t) {
    if (this.visible === !1)
      return;
    t(this);
    const e = this.children;
    for (let n = 0, r = e.length; n < r; n++)
      e[n].traverseVisible(t);
  }
  traverseAncestors(t) {
    const e = this.parent;
    e !== null && (t(e), e.traverseAncestors(t));
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0;
  }
  updateMatrixWorld(t) {
    this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t) && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, t = !0);
    const e = this.children;
    for (let n = 0, r = e.length; n < r; n++) {
      const s = e[n];
      s.matrixWorldAutoUpdate !== !0 && t !== !0 || s.updateMatrixWorld(t);
    }
  }
  updateWorldMatrix(t, e) {
    const n = this.parent;
    if (t === !0 && n !== null && n.matrixWorldAutoUpdate === !0 && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), e === !0) {
      const r = this.children;
      for (let s = 0, a = r.length; s < a; s++) {
        const o = r[s];
        o.matrixWorldAutoUpdate === !0 && o.updateWorldMatrix(!1, !0);
      }
    }
  }
  toJSON(t) {
    const e = t === void 0 || typeof t == "string", n = {};
    e && (t = { geometries: {}, materials: {}, textures: {}, images: {}, shapes: {}, skeletons: {}, animations: {}, nodes: {} }, n.metadata = { version: 4.5, type: "Object", generator: "Object3D.toJSON" });
    const r = {};
    function s(o, l) {
      return o[l.uuid] === void 0 && (o[l.uuid] = l.toJSON(t)), l.uuid;
    }
    if (r.uuid = this.uuid, r.type = this.type, this.name !== "" && (r.name = this.name), this.castShadow === !0 && (r.castShadow = !0), this.receiveShadow === !0 && (r.receiveShadow = !0), this.visible === !1 && (r.visible = !1), this.frustumCulled === !1 && (r.frustumCulled = !1), this.renderOrder !== 0 && (r.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (r.userData = this.userData), r.layers = this.layers.mask, r.matrix = this.matrix.toArray(), this.matrixAutoUpdate === !1 && (r.matrixAutoUpdate = !1), this.isInstancedMesh && (r.type = "InstancedMesh", r.count = this.count, r.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (r.instanceColor = this.instanceColor.toJSON())), this.isScene)
      this.background && (this.background.isColor ? r.background = this.background.toJSON() : this.background.isTexture && (r.background = this.background.toJSON(t).uuid)), this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (r.environment = this.environment.toJSON(t).uuid);
    else if (this.isMesh || this.isLine || this.isPoints) {
      r.geometry = s(t.geometries, this.geometry);
      const o = this.geometry.parameters;
      if (o !== void 0 && o.shapes !== void 0) {
        const l = o.shapes;
        if (Array.isArray(l))
          for (let c = 0, u = l.length; c < u; c++) {
            const h = l[c];
            s(t.shapes, h);
          }
        else
          s(t.shapes, l);
      }
    }
    if (this.isSkinnedMesh && (r.bindMode = this.bindMode, r.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (s(t.skeletons, this.skeleton), r.skeleton = this.skeleton.uuid)), this.material !== void 0)
      if (Array.isArray(this.material)) {
        const o = [];
        for (let l = 0, c = this.material.length; l < c; l++)
          o.push(s(t.materials, this.material[l]));
        r.material = o;
      } else
        r.material = s(t.materials, this.material);
    if (this.children.length > 0) {
      r.children = [];
      for (let o = 0; o < this.children.length; o++)
        r.children.push(this.children[o].toJSON(t).object);
    }
    if (this.animations.length > 0) {
      r.animations = [];
      for (let o = 0; o < this.animations.length; o++) {
        const l = this.animations[o];
        r.animations.push(s(t.animations, l));
      }
    }
    if (e) {
      const o = a(t.geometries), l = a(t.materials), c = a(t.textures), u = a(t.images), h = a(t.shapes), p = a(t.skeletons), f = a(t.animations), v = a(t.nodes);
      o.length > 0 && (n.geometries = o), l.length > 0 && (n.materials = l), c.length > 0 && (n.textures = c), u.length > 0 && (n.images = u), h.length > 0 && (n.shapes = h), p.length > 0 && (n.skeletons = p), f.length > 0 && (n.animations = f), v.length > 0 && (n.nodes = v);
    }
    return n.object = r, n;
    function a(o) {
      const l = [];
      for (const c in o) {
        const u = o[c];
        delete u.metadata, l.push(u);
      }
      return l;
    }
  }
  clone(t) {
    return new this.constructor().copy(this, t);
  }
  copy(t, e = !0) {
    if (this.name = t.name, this.up.copy(t.up), this.position.copy(t.position), this.rotation.order = t.rotation.order, this.quaternion.copy(t.quaternion), this.scale.copy(t.scale), this.matrix.copy(t.matrix), this.matrixWorld.copy(t.matrixWorld), this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate, this.matrixWorldAutoUpdate = t.matrixWorldAutoUpdate, this.layers.mask = t.layers.mask, this.visible = t.visible, this.castShadow = t.castShadow, this.receiveShadow = t.receiveShadow, this.frustumCulled = t.frustumCulled, this.renderOrder = t.renderOrder, this.userData = JSON.parse(JSON.stringify(t.userData)), e === !0)
      for (let n = 0; n < t.children.length; n++) {
        const r = t.children[n];
        this.add(r.clone());
      }
    return this;
  }
}
Ue.DEFAULT_UP = new D(0, 1, 0), Ue.DEFAULT_MATRIX_AUTO_UPDATE = !0, Ue.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const vs = new D(), ya = new D(), n_ = new D(), _a = new D(), Ic = new D(), Oc = new D(), PT = new D(), r_ = new D(), i_ = new D(), s_ = new D();
class Pr {
  constructor(t = new D(), e = new D(), n = new D()) {
    this.a = t, this.b = e, this.c = n;
  }
  static getNormal(t, e, n, r) {
    r.subVectors(n, e), vs.subVectors(t, e), r.cross(vs);
    const s = r.lengthSq();
    return s > 0 ? r.multiplyScalar(1 / Math.sqrt(s)) : r.set(0, 0, 0);
  }
  static getBarycoord(t, e, n, r, s) {
    vs.subVectors(r, e), ya.subVectors(n, e), n_.subVectors(t, e);
    const a = vs.dot(vs), o = vs.dot(ya), l = vs.dot(n_), c = ya.dot(ya), u = ya.dot(n_), h = a * c - o * o;
    if (h === 0)
      return s.set(-2, -1, -1);
    const p = 1 / h, f = (c * l - o * u) * p, v = (a * u - o * l) * p;
    return s.set(1 - f - v, v, f);
  }
  static containsPoint(t, e, n, r) {
    return this.getBarycoord(t, e, n, r, _a), _a.x >= 0 && _a.y >= 0 && _a.x + _a.y <= 1;
  }
  static getUV(t, e, n, r, s, a, o, l) {
    return this.getBarycoord(t, e, n, r, _a), l.set(0, 0), l.addScaledVector(s, _a.x), l.addScaledVector(a, _a.y), l.addScaledVector(o, _a.z), l;
  }
  static isFrontFacing(t, e, n, r) {
    return vs.subVectors(n, e), ya.subVectors(t, e), vs.cross(ya).dot(r) < 0;
  }
  set(t, e, n) {
    return this.a.copy(t), this.b.copy(e), this.c.copy(n), this;
  }
  setFromPointsAndIndices(t, e, n, r) {
    return this.a.copy(t[e]), this.b.copy(t[n]), this.c.copy(t[r]), this;
  }
  setFromAttributeAndIndices(t, e, n, r) {
    return this.a.fromBufferAttribute(t, e), this.b.fromBufferAttribute(t, n), this.c.fromBufferAttribute(t, r), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(t) {
    return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this;
  }
  getArea() {
    return vs.subVectors(this.c, this.b), ya.subVectors(this.a, this.b), 0.5 * vs.cross(ya).length();
  }
  getMidpoint(t) {
    return t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  }
  getNormal(t) {
    return Pr.getNormal(this.a, this.b, this.c, t);
  }
  getPlane(t) {
    return t.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(t, e) {
    return Pr.getBarycoord(t, this.a, this.b, this.c, e);
  }
  getUV(t, e, n, r, s) {
    return Pr.getUV(t, this.a, this.b, this.c, e, n, r, s);
  }
  containsPoint(t) {
    return Pr.containsPoint(t, this.a, this.b, this.c);
  }
  isFrontFacing(t) {
    return Pr.isFrontFacing(this.a, this.b, this.c, t);
  }
  intersectsBox(t) {
    return t.intersectsTriangle(this);
  }
  closestPointToPoint(t, e) {
    const n = this.a, r = this.b, s = this.c;
    let a, o;
    Ic.subVectors(r, n), Oc.subVectors(s, n), r_.subVectors(t, n);
    const l = Ic.dot(r_), c = Oc.dot(r_);
    if (l <= 0 && c <= 0)
      return e.copy(n);
    i_.subVectors(t, r);
    const u = Ic.dot(i_), h = Oc.dot(i_);
    if (u >= 0 && h <= u)
      return e.copy(r);
    const p = l * h - u * c;
    if (p <= 0 && l >= 0 && u <= 0)
      return a = l / (l - u), e.copy(n).addScaledVector(Ic, a);
    s_.subVectors(t, s);
    const f = Ic.dot(s_), v = Oc.dot(s_);
    if (v >= 0 && f <= v)
      return e.copy(s);
    const m = f * c - l * v;
    if (m <= 0 && c >= 0 && v <= 0)
      return o = c / (c - v), e.copy(n).addScaledVector(Oc, o);
    const y = u * v - f * h;
    if (y <= 0 && h - u >= 0 && f - v >= 0)
      return PT.subVectors(s, r), o = (h - u) / (h - u + (f - v)), e.copy(r).addScaledVector(PT, o);
    const _ = 1 / (y + m + p);
    return a = m * _, o = p * _, e.copy(n).addScaledVector(Ic, a).addScaledVector(Oc, o);
  }
  equals(t) {
    return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c);
  }
}
let SN = 0;
class Kr extends Ga {
  constructor() {
    super(), this.isMaterial = !0, Object.defineProperty(this, "id", { value: SN++ }), this.uuid = Vi(), this.name = "", this.type = "Material", this.blending = 1, this.side = 0, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.blendSrc = 204, this.blendDst = 205, this.blendEquation = 100, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = 3, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = 519, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = 7680, this.stencilZFail = 7680, this.stencilZPass = 7680, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.forceSinglePass = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0;
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(t) {
    this._alphaTest > 0 != t > 0 && this.version++, this._alphaTest = t;
  }
  onBuild() {
  }
  onBeforeRender() {
  }
  onBeforeCompile() {
  }
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(t) {
    if (t !== void 0)
      for (const e in t) {
        const n = t[e];
        if (n === void 0) {
          console.warn("THREE.Material: '" + e + "' parameter is undefined.");
          continue;
        }
        const r = this[e];
        r !== void 0 ? r && r.isColor ? r.set(n) : r && r.isVector3 && n && n.isVector3 ? r.copy(n) : this[e] = n : console.warn("THREE." + this.type + ": '" + e + "' is not a property of this material.");
      }
  }
  toJSON(t) {
    const e = t === void 0 || typeof t == "string";
    e && (t = { textures: {}, images: {} });
    const n = { metadata: { version: 4.5, type: "Material", generator: "Material.toJSON" } };
    function r(s) {
      const a = [];
      for (const o in s) {
        const l = s[o];
        delete l.metadata, a.push(l);
      }
      return a;
    }
    if (n.uuid = this.uuid, n.type = this.type, this.name !== "" && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), this.roughness !== void 0 && (n.roughness = this.roughness), this.metalness !== void 0 && (n.metalness = this.metalness), this.sheen !== void 0 && (n.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()), this.sheenRoughness !== void 0 && (n.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity && this.emissiveIntensity !== 1 && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), this.specularIntensity !== void 0 && (n.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (n.specularColor = this.specularColor.getHex()), this.shininess !== void 0 && (n.shininess = this.shininess), this.clearcoat !== void 0 && (n.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(t).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.iridescence !== void 0 && (n.iridescence = this.iridescence), this.iridescenceIOR !== void 0 && (n.iridescenceIOR = this.iridescenceIOR), this.iridescenceThicknessRange !== void 0 && (n.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (n.iridescenceMap = this.iridescenceMap.toJSON(t).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (n.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(t).uuid), this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(t).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(t).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(t).uuid, n.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(t).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(t).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(t).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(t).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(t).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(t).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(t).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(t).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(t).uuid), this.specularColorMap && this.specularColorMap.isTexture && (n.specularColorMap = this.specularColorMap.toJSON(t).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(t).uuid, this.combine !== void 0 && (n.combine = this.combine)), this.envMapIntensity !== void 0 && (n.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (n.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (n.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(t).uuid), this.transmission !== void 0 && (n.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(t).uuid), this.thickness !== void 0 && (n.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(t).uuid), this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (n.attenuationDistance = this.attenuationDistance), this.attenuationColor !== void 0 && (n.attenuationColor = this.attenuationColor.getHex()), this.size !== void 0 && (n.size = this.size), this.shadowSide !== null && (n.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (n.sizeAttenuation = this.sizeAttenuation), this.blending !== 1 && (n.blending = this.blending), this.side !== 0 && (n.side = this.side), this.vertexColors && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), this.transparent === !0 && (n.transparent = this.transparent), n.depthFunc = this.depthFunc, n.depthTest = this.depthTest, n.depthWrite = this.depthWrite, n.colorWrite = this.colorWrite, n.stencilWrite = this.stencilWrite, n.stencilWriteMask = this.stencilWriteMask, n.stencilFunc = this.stencilFunc, n.stencilRef = this.stencilRef, n.stencilFuncMask = this.stencilFuncMask, n.stencilFail = this.stencilFail, n.stencilZFail = this.stencilZFail, n.stencilZPass = this.stencilZPass, this.rotation !== void 0 && this.rotation !== 0 && (n.rotation = this.rotation), this.polygonOffset === !0 && (n.polygonOffset = !0), this.polygonOffsetFactor !== 0 && (n.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (n.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth !== void 0 && this.linewidth !== 1 && (n.linewidth = this.linewidth), this.dashSize !== void 0 && (n.dashSize = this.dashSize), this.gapSize !== void 0 && (n.gapSize = this.gapSize), this.scale !== void 0 && (n.scale = this.scale), this.dithering === !0 && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), this.alphaToCoverage === !0 && (n.alphaToCoverage = this.alphaToCoverage), this.premultipliedAlpha === !0 && (n.premultipliedAlpha = this.premultipliedAlpha), this.forceSinglePass === !0 && (n.forceSinglePass = this.forceSinglePass), this.wireframe === !0 && (n.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (n.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (n.wireframeLinejoin = this.wireframeLinejoin), this.flatShading === !0 && (n.flatShading = this.flatShading), this.visible === !1 && (n.visible = !1), this.toneMapped === !1 && (n.toneMapped = !1), this.fog === !1 && (n.fog = !1), Object.keys(this.userData).length > 0 && (n.userData = this.userData), e) {
      const s = r(t.textures), a = r(t.images);
      s.length > 0 && (n.textures = s), a.length > 0 && (n.images = a);
    }
    return n;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(t) {
    this.name = t.name, this.blending = t.blending, this.side = t.side, this.vertexColors = t.vertexColors, this.opacity = t.opacity, this.transparent = t.transparent, this.blendSrc = t.blendSrc, this.blendDst = t.blendDst, this.blendEquation = t.blendEquation, this.blendSrcAlpha = t.blendSrcAlpha, this.blendDstAlpha = t.blendDstAlpha, this.blendEquationAlpha = t.blendEquationAlpha, this.depthFunc = t.depthFunc, this.depthTest = t.depthTest, this.depthWrite = t.depthWrite, this.stencilWriteMask = t.stencilWriteMask, this.stencilFunc = t.stencilFunc, this.stencilRef = t.stencilRef, this.stencilFuncMask = t.stencilFuncMask, this.stencilFail = t.stencilFail, this.stencilZFail = t.stencilZFail, this.stencilZPass = t.stencilZPass, this.stencilWrite = t.stencilWrite;
    const e = t.clippingPlanes;
    let n = null;
    if (e !== null) {
      const r = e.length;
      n = new Array(r);
      for (let s = 0; s !== r; ++s)
        n[s] = e[s].clone();
    }
    return this.clippingPlanes = n, this.clipIntersection = t.clipIntersection, this.clipShadows = t.clipShadows, this.shadowSide = t.shadowSide, this.colorWrite = t.colorWrite, this.precision = t.precision, this.polygonOffset = t.polygonOffset, this.polygonOffsetFactor = t.polygonOffsetFactor, this.polygonOffsetUnits = t.polygonOffsetUnits, this.dithering = t.dithering, this.alphaTest = t.alphaTest, this.alphaToCoverage = t.alphaToCoverage, this.premultipliedAlpha = t.premultipliedAlpha, this.forceSinglePass = t.forceSinglePass, this.visible = t.visible, this.toneMapped = t.toneMapped, this.userData = JSON.parse(JSON.stringify(t.userData)), this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(t) {
    t === !0 && this.version++;
  }
}
class ci extends Kr {
  constructor(t) {
    super(), this.isMeshBasicMaterial = !0, this.type = "MeshBasicMaterial", this.color = new Ht(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(t);
  }
  copy(t) {
    return super.copy(t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.fog = t.fog, this;
  }
}
const lr = new D(), Jf = new wt();
class Ze {
  constructor(t, e, n = !1) {
    if (Array.isArray(t))
      throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    this.isBufferAttribute = !0, this.name = "", this.array = t, this.itemSize = e, this.count = t !== void 0 ? t.length / e : 0, this.normalized = n, this.usage = 35044, this.updateRange = { offset: 0, count: -1 }, this.version = 0;
  }
  onUploadCallback() {
  }
  set needsUpdate(t) {
    t === !0 && this.version++;
  }
  setUsage(t) {
    return this.usage = t, this;
  }
  copy(t) {
    return this.name = t.name, this.array = new t.array.constructor(t.array), this.itemSize = t.itemSize, this.count = t.count, this.normalized = t.normalized, this.usage = t.usage, this;
  }
  copyAt(t, e, n) {
    t *= this.itemSize, n *= e.itemSize;
    for (let r = 0, s = this.itemSize; r < s; r++)
      this.array[t + r] = e.array[n + r];
    return this;
  }
  copyArray(t) {
    return this.array.set(t), this;
  }
  applyMatrix3(t) {
    if (this.itemSize === 2)
      for (let e = 0, n = this.count; e < n; e++)
        Jf.fromBufferAttribute(this, e), Jf.applyMatrix3(t), this.setXY(e, Jf.x, Jf.y);
    else if (this.itemSize === 3)
      for (let e = 0, n = this.count; e < n; e++)
        lr.fromBufferAttribute(this, e), lr.applyMatrix3(t), this.setXYZ(e, lr.x, lr.y, lr.z);
    return this;
  }
  applyMatrix4(t) {
    for (let e = 0, n = this.count; e < n; e++)
      lr.fromBufferAttribute(this, e), lr.applyMatrix4(t), this.setXYZ(e, lr.x, lr.y, lr.z);
    return this;
  }
  applyNormalMatrix(t) {
    for (let e = 0, n = this.count; e < n; e++)
      lr.fromBufferAttribute(this, e), lr.applyNormalMatrix(t), this.setXYZ(e, lr.x, lr.y, lr.z);
    return this;
  }
  transformDirection(t) {
    for (let e = 0, n = this.count; e < n; e++)
      lr.fromBufferAttribute(this, e), lr.transformDirection(t), this.setXYZ(e, lr.x, lr.y, lr.z);
    return this;
  }
  set(t, e = 0) {
    return this.array.set(t, e), this;
  }
  getX(t) {
    let e = this.array[t * this.itemSize];
    return this.normalized && (e = Na(e, this.array)), e;
  }
  setX(t, e) {
    return this.normalized && (e = vn(e, this.array)), this.array[t * this.itemSize] = e, this;
  }
  getY(t) {
    let e = this.array[t * this.itemSize + 1];
    return this.normalized && (e = Na(e, this.array)), e;
  }
  setY(t, e) {
    return this.normalized && (e = vn(e, this.array)), this.array[t * this.itemSize + 1] = e, this;
  }
  getZ(t) {
    let e = this.array[t * this.itemSize + 2];
    return this.normalized && (e = Na(e, this.array)), e;
  }
  setZ(t, e) {
    return this.normalized && (e = vn(e, this.array)), this.array[t * this.itemSize + 2] = e, this;
  }
  getW(t) {
    let e = this.array[t * this.itemSize + 3];
    return this.normalized && (e = Na(e, this.array)), e;
  }
  setW(t, e) {
    return this.normalized && (e = vn(e, this.array)), this.array[t * this.itemSize + 3] = e, this;
  }
  setXY(t, e, n) {
    return t *= this.itemSize, this.normalized && (e = vn(e, this.array), n = vn(n, this.array)), this.array[t + 0] = e, this.array[t + 1] = n, this;
  }
  setXYZ(t, e, n, r) {
    return t *= this.itemSize, this.normalized && (e = vn(e, this.array), n = vn(n, this.array), r = vn(r, this.array)), this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = r, this;
  }
  setXYZW(t, e, n, r, s) {
    return t *= this.itemSize, this.normalized && (e = vn(e, this.array), n = vn(n, this.array), r = vn(r, this.array), s = vn(s, this.array)), this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = r, this.array[t + 3] = s, this;
  }
  onUpload(t) {
    return this.onUploadCallback = t, this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const t = { itemSize: this.itemSize, type: this.array.constructor.name, array: Array.from(this.array), normalized: this.normalized };
    return this.name !== "" && (t.name = this.name), this.usage !== 35044 && (t.usage = this.usage), this.updateRange.offset === 0 && this.updateRange.count === -1 || (t.updateRange = this.updateRange), t;
  }
  copyColorsArray() {
    console.error("THREE.BufferAttribute: copyColorsArray() was removed in r144.");
  }
  copyVector2sArray() {
    console.error("THREE.BufferAttribute: copyVector2sArray() was removed in r144.");
  }
  copyVector3sArray() {
    console.error("THREE.BufferAttribute: copyVector3sArray() was removed in r144.");
  }
  copyVector4sArray() {
    console.error("THREE.BufferAttribute: copyVector4sArray() was removed in r144.");
  }
}
class Gl extends Ze {
  constructor(t, e, n) {
    super(new Uint16Array(t), e, n);
  }
}
class Wl extends Ze {
  constructor(t, e, n) {
    super(new Uint32Array(t), e, n);
  }
}
class Wt extends Ze {
  constructor(t, e, n) {
    super(new Float32Array(t), e, n);
  }
}
let MN = 0;
const Ki = new Vt(), a_ = new Ue(), Lc = new D(), Ii = new ke(), ku = new ke(), _r = new D();
class _e extends Ga {
  constructor() {
    super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", { value: MN++ }), this.uuid = Vi(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {};
  }
  getIndex() {
    return this.index;
  }
  setIndex(t) {
    return Array.isArray(t) ? this.index = new (yI(t) ? Wl : Gl)(t, 1) : this.index = t, this;
  }
  getAttribute(t) {
    return this.attributes[t];
  }
  setAttribute(t, e) {
    return this.attributes[t] = e, this;
  }
  deleteAttribute(t) {
    return delete this.attributes[t], this;
  }
  hasAttribute(t) {
    return this.attributes[t] !== void 0;
  }
  addGroup(t, e, n = 0) {
    this.groups.push({ start: t, count: e, materialIndex: n });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(t, e) {
    this.drawRange.start = t, this.drawRange.count = e;
  }
  applyMatrix4(t) {
    const e = this.attributes.position;
    e !== void 0 && (e.applyMatrix4(t), e.needsUpdate = !0);
    const n = this.attributes.normal;
    if (n !== void 0) {
      const s = new hi().getNormalMatrix(t);
      n.applyNormalMatrix(s), n.needsUpdate = !0;
    }
    const r = this.attributes.tangent;
    return r !== void 0 && (r.transformDirection(t), r.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
  }
  applyQuaternion(t) {
    return Ki.makeRotationFromQuaternion(t), this.applyMatrix4(Ki), this;
  }
  rotateX(t) {
    return Ki.makeRotationX(t), this.applyMatrix4(Ki), this;
  }
  rotateY(t) {
    return Ki.makeRotationY(t), this.applyMatrix4(Ki), this;
  }
  rotateZ(t) {
    return Ki.makeRotationZ(t), this.applyMatrix4(Ki), this;
  }
  translate(t, e, n) {
    return Ki.makeTranslation(t, e, n), this.applyMatrix4(Ki), this;
  }
  scale(t, e, n) {
    return Ki.makeScale(t, e, n), this.applyMatrix4(Ki), this;
  }
  lookAt(t) {
    return a_.lookAt(t), a_.updateMatrix(), this.applyMatrix4(a_.matrix), this;
  }
  center() {
    return this.computeBoundingBox(), this.boundingBox.getCenter(Lc).negate(), this.translate(Lc.x, Lc.y, Lc.z), this;
  }
  setFromPoints(t) {
    const e = [];
    for (let n = 0, r = t.length; n < r; n++) {
      const s = t[n];
      e.push(s.x, s.y, s.z || 0);
    }
    return this.setAttribute("position", new Wt(e, 3)), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new ke());
    const t = this.attributes.position, e = this.morphAttributes.position;
    if (t && t.isGLBufferAttribute)
      return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingBox.set(new D(-1 / 0, -1 / 0, -1 / 0), new D(1 / 0, 1 / 0, 1 / 0));
    if (t !== void 0) {
      if (this.boundingBox.setFromBufferAttribute(t), e)
        for (let n = 0, r = e.length; n < r; n++) {
          const s = e[n];
          Ii.setFromBufferAttribute(s), this.morphTargetsRelative ? (_r.addVectors(this.boundingBox.min, Ii.min), this.boundingBox.expandByPoint(_r), _r.addVectors(this.boundingBox.max, Ii.max), this.boundingBox.expandByPoint(_r)) : (this.boundingBox.expandByPoint(Ii.min), this.boundingBox.expandByPoint(Ii.max));
        }
    } else
      this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new Mi());
    const t = this.attributes.position, e = this.morphAttributes.position;
    if (t && t.isGLBufferAttribute)
      return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingSphere.set(new D(), 1 / 0);
    if (t) {
      const n = this.boundingSphere.center;
      if (Ii.setFromBufferAttribute(t), e)
        for (let s = 0, a = e.length; s < a; s++) {
          const o = e[s];
          ku.setFromBufferAttribute(o), this.morphTargetsRelative ? (_r.addVectors(Ii.min, ku.min), Ii.expandByPoint(_r), _r.addVectors(Ii.max, ku.max), Ii.expandByPoint(_r)) : (Ii.expandByPoint(ku.min), Ii.expandByPoint(ku.max));
        }
      Ii.getCenter(n);
      let r = 0;
      for (let s = 0, a = t.count; s < a; s++)
        _r.fromBufferAttribute(t, s), r = Math.max(r, n.distanceToSquared(_r));
      if (e)
        for (let s = 0, a = e.length; s < a; s++) {
          const o = e[s], l = this.morphTargetsRelative;
          for (let c = 0, u = o.count; c < u; c++)
            _r.fromBufferAttribute(o, c), l && (Lc.fromBufferAttribute(t, c), _r.add(Lc)), r = Math.max(r, n.distanceToSquared(_r));
        }
      this.boundingSphere.radius = Math.sqrt(r), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
    }
  }
  computeTangents() {
    const t = this.index, e = this.attributes;
    if (t === null || e.position === void 0 || e.normal === void 0 || e.uv === void 0)
      return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
    const n = t.array, r = e.position.array, s = e.normal.array, a = e.uv.array, o = r.length / 3;
    this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new Ze(new Float32Array(4 * o), 4));
    const l = this.getAttribute("tangent").array, c = [], u = [];
    for (let R = 0; R < o; R++)
      c[R] = new D(), u[R] = new D();
    const h = new D(), p = new D(), f = new D(), v = new wt(), m = new wt(), y = new wt(), _ = new D(), w = new D();
    function b(R, L, E) {
      h.fromArray(r, 3 * R), p.fromArray(r, 3 * L), f.fromArray(r, 3 * E), v.fromArray(a, 2 * R), m.fromArray(a, 2 * L), y.fromArray(a, 2 * E), p.sub(h), f.sub(h), m.sub(v), y.sub(v);
      const q = 1 / (m.x * y.y - y.x * m.y);
      isFinite(q) && (_.copy(p).multiplyScalar(y.y).addScaledVector(f, -m.y).multiplyScalar(q), w.copy(f).multiplyScalar(m.x).addScaledVector(p, -y.x).multiplyScalar(q), c[R].add(_), c[L].add(_), c[E].add(_), u[R].add(w), u[L].add(w), u[E].add(w));
    }
    let T = this.groups;
    T.length === 0 && (T = [{ start: 0, count: n.length }]);
    for (let R = 0, L = T.length; R < L; ++R) {
      const E = T[R], q = E.start;
      for (let it = q, rt = q + E.count; it < rt; it += 3)
        b(n[it + 0], n[it + 1], n[it + 2]);
    }
    const M = new D(), A = new D(), C = new D(), I = new D();
    function k(R) {
      C.fromArray(s, 3 * R), I.copy(C);
      const L = c[R];
      M.copy(L), M.sub(C.multiplyScalar(C.dot(L))).normalize(), A.crossVectors(I, L);
      const E = A.dot(u[R]) < 0 ? -1 : 1;
      l[4 * R] = M.x, l[4 * R + 1] = M.y, l[4 * R + 2] = M.z, l[4 * R + 3] = E;
    }
    for (let R = 0, L = T.length; R < L; ++R) {
      const E = T[R], q = E.start;
      for (let it = q, rt = q + E.count; it < rt; it += 3)
        k(n[it + 0]), k(n[it + 1]), k(n[it + 2]);
    }
  }
  computeVertexNormals() {
    const t = this.index, e = this.getAttribute("position");
    if (e !== void 0) {
      let n = this.getAttribute("normal");
      if (n === void 0)
        n = new Ze(new Float32Array(3 * e.count), 3), this.setAttribute("normal", n);
      else
        for (let p = 0, f = n.count; p < f; p++)
          n.setXYZ(p, 0, 0, 0);
      const r = new D(), s = new D(), a = new D(), o = new D(), l = new D(), c = new D(), u = new D(), h = new D();
      if (t)
        for (let p = 0, f = t.count; p < f; p += 3) {
          const v = t.getX(p + 0), m = t.getX(p + 1), y = t.getX(p + 2);
          r.fromBufferAttribute(e, v), s.fromBufferAttribute(e, m), a.fromBufferAttribute(e, y), u.subVectors(a, s), h.subVectors(r, s), u.cross(h), o.fromBufferAttribute(n, v), l.fromBufferAttribute(n, m), c.fromBufferAttribute(n, y), o.add(u), l.add(u), c.add(u), n.setXYZ(v, o.x, o.y, o.z), n.setXYZ(m, l.x, l.y, l.z), n.setXYZ(y, c.x, c.y, c.z);
        }
      else
        for (let p = 0, f = e.count; p < f; p += 3)
          r.fromBufferAttribute(e, p + 0), s.fromBufferAttribute(e, p + 1), a.fromBufferAttribute(e, p + 2), u.subVectors(a, s), h.subVectors(r, s), u.cross(h), n.setXYZ(p + 0, u.x, u.y, u.z), n.setXYZ(p + 1, u.x, u.y, u.z), n.setXYZ(p + 2, u.x, u.y, u.z);
      this.normalizeNormals(), n.needsUpdate = !0;
    }
  }
  merge() {
    return console.error("THREE.BufferGeometry.merge() has been removed. Use THREE.BufferGeometryUtils.mergeBufferGeometries() instead."), this;
  }
  normalizeNormals() {
    const t = this.attributes.normal;
    for (let e = 0, n = t.count; e < n; e++)
      _r.fromBufferAttribute(t, e), _r.normalize(), t.setXYZ(e, _r.x, _r.y, _r.z);
  }
  toNonIndexed() {
    function t(o, l) {
      const c = o.array, u = o.itemSize, h = o.normalized, p = new c.constructor(l.length * u);
      let f = 0, v = 0;
      for (let m = 0, y = l.length; m < y; m++) {
        f = o.isInterleavedBufferAttribute ? l[m] * o.data.stride + o.offset : l[m] * u;
        for (let _ = 0; _ < u; _++)
          p[v++] = c[f++];
      }
      return new Ze(p, u, h);
    }
    if (this.index === null)
      return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
    const e = new _e(), n = this.index.array, r = this.attributes;
    for (const o in r) {
      const l = t(r[o], n);
      e.setAttribute(o, l);
    }
    const s = this.morphAttributes;
    for (const o in s) {
      const l = [], c = s[o];
      for (let u = 0, h = c.length; u < h; u++) {
        const p = t(c[u], n);
        l.push(p);
      }
      e.morphAttributes[o] = l;
    }
    e.morphTargetsRelative = this.morphTargetsRelative;
    const a = this.groups;
    for (let o = 0, l = a.length; o < l; o++) {
      const c = a[o];
      e.addGroup(c.start, c.count, c.materialIndex);
    }
    return e;
  }
  toJSON() {
    const t = { metadata: { version: 4.5, type: "BufferGeometry", generator: "BufferGeometry.toJSON" } };
    if (t.uuid = this.uuid, t.type = this.type, this.name !== "" && (t.name = this.name), Object.keys(this.userData).length > 0 && (t.userData = this.userData), this.parameters !== void 0) {
      const l = this.parameters;
      for (const c in l)
        l[c] !== void 0 && (t[c] = l[c]);
      return t;
    }
    t.data = { attributes: {} };
    const e = this.index;
    e !== null && (t.data.index = { type: e.array.constructor.name, array: Array.prototype.slice.call(e.array) });
    const n = this.attributes;
    for (const l in n) {
      const c = n[l];
      t.data.attributes[l] = c.toJSON(t.data);
    }
    const r = {};
    let s = !1;
    for (const l in this.morphAttributes) {
      const c = this.morphAttributes[l], u = [];
      for (let h = 0, p = c.length; h < p; h++) {
        const f = c[h];
        u.push(f.toJSON(t.data));
      }
      u.length > 0 && (r[l] = u, s = !0);
    }
    s && (t.data.morphAttributes = r, t.data.morphTargetsRelative = this.morphTargetsRelative);
    const a = this.groups;
    a.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(a)));
    const o = this.boundingSphere;
    return o !== null && (t.data.boundingSphere = { center: o.center.toArray(), radius: o.radius }), t;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(t) {
    this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
    const e = {};
    this.name = t.name;
    const n = t.index;
    n !== null && this.setIndex(n.clone(e));
    const r = t.attributes;
    for (const c in r) {
      const u = r[c];
      this.setAttribute(c, u.clone(e));
    }
    const s = t.morphAttributes;
    for (const c in s) {
      const u = [], h = s[c];
      for (let p = 0, f = h.length; p < f; p++)
        u.push(h[p].clone(e));
      this.morphAttributes[c] = u;
    }
    this.morphTargetsRelative = t.morphTargetsRelative;
    const a = t.groups;
    for (let c = 0, u = a.length; c < u; c++) {
      const h = a[c];
      this.addGroup(h.start, h.count, h.materialIndex);
    }
    const o = t.boundingBox;
    o !== null && (this.boundingBox = o.clone());
    const l = t.boundingSphere;
    return l !== null && (this.boundingSphere = l.clone()), this.drawRange.start = t.drawRange.start, this.drawRange.count = t.drawRange.count, this.userData = t.userData, t.parameters !== void 0 && (this.parameters = Object.assign({}, t.parameters)), this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
const DT = new Vt(), Bc = new Uo(), o_ = new Mi(), Nu = new D(), Fu = new D(), Uu = new D(), l_ = new D(), Kf = new D(), $f = new wt(), Qf = new wt(), tm = new wt(), c_ = new D(), em = new D();
class Nt extends Ue {
  constructor(t = new _e(), e = new ci()) {
    super(), this.isMesh = !0, this.type = "Mesh", this.geometry = t, this.material = e, this.updateMorphTargets();
  }
  copy(t, e) {
    return super.copy(t, e), t.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = t.morphTargetInfluences.slice()), t.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)), this.material = t.material, this.geometry = t.geometry, this;
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes, e = Object.keys(t);
    if (e.length > 0) {
      const n = t[e[0]];
      if (n !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let r = 0, s = n.length; r < s; r++) {
          const a = n[r].name || String(r);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = r;
        }
      }
    }
  }
  getVertexPosition(t, e) {
    const n = this.geometry, r = n.attributes.position, s = n.morphAttributes.position, a = n.morphTargetsRelative;
    e.fromBufferAttribute(r, t);
    const o = this.morphTargetInfluences;
    if (s && o) {
      Kf.set(0, 0, 0);
      for (let l = 0, c = s.length; l < c; l++) {
        const u = o[l], h = s[l];
        u !== 0 && (l_.fromBufferAttribute(h, t), a ? Kf.addScaledVector(l_, u) : Kf.addScaledVector(l_.sub(e), u));
      }
      e.add(Kf);
    }
    return this.isSkinnedMesh && this.boneTransform(t, e), e;
  }
  raycast(t, e) {
    const n = this.geometry, r = this.material, s = this.matrixWorld;
    if (r === void 0 || (n.boundingSphere === null && n.computeBoundingSphere(), o_.copy(n.boundingSphere), o_.applyMatrix4(s), t.ray.intersectsSphere(o_) === !1) || (DT.copy(s).invert(), Bc.copy(t.ray).applyMatrix4(DT), n.boundingBox !== null && Bc.intersectsBox(n.boundingBox) === !1))
      return;
    let a;
    const o = n.index, l = n.attributes.position, c = n.attributes.uv, u = n.attributes.uv2, h = n.groups, p = n.drawRange;
    if (o !== null)
      if (Array.isArray(r))
        for (let f = 0, v = h.length; f < v; f++) {
          const m = h[f], y = r[m.materialIndex];
          for (let _ = Math.max(m.start, p.start), w = Math.min(o.count, Math.min(m.start + m.count, p.start + p.count)); _ < w; _ += 3) {
            const b = o.getX(_), T = o.getX(_ + 1), M = o.getX(_ + 2);
            a = nm(this, y, t, Bc, c, u, b, T, M), a && (a.faceIndex = Math.floor(_ / 3), a.face.materialIndex = m.materialIndex, e.push(a));
          }
        }
      else
        for (let f = Math.max(0, p.start), v = Math.min(o.count, p.start + p.count); f < v; f += 3) {
          const m = o.getX(f), y = o.getX(f + 1), _ = o.getX(f + 2);
          a = nm(this, r, t, Bc, c, u, m, y, _), a && (a.faceIndex = Math.floor(f / 3), e.push(a));
        }
    else if (l !== void 0)
      if (Array.isArray(r))
        for (let f = 0, v = h.length; f < v; f++) {
          const m = h[f], y = r[m.materialIndex];
          for (let _ = Math.max(m.start, p.start), w = Math.min(l.count, Math.min(m.start + m.count, p.start + p.count)); _ < w; _ += 3)
            a = nm(this, y, t, Bc, c, u, _, _ + 1, _ + 2), a && (a.faceIndex = Math.floor(_ / 3), a.face.materialIndex = m.materialIndex, e.push(a));
        }
      else
        for (let f = Math.max(0, p.start), v = Math.min(l.count, p.start + p.count); f < v; f += 3)
          a = nm(this, r, t, Bc, c, u, f, f + 1, f + 2), a && (a.faceIndex = Math.floor(f / 3), e.push(a));
  }
}
function nm(i, t, e, n, r, s, a, o, l) {
  i.getVertexPosition(a, Nu), i.getVertexPosition(o, Fu), i.getVertexPosition(l, Uu);
  const c = function(u, h, p, f, v, m, y, _) {
    let w;
    if (w = h.side === 1 ? f.intersectTriangle(y, m, v, !0, _) : f.intersectTriangle(v, m, y, h.side === 0, _), w === null)
      return null;
    em.copy(_), em.applyMatrix4(u.matrixWorld);
    const b = p.ray.origin.distanceTo(em);
    return b < p.near || b > p.far ? null : { distance: b, point: em.clone(), object: u };
  }(i, t, e, n, Nu, Fu, Uu, c_);
  if (c) {
    r && ($f.fromBufferAttribute(r, a), Qf.fromBufferAttribute(r, o), tm.fromBufferAttribute(r, l), c.uv = Pr.getUV(c_, Nu, Fu, Uu, $f, Qf, tm, new wt())), s && ($f.fromBufferAttribute(s, a), Qf.fromBufferAttribute(s, o), tm.fromBufferAttribute(s, l), c.uv2 = Pr.getUV(c_, Nu, Fu, Uu, $f, Qf, tm, new wt()));
    const u = { a, b: o, c: l, normal: new D(), materialIndex: 0 };
    Pr.getNormal(Nu, Fu, Uu, u.normal), c.face = u;
  }
  return c;
}
class zn extends _e {
  constructor(t = 1, e = 1, n = 1, r = 1, s = 1, a = 1) {
    super(), this.type = "BoxGeometry", this.parameters = { width: t, height: e, depth: n, widthSegments: r, heightSegments: s, depthSegments: a };
    const o = this;
    r = Math.floor(r), s = Math.floor(s), a = Math.floor(a);
    const l = [], c = [], u = [], h = [];
    let p = 0, f = 0;
    function v(m, y, _, w, b, T, M, A, C, I, k) {
      const R = T / C, L = M / I, E = T / 2, q = M / 2, it = A / 2, rt = C + 1, ft = I + 1;
      let nt = 0, vt = 0;
      const $ = new D();
      for (let W = 0; W < ft; W++) {
        const ct = W * L - q;
        for (let mt = 0; mt < rt; mt++) {
          const dt = mt * R - E;
          $[m] = dt * w, $[y] = ct * b, $[_] = it, c.push($.x, $.y, $.z), $[m] = 0, $[y] = 0, $[_] = A > 0 ? 1 : -1, u.push($.x, $.y, $.z), h.push(mt / C), h.push(1 - W / I), nt += 1;
        }
      }
      for (let W = 0; W < I; W++)
        for (let ct = 0; ct < C; ct++) {
          const mt = p + ct + rt * W, dt = p + ct + rt * (W + 1), Mt = p + (ct + 1) + rt * (W + 1), At = p + (ct + 1) + rt * W;
          l.push(mt, dt, At), l.push(dt, Mt, At), vt += 6;
        }
      o.addGroup(f, vt, k), f += vt, p += nt;
    }
    v("z", "y", "x", -1, -1, n, e, t, a, s, 0), v("z", "y", "x", 1, -1, n, e, -t, a, s, 1), v("x", "z", "y", 1, 1, t, n, e, r, a, 2), v("x", "z", "y", 1, -1, t, n, -e, r, a, 3), v("x", "y", "z", 1, -1, t, e, n, r, s, 4), v("x", "y", "z", -1, -1, t, e, -n, r, s, 5), this.setIndex(l), this.setAttribute("position", new Wt(c, 3)), this.setAttribute("normal", new Wt(u, 3)), this.setAttribute("uv", new Wt(h, 2));
  }
  static fromJSON(t) {
    return new zn(t.width, t.height, t.depth, t.widthSegments, t.heightSegments, t.depthSegments);
  }
}
function Fh(i) {
  const t = {};
  for (const e in i) {
    t[e] = {};
    for (const n in i[e]) {
      const r = i[e][n];
      r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture || r.isQuaternion) ? t[e][n] = r.clone() : Array.isArray(r) ? t[e][n] = r.slice() : t[e][n] = r;
    }
  }
  return t;
}
function ai(i) {
  const t = {};
  for (let e = 0; e < i.length; e++) {
    const n = Fh(i[e]);
    for (const r in n)
      t[r] = n[r];
  }
  return t;
}
function xI(i) {
  return i.getRenderTarget() === null && i.outputEncoding === 3001 ? Ms : Zd;
}
const Jn = { clone: Fh, merge: ai };
class Gn extends Kr {
  constructor(t) {
    super(), this.isShaderMaterial = !0, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`, this.fragmentShader = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.extensions = { derivatives: !1, fragDepth: !1, drawBuffers: !1, shaderTextureLOD: !1 }, this.defaultAttributeValues = { color: [1, 1, 1], uv: [0, 0], uv2: [0, 0] }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, t !== void 0 && this.setValues(t);
  }
  copy(t) {
    return super.copy(t), this.fragmentShader = t.fragmentShader, this.vertexShader = t.vertexShader, this.uniforms = Fh(t.uniforms), this.uniformsGroups = function(e) {
      const n = [];
      for (let r = 0; r < e.length; r++)
        n.push(e[r].clone());
      return n;
    }(t.uniformsGroups), this.defines = Object.assign({}, t.defines), this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.fog = t.fog, this.lights = t.lights, this.clipping = t.clipping, this.extensions = Object.assign({}, t.extensions), this.glslVersion = t.glslVersion, this;
  }
  toJSON(t) {
    const e = super.toJSON(t);
    e.glslVersion = this.glslVersion, e.uniforms = {};
    for (const r in this.uniforms) {
      const s = this.uniforms[r].value;
      s && s.isTexture ? e.uniforms[r] = { type: "t", value: s.toJSON(t).uuid } : s && s.isColor ? e.uniforms[r] = { type: "c", value: s.getHex() } : s && s.isVector2 ? e.uniforms[r] = { type: "v2", value: s.toArray() } : s && s.isVector3 ? e.uniforms[r] = { type: "v3", value: s.toArray() } : s && s.isVector4 ? e.uniforms[r] = { type: "v4", value: s.toArray() } : s && s.isMatrix3 ? e.uniforms[r] = { type: "m3", value: s.toArray() } : s && s.isMatrix4 ? e.uniforms[r] = { type: "m4", value: s.toArray() } : e.uniforms[r] = { value: s };
    }
    Object.keys(this.defines).length > 0 && (e.defines = this.defines), e.vertexShader = this.vertexShader, e.fragmentShader = this.fragmentShader;
    const n = {};
    for (const r in this.extensions)
      this.extensions[r] === !0 && (n[r] = !0);
    return Object.keys(n).length > 0 && (e.extensions = n), e;
  }
}
class Qv extends Ue {
  constructor() {
    super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new Vt(), this.projectionMatrix = new Vt(), this.projectionMatrixInverse = new Vt();
  }
  copy(t, e) {
    return super.copy(t, e), this.matrixWorldInverse.copy(t.matrixWorldInverse), this.projectionMatrix.copy(t.projectionMatrix), this.projectionMatrixInverse.copy(t.projectionMatrixInverse), this;
  }
  getWorldDirection(t) {
    this.updateWorldMatrix(!0, !1);
    const e = this.matrixWorld.elements;
    return t.set(-e[8], -e[9], -e[10]).normalize();
  }
  updateMatrixWorld(t) {
    super.updateMatrixWorld(t), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(t, e) {
    super.updateWorldMatrix(t, e), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class Cr extends Qv {
  constructor(t = 50, e = 1, n = 0.1, r = 2e3) {
    super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = t, this.zoom = 1, this.near = n, this.far = r, this.focus = 10, this.aspect = e, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
  }
  copy(t, e) {
    return super.copy(t, e), this.fov = t.fov, this.zoom = t.zoom, this.near = t.near, this.far = t.far, this.focus = t.focus, this.aspect = t.aspect, this.view = t.view === null ? null : Object.assign({}, t.view), this.filmGauge = t.filmGauge, this.filmOffset = t.filmOffset, this;
  }
  setFocalLength(t) {
    const e = 0.5 * this.getFilmHeight() / t;
    this.fov = 2 * qd * Math.atan(e), this.updateProjectionMatrix();
  }
  getFocalLength() {
    const t = Math.tan(0.5 * Vl * this.fov);
    return 0.5 * this.getFilmHeight() / t;
  }
  getEffectiveFOV() {
    return 2 * qd * Math.atan(Math.tan(0.5 * Vl * this.fov) / this.zoom);
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  setViewOffset(t, e, n, r, s, a) {
    this.aspect = t / e, this.view === null && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = r, this.view.width = s, this.view.height = a, this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const t = this.near;
    let e = t * Math.tan(0.5 * Vl * this.fov) / this.zoom, n = 2 * e, r = this.aspect * n, s = -0.5 * r;
    const a = this.view;
    if (this.view !== null && this.view.enabled) {
      const l = a.fullWidth, c = a.fullHeight;
      s += a.offsetX * r / l, e -= a.offsetY * n / c, r *= a.width / l, n *= a.height / c;
    }
    const o = this.filmOffset;
    o !== 0 && (s += t * o / this.getFilmWidth()), this.projectionMatrix.makePerspective(s, s + r, e, e - n, t, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(t) {
    const e = super.toJSON(t);
    return e.object.fov = this.fov, e.object.zoom = this.zoom, e.object.near = this.near, e.object.far = this.far, e.object.focus = this.focus, e.object.aspect = this.aspect, this.view !== null && (e.object.view = Object.assign({}, this.view)), e.object.filmGauge = this.filmGauge, e.object.filmOffset = this.filmOffset, e;
  }
}
const zc = -90;
class bI extends Ue {
  constructor(t, e, n) {
    super(), this.type = "CubeCamera", this.renderTarget = n;
    const r = new Cr(zc, 1, t, e);
    r.layers = this.layers, r.up.set(0, 1, 0), r.lookAt(1, 0, 0), this.add(r);
    const s = new Cr(zc, 1, t, e);
    s.layers = this.layers, s.up.set(0, 1, 0), s.lookAt(-1, 0, 0), this.add(s);
    const a = new Cr(zc, 1, t, e);
    a.layers = this.layers, a.up.set(0, 0, -1), a.lookAt(0, 1, 0), this.add(a);
    const o = new Cr(zc, 1, t, e);
    o.layers = this.layers, o.up.set(0, 0, 1), o.lookAt(0, -1, 0), this.add(o);
    const l = new Cr(zc, 1, t, e);
    l.layers = this.layers, l.up.set(0, 1, 0), l.lookAt(0, 0, 1), this.add(l);
    const c = new Cr(zc, 1, t, e);
    c.layers = this.layers, c.up.set(0, 1, 0), c.lookAt(0, 0, -1), this.add(c);
  }
  update(t, e) {
    this.parent === null && this.updateMatrixWorld();
    const n = this.renderTarget, [r, s, a, o, l, c] = this.children, u = t.getRenderTarget(), h = t.toneMapping, p = t.xr.enabled;
    t.toneMapping = 0, t.xr.enabled = !1;
    const f = n.texture.generateMipmaps;
    n.texture.generateMipmaps = !1, t.setRenderTarget(n, 0), t.render(e, r), t.setRenderTarget(n, 1), t.render(e, s), t.setRenderTarget(n, 2), t.render(e, a), t.setRenderTarget(n, 3), t.render(e, o), t.setRenderTarget(n, 4), t.render(e, l), n.texture.generateMipmaps = f, t.setRenderTarget(n, 5), t.render(e, c), t.setRenderTarget(u), t.toneMapping = h, t.xr.enabled = p, n.texture.needsPMREMUpdate = !0;
  }
}
class Dd extends Yn {
  constructor(t, e, n, r, s, a, o, l, c, u) {
    super(t = t !== void 0 ? t : [], e = e !== void 0 ? e : 301, n, r, s, a, o, l, c, u), this.isCubeTexture = !0, this.flipY = !1;
  }
  get images() {
    return this.image;
  }
  set images(t) {
    this.image = t;
  }
}
class SI extends ir {
  constructor(t = 1, e = {}) {
    super(t, t, e), this.isWebGLCubeRenderTarget = !0;
    const n = { width: t, height: t, depth: 1 }, r = [n, n, n, n, n, n];
    this.texture = new Dd(r, e.mapping, e.wrapS, e.wrapT, e.magFilter, e.minFilter, e.format, e.type, e.anisotropy, e.encoding), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = e.generateMipmaps !== void 0 && e.generateMipmaps, this.texture.minFilter = e.minFilter !== void 0 ? e.minFilter : 1006;
  }
  fromEquirectangularTexture(t, e) {
    this.texture.type = e.type, this.texture.encoding = e.encoding, this.texture.generateMipmaps = e.generateMipmaps, this.texture.minFilter = e.minFilter, this.texture.magFilter = e.magFilter;
    const n = { uniforms: { tEquirect: { value: null } }, vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`, fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			` }, r = new zn(5, 5, 5), s = new Gn({ name: "CubemapFromEquirect", uniforms: Fh(n.uniforms), vertexShader: n.vertexShader, fragmentShader: n.fragmentShader, side: 1, blending: 0 });
    s.uniforms.tEquirect.value = e;
    const a = new Nt(r, s), o = e.minFilter;
    return e.minFilter === 1008 && (e.minFilter = 1006), new bI(1, 10, this).update(t, a), e.minFilter = o, a.geometry.dispose(), a.material.dispose(), this;
  }
  clear(t, e, n, r) {
    const s = t.getRenderTarget();
    for (let a = 0; a < 6; a++)
      t.setRenderTarget(this, a), t.clear(e, n, r);
    t.setRenderTarget(s);
  }
}
const h_ = new D(), TN = new D(), EN = new hi();
class Hn {
  constructor(t = new D(1, 0, 0), e = 0) {
    this.isPlane = !0, this.normal = t, this.constant = e;
  }
  set(t, e) {
    return this.normal.copy(t), this.constant = e, this;
  }
  setComponents(t, e, n, r) {
    return this.normal.set(t, e, n), this.constant = r, this;
  }
  setFromNormalAndCoplanarPoint(t, e) {
    return this.normal.copy(t), this.constant = -e.dot(this.normal), this;
  }
  setFromCoplanarPoints(t, e, n) {
    const r = h_.subVectors(n, e).cross(TN.subVectors(t, e)).normalize();
    return this.setFromNormalAndCoplanarPoint(r, t), this;
  }
  copy(t) {
    return this.normal.copy(t.normal), this.constant = t.constant, this;
  }
  normalize() {
    const t = 1 / this.normal.length();
    return this.normal.multiplyScalar(t), this.constant *= t, this;
  }
  negate() {
    return this.constant *= -1, this.normal.negate(), this;
  }
  distanceToPoint(t) {
    return this.normal.dot(t) + this.constant;
  }
  distanceToSphere(t) {
    return this.distanceToPoint(t.center) - t.radius;
  }
  projectPoint(t, e) {
    return e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t);
  }
  intersectLine(t, e) {
    const n = t.delta(h_), r = this.normal.dot(n);
    if (r === 0)
      return this.distanceToPoint(t.start) === 0 ? e.copy(t.start) : null;
    const s = -(t.start.dot(this.normal) + this.constant) / r;
    return s < 0 || s > 1 ? null : e.copy(n).multiplyScalar(s).add(t.start);
  }
  intersectsLine(t) {
    const e = this.distanceToPoint(t.start), n = this.distanceToPoint(t.end);
    return e < 0 && n > 0 || n < 0 && e > 0;
  }
  intersectsBox(t) {
    return t.intersectsPlane(this);
  }
  intersectsSphere(t) {
    return t.intersectsPlane(this);
  }
  coplanarPoint(t) {
    return t.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(t, e) {
    const n = e || EN.getNormalMatrix(t), r = this.coplanarPoint(h_).applyMatrix4(t), s = this.normal.applyMatrix3(n).normalize();
    return this.constant = -r.dot(s), this;
  }
  translate(t) {
    return this.constant -= t.dot(this.normal), this;
  }
  equals(t) {
    return t.normal.equals(this.normal) && t.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const kc = new Mi(), rm = new D();
class t0 {
  constructor(t = new Hn(), e = new Hn(), n = new Hn(), r = new Hn(), s = new Hn(), a = new Hn()) {
    this.planes = [t, e, n, r, s, a];
  }
  set(t, e, n, r, s, a) {
    const o = this.planes;
    return o[0].copy(t), o[1].copy(e), o[2].copy(n), o[3].copy(r), o[4].copy(s), o[5].copy(a), this;
  }
  copy(t) {
    const e = this.planes;
    for (let n = 0; n < 6; n++)
      e[n].copy(t.planes[n]);
    return this;
  }
  setFromProjectionMatrix(t) {
    const e = this.planes, n = t.elements, r = n[0], s = n[1], a = n[2], o = n[3], l = n[4], c = n[5], u = n[6], h = n[7], p = n[8], f = n[9], v = n[10], m = n[11], y = n[12], _ = n[13], w = n[14], b = n[15];
    return e[0].setComponents(o - r, h - l, m - p, b - y).normalize(), e[1].setComponents(o + r, h + l, m + p, b + y).normalize(), e[2].setComponents(o + s, h + c, m + f, b + _).normalize(), e[3].setComponents(o - s, h - c, m - f, b - _).normalize(), e[4].setComponents(o - a, h - u, m - v, b - w).normalize(), e[5].setComponents(o + a, h + u, m + v, b + w).normalize(), this;
  }
  intersectsObject(t) {
    const e = t.geometry;
    return e.boundingSphere === null && e.computeBoundingSphere(), kc.copy(e.boundingSphere).applyMatrix4(t.matrixWorld), this.intersectsSphere(kc);
  }
  intersectsSprite(t) {
    return kc.center.set(0, 0, 0), kc.radius = 0.7071067811865476, kc.applyMatrix4(t.matrixWorld), this.intersectsSphere(kc);
  }
  intersectsSphere(t) {
    const e = this.planes, n = t.center, r = -t.radius;
    for (let s = 0; s < 6; s++)
      if (e[s].distanceToPoint(n) < r)
        return !1;
    return !0;
  }
  intersectsBox(t) {
    const e = this.planes;
    for (let n = 0; n < 6; n++) {
      const r = e[n];
      if (rm.x = r.normal.x > 0 ? t.max.x : t.min.x, rm.y = r.normal.y > 0 ? t.max.y : t.min.y, rm.z = r.normal.z > 0 ? t.max.z : t.min.z, r.distanceToPoint(rm) < 0)
        return !1;
    }
    return !0;
  }
  containsPoint(t) {
    const e = this.planes;
    for (let n = 0; n < 6; n++)
      if (e[n].distanceToPoint(t) < 0)
        return !1;
    return !0;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
function MI() {
  let i = null, t = !1, e = null, n = null;
  function r(s, a) {
    e(s, a), n = i.requestAnimationFrame(r);
  }
  return { start: function() {
    t !== !0 && e !== null && (n = i.requestAnimationFrame(r), t = !0);
  }, stop: function() {
    i.cancelAnimationFrame(n), t = !1;
  }, setAnimationLoop: function(s) {
    e = s;
  }, setContext: function(s) {
    i = s;
  } };
}
function AN(i, t) {
  const e = t.isWebGL2, n = /* @__PURE__ */ new WeakMap();
  return { get: function(r) {
    return r.isInterleavedBufferAttribute && (r = r.data), n.get(r);
  }, remove: function(r) {
    r.isInterleavedBufferAttribute && (r = r.data);
    const s = n.get(r);
    s && (i.deleteBuffer(s.buffer), n.delete(r));
  }, update: function(r, s) {
    if (r.isGLBufferAttribute) {
      const o = n.get(r);
      return void ((!o || o.version < r.version) && n.set(r, { buffer: r.buffer, type: r.type, bytesPerElement: r.elementSize, version: r.version }));
    }
    r.isInterleavedBufferAttribute && (r = r.data);
    const a = n.get(r);
    a === void 0 ? n.set(r, function(o, l) {
      const c = o.array, u = o.usage, h = i.createBuffer();
      let p;
      if (i.bindBuffer(l, h), i.bufferData(l, c, u), o.onUploadCallback(), c instanceof Float32Array)
        p = 5126;
      else if (c instanceof Uint16Array)
        if (o.isFloat16BufferAttribute) {
          if (!e)
            throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
          p = 5131;
        } else
          p = 5123;
      else if (c instanceof Int16Array)
        p = 5122;
      else if (c instanceof Uint32Array)
        p = 5125;
      else if (c instanceof Int32Array)
        p = 5124;
      else if (c instanceof Int8Array)
        p = 5120;
      else if (c instanceof Uint8Array)
        p = 5121;
      else {
        if (!(c instanceof Uint8ClampedArray))
          throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + c);
        p = 5121;
      }
      return { buffer: h, type: p, bytesPerElement: c.BYTES_PER_ELEMENT, version: o.version };
    }(r, s)) : a.version < r.version && (function(o, l, c) {
      const u = l.array, h = l.updateRange;
      i.bindBuffer(c, o), h.count === -1 ? i.bufferSubData(c, 0, u) : (e ? i.bufferSubData(c, h.offset * u.BYTES_PER_ELEMENT, u, h.offset, h.count) : i.bufferSubData(c, h.offset * u.BYTES_PER_ELEMENT, u.subarray(h.offset, h.offset + h.count)), h.count = -1), l.onUploadCallback();
    }(a.buffer, r, s), a.version = r.version);
  } };
}
class Wa extends _e {
  constructor(t = 1, e = 1, n = 1, r = 1) {
    super(), this.type = "PlaneGeometry", this.parameters = { width: t, height: e, widthSegments: n, heightSegments: r };
    const s = t / 2, a = e / 2, o = Math.floor(n), l = Math.floor(r), c = o + 1, u = l + 1, h = t / o, p = e / l, f = [], v = [], m = [], y = [];
    for (let _ = 0; _ < u; _++) {
      const w = _ * p - a;
      for (let b = 0; b < c; b++) {
        const T = b * h - s;
        v.push(T, -w, 0), m.push(0, 0, 1), y.push(b / o), y.push(1 - _ / l);
      }
    }
    for (let _ = 0; _ < l; _++)
      for (let w = 0; w < o; w++) {
        const b = w + c * _, T = w + c * (_ + 1), M = w + 1 + c * (_ + 1), A = w + 1 + c * _;
        f.push(b, T, A), f.push(T, M, A);
      }
    this.setIndex(f), this.setAttribute("position", new Wt(v, 3)), this.setAttribute("normal", new Wt(m, 3)), this.setAttribute("uv", new Wt(y, 2));
  }
  static fromJSON(t) {
    return new Wa(t.width, t.height, t.widthSegments, t.heightSegments);
  }
}
const Le = { alphamap_fragment: `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif`, alphamap_pars_fragment: `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, alphatest_fragment: `#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`, alphatest_pars_fragment: `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`, aomap_fragment: `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`, aomap_pars_fragment: `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`, begin_vertex: "vec3 transformed = vec3( position );", beginnormal_vertex: `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`, bsdfs: `vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( V * D );
}
#ifdef USE_IRIDESCENCE
	vec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = mix( F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif`, iridescence_fragment: `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			 return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float R21 = R12;
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`, bumpmap_pars_fragment: `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );
		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = dFdx( surf_pos.xyz );
		vec3 vSigmaY = dFdy( surf_pos.xyz );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`, clipping_planes_fragment: `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`, clipping_planes_pars_fragment: `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`, clipping_planes_pars_vertex: `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`, clipping_planes_vertex: `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`, color_fragment: `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`, color_pars_fragment: `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`, color_pars_vertex: `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`, color_vertex: `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`, common: `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}`, cube_uv_reflection_fragment: `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_v0 0.339
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_v1 0.276
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_v4 0.046
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_v5 0.016
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_v6 0.0038
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`, defaultnormal_vertex: `vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`, displacementmap_pars_vertex: `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`, displacementmap_vertex: `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );
#endif`, emissivemap_fragment: `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`, emissivemap_pars_fragment: `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`, encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );", encodings_pars_fragment: `vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`, envmap_fragment: `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`, envmap_common_pars_fragment: `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`, envmap_pars_fragment: `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`, envmap_pars_vertex: `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`, envmap_physical_pars_fragment: `#if defined( USE_ENVMAP )
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
#endif`, envmap_vertex: `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`, fog_vertex: `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`, fog_pars_vertex: `#ifdef USE_FOG
	varying float vFogDepth;
#endif`, fog_fragment: `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`, fog_pars_fragment: `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`, gradientmap_pars_fragment: `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`, lightmap_fragment: `#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vUv2 );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`, lightmap_pars_fragment: `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`, lights_lambert_fragment: `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`, lights_lambert_pars_fragment: `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`, lights_pars_begin: `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( PHYSICALLY_CORRECT_LIGHTS )
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#else
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometry.position;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometry.position;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`, lights_toon_fragment: `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`, lights_toon_pars_fragment: `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`, lights_phong_fragment: `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`, lights_phong_pars_fragment: `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`, lights_physical_fragment: `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULARINTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;
		#endif
		#ifdef USE_SPECULARCOLORMAP
			specularColorFactor *= texture2D( specularColorMap, vUv ).rgb;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEENCOLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEENROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;
	#endif
#endif`, lights_physical_pars_fragment: `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
};
vec3 clearcoatSpecular = vec3( 0.0 );
vec3 sheenSpecular = vec3( 0.0 );
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );
	#endif
	#ifdef USE_IRIDESCENCE
		reflectedLight.directSpecular += irradiance * BRDF_GGX_Iridescence( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness );
	#else
		reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );
	#endif
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`, lights_fragment_begin: `
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef USE_CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometry.viewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometry, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`, lights_fragment_maps: `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometry.normal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`, lights_fragment_end: `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`, logdepthbuf_fragment: `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`, logdepthbuf_pars_fragment: `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, logdepthbuf_pars_vertex: `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`, logdepthbuf_vertex: `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`, map_fragment: `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`, map_pars_fragment: `#ifdef USE_MAP
	uniform sampler2D map;
#endif`, map_particle_fragment: `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`, map_particle_pars_fragment: `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	uniform mat3 uvTransform;
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, metalnessmap_fragment: `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vUv );
	metalnessFactor *= texelMetalness.b;
#endif`, metalnessmap_pars_fragment: `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`, morphcolor_vertex: `#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`, morphnormal_vertex: `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`, morphtarget_pars_vertex: `#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`, morphtarget_vertex: `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`, normal_fragment_begin: `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	#ifdef USE_TANGENT
		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );
		#ifdef DOUBLE_SIDED
			tangent = tangent * faceDirection;
			bitangent = bitangent * faceDirection;
		#endif
		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )
			mat3 vTBN = mat3( tangent, bitangent, normal );
		#endif
	#endif
#endif
vec3 geometryNormal = normal;`, normal_fragment_maps: `#ifdef OBJECTSPACE_NORMALMAP
	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( TANGENTSPACE_NORMALMAP )
	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	#ifdef USE_TANGENT
		normal = normalize( vTBN * mapN );
	#else
		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );
	#endif
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`, normal_pars_fragment: `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, normal_pars_vertex: `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, normal_vertex: `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`, normalmap_pars_fragment: `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef OBJECTSPACE_NORMALMAP
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )
	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );
		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );
	}
#endif`, clearcoat_normal_fragment_begin: `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`, clearcoat_normal_fragment_maps: `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	#ifdef USE_TANGENT
		clearcoatNormal = normalize( vTBN * clearcoatMapN );
	#else
		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );
	#endif
#endif`, clearcoat_pars_fragment: `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif`, iridescence_pars_fragment: `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`, output_fragment: `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha + 0.1;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`, packing: `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}`, premultiplied_alpha_fragment: `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`, project_vertex: `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`, dithering_fragment: `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`, dithering_pars_fragment: `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`, roughnessmap_fragment: `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vUv );
	roughnessFactor *= texelRoughness.g;
#endif`, roughnessmap_pars_fragment: `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`, shadowmap_pars_fragment: `#if NUM_SPOT_LIGHT_COORDS > 0
  varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
  uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`, shadowmap_pars_vertex: `#if NUM_SPOT_LIGHT_COORDS > 0
  uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
  varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`, shadowmap_vertex: `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`, shadowmask_pars_fragment: `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`, skinbase_vertex: `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`, skinning_pars_vertex: `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	uniform int boneTextureSize;
	mat4 getBoneMatrix( const in float i ) {
		float j = i * 4.0;
		float x = mod( j, float( boneTextureSize ) );
		float y = floor( j / float( boneTextureSize ) );
		float dx = 1.0 / float( boneTextureSize );
		float dy = 1.0 / float( boneTextureSize );
		y = dy * ( y + 0.5 );
		vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
		vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
		vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
		vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
		mat4 bone = mat4( v1, v2, v3, v4 );
		return bone;
	}
#endif`, skinning_vertex: `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`, skinnormal_vertex: `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`, specularmap_fragment: `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`, specularmap_pars_fragment: `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`, tonemapping_fragment: `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`, tonemapping_pars_fragment: `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`, transmission_fragment: `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmission = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmission.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmission.rgb, material.transmission );
#endif`, transmission_pars_fragment: `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		#ifdef texture2DLodEXT
			return texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#else
			return texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#endif
	}
	vec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return radiance;
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );
	}
#endif`, uv_pars_fragment: `#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )
	varying vec2 vUv;
#endif`, uv_pars_vertex: `#ifdef USE_UV
	#ifdef UVS_VERTEX_ONLY
		vec2 vUv;
	#else
		varying vec2 vUv;
	#endif
	uniform mat3 uvTransform;
#endif`, uv_vertex: `#ifdef USE_UV
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
#endif`, uv2_pars_fragment: `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	varying vec2 vUv2;
#endif`, uv2_pars_vertex: `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	attribute vec2 uv2;
	varying vec2 vUv2;
	uniform mat3 uv2Transform;
#endif`, uv2_vertex: `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;
#endif`, worldpos_vertex: `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`, background_vert: `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`, background_frag: `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`, backgroundCube_vert: `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, backgroundCube_frag: `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`, cube_vert: `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, cube_frag: `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`, depth_vert: `#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`, depth_frag: `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`, distanceRGBA_vert: `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`, distanceRGBA_frag: `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`, equirect_vert: `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`, equirect_frag: `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`, linedashed_vert: `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, linedashed_frag: `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, meshbasic_vert: `#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`, meshbasic_frag: `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, meshlambert_vert: `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, meshlambert_frag: `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, meshmatcap_vert: `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`, meshmatcap_frag: `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, meshnormal_vert: `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	vViewPosition = - mvPosition.xyz;
#endif
}`, meshnormal_frag: `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`, meshphong_vert: `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, meshphong_frag: `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, meshphysical_vert: `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`, meshphysical_frag: `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULARINTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
	#ifdef USE_SPECULARCOLORMAP
		uniform sampler2D specularColorMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEENCOLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEENROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <bsdfs>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;
	#endif
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, meshtoon_vert: `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, meshtoon_frag: `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, points_vert: `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`, points_frag: `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, shadow_vert: `#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, shadow_frag: `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`, sprite_vert: `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, sprite_frag: `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}` }, Xt = { common: { diffuse: { value: new Ht(16777215) }, opacity: { value: 1 }, map: { value: null }, uvTransform: { value: new hi() }, uv2Transform: { value: new hi() }, alphaMap: { value: null }, alphaTest: { value: 0 } }, specularmap: { specularMap: { value: null } }, envmap: { envMap: { value: null }, flipEnvMap: { value: -1 }, reflectivity: { value: 1 }, ior: { value: 1.5 }, refractionRatio: { value: 0.98 } }, aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } }, lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 } }, emissivemap: { emissiveMap: { value: null } }, bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } }, normalmap: { normalMap: { value: null }, normalScale: { value: new wt(1, 1) } }, displacementmap: { displacementMap: { value: null }, displacementScale: { value: 1 }, displacementBias: { value: 0 } }, roughnessmap: { roughnessMap: { value: null } }, metalnessmap: { metalnessMap: { value: null } }, gradientmap: { gradientMap: { value: null } }, fog: { fogDensity: { value: 25e-5 }, fogNear: { value: 1 }, fogFar: { value: 2e3 }, fogColor: { value: new Ht(16777215) } }, lights: { ambientLightColor: { value: [] }, lightProbe: { value: [] }, directionalLights: { value: [], properties: { direction: {}, color: {} } }, directionalLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, directionalShadowMap: { value: [] }, directionalShadowMatrix: { value: [] }, spotLights: { value: [], properties: { color: {}, position: {}, direction: {}, distance: {}, coneCos: {}, penumbraCos: {}, decay: {} } }, spotLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, spotLightMap: { value: [] }, spotShadowMap: { value: [] }, spotLightMatrix: { value: [] }, pointLights: { value: [], properties: { color: {}, position: {}, decay: {}, distance: {} } }, pointLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {}, shadowCameraNear: {}, shadowCameraFar: {} } }, pointShadowMap: { value: [] }, pointShadowMatrix: { value: [] }, hemisphereLights: { value: [], properties: { direction: {}, skyColor: {}, groundColor: {} } }, rectAreaLights: { value: [], properties: { color: {}, position: {}, width: {}, height: {} } }, ltc_1: { value: null }, ltc_2: { value: null } }, points: { diffuse: { value: new Ht(16777215) }, opacity: { value: 1 }, size: { value: 1 }, scale: { value: 1 }, map: { value: null }, alphaMap: { value: null }, alphaTest: { value: 0 }, uvTransform: { value: new hi() } }, sprite: { diffuse: { value: new Ht(16777215) }, opacity: { value: 1 }, center: { value: new wt(0.5, 0.5) }, rotation: { value: 0 }, map: { value: null }, alphaMap: { value: null }, alphaTest: { value: 0 }, uvTransform: { value: new hi() } } }, Pn = { basic: { uniforms: ai([Xt.common, Xt.specularmap, Xt.envmap, Xt.aomap, Xt.lightmap, Xt.fog]), vertexShader: Le.meshbasic_vert, fragmentShader: Le.meshbasic_frag }, lambert: { uniforms: ai([Xt.common, Xt.specularmap, Xt.envmap, Xt.aomap, Xt.lightmap, Xt.emissivemap, Xt.bumpmap, Xt.normalmap, Xt.displacementmap, Xt.fog, Xt.lights, { emissive: { value: new Ht(0) } }]), vertexShader: Le.meshlambert_vert, fragmentShader: Le.meshlambert_frag }, phong: { uniforms: ai([Xt.common, Xt.specularmap, Xt.envmap, Xt.aomap, Xt.lightmap, Xt.emissivemap, Xt.bumpmap, Xt.normalmap, Xt.displacementmap, Xt.fog, Xt.lights, { emissive: { value: new Ht(0) }, specular: { value: new Ht(1118481) }, shininess: { value: 30 } }]), vertexShader: Le.meshphong_vert, fragmentShader: Le.meshphong_frag }, standard: { uniforms: ai([Xt.common, Xt.envmap, Xt.aomap, Xt.lightmap, Xt.emissivemap, Xt.bumpmap, Xt.normalmap, Xt.displacementmap, Xt.roughnessmap, Xt.metalnessmap, Xt.fog, Xt.lights, { emissive: { value: new Ht(0) }, roughness: { value: 1 }, metalness: { value: 0 }, envMapIntensity: { value: 1 } }]), vertexShader: Le.meshphysical_vert, fragmentShader: Le.meshphysical_frag }, toon: { uniforms: ai([Xt.common, Xt.aomap, Xt.lightmap, Xt.emissivemap, Xt.bumpmap, Xt.normalmap, Xt.displacementmap, Xt.gradientmap, Xt.fog, Xt.lights, { emissive: { value: new Ht(0) } }]), vertexShader: Le.meshtoon_vert, fragmentShader: Le.meshtoon_frag }, matcap: { uniforms: ai([Xt.common, Xt.bumpmap, Xt.normalmap, Xt.displacementmap, Xt.fog, { matcap: { value: null } }]), vertexShader: Le.meshmatcap_vert, fragmentShader: Le.meshmatcap_frag }, points: { uniforms: ai([Xt.points, Xt.fog]), vertexShader: Le.points_vert, fragmentShader: Le.points_frag }, dashed: { uniforms: ai([Xt.common, Xt.fog, { scale: { value: 1 }, dashSize: { value: 1 }, totalSize: { value: 2 } }]), vertexShader: Le.linedashed_vert, fragmentShader: Le.linedashed_frag }, depth: { uniforms: ai([Xt.common, Xt.displacementmap]), vertexShader: Le.depth_vert, fragmentShader: Le.depth_frag }, normal: { uniforms: ai([Xt.common, Xt.bumpmap, Xt.normalmap, Xt.displacementmap, { opacity: { value: 1 } }]), vertexShader: Le.meshnormal_vert, fragmentShader: Le.meshnormal_frag }, sprite: { uniforms: ai([Xt.sprite, Xt.fog]), vertexShader: Le.sprite_vert, fragmentShader: Le.sprite_frag }, background: { uniforms: { uvTransform: { value: new hi() }, t2D: { value: null }, backgroundIntensity: { value: 1 } }, vertexShader: Le.background_vert, fragmentShader: Le.background_frag }, backgroundCube: { uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 }, backgroundBlurriness: { value: 0 }, backgroundIntensity: { value: 1 } }, vertexShader: Le.backgroundCube_vert, fragmentShader: Le.backgroundCube_frag }, cube: { uniforms: { tCube: { value: null }, tFlip: { value: -1 }, opacity: { value: 1 } }, vertexShader: Le.cube_vert, fragmentShader: Le.cube_frag }, equirect: { uniforms: { tEquirect: { value: null } }, vertexShader: Le.equirect_vert, fragmentShader: Le.equirect_frag }, distanceRGBA: { uniforms: ai([Xt.common, Xt.displacementmap, { referencePosition: { value: new D() }, nearDistance: { value: 1 }, farDistance: { value: 1e3 } }]), vertexShader: Le.distanceRGBA_vert, fragmentShader: Le.distanceRGBA_frag }, shadow: { uniforms: ai([Xt.lights, Xt.fog, { color: { value: new Ht(0) }, opacity: { value: 1 } }]), vertexShader: Le.shadow_vert, fragmentShader: Le.shadow_frag } };
Pn.physical = { uniforms: ai([Pn.standard.uniforms, { clearcoat: { value: 0 }, clearcoatMap: { value: null }, clearcoatRoughness: { value: 0 }, clearcoatRoughnessMap: { value: null }, clearcoatNormalScale: { value: new wt(1, 1) }, clearcoatNormalMap: { value: null }, iridescence: { value: 0 }, iridescenceMap: { value: null }, iridescenceIOR: { value: 1.3 }, iridescenceThicknessMinimum: { value: 100 }, iridescenceThicknessMaximum: { value: 400 }, iridescenceThicknessMap: { value: null }, sheen: { value: 0 }, sheenColor: { value: new Ht(0) }, sheenColorMap: { value: null }, sheenRoughness: { value: 1 }, sheenRoughnessMap: { value: null }, transmission: { value: 0 }, transmissionMap: { value: null }, transmissionSamplerSize: { value: new wt() }, transmissionSamplerMap: { value: null }, thickness: { value: 0 }, thicknessMap: { value: null }, attenuationDistance: { value: 0 }, attenuationColor: { value: new Ht(0) }, specularIntensity: { value: 1 }, specularIntensityMap: { value: null }, specularColor: { value: new Ht(1, 1, 1) }, specularColorMap: { value: null } }]), vertexShader: Le.meshphysical_vert, fragmentShader: Le.meshphysical_frag };
const im = { r: 0, b: 0, g: 0 };
function CN(i, t, e, n, r, s, a) {
  const o = new Ht(0);
  let l, c, u = s === !0 ? 0 : 1, h = null, p = 0, f = null;
  function v(m, y) {
    m.getRGB(im, xI(i)), n.buffers.color.setClear(im.r, im.g, im.b, y, a);
  }
  return { getClearColor: function() {
    return o;
  }, setClearColor: function(m, y = 1) {
    o.set(m), u = y, v(o, u);
  }, getClearAlpha: function() {
    return u;
  }, setClearAlpha: function(m) {
    u = m, v(o, u);
  }, render: function(m, y) {
    let _ = !1, w = y.isScene === !0 ? y.background : null;
    w && w.isTexture && (w = (y.backgroundBlurriness > 0 ? e : t).get(w));
    const b = i.xr, T = b.getSession && b.getSession();
    T && T.environmentBlendMode === "additive" && (w = null), w === null ? v(o, u) : w && w.isColor && (v(w, 1), _ = !0), (i.autoClear || _) && i.clear(i.autoClearColor, i.autoClearDepth, i.autoClearStencil), w && (w.isCubeTexture || w.mapping === 306) ? (c === void 0 && (c = new Nt(new zn(1, 1, 1), new Gn({ name: "BackgroundCubeMaterial", uniforms: Fh(Pn.backgroundCube.uniforms), vertexShader: Pn.backgroundCube.vertexShader, fragmentShader: Pn.backgroundCube.fragmentShader, side: 1, depthTest: !1, depthWrite: !1, fog: !1 })), c.geometry.deleteAttribute("normal"), c.geometry.deleteAttribute("uv"), c.onBeforeRender = function(M, A, C) {
      this.matrixWorld.copyPosition(C.matrixWorld);
    }, Object.defineProperty(c.material, "envMap", { get: function() {
      return this.uniforms.envMap.value;
    } }), r.update(c)), c.material.uniforms.envMap.value = w, c.material.uniforms.flipEnvMap.value = w.isCubeTexture && w.isRenderTargetTexture === !1 ? -1 : 1, c.material.uniforms.backgroundBlurriness.value = y.backgroundBlurriness, c.material.uniforms.backgroundIntensity.value = y.backgroundIntensity, c.material.toneMapped = w.encoding !== 3001, h === w && p === w.version && f === i.toneMapping || (c.material.needsUpdate = !0, h = w, p = w.version, f = i.toneMapping), c.layers.enableAll(), m.unshift(c, c.geometry, c.material, 0, 0, null)) : w && w.isTexture && (l === void 0 && (l = new Nt(new Wa(2, 2), new Gn({ name: "BackgroundMaterial", uniforms: Fh(Pn.background.uniforms), vertexShader: Pn.background.vertexShader, fragmentShader: Pn.background.fragmentShader, side: 0, depthTest: !1, depthWrite: !1, fog: !1 })), l.geometry.deleteAttribute("normal"), Object.defineProperty(l.material, "map", { get: function() {
      return this.uniforms.t2D.value;
    } }), r.update(l)), l.material.uniforms.t2D.value = w, l.material.uniforms.backgroundIntensity.value = y.backgroundIntensity, l.material.toneMapped = w.encoding !== 3001, w.matrixAutoUpdate === !0 && w.updateMatrix(), l.material.uniforms.uvTransform.value.copy(w.matrix), h === w && p === w.version && f === i.toneMapping || (l.material.needsUpdate = !0, h = w, p = w.version, f = i.toneMapping), l.layers.enableAll(), m.unshift(l, l.geometry, l.material, 0, 0, null));
  } };
}
function PN(i, t, e, n) {
  const r = i.getParameter(34921), s = n.isWebGL2 ? null : t.get("OES_vertex_array_object"), a = n.isWebGL2 || s !== null, o = {}, l = f(null);
  let c = l, u = !1;
  function h(M) {
    return n.isWebGL2 ? i.bindVertexArray(M) : s.bindVertexArrayOES(M);
  }
  function p(M) {
    return n.isWebGL2 ? i.deleteVertexArray(M) : s.deleteVertexArrayOES(M);
  }
  function f(M) {
    const A = [], C = [], I = [];
    for (let k = 0; k < r; k++)
      A[k] = 0, C[k] = 0, I[k] = 0;
    return { geometry: null, program: null, wireframe: !1, newAttributes: A, enabledAttributes: C, attributeDivisors: I, object: M, attributes: {}, index: null };
  }
  function v() {
    const M = c.newAttributes;
    for (let A = 0, C = M.length; A < C; A++)
      M[A] = 0;
  }
  function m(M) {
    y(M, 0);
  }
  function y(M, A) {
    const C = c.newAttributes, I = c.enabledAttributes, k = c.attributeDivisors;
    C[M] = 1, I[M] === 0 && (i.enableVertexAttribArray(M), I[M] = 1), k[M] !== A && ((n.isWebGL2 ? i : t.get("ANGLE_instanced_arrays"))[n.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](M, A), k[M] = A);
  }
  function _() {
    const M = c.newAttributes, A = c.enabledAttributes;
    for (let C = 0, I = A.length; C < I; C++)
      A[C] !== M[C] && (i.disableVertexAttribArray(C), A[C] = 0);
  }
  function w(M, A, C, I, k, R) {
    n.isWebGL2 !== !0 || C !== 5124 && C !== 5125 ? i.vertexAttribPointer(M, A, C, I, k, R) : i.vertexAttribIPointer(M, A, C, k, R);
  }
  function b() {
    T(), u = !0, c !== l && (c = l, h(c.object));
  }
  function T() {
    l.geometry = null, l.program = null, l.wireframe = !1;
  }
  return { setup: function(M, A, C, I, k) {
    let R = !1;
    if (a) {
      const L = function(E, q, it) {
        const rt = it.wireframe === !0;
        let ft = o[E.id];
        ft === void 0 && (ft = {}, o[E.id] = ft);
        let nt = ft[q.id];
        nt === void 0 && (nt = {}, ft[q.id] = nt);
        let vt = nt[rt];
        return vt === void 0 && (vt = f(n.isWebGL2 ? i.createVertexArray() : s.createVertexArrayOES()), nt[rt] = vt), vt;
      }(I, C, A);
      c !== L && (c = L, h(c.object)), R = function(E, q, it, rt) {
        const ft = c.attributes, nt = q.attributes;
        let vt = 0;
        const $ = it.getAttributes();
        for (const W in $)
          if ($[W].location >= 0) {
            const ct = ft[W];
            let mt = nt[W];
            if (mt === void 0 && (W === "instanceMatrix" && E.instanceMatrix && (mt = E.instanceMatrix), W === "instanceColor" && E.instanceColor && (mt = E.instanceColor)), ct === void 0 || ct.attribute !== mt || mt && ct.data !== mt.data)
              return !0;
            vt++;
          }
        return c.attributesNum !== vt || c.index !== rt;
      }(M, I, C, k), R && function(E, q, it, rt) {
        const ft = {}, nt = q.attributes;
        let vt = 0;
        const $ = it.getAttributes();
        for (const W in $)
          if ($[W].location >= 0) {
            let ct = nt[W];
            ct === void 0 && (W === "instanceMatrix" && E.instanceMatrix && (ct = E.instanceMatrix), W === "instanceColor" && E.instanceColor && (ct = E.instanceColor));
            const mt = {};
            mt.attribute = ct, ct && ct.data && (mt.data = ct.data), ft[W] = mt, vt++;
          }
        c.attributes = ft, c.attributesNum = vt, c.index = rt;
      }(M, I, C, k);
    } else {
      const L = A.wireframe === !0;
      c.geometry === I.id && c.program === C.id && c.wireframe === L || (c.geometry = I.id, c.program = C.id, c.wireframe = L, R = !0);
    }
    k !== null && e.update(k, 34963), (R || u) && (u = !1, function(L, E, q, it) {
      if (n.isWebGL2 === !1 && (L.isInstancedMesh || it.isInstancedBufferGeometry) && t.get("ANGLE_instanced_arrays") === null)
        return;
      v();
      const rt = it.attributes, ft = q.getAttributes(), nt = E.defaultAttributeValues;
      for (const vt in ft) {
        const $ = ft[vt];
        if ($.location >= 0) {
          let W = rt[vt];
          if (W === void 0 && (vt === "instanceMatrix" && L.instanceMatrix && (W = L.instanceMatrix), vt === "instanceColor" && L.instanceColor && (W = L.instanceColor)), W !== void 0) {
            const ct = W.normalized, mt = W.itemSize, dt = e.get(W);
            if (dt === void 0)
              continue;
            const Mt = dt.buffer, At = dt.type, H = dt.bytesPerElement;
            if (W.isInterleavedBufferAttribute) {
              const N = W.data, st = N.stride, et = W.offset;
              if (N.isInstancedInterleavedBuffer) {
                for (let J = 0; J < $.locationSize; J++)
                  y($.location + J, N.meshPerAttribute);
                L.isInstancedMesh !== !0 && it._maxInstanceCount === void 0 && (it._maxInstanceCount = N.meshPerAttribute * N.count);
              } else
                for (let J = 0; J < $.locationSize; J++)
                  m($.location + J);
              i.bindBuffer(34962, Mt);
              for (let J = 0; J < $.locationSize; J++)
                w($.location + J, mt / $.locationSize, At, ct, st * H, (et + mt / $.locationSize * J) * H);
            } else {
              if (W.isInstancedBufferAttribute) {
                for (let N = 0; N < $.locationSize; N++)
                  y($.location + N, W.meshPerAttribute);
                L.isInstancedMesh !== !0 && it._maxInstanceCount === void 0 && (it._maxInstanceCount = W.meshPerAttribute * W.count);
              } else
                for (let N = 0; N < $.locationSize; N++)
                  m($.location + N);
              i.bindBuffer(34962, Mt);
              for (let N = 0; N < $.locationSize; N++)
                w($.location + N, mt / $.locationSize, At, ct, mt * H, mt / $.locationSize * N * H);
            }
          } else if (nt !== void 0) {
            const ct = nt[vt];
            if (ct !== void 0)
              switch (ct.length) {
                case 2:
                  i.vertexAttrib2fv($.location, ct);
                  break;
                case 3:
                  i.vertexAttrib3fv($.location, ct);
                  break;
                case 4:
                  i.vertexAttrib4fv($.location, ct);
                  break;
                default:
                  i.vertexAttrib1fv($.location, ct);
              }
          }
        }
      }
      _();
    }(M, A, C, I), k !== null && i.bindBuffer(34963, e.get(k).buffer));
  }, reset: b, resetDefaultState: T, dispose: function() {
    b();
    for (const M in o) {
      const A = o[M];
      for (const C in A) {
        const I = A[C];
        for (const k in I)
          p(I[k].object), delete I[k];
        delete A[C];
      }
      delete o[M];
    }
  }, releaseStatesOfGeometry: function(M) {
    if (o[M.id] === void 0)
      return;
    const A = o[M.id];
    for (const C in A) {
      const I = A[C];
      for (const k in I)
        p(I[k].object), delete I[k];
      delete A[C];
    }
    delete o[M.id];
  }, releaseStatesOfProgram: function(M) {
    for (const A in o) {
      const C = o[A];
      if (C[M.id] === void 0)
        continue;
      const I = C[M.id];
      for (const k in I)
        p(I[k].object), delete I[k];
      delete C[M.id];
    }
  }, initAttributes: v, enableAttribute: m, disableUnusedAttributes: _ };
}
function DN(i, t, e, n) {
  const r = n.isWebGL2;
  let s;
  this.setMode = function(a) {
    s = a;
  }, this.render = function(a, o) {
    i.drawArrays(s, a, o), e.update(o, s, 1);
  }, this.renderInstances = function(a, o, l) {
    if (l === 0)
      return;
    let c, u;
    if (r)
      c = i, u = "drawArraysInstanced";
    else if (c = t.get("ANGLE_instanced_arrays"), u = "drawArraysInstancedANGLE", c === null)
      return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
    c[u](s, a, o, l), e.update(o, s, l);
  };
}
function RN(i, t, e) {
  let n;
  function r(T) {
    if (T === "highp") {
      if (i.getShaderPrecisionFormat(35633, 36338).precision > 0 && i.getShaderPrecisionFormat(35632, 36338).precision > 0)
        return "highp";
      T = "mediump";
    }
    return T === "mediump" && i.getShaderPrecisionFormat(35633, 36337).precision > 0 && i.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp";
  }
  const s = typeof WebGL2RenderingContext < "u" && i instanceof WebGL2RenderingContext;
  let a = e.precision !== void 0 ? e.precision : "highp";
  const o = r(a);
  o !== a && (console.warn("THREE.WebGLRenderer:", a, "not supported, using", o, "instead."), a = o);
  const l = s || t.has("WEBGL_draw_buffers"), c = e.logarithmicDepthBuffer === !0, u = i.getParameter(34930), h = i.getParameter(35660), p = i.getParameter(3379), f = i.getParameter(34076), v = i.getParameter(34921), m = i.getParameter(36347), y = i.getParameter(36348), _ = i.getParameter(36349), w = h > 0, b = s || t.has("OES_texture_float");
  return { isWebGL2: s, drawBuffers: l, getMaxAnisotropy: function() {
    if (n !== void 0)
      return n;
    if (t.has("EXT_texture_filter_anisotropic") === !0) {
      const T = t.get("EXT_texture_filter_anisotropic");
      n = i.getParameter(T.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else
      n = 0;
    return n;
  }, getMaxPrecision: r, precision: a, logarithmicDepthBuffer: c, maxTextures: u, maxVertexTextures: h, maxTextureSize: p, maxCubemapSize: f, maxAttributes: v, maxVertexUniforms: m, maxVaryings: y, maxFragmentUniforms: _, vertexTextures: w, floatFragmentTextures: b, floatVertexTextures: w && b, maxSamples: s ? i.getParameter(36183) : 0 };
}
function IN(i) {
  const t = this;
  let e = null, n = 0, r = !1, s = !1;
  const a = new Hn(), o = new hi(), l = { value: null, needsUpdate: !1 };
  function c(u, h, p, f) {
    const v = u !== null ? u.length : 0;
    let m = null;
    if (v !== 0) {
      if (m = l.value, f !== !0 || m === null) {
        const y = p + 4 * v, _ = h.matrixWorldInverse;
        o.getNormalMatrix(_), (m === null || m.length < y) && (m = new Float32Array(y));
        for (let w = 0, b = p; w !== v; ++w, b += 4)
          a.copy(u[w]).applyMatrix4(_, o), a.normal.toArray(m, b), m[b + 3] = a.constant;
      }
      l.value = m, l.needsUpdate = !0;
    }
    return t.numPlanes = v, t.numIntersection = 0, m;
  }
  this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function(u, h) {
    const p = u.length !== 0 || h || n !== 0 || r;
    return r = h, n = u.length, p;
  }, this.beginShadows = function() {
    s = !0, c(null);
  }, this.endShadows = function() {
    s = !1;
  }, this.setGlobalState = function(u, h) {
    e = c(u, h, 0);
  }, this.setState = function(u, h, p) {
    const f = u.clippingPlanes, v = u.clipIntersection, m = u.clipShadows, y = i.get(u);
    if (!r || f === null || f.length === 0 || s && !m)
      s ? c(null) : function() {
        l.value !== e && (l.value = e, l.needsUpdate = n > 0), t.numPlanes = n, t.numIntersection = 0;
      }();
    else {
      const _ = s ? 0 : n, w = 4 * _;
      let b = y.clippingState || null;
      l.value = b, b = c(f, h, w, p);
      for (let T = 0; T !== w; ++T)
        b[T] = e[T];
      y.clippingState = b, this.numIntersection = v ? this.numPlanes : 0, this.numPlanes += _;
    }
  };
}
function ON(i) {
  let t = /* @__PURE__ */ new WeakMap();
  function e(r, s) {
    return s === 303 ? r.mapping = 301 : s === 304 && (r.mapping = 302), r;
  }
  function n(r) {
    const s = r.target;
    s.removeEventListener("dispose", n);
    const a = t.get(s);
    a !== void 0 && (t.delete(s), a.dispose());
  }
  return { get: function(r) {
    if (r && r.isTexture && r.isRenderTargetTexture === !1) {
      const s = r.mapping;
      if (s === 303 || s === 304) {
        if (t.has(r))
          return e(t.get(r).texture, r.mapping);
        {
          const a = r.image;
          if (a && a.height > 0) {
            const o = new SI(a.height / 2);
            return o.fromEquirectangularTexture(i, r), t.set(r, o), r.addEventListener("dispose", n), e(o.texture, r.mapping);
          }
          return null;
        }
      }
    }
    return r;
  }, dispose: function() {
    t = /* @__PURE__ */ new WeakMap();
  } };
}
class Yl extends Qv {
  constructor(t = -1, e = 1, n = 1, r = -1, s = 0.1, a = 2e3) {
    super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = t, this.right = e, this.top = n, this.bottom = r, this.near = s, this.far = a, this.updateProjectionMatrix();
  }
  copy(t, e) {
    return super.copy(t, e), this.left = t.left, this.right = t.right, this.top = t.top, this.bottom = t.bottom, this.near = t.near, this.far = t.far, this.zoom = t.zoom, this.view = t.view === null ? null : Object.assign({}, t.view), this;
  }
  setViewOffset(t, e, n, r, s, a) {
    this.view === null && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = r, this.view.width = s, this.view.height = a, this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const t = (this.right - this.left) / (2 * this.zoom), e = (this.top - this.bottom) / (2 * this.zoom), n = (this.right + this.left) / 2, r = (this.top + this.bottom) / 2;
    let s = n - t, a = n + t, o = r + e, l = r - e;
    if (this.view !== null && this.view.enabled) {
      const c = (this.right - this.left) / this.view.fullWidth / this.zoom, u = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      s += c * this.view.offsetX, a = s + c * this.view.width, o -= u * this.view.offsetY, l = o - u * this.view.height;
    }
    this.projectionMatrix.makeOrthographic(s, a, o, l, this.near, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(t) {
    const e = super.toJSON(t);
    return e.object.zoom = this.zoom, e.object.left = this.left, e.object.right = this.right, e.object.top = this.top, e.object.bottom = this.bottom, e.object.near = this.near, e.object.far = this.far, this.view !== null && (e.object.view = Object.assign({}, this.view)), e;
  }
}
const RT = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582], Vu = 20, u_ = new Yl(), IT = new Ht();
let d_ = null;
const Tl = (1 + Math.sqrt(5)) / 2, Nc = 1 / Tl, OT = [new D(1, 1, 1), new D(-1, 1, 1), new D(1, 1, -1), new D(-1, 1, -1), new D(0, Tl, Nc), new D(0, Tl, -Nc), new D(Nc, 0, Tl), new D(-Nc, 0, Tl), new D(Tl, Nc, 0), new D(-Tl, Nc, 0)];
class Yd {
  constructor(t) {
    this._renderer = t, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial);
  }
  fromScene(t, e = 0, n = 0.1, r = 100) {
    d_ = this._renderer.getRenderTarget(), this._setSize(256);
    const s = this._allocateTargets();
    return s.depthBuffer = !0, this._sceneToCubeUV(t, n, r, s), e > 0 && this._blur(s, 0, 0, e), this._applyPMREM(s), this._cleanup(s), s;
  }
  fromEquirectangular(t, e = null) {
    return this._fromTexture(t, e);
  }
  fromCubemap(t, e = null) {
    return this._fromTexture(t, e);
  }
  compileCubemapShader() {
    this._cubemapMaterial === null && (this._cubemapMaterial = zT(), this._compileMaterial(this._cubemapMaterial));
  }
  compileEquirectangularShader() {
    this._equirectMaterial === null && (this._equirectMaterial = BT(), this._compileMaterial(this._equirectMaterial));
  }
  dispose() {
    this._dispose(), this._cubemapMaterial !== null && this._cubemapMaterial.dispose(), this._equirectMaterial !== null && this._equirectMaterial.dispose();
  }
  _setSize(t) {
    this._lodMax = Math.floor(Math.log2(t)), this._cubeSize = Math.pow(2, this._lodMax);
  }
  _dispose() {
    this._blurMaterial !== null && this._blurMaterial.dispose(), this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
    for (let t = 0; t < this._lodPlanes.length; t++)
      this._lodPlanes[t].dispose();
  }
  _cleanup(t) {
    this._renderer.setRenderTarget(d_), t.scissorTest = !1, sm(t, 0, 0, t.width, t.height);
  }
  _fromTexture(t, e) {
    t.mapping === 301 || t.mapping === 302 ? this._setSize(t.image.length === 0 ? 16 : t.image[0].width || t.image[0].image.width) : this._setSize(t.image.width / 4), d_ = this._renderer.getRenderTarget();
    const n = e || this._allocateTargets();
    return this._textureToCubeUV(t, n), this._applyPMREM(n), this._cleanup(n), n;
  }
  _allocateTargets() {
    const t = 3 * Math.max(this._cubeSize, 112), e = 4 * this._cubeSize, n = { magFilter: 1006, minFilter: 1006, generateMipmaps: !1, type: 1016, format: 1023, encoding: 3e3, depthBuffer: !1 }, r = LT(t, e, n);
    if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== t || this._pingPongRenderTarget.height !== e) {
      this._pingPongRenderTarget !== null && this._dispose(), this._pingPongRenderTarget = LT(t, e, n);
      const { _lodMax: s } = this;
      ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = function(a) {
        const o = [], l = [], c = [];
        let u = a;
        const h = a - 4 + 1 + RT.length;
        for (let p = 0; p < h; p++) {
          const f = Math.pow(2, u);
          l.push(f);
          let v = 1 / f;
          p > a - 4 ? v = RT[p - a + 4 - 1] : p === 0 && (v = 0), c.push(v);
          const m = 1 / (f - 2), y = -m, _ = 1 + m, w = [y, y, _, y, _, _, y, y, _, _, y, _], b = 6, T = 6, M = 3, A = 2, C = 1, I = new Float32Array(M * T * b), k = new Float32Array(A * T * b), R = new Float32Array(C * T * b);
          for (let E = 0; E < b; E++) {
            const q = E % 3 * 2 / 3 - 1, it = E > 2 ? 0 : -1, rt = [q, it, 0, q + 2 / 3, it, 0, q + 2 / 3, it + 1, 0, q, it, 0, q + 2 / 3, it + 1, 0, q, it + 1, 0];
            I.set(rt, M * T * E), k.set(w, A * T * E);
            const ft = [E, E, E, E, E, E];
            R.set(ft, C * T * E);
          }
          const L = new _e();
          L.setAttribute("position", new Ze(I, M)), L.setAttribute("uv", new Ze(k, A)), L.setAttribute("faceIndex", new Ze(R, C)), o.push(L), u > 4 && u--;
        }
        return { lodPlanes: o, sizeLods: l, sigmas: c };
      }(s)), this._blurMaterial = function(a, o, l) {
        const c = new Float32Array(Vu), u = new D(0, 1, 0);
        return new Gn({ name: "SphericalGaussianBlur", defines: { n: Vu, CUBEUV_TEXEL_WIDTH: 1 / o, CUBEUV_TEXEL_HEIGHT: 1 / l, CUBEUV_MAX_MIP: `${a}.0` }, uniforms: { envMap: { value: null }, samples: { value: 1 }, weights: { value: c }, latitudinal: { value: !1 }, dTheta: { value: 0 }, mipInt: { value: 0 }, poleAxis: { value: u } }, vertexShader: Nb(), fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`, blending: 0, depthTest: !1, depthWrite: !1 });
      }(s, t, e);
    }
    return r;
  }
  _compileMaterial(t) {
    const e = new Nt(this._lodPlanes[0], t);
    this._renderer.compile(e, u_);
  }
  _sceneToCubeUV(t, e, n, r) {
    const s = new Cr(90, 1, e, n), a = [1, -1, 1, 1, 1, 1], o = [1, 1, 1, -1, -1, -1], l = this._renderer, c = l.autoClear, u = l.toneMapping;
    l.getClearColor(IT), l.toneMapping = 0, l.autoClear = !1;
    const h = new ci({ name: "PMREM.Background", side: 1, depthWrite: !1, depthTest: !1 }), p = new Nt(new zn(), h);
    let f = !1;
    const v = t.background;
    v ? v.isColor && (h.color.copy(v), t.background = null, f = !0) : (h.color.copy(IT), f = !0);
    for (let m = 0; m < 6; m++) {
      const y = m % 3;
      y === 0 ? (s.up.set(0, a[m], 0), s.lookAt(o[m], 0, 0)) : y === 1 ? (s.up.set(0, 0, a[m]), s.lookAt(0, o[m], 0)) : (s.up.set(0, a[m], 0), s.lookAt(0, 0, o[m]));
      const _ = this._cubeSize;
      sm(r, y * _, m > 2 ? _ : 0, _, _), l.setRenderTarget(r), f && l.render(p, s), l.render(t, s);
    }
    p.geometry.dispose(), p.material.dispose(), l.toneMapping = u, l.autoClear = c, t.background = v;
  }
  _textureToCubeUV(t, e) {
    const n = this._renderer, r = t.mapping === 301 || t.mapping === 302;
    r ? (this._cubemapMaterial === null && (this._cubemapMaterial = zT()), this._cubemapMaterial.uniforms.flipEnvMap.value = t.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = BT());
    const s = r ? this._cubemapMaterial : this._equirectMaterial, a = new Nt(this._lodPlanes[0], s);
    s.uniforms.envMap.value = t;
    const o = this._cubeSize;
    sm(e, 0, 0, 3 * o, 2 * o), n.setRenderTarget(e), n.render(a, u_);
  }
  _applyPMREM(t) {
    const e = this._renderer, n = e.autoClear;
    e.autoClear = !1;
    for (let r = 1; r < this._lodPlanes.length; r++) {
      const s = Math.sqrt(this._sigmas[r] * this._sigmas[r] - this._sigmas[r - 1] * this._sigmas[r - 1]), a = OT[(r - 1) % OT.length];
      this._blur(t, r - 1, r, s, a);
    }
    e.autoClear = n;
  }
  _blur(t, e, n, r, s) {
    const a = this._pingPongRenderTarget;
    this._halfBlur(t, a, e, n, r, "latitudinal", s), this._halfBlur(a, t, n, n, r, "longitudinal", s);
  }
  _halfBlur(t, e, n, r, s, a, o) {
    const l = this._renderer, c = this._blurMaterial;
    a !== "latitudinal" && a !== "longitudinal" && console.error("blur direction must be either latitudinal or longitudinal!");
    const u = new Nt(this._lodPlanes[r], c), h = c.uniforms, p = this._sizeLods[n] - 1, f = isFinite(s) ? Math.PI / (2 * p) : 2 * Math.PI / 39, v = s / f, m = isFinite(s) ? 1 + Math.floor(3 * v) : Vu;
    m > Vu && console.warn(`sigmaRadians, ${s}, is too large and will clip, as it requested ${m} samples when the maximum is set to 20`);
    const y = [];
    let _ = 0;
    for (let T = 0; T < Vu; ++T) {
      const M = T / v, A = Math.exp(-M * M / 2);
      y.push(A), T === 0 ? _ += A : T < m && (_ += 2 * A);
    }
    for (let T = 0; T < y.length; T++)
      y[T] = y[T] / _;
    h.envMap.value = t.texture, h.samples.value = m, h.weights.value = y, h.latitudinal.value = a === "latitudinal", o && (h.poleAxis.value = o);
    const { _lodMax: w } = this;
    h.dTheta.value = f, h.mipInt.value = w - n;
    const b = this._sizeLods[r];
    sm(e, 3 * b * (r > w - 4 ? r - w + 4 : 0), 4 * (this._cubeSize - b), 3 * b, 2 * b), l.setRenderTarget(e), l.render(u, u_);
  }
}
function LT(i, t, e) {
  const n = new ir(i, t, e);
  return n.texture.mapping = 306, n.texture.name = "PMREM.cubeUv", n.scissorTest = !0, n;
}
function sm(i, t, e, n, r) {
  i.viewport.set(t, e, n, r), i.scissor.set(t, e, n, r);
}
function BT() {
  return new Gn({ name: "EquirectangularToCubeUV", uniforms: { envMap: { value: null } }, vertexShader: Nb(), fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`, blending: 0, depthTest: !1, depthWrite: !1 });
}
function zT() {
  return new Gn({ name: "CubemapToCubeUV", uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } }, vertexShader: Nb(), fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`, blending: 0, depthTest: !1, depthWrite: !1 });
}
function Nb() {
  return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
}
function LN(i) {
  let t = /* @__PURE__ */ new WeakMap(), e = null;
  function n(r) {
    const s = r.target;
    s.removeEventListener("dispose", n);
    const a = t.get(s);
    a !== void 0 && (t.delete(s), a.dispose());
  }
  return { get: function(r) {
    if (r && r.isTexture) {
      const s = r.mapping, a = s === 303 || s === 304, o = s === 301 || s === 302;
      if (a || o) {
        if (r.isRenderTargetTexture && r.needsPMREMUpdate === !0) {
          r.needsPMREMUpdate = !1;
          let l = t.get(r);
          return e === null && (e = new Yd(i)), l = a ? e.fromEquirectangular(r, l) : e.fromCubemap(r, l), t.set(r, l), l.texture;
        }
        if (t.has(r))
          return t.get(r).texture;
        {
          const l = r.image;
          if (a && l && l.height > 0 || o && l && function(c) {
            let u = 0;
            const h = 6;
            for (let p = 0; p < h; p++)
              c[p] !== void 0 && u++;
            return u === h;
          }(l)) {
            e === null && (e = new Yd(i));
            const c = a ? e.fromEquirectangular(r) : e.fromCubemap(r);
            return t.set(r, c), r.addEventListener("dispose", n), c.texture;
          }
          return null;
        }
      }
    }
    return r;
  }, dispose: function() {
    t = /* @__PURE__ */ new WeakMap(), e !== null && (e.dispose(), e = null);
  } };
}
function BN(i) {
  const t = {};
  function e(n) {
    if (t[n] !== void 0)
      return t[n];
    let r;
    switch (n) {
      case "WEBGL_depth_texture":
        r = i.getExtension("WEBGL_depth_texture") || i.getExtension("MOZ_WEBGL_depth_texture") || i.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        r = i.getExtension("EXT_texture_filter_anisotropic") || i.getExtension("MOZ_EXT_texture_filter_anisotropic") || i.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        r = i.getExtension("WEBGL_compressed_texture_s3tc") || i.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || i.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        r = i.getExtension("WEBGL_compressed_texture_pvrtc") || i.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        r = i.getExtension(n);
    }
    return t[n] = r, r;
  }
  return { has: function(n) {
    return e(n) !== null;
  }, init: function(n) {
    n.isWebGL2 ? e("EXT_color_buffer_float") : (e("WEBGL_depth_texture"), e("OES_texture_float"), e("OES_texture_half_float"), e("OES_texture_half_float_linear"), e("OES_standard_derivatives"), e("OES_element_index_uint"), e("OES_vertex_array_object"), e("ANGLE_instanced_arrays")), e("OES_texture_float_linear"), e("EXT_color_buffer_half_float"), e("WEBGL_multisampled_render_to_texture");
  }, get: function(n) {
    const r = e(n);
    return r === null && console.warn("THREE.WebGLRenderer: " + n + " extension not supported."), r;
  } };
}
function zN(i, t, e, n) {
  const r = {}, s = /* @__PURE__ */ new WeakMap();
  function a(l) {
    const c = l.target;
    c.index !== null && t.remove(c.index);
    for (const h in c.attributes)
      t.remove(c.attributes[h]);
    c.removeEventListener("dispose", a), delete r[c.id];
    const u = s.get(c);
    u && (t.remove(u), s.delete(c)), n.releaseStatesOfGeometry(c), c.isInstancedBufferGeometry === !0 && delete c._maxInstanceCount, e.memory.geometries--;
  }
  function o(l) {
    const c = [], u = l.index, h = l.attributes.position;
    let p = 0;
    if (u !== null) {
      const m = u.array;
      p = u.version;
      for (let y = 0, _ = m.length; y < _; y += 3) {
        const w = m[y + 0], b = m[y + 1], T = m[y + 2];
        c.push(w, b, b, T, T, w);
      }
    } else {
      const m = h.array;
      p = h.version;
      for (let y = 0, _ = m.length / 3 - 1; y < _; y += 3) {
        const w = y + 0, b = y + 1, T = y + 2;
        c.push(w, b, b, T, T, w);
      }
    }
    const f = new (yI(c) ? Wl : Gl)(c, 1);
    f.version = p;
    const v = s.get(l);
    v && t.remove(v), s.set(l, f);
  }
  return { get: function(l, c) {
    return r[c.id] === !0 || (c.addEventListener("dispose", a), r[c.id] = !0, e.memory.geometries++), c;
  }, update: function(l) {
    const c = l.attributes;
    for (const h in c)
      t.update(c[h], 34962);
    const u = l.morphAttributes;
    for (const h in u) {
      const p = u[h];
      for (let f = 0, v = p.length; f < v; f++)
        t.update(p[f], 34962);
    }
  }, getWireframeAttribute: function(l) {
    const c = s.get(l);
    if (c) {
      const u = l.index;
      u !== null && c.version < u.version && o(l);
    } else
      o(l);
    return s.get(l);
  } };
}
function kN(i, t, e, n) {
  const r = n.isWebGL2;
  let s, a, o;
  this.setMode = function(l) {
    s = l;
  }, this.setIndex = function(l) {
    a = l.type, o = l.bytesPerElement;
  }, this.render = function(l, c) {
    i.drawElements(s, c, a, l * o), e.update(c, s, 1);
  }, this.renderInstances = function(l, c, u) {
    if (u === 0)
      return;
    let h, p;
    if (r)
      h = i, p = "drawElementsInstanced";
    else if (h = t.get("ANGLE_instanced_arrays"), p = "drawElementsInstancedANGLE", h === null)
      return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
    h[p](s, c, a, l * o, u), e.update(c, s, u);
  };
}
function NN(i) {
  const t = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
  return { memory: { geometries: 0, textures: 0 }, render: t, programs: null, autoReset: !0, reset: function() {
    t.frame++, t.calls = 0, t.triangles = 0, t.points = 0, t.lines = 0;
  }, update: function(e, n, r) {
    switch (t.calls++, n) {
      case 4:
        t.triangles += r * (e / 3);
        break;
      case 1:
        t.lines += r * (e / 2);
        break;
      case 3:
        t.lines += r * (e - 1);
        break;
      case 2:
        t.lines += r * e;
        break;
      case 0:
        t.points += r * e;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", n);
    }
  } };
}
function FN(i, t) {
  return i[0] - t[0];
}
function UN(i, t) {
  return Math.abs(t[1]) - Math.abs(i[1]);
}
function VN(i, t, e) {
  const n = {}, r = new Float32Array(8), s = /* @__PURE__ */ new WeakMap(), a = new ze(), o = [];
  for (let l = 0; l < 8; l++)
    o[l] = [l, 0];
  return { update: function(l, c, u, h) {
    const p = l.morphTargetInfluences;
    if (t.isWebGL2 === !0) {
      const f = c.morphAttributes.position || c.morphAttributes.normal || c.morphAttributes.color, v = f !== void 0 ? f.length : 0;
      let m = s.get(c);
      if (m === void 0 || m.count !== v) {
        let it = function() {
          E.dispose(), s.delete(c), c.removeEventListener("dispose", it);
        };
        m !== void 0 && m.texture.dispose();
        const w = c.morphAttributes.position !== void 0, b = c.morphAttributes.normal !== void 0, T = c.morphAttributes.color !== void 0, M = c.morphAttributes.position || [], A = c.morphAttributes.normal || [], C = c.morphAttributes.color || [];
        let I = 0;
        w === !0 && (I = 1), b === !0 && (I = 2), T === !0 && (I = 3);
        let k = c.attributes.position.count * I, R = 1;
        k > t.maxTextureSize && (R = Math.ceil(k / t.maxTextureSize), k = t.maxTextureSize);
        const L = new Float32Array(k * R * 4 * v), E = new bv(L, k, R, v);
        E.type = 1015, E.needsUpdate = !0;
        const q = 4 * I;
        for (let rt = 0; rt < v; rt++) {
          const ft = M[rt], nt = A[rt], vt = C[rt], $ = k * R * 4 * rt;
          for (let W = 0; W < ft.count; W++) {
            const ct = W * q;
            w === !0 && (a.fromBufferAttribute(ft, W), L[$ + ct + 0] = a.x, L[$ + ct + 1] = a.y, L[$ + ct + 2] = a.z, L[$ + ct + 3] = 0), b === !0 && (a.fromBufferAttribute(nt, W), L[$ + ct + 4] = a.x, L[$ + ct + 5] = a.y, L[$ + ct + 6] = a.z, L[$ + ct + 7] = 0), T === !0 && (a.fromBufferAttribute(vt, W), L[$ + ct + 8] = a.x, L[$ + ct + 9] = a.y, L[$ + ct + 10] = a.z, L[$ + ct + 11] = vt.itemSize === 4 ? a.w : 1);
          }
        }
        m = { count: v, texture: E, size: new wt(k, R) }, s.set(c, m), c.addEventListener("dispose", it);
      }
      let y = 0;
      for (let w = 0; w < p.length; w++)
        y += p[w];
      const _ = c.morphTargetsRelative ? 1 : 1 - y;
      h.getUniforms().setValue(i, "morphTargetBaseInfluence", _), h.getUniforms().setValue(i, "morphTargetInfluences", p), h.getUniforms().setValue(i, "morphTargetsTexture", m.texture, e), h.getUniforms().setValue(i, "morphTargetsTextureSize", m.size);
    } else {
      const f = p === void 0 ? 0 : p.length;
      let v = n[c.id];
      if (v === void 0 || v.length !== f) {
        v = [];
        for (let b = 0; b < f; b++)
          v[b] = [b, 0];
        n[c.id] = v;
      }
      for (let b = 0; b < f; b++) {
        const T = v[b];
        T[0] = b, T[1] = p[b];
      }
      v.sort(UN);
      for (let b = 0; b < 8; b++)
        b < f && v[b][1] ? (o[b][0] = v[b][0], o[b][1] = v[b][1]) : (o[b][0] = Number.MAX_SAFE_INTEGER, o[b][1] = 0);
      o.sort(FN);
      const m = c.morphAttributes.position, y = c.morphAttributes.normal;
      let _ = 0;
      for (let b = 0; b < 8; b++) {
        const T = o[b], M = T[0], A = T[1];
        M !== Number.MAX_SAFE_INTEGER && A ? (m && c.getAttribute("morphTarget" + b) !== m[M] && c.setAttribute("morphTarget" + b, m[M]), y && c.getAttribute("morphNormal" + b) !== y[M] && c.setAttribute("morphNormal" + b, y[M]), r[b] = A, _ += A) : (m && c.hasAttribute("morphTarget" + b) === !0 && c.deleteAttribute("morphTarget" + b), y && c.hasAttribute("morphNormal" + b) === !0 && c.deleteAttribute("morphNormal" + b), r[b] = 0);
      }
      const w = c.morphTargetsRelative ? 1 : 1 - _;
      h.getUniforms().setValue(i, "morphTargetBaseInfluence", w), h.getUniforms().setValue(i, "morphTargetInfluences", r);
    }
  } };
}
function HN(i, t, e, n) {
  let r = /* @__PURE__ */ new WeakMap();
  function s(a) {
    const o = a.target;
    o.removeEventListener("dispose", s), e.remove(o.instanceMatrix), o.instanceColor !== null && e.remove(o.instanceColor);
  }
  return { update: function(a) {
    const o = n.render.frame, l = a.geometry, c = t.get(a, l);
    return r.get(c) !== o && (t.update(c), r.set(c, o)), a.isInstancedMesh && (a.hasEventListener("dispose", s) === !1 && a.addEventListener("dispose", s), e.update(a.instanceMatrix, 34962), a.instanceColor !== null && e.update(a.instanceColor, 34962)), c;
  }, dispose: function() {
    r = /* @__PURE__ */ new WeakMap();
  } };
}
const TI = new Yn(), EI = new bv(), AI = new ex(), CI = new Dd(), kT = [], NT = [], FT = new Float32Array(16), UT = new Float32Array(9), VT = new Float32Array(4);
function ru(i, t, e) {
  const n = i[0];
  if (n <= 0 || n > 0)
    return i;
  const r = t * e;
  let s = kT[r];
  if (s === void 0 && (s = new Float32Array(r), kT[r] = s), t !== 0) {
    n.toArray(s, 0);
    for (let a = 1, o = 0; a !== t; ++a)
      o += e, i[a].toArray(s, o);
  }
  return s;
}
function mr(i, t) {
  if (i.length !== t.length)
    return !1;
  for (let e = 0, n = i.length; e < n; e++)
    if (i[e] !== t[e])
      return !1;
  return !0;
}
function gr(i, t) {
  for (let e = 0, n = t.length; e < n; e++)
    i[e] = t[e];
}
function e0(i, t) {
  let e = NT[t];
  e === void 0 && (e = new Int32Array(t), NT[t] = e);
  for (let n = 0; n !== t; ++n)
    e[n] = i.allocateTextureUnit();
  return e;
}
function jN(i, t) {
  const e = this.cache;
  e[0] !== t && (i.uniform1f(this.addr, t), e[0] = t);
}
function GN(i, t) {
  const e = this.cache;
  if (t.x !== void 0)
    e[0] === t.x && e[1] === t.y || (i.uniform2f(this.addr, t.x, t.y), e[0] = t.x, e[1] = t.y);
  else {
    if (mr(e, t))
      return;
    i.uniform2fv(this.addr, t), gr(e, t);
  }
}
function WN(i, t) {
  const e = this.cache;
  if (t.x !== void 0)
    e[0] === t.x && e[1] === t.y && e[2] === t.z || (i.uniform3f(this.addr, t.x, t.y, t.z), e[0] = t.x, e[1] = t.y, e[2] = t.z);
  else if (t.r !== void 0)
    e[0] === t.r && e[1] === t.g && e[2] === t.b || (i.uniform3f(this.addr, t.r, t.g, t.b), e[0] = t.r, e[1] = t.g, e[2] = t.b);
  else {
    if (mr(e, t))
      return;
    i.uniform3fv(this.addr, t), gr(e, t);
  }
}
function ZN(i, t) {
  const e = this.cache;
  if (t.x !== void 0)
    e[0] === t.x && e[1] === t.y && e[2] === t.z && e[3] === t.w || (i.uniform4f(this.addr, t.x, t.y, t.z, t.w), e[0] = t.x, e[1] = t.y, e[2] = t.z, e[3] = t.w);
  else {
    if (mr(e, t))
      return;
    i.uniform4fv(this.addr, t), gr(e, t);
  }
}
function qN(i, t) {
  const e = this.cache, n = t.elements;
  if (n === void 0) {
    if (mr(e, t))
      return;
    i.uniformMatrix2fv(this.addr, !1, t), gr(e, t);
  } else {
    if (mr(e, n))
      return;
    VT.set(n), i.uniformMatrix2fv(this.addr, !1, VT), gr(e, n);
  }
}
function XN(i, t) {
  const e = this.cache, n = t.elements;
  if (n === void 0) {
    if (mr(e, t))
      return;
    i.uniformMatrix3fv(this.addr, !1, t), gr(e, t);
  } else {
    if (mr(e, n))
      return;
    UT.set(n), i.uniformMatrix3fv(this.addr, !1, UT), gr(e, n);
  }
}
function YN(i, t) {
  const e = this.cache, n = t.elements;
  if (n === void 0) {
    if (mr(e, t))
      return;
    i.uniformMatrix4fv(this.addr, !1, t), gr(e, t);
  } else {
    if (mr(e, n))
      return;
    FT.set(n), i.uniformMatrix4fv(this.addr, !1, FT), gr(e, n);
  }
}
function JN(i, t) {
  const e = this.cache;
  e[0] !== t && (i.uniform1i(this.addr, t), e[0] = t);
}
function KN(i, t) {
  const e = this.cache;
  if (t.x !== void 0)
    e[0] === t.x && e[1] === t.y || (i.uniform2i(this.addr, t.x, t.y), e[0] = t.x, e[1] = t.y);
  else {
    if (mr(e, t))
      return;
    i.uniform2iv(this.addr, t), gr(e, t);
  }
}
function $N(i, t) {
  const e = this.cache;
  if (t.x !== void 0)
    e[0] === t.x && e[1] === t.y && e[2] === t.z || (i.uniform3i(this.addr, t.x, t.y, t.z), e[0] = t.x, e[1] = t.y, e[2] = t.z);
  else {
    if (mr(e, t))
      return;
    i.uniform3iv(this.addr, t), gr(e, t);
  }
}
function QN(i, t) {
  const e = this.cache;
  if (t.x !== void 0)
    e[0] === t.x && e[1] === t.y && e[2] === t.z && e[3] === t.w || (i.uniform4i(this.addr, t.x, t.y, t.z, t.w), e[0] = t.x, e[1] = t.y, e[2] = t.z, e[3] = t.w);
  else {
    if (mr(e, t))
      return;
    i.uniform4iv(this.addr, t), gr(e, t);
  }
}
function tF(i, t) {
  const e = this.cache;
  e[0] !== t && (i.uniform1ui(this.addr, t), e[0] = t);
}
function eF(i, t) {
  const e = this.cache;
  if (t.x !== void 0)
    e[0] === t.x && e[1] === t.y || (i.uniform2ui(this.addr, t.x, t.y), e[0] = t.x, e[1] = t.y);
  else {
    if (mr(e, t))
      return;
    i.uniform2uiv(this.addr, t), gr(e, t);
  }
}
function nF(i, t) {
  const e = this.cache;
  if (t.x !== void 0)
    e[0] === t.x && e[1] === t.y && e[2] === t.z || (i.uniform3ui(this.addr, t.x, t.y, t.z), e[0] = t.x, e[1] = t.y, e[2] = t.z);
  else {
    if (mr(e, t))
      return;
    i.uniform3uiv(this.addr, t), gr(e, t);
  }
}
function rF(i, t) {
  const e = this.cache;
  if (t.x !== void 0)
    e[0] === t.x && e[1] === t.y && e[2] === t.z && e[3] === t.w || (i.uniform4ui(this.addr, t.x, t.y, t.z, t.w), e[0] = t.x, e[1] = t.y, e[2] = t.z, e[3] = t.w);
  else {
    if (mr(e, t))
      return;
    i.uniform4uiv(this.addr, t), gr(e, t);
  }
}
function iF(i, t, e) {
  const n = this.cache, r = e.allocateTextureUnit();
  n[0] !== r && (i.uniform1i(this.addr, r), n[0] = r), e.setTexture2D(t || TI, r);
}
function sF(i, t, e) {
  const n = this.cache, r = e.allocateTextureUnit();
  n[0] !== r && (i.uniform1i(this.addr, r), n[0] = r), e.setTexture3D(t || AI, r);
}
function aF(i, t, e) {
  const n = this.cache, r = e.allocateTextureUnit();
  n[0] !== r && (i.uniform1i(this.addr, r), n[0] = r), e.setTextureCube(t || CI, r);
}
function oF(i, t, e) {
  const n = this.cache, r = e.allocateTextureUnit();
  n[0] !== r && (i.uniform1i(this.addr, r), n[0] = r), e.setTexture2DArray(t || EI, r);
}
function lF(i, t) {
  i.uniform1fv(this.addr, t);
}
function cF(i, t) {
  const e = ru(t, this.size, 2);
  i.uniform2fv(this.addr, e);
}
function hF(i, t) {
  const e = ru(t, this.size, 3);
  i.uniform3fv(this.addr, e);
}
function uF(i, t) {
  const e = ru(t, this.size, 4);
  i.uniform4fv(this.addr, e);
}
function dF(i, t) {
  const e = ru(t, this.size, 4);
  i.uniformMatrix2fv(this.addr, !1, e);
}
function pF(i, t) {
  const e = ru(t, this.size, 9);
  i.uniformMatrix3fv(this.addr, !1, e);
}
function fF(i, t) {
  const e = ru(t, this.size, 16);
  i.uniformMatrix4fv(this.addr, !1, e);
}
function mF(i, t) {
  i.uniform1iv(this.addr, t);
}
function gF(i, t) {
  i.uniform2iv(this.addr, t);
}
function vF(i, t) {
  i.uniform3iv(this.addr, t);
}
function yF(i, t) {
  i.uniform4iv(this.addr, t);
}
function _F(i, t) {
  i.uniform1uiv(this.addr, t);
}
function wF(i, t) {
  i.uniform2uiv(this.addr, t);
}
function xF(i, t) {
  i.uniform3uiv(this.addr, t);
}
function bF(i, t) {
  i.uniform4uiv(this.addr, t);
}
function SF(i, t, e) {
  const n = this.cache, r = t.length, s = e0(e, r);
  mr(n, s) || (i.uniform1iv(this.addr, s), gr(n, s));
  for (let a = 0; a !== r; ++a)
    e.setTexture2D(t[a] || TI, s[a]);
}
function MF(i, t, e) {
  const n = this.cache, r = t.length, s = e0(e, r);
  mr(n, s) || (i.uniform1iv(this.addr, s), gr(n, s));
  for (let a = 0; a !== r; ++a)
    e.setTexture3D(t[a] || AI, s[a]);
}
function TF(i, t, e) {
  const n = this.cache, r = t.length, s = e0(e, r);
  mr(n, s) || (i.uniform1iv(this.addr, s), gr(n, s));
  for (let a = 0; a !== r; ++a)
    e.setTextureCube(t[a] || CI, s[a]);
}
function EF(i, t, e) {
  const n = this.cache, r = t.length, s = e0(e, r);
  mr(n, s) || (i.uniform1iv(this.addr, s), gr(n, s));
  for (let a = 0; a !== r; ++a)
    e.setTexture2DArray(t[a] || EI, s[a]);
}
class AF {
  constructor(t, e, n) {
    this.id = t, this.addr = n, this.cache = [], this.setValue = function(r) {
      switch (r) {
        case 5126:
          return jN;
        case 35664:
          return GN;
        case 35665:
          return WN;
        case 35666:
          return ZN;
        case 35674:
          return qN;
        case 35675:
          return XN;
        case 35676:
          return YN;
        case 5124:
        case 35670:
          return JN;
        case 35667:
        case 35671:
          return KN;
        case 35668:
        case 35672:
          return $N;
        case 35669:
        case 35673:
          return QN;
        case 5125:
          return tF;
        case 36294:
          return eF;
        case 36295:
          return nF;
        case 36296:
          return rF;
        case 35678:
        case 36198:
        case 36298:
        case 36306:
        case 35682:
          return iF;
        case 35679:
        case 36299:
        case 36307:
          return sF;
        case 35680:
        case 36300:
        case 36308:
        case 36293:
          return aF;
        case 36289:
        case 36303:
        case 36311:
        case 36292:
          return oF;
      }
    }(e.type);
  }
}
class CF {
  constructor(t, e, n) {
    this.id = t, this.addr = n, this.cache = [], this.size = e.size, this.setValue = function(r) {
      switch (r) {
        case 5126:
          return lF;
        case 35664:
          return cF;
        case 35665:
          return hF;
        case 35666:
          return uF;
        case 35674:
          return dF;
        case 35675:
          return pF;
        case 35676:
          return fF;
        case 5124:
        case 35670:
          return mF;
        case 35667:
        case 35671:
          return gF;
        case 35668:
        case 35672:
          return vF;
        case 35669:
        case 35673:
          return yF;
        case 5125:
          return _F;
        case 36294:
          return wF;
        case 36295:
          return xF;
        case 36296:
          return bF;
        case 35678:
        case 36198:
        case 36298:
        case 36306:
        case 35682:
          return SF;
        case 35679:
        case 36299:
        case 36307:
          return MF;
        case 35680:
        case 36300:
        case 36308:
        case 36293:
          return TF;
        case 36289:
        case 36303:
        case 36311:
        case 36292:
          return EF;
      }
    }(e.type);
  }
}
class PF {
  constructor(t) {
    this.id = t, this.seq = [], this.map = {};
  }
  setValue(t, e, n) {
    const r = this.seq;
    for (let s = 0, a = r.length; s !== a; ++s) {
      const o = r[s];
      o.setValue(t, e[o.id], n);
    }
  }
}
const p_ = /(\w+)(\])?(\[|\.)?/g;
function HT(i, t) {
  i.seq.push(t), i.map[t.id] = t;
}
function DF(i, t, e) {
  const n = i.name, r = n.length;
  for (p_.lastIndex = 0; ; ) {
    const s = p_.exec(n), a = p_.lastIndex;
    let o = s[1];
    const l = s[2] === "]", c = s[3];
    if (l && (o |= 0), c === void 0 || c === "[" && a + 2 === r) {
      HT(e, c === void 0 ? new AF(o, i, t) : new CF(o, i, t));
      break;
    }
    {
      let u = e.map[o];
      u === void 0 && (u = new PF(o), HT(e, u)), e = u;
    }
  }
}
class tv {
  constructor(t, e) {
    this.seq = [], this.map = {};
    const n = t.getProgramParameter(e, 35718);
    for (let r = 0; r < n; ++r) {
      const s = t.getActiveUniform(e, r);
      DF(s, t.getUniformLocation(e, s.name), this);
    }
  }
  setValue(t, e, n, r) {
    const s = this.map[e];
    s !== void 0 && s.setValue(t, n, r);
  }
  setOptional(t, e, n) {
    const r = e[n];
    r !== void 0 && this.setValue(t, n, r);
  }
  static upload(t, e, n, r) {
    for (let s = 0, a = e.length; s !== a; ++s) {
      const o = e[s], l = n[o.id];
      l.needsUpdate !== !1 && o.setValue(t, l.value, r);
    }
  }
  static seqWithValue(t, e) {
    const n = [];
    for (let r = 0, s = t.length; r !== s; ++r) {
      const a = t[r];
      a.id in e && n.push(a);
    }
    return n;
  }
}
function jT(i, t, e) {
  const n = i.createShader(t);
  return i.shaderSource(n, e), i.compileShader(n), n;
}
let RF = 0;
function GT(i, t, e) {
  const n = i.getShaderParameter(t, 35713), r = i.getShaderInfoLog(t).trim();
  if (n && r === "")
    return "";
  const s = /ERROR: 0:(\d+)/.exec(r);
  if (s) {
    const a = parseInt(s[1]);
    return e.toUpperCase() + `

` + r + `

` + function(o, l) {
      const c = o.split(`
`), u = [], h = Math.max(l - 6, 0), p = Math.min(l + 6, c.length);
      for (let f = h; f < p; f++) {
        const v = f + 1;
        u.push(`${v === l ? ">" : " "} ${v}: ${c[f]}`);
      }
      return u.join(`
`);
    }(i.getShaderSource(t), a);
  }
  return r;
}
function IF(i, t) {
  const e = function(n) {
    switch (n) {
      case 3e3:
        return ["Linear", "( value )"];
      case 3001:
        return ["sRGB", "( value )"];
      default:
        return console.warn("THREE.WebGLProgram: Unsupported encoding:", n), ["Linear", "( value )"];
    }
  }(t);
  return "vec4 " + i + "( vec4 value ) { return LinearTo" + e[0] + e[1] + "; }";
}
function OF(i, t) {
  let e;
  switch (t) {
    case 1:
      e = "Linear";
      break;
    case 2:
      e = "Reinhard";
      break;
    case 3:
      e = "OptimizedCineon";
      break;
    case 4:
      e = "ACESFilmic";
      break;
    case 5:
      e = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", t), e = "Linear";
  }
  return "vec3 " + i + "( vec3 color ) { return " + e + "ToneMapping( color ); }";
}
function Hu(i) {
  return i !== "";
}
function WT(i, t) {
  const e = t.numSpotLightShadows + t.numSpotLightMaps - t.numSpotLightShadowsWithMaps;
  return i.replace(/NUM_DIR_LIGHTS/g, t.numDirLights).replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, t.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, e).replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, t.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, t.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, t.numPointLightShadows);
}
function ZT(i, t) {
  return i.replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, t.numClippingPlanes - t.numClipIntersection);
}
const LF = /^[ \t]*#include +<([\w\d./]+)>/gm;
function nx(i) {
  return i.replace(LF, BF);
}
function BF(i, t) {
  const e = Le[t];
  if (e === void 0)
    throw new Error("Can not resolve #include <" + t + ">");
  return nx(e);
}
const zF = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function qT(i) {
  return i.replace(zF, kF);
}
function kF(i, t, e, n) {
  let r = "";
  for (let s = parseInt(t); s < parseInt(e); s++)
    r += n.replace(/\[\s*i\s*\]/g, "[ " + s + " ]").replace(/UNROLLED_LOOP_INDEX/g, s);
  return r;
}
function XT(i) {
  let t = "precision " + i.precision + ` float;
precision ` + i.precision + " int;";
  return i.precision === "highp" ? t += `
#define HIGH_PRECISION` : i.precision === "mediump" ? t += `
#define MEDIUM_PRECISION` : i.precision === "lowp" && (t += `
#define LOW_PRECISION`), t;
}
function NF(i, t, e, n) {
  const r = i.getContext(), s = e.defines;
  let a = e.vertexShader, o = e.fragmentShader;
  const l = function(I) {
    let k = "SHADOWMAP_TYPE_BASIC";
    return I.shadowMapType === 1 ? k = "SHADOWMAP_TYPE_PCF" : I.shadowMapType === 2 ? k = "SHADOWMAP_TYPE_PCF_SOFT" : I.shadowMapType === 3 && (k = "SHADOWMAP_TYPE_VSM"), k;
  }(e), c = function(I) {
    let k = "ENVMAP_TYPE_CUBE";
    if (I.envMap)
      switch (I.envMapMode) {
        case 301:
        case 302:
          k = "ENVMAP_TYPE_CUBE";
          break;
        case 306:
          k = "ENVMAP_TYPE_CUBE_UV";
      }
    return k;
  }(e), u = function(I) {
    let k = "ENVMAP_MODE_REFLECTION";
    return I.envMap && I.envMapMode === 302 && (k = "ENVMAP_MODE_REFRACTION"), k;
  }(e), h = function(I) {
    let k = "ENVMAP_BLENDING_NONE";
    if (I.envMap)
      switch (I.combine) {
        case 0:
          k = "ENVMAP_BLENDING_MULTIPLY";
          break;
        case 1:
          k = "ENVMAP_BLENDING_MIX";
          break;
        case 2:
          k = "ENVMAP_BLENDING_ADD";
      }
    return k;
  }(e), p = function(I) {
    const k = I.envMapCubeUVHeight;
    if (k === null)
      return null;
    const R = Math.log2(k) - 2, L = 1 / k;
    return { texelWidth: 1 / (3 * Math.max(Math.pow(2, R), 112)), texelHeight: L, maxMip: R };
  }(e), f = e.isWebGL2 ? "" : function(I) {
    return [I.extensionDerivatives || I.envMapCubeUVHeight || I.bumpMap || I.tangentSpaceNormalMap || I.clearcoatNormalMap || I.flatShading || I.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "", (I.extensionFragDepth || I.logarithmicDepthBuffer) && I.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", I.extensionDrawBuffers && I.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (I.extensionShaderTextureLOD || I.envMap || I.transmission) && I.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(Hu).join(`
`);
  }(e), v = function(I) {
    const k = [];
    for (const R in I) {
      const L = I[R];
      L !== !1 && k.push("#define " + R + " " + L);
    }
    return k.join(`
`);
  }(s), m = r.createProgram();
  let y, _, w = e.glslVersion ? "#version " + e.glslVersion + `
` : "";
  e.isRawShaderMaterial ? (y = [v].filter(Hu).join(`
`), y.length > 0 && (y += `
`), _ = [f, v].filter(Hu).join(`
`), _.length > 0 && (_ += `
`)) : (y = [XT(e), "#define SHADER_NAME " + e.shaderName, v, e.instancing ? "#define USE_INSTANCING" : "", e.instancingColor ? "#define USE_INSTANCING_COLOR" : "", e.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", e.useFog && e.fog ? "#define USE_FOG" : "", e.useFog && e.fogExp2 ? "#define FOG_EXP2" : "", e.map ? "#define USE_MAP" : "", e.envMap ? "#define USE_ENVMAP" : "", e.envMap ? "#define " + u : "", e.lightMap ? "#define USE_LIGHTMAP" : "", e.aoMap ? "#define USE_AOMAP" : "", e.emissiveMap ? "#define USE_EMISSIVEMAP" : "", e.bumpMap ? "#define USE_BUMPMAP" : "", e.normalMap ? "#define USE_NORMALMAP" : "", e.normalMap && e.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", e.normalMap && e.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", e.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", e.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", e.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", e.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", e.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", e.displacementMap && e.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", e.specularMap ? "#define USE_SPECULARMAP" : "", e.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", e.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", e.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", e.metalnessMap ? "#define USE_METALNESSMAP" : "", e.alphaMap ? "#define USE_ALPHAMAP" : "", e.transmission ? "#define USE_TRANSMISSION" : "", e.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", e.thicknessMap ? "#define USE_THICKNESSMAP" : "", e.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", e.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", e.vertexTangents ? "#define USE_TANGENT" : "", e.vertexColors ? "#define USE_COLOR" : "", e.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", e.vertexUvs ? "#define USE_UV" : "", e.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", e.flatShading ? "#define FLAT_SHADED" : "", e.skinning ? "#define USE_SKINNING" : "", e.morphTargets ? "#define USE_MORPHTARGETS" : "", e.morphNormals && e.flatShading === !1 ? "#define USE_MORPHNORMALS" : "", e.morphColors && e.isWebGL2 ? "#define USE_MORPHCOLORS" : "", e.morphTargetsCount > 0 && e.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "", e.morphTargetsCount > 0 && e.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + e.morphTextureStride : "", e.morphTargetsCount > 0 && e.isWebGL2 ? "#define MORPHTARGETS_COUNT " + e.morphTargetsCount : "", e.doubleSided ? "#define DOUBLE_SIDED" : "", e.flipSided ? "#define FLIP_SIDED" : "", e.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", e.shadowMapEnabled ? "#define " + l : "", e.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", e.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", e.logarithmicDepthBuffer && e.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "	attribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "	attribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "	attribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "	attribute vec4 color;", "#elif defined( USE_COLOR )", "	attribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", "	attribute vec3 morphTarget0;", "	attribute vec3 morphTarget1;", "	attribute vec3 morphTarget2;", "	attribute vec3 morphTarget3;", "	#ifdef USE_MORPHNORMALS", "		attribute vec3 morphNormal0;", "		attribute vec3 morphNormal1;", "		attribute vec3 morphNormal2;", "		attribute vec3 morphNormal3;", "	#else", "		attribute vec3 morphTarget4;", "		attribute vec3 morphTarget5;", "		attribute vec3 morphTarget6;", "		attribute vec3 morphTarget7;", "	#endif", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", `
`].filter(Hu).join(`
`), _ = [f, XT(e), "#define SHADER_NAME " + e.shaderName, v, e.useFog && e.fog ? "#define USE_FOG" : "", e.useFog && e.fogExp2 ? "#define FOG_EXP2" : "", e.map ? "#define USE_MAP" : "", e.matcap ? "#define USE_MATCAP" : "", e.envMap ? "#define USE_ENVMAP" : "", e.envMap ? "#define " + c : "", e.envMap ? "#define " + u : "", e.envMap ? "#define " + h : "", p ? "#define CUBEUV_TEXEL_WIDTH " + p.texelWidth : "", p ? "#define CUBEUV_TEXEL_HEIGHT " + p.texelHeight : "", p ? "#define CUBEUV_MAX_MIP " + p.maxMip + ".0" : "", e.lightMap ? "#define USE_LIGHTMAP" : "", e.aoMap ? "#define USE_AOMAP" : "", e.emissiveMap ? "#define USE_EMISSIVEMAP" : "", e.bumpMap ? "#define USE_BUMPMAP" : "", e.normalMap ? "#define USE_NORMALMAP" : "", e.normalMap && e.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", e.normalMap && e.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", e.clearcoat ? "#define USE_CLEARCOAT" : "", e.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", e.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", e.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", e.iridescence ? "#define USE_IRIDESCENCE" : "", e.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", e.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", e.specularMap ? "#define USE_SPECULARMAP" : "", e.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", e.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", e.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", e.metalnessMap ? "#define USE_METALNESSMAP" : "", e.alphaMap ? "#define USE_ALPHAMAP" : "", e.alphaTest ? "#define USE_ALPHATEST" : "", e.sheen ? "#define USE_SHEEN" : "", e.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", e.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", e.transmission ? "#define USE_TRANSMISSION" : "", e.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", e.thicknessMap ? "#define USE_THICKNESSMAP" : "", e.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", e.vertexTangents ? "#define USE_TANGENT" : "", e.vertexColors || e.instancingColor ? "#define USE_COLOR" : "", e.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", e.vertexUvs ? "#define USE_UV" : "", e.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", e.gradientMap ? "#define USE_GRADIENTMAP" : "", e.flatShading ? "#define FLAT_SHADED" : "", e.doubleSided ? "#define DOUBLE_SIDED" : "", e.flipSided ? "#define FLIP_SIDED" : "", e.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", e.shadowMapEnabled ? "#define " + l : "", e.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", e.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", e.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", e.logarithmicDepthBuffer && e.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", e.toneMapping !== 0 ? "#define TONE_MAPPING" : "", e.toneMapping !== 0 ? Le.tonemapping_pars_fragment : "", e.toneMapping !== 0 ? OF("toneMapping", e.toneMapping) : "", e.dithering ? "#define DITHERING" : "", e.opaque ? "#define OPAQUE" : "", Le.encodings_pars_fragment, IF("linearToOutputTexel", e.outputEncoding), e.useDepthPacking ? "#define DEPTH_PACKING " + e.depthPacking : "", `
`].filter(Hu).join(`
`)), a = nx(a), a = WT(a, e), a = ZT(a, e), o = nx(o), o = WT(o, e), o = ZT(o, e), a = qT(a), o = qT(o), e.isWebGL2 && e.isRawShaderMaterial !== !0 && (w = `#version 300 es
`, y = ["precision mediump sampler2DArray;", "#define attribute in", "#define varying out", "#define texture2D texture"].join(`
`) + `
` + y, _ = ["#define varying in", e.glslVersion === $w ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", e.glslVersion === $w ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join(`
`) + `
` + _);
  const b = w + _ + o, T = jT(r, 35633, w + y + a), M = jT(r, 35632, b);
  if (r.attachShader(m, T), r.attachShader(m, M), e.index0AttributeName !== void 0 ? r.bindAttribLocation(m, 0, e.index0AttributeName) : e.morphTargets === !0 && r.bindAttribLocation(m, 0, "position"), r.linkProgram(m), i.debug.checkShaderErrors) {
    const I = r.getProgramInfoLog(m).trim(), k = r.getShaderInfoLog(T).trim(), R = r.getShaderInfoLog(M).trim();
    let L = !0, E = !0;
    if (r.getProgramParameter(m, 35714) === !1) {
      L = !1;
      const q = GT(r, T, "vertex"), it = GT(r, M, "fragment");
      console.error("THREE.WebGLProgram: Shader Error " + r.getError() + " - VALIDATE_STATUS " + r.getProgramParameter(m, 35715) + `

Program Info Log: ` + I + `
` + q + `
` + it);
    } else
      I !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", I) : k !== "" && R !== "" || (E = !1);
    E && (this.diagnostics = { runnable: L, programLog: I, vertexShader: { log: k, prefix: y }, fragmentShader: { log: R, prefix: _ } });
  }
  let A, C;
  return r.deleteShader(T), r.deleteShader(M), this.getUniforms = function() {
    return A === void 0 && (A = new tv(r, m)), A;
  }, this.getAttributes = function() {
    return C === void 0 && (C = function(I, k) {
      const R = {}, L = I.getProgramParameter(k, 35721);
      for (let E = 0; E < L; E++) {
        const q = I.getActiveAttrib(k, E), it = q.name;
        let rt = 1;
        q.type === 35674 && (rt = 2), q.type === 35675 && (rt = 3), q.type === 35676 && (rt = 4), R[it] = { type: q.type, location: I.getAttribLocation(k, it), locationSize: rt };
      }
      return R;
    }(r, m)), C;
  }, this.destroy = function() {
    n.releaseStatesOfProgram(this), r.deleteProgram(m), this.program = void 0;
  }, this.name = e.shaderName, this.id = RF++, this.cacheKey = t, this.usedTimes = 1, this.program = m, this.vertexShader = T, this.fragmentShader = M, this;
}
let FF = 0;
class UF {
  constructor() {
    this.shaderCache = /* @__PURE__ */ new Map(), this.materialCache = /* @__PURE__ */ new Map();
  }
  update(t) {
    const e = t.vertexShader, n = t.fragmentShader, r = this._getShaderStage(e), s = this._getShaderStage(n), a = this._getShaderCacheForMaterial(t);
    return a.has(r) === !1 && (a.add(r), r.usedTimes++), a.has(s) === !1 && (a.add(s), s.usedTimes++), this;
  }
  remove(t) {
    const e = this.materialCache.get(t);
    for (const n of e)
      n.usedTimes--, n.usedTimes === 0 && this.shaderCache.delete(n.code);
    return this.materialCache.delete(t), this;
  }
  getVertexShaderID(t) {
    return this._getShaderStage(t.vertexShader).id;
  }
  getFragmentShaderID(t) {
    return this._getShaderStage(t.fragmentShader).id;
  }
  dispose() {
    this.shaderCache.clear(), this.materialCache.clear();
  }
  _getShaderCacheForMaterial(t) {
    const e = this.materialCache;
    let n = e.get(t);
    return n === void 0 && (n = /* @__PURE__ */ new Set(), e.set(t, n)), n;
  }
  _getShaderStage(t) {
    const e = this.shaderCache;
    let n = e.get(t);
    return n === void 0 && (n = new VF(t), e.set(t, n)), n;
  }
}
class VF {
  constructor(t) {
    this.id = FF++, this.code = t, this.usedTimes = 0;
  }
}
function HF(i, t, e, n, r, s, a) {
  const o = new $v(), l = new UF(), c = [], u = r.isWebGL2, h = r.logarithmicDepthBuffer, p = r.vertexTextures;
  let f = r.precision;
  const v = { MeshDepthMaterial: "depth", MeshDistanceMaterial: "distanceRGBA", MeshNormalMaterial: "normal", MeshBasicMaterial: "basic", MeshLambertMaterial: "lambert", MeshPhongMaterial: "phong", MeshToonMaterial: "toon", MeshStandardMaterial: "physical", MeshPhysicalMaterial: "physical", MeshMatcapMaterial: "matcap", LineBasicMaterial: "basic", LineDashedMaterial: "dashed", PointsMaterial: "points", ShadowMaterial: "shadow", SpriteMaterial: "sprite" };
  return { getParameters: function(m, y, _, w, b) {
    const T = w.fog, M = b.geometry, A = m.isMeshStandardMaterial ? w.environment : null, C = (m.isMeshStandardMaterial ? e : t).get(m.envMap || A), I = C && C.mapping === 306 ? C.image.height : null, k = v[m.type];
    m.precision !== null && (f = r.getMaxPrecision(m.precision), f !== m.precision && console.warn("THREE.WebGLProgram.getParameters:", m.precision, "not supported, using", f, "instead."));
    const R = M.morphAttributes.position || M.morphAttributes.normal || M.morphAttributes.color, L = R !== void 0 ? R.length : 0;
    let E, q, it, rt, ft = 0;
    if (M.morphAttributes.position !== void 0 && (ft = 1), M.morphAttributes.normal !== void 0 && (ft = 2), M.morphAttributes.color !== void 0 && (ft = 3), k) {
      const ct = Pn[k];
      E = ct.vertexShader, q = ct.fragmentShader;
    } else
      E = m.vertexShader, q = m.fragmentShader, l.update(m), it = l.getVertexShaderID(m), rt = l.getFragmentShaderID(m);
    const nt = i.getRenderTarget(), vt = m.alphaTest > 0, $ = m.clearcoat > 0, W = m.iridescence > 0;
    return { isWebGL2: u, shaderID: k, shaderName: m.type, vertexShader: E, fragmentShader: q, defines: m.defines, customVertexShaderID: it, customFragmentShaderID: rt, isRawShaderMaterial: m.isRawShaderMaterial === !0, glslVersion: m.glslVersion, precision: f, instancing: b.isInstancedMesh === !0, instancingColor: b.isInstancedMesh === !0 && b.instanceColor !== null, supportsVertexTextures: p, outputEncoding: nt === null ? i.outputEncoding : nt.isXRRenderTarget === !0 ? nt.texture.encoding : 3e3, map: !!m.map, matcap: !!m.matcap, envMap: !!C, envMapMode: C && C.mapping, envMapCubeUVHeight: I, lightMap: !!m.lightMap, aoMap: !!m.aoMap, emissiveMap: !!m.emissiveMap, bumpMap: !!m.bumpMap, normalMap: !!m.normalMap, objectSpaceNormalMap: m.normalMapType === 1, tangentSpaceNormalMap: m.normalMapType === 0, decodeVideoTexture: !!m.map && m.map.isVideoTexture === !0 && m.map.encoding === 3001, clearcoat: $, clearcoatMap: $ && !!m.clearcoatMap, clearcoatRoughnessMap: $ && !!m.clearcoatRoughnessMap, clearcoatNormalMap: $ && !!m.clearcoatNormalMap, iridescence: W, iridescenceMap: W && !!m.iridescenceMap, iridescenceThicknessMap: W && !!m.iridescenceThicknessMap, displacementMap: !!m.displacementMap, roughnessMap: !!m.roughnessMap, metalnessMap: !!m.metalnessMap, specularMap: !!m.specularMap, specularIntensityMap: !!m.specularIntensityMap, specularColorMap: !!m.specularColorMap, opaque: m.transparent === !1 && m.blending === 1, alphaMap: !!m.alphaMap, alphaTest: vt, gradientMap: !!m.gradientMap, sheen: m.sheen > 0, sheenColorMap: !!m.sheenColorMap, sheenRoughnessMap: !!m.sheenRoughnessMap, transmission: m.transmission > 0, transmissionMap: !!m.transmissionMap, thicknessMap: !!m.thicknessMap, combine: m.combine, vertexTangents: !!m.normalMap && !!M.attributes.tangent, vertexColors: m.vertexColors, vertexAlphas: m.vertexColors === !0 && !!M.attributes.color && M.attributes.color.itemSize === 4, vertexUvs: !!(m.map || m.bumpMap || m.normalMap || m.specularMap || m.alphaMap || m.emissiveMap || m.roughnessMap || m.metalnessMap || m.clearcoatMap || m.clearcoatRoughnessMap || m.clearcoatNormalMap || m.iridescenceMap || m.iridescenceThicknessMap || m.displacementMap || m.transmissionMap || m.thicknessMap || m.specularIntensityMap || m.specularColorMap || m.sheenColorMap || m.sheenRoughnessMap), uvsVertexOnly: !(m.map || m.bumpMap || m.normalMap || m.specularMap || m.alphaMap || m.emissiveMap || m.roughnessMap || m.metalnessMap || m.clearcoatNormalMap || m.iridescenceMap || m.iridescenceThicknessMap || m.transmission > 0 || m.transmissionMap || m.thicknessMap || m.specularIntensityMap || m.specularColorMap || m.sheen > 0 || m.sheenColorMap || m.sheenRoughnessMap || !m.displacementMap), fog: !!T, useFog: m.fog === !0, fogExp2: T && T.isFogExp2, flatShading: !!m.flatShading, sizeAttenuation: m.sizeAttenuation, logarithmicDepthBuffer: h, skinning: b.isSkinnedMesh === !0, morphTargets: M.morphAttributes.position !== void 0, morphNormals: M.morphAttributes.normal !== void 0, morphColors: M.morphAttributes.color !== void 0, morphTargetsCount: L, morphTextureStride: ft, numDirLights: y.directional.length, numPointLights: y.point.length, numSpotLights: y.spot.length, numSpotLightMaps: y.spotLightMap.length, numRectAreaLights: y.rectArea.length, numHemiLights: y.hemi.length, numDirLightShadows: y.directionalShadowMap.length, numPointLightShadows: y.pointShadowMap.length, numSpotLightShadows: y.spotShadowMap.length, numSpotLightShadowsWithMaps: y.numSpotLightShadowsWithMaps, numClippingPlanes: a.numPlanes, numClipIntersection: a.numIntersection, dithering: m.dithering, shadowMapEnabled: i.shadowMap.enabled && _.length > 0, shadowMapType: i.shadowMap.type, toneMapping: m.toneMapped ? i.toneMapping : 0, physicallyCorrectLights: i.physicallyCorrectLights, premultipliedAlpha: m.premultipliedAlpha, doubleSided: m.side === 2, flipSided: m.side === 1, useDepthPacking: !!m.depthPacking, depthPacking: m.depthPacking || 0, index0AttributeName: m.index0AttributeName, extensionDerivatives: m.extensions && m.extensions.derivatives, extensionFragDepth: m.extensions && m.extensions.fragDepth, extensionDrawBuffers: m.extensions && m.extensions.drawBuffers, extensionShaderTextureLOD: m.extensions && m.extensions.shaderTextureLOD, rendererExtensionFragDepth: u || n.has("EXT_frag_depth"), rendererExtensionDrawBuffers: u || n.has("WEBGL_draw_buffers"), rendererExtensionShaderTextureLod: u || n.has("EXT_shader_texture_lod"), customProgramCacheKey: m.customProgramCacheKey() };
  }, getProgramCacheKey: function(m) {
    const y = [];
    if (m.shaderID ? y.push(m.shaderID) : (y.push(m.customVertexShaderID), y.push(m.customFragmentShaderID)), m.defines !== void 0)
      for (const _ in m.defines)
        y.push(_), y.push(m.defines[_]);
    return m.isRawShaderMaterial === !1 && (function(_, w) {
      _.push(w.precision), _.push(w.outputEncoding), _.push(w.envMapMode), _.push(w.envMapCubeUVHeight), _.push(w.combine), _.push(w.vertexUvs), _.push(w.fogExp2), _.push(w.sizeAttenuation), _.push(w.morphTargetsCount), _.push(w.morphAttributeCount), _.push(w.numDirLights), _.push(w.numPointLights), _.push(w.numSpotLights), _.push(w.numSpotLightMaps), _.push(w.numHemiLights), _.push(w.numRectAreaLights), _.push(w.numDirLightShadows), _.push(w.numPointLightShadows), _.push(w.numSpotLightShadows), _.push(w.numSpotLightShadowsWithMaps), _.push(w.shadowMapType), _.push(w.toneMapping), _.push(w.numClippingPlanes), _.push(w.numClipIntersection), _.push(w.depthPacking);
    }(y, m), function(_, w) {
      o.disableAll(), w.isWebGL2 && o.enable(0), w.supportsVertexTextures && o.enable(1), w.instancing && o.enable(2), w.instancingColor && o.enable(3), w.map && o.enable(4), w.matcap && o.enable(5), w.envMap && o.enable(6), w.lightMap && o.enable(7), w.aoMap && o.enable(8), w.emissiveMap && o.enable(9), w.bumpMap && o.enable(10), w.normalMap && o.enable(11), w.objectSpaceNormalMap && o.enable(12), w.tangentSpaceNormalMap && o.enable(13), w.clearcoat && o.enable(14), w.clearcoatMap && o.enable(15), w.clearcoatRoughnessMap && o.enable(16), w.clearcoatNormalMap && o.enable(17), w.iridescence && o.enable(18), w.iridescenceMap && o.enable(19), w.iridescenceThicknessMap && o.enable(20), w.displacementMap && o.enable(21), w.specularMap && o.enable(22), w.roughnessMap && o.enable(23), w.metalnessMap && o.enable(24), w.gradientMap && o.enable(25), w.alphaMap && o.enable(26), w.alphaTest && o.enable(27), w.vertexColors && o.enable(28), w.vertexAlphas && o.enable(29), w.vertexUvs && o.enable(30), w.vertexTangents && o.enable(31), w.uvsVertexOnly && o.enable(32), _.push(o.mask), o.disableAll(), w.fog && o.enable(0), w.useFog && o.enable(1), w.flatShading && o.enable(2), w.logarithmicDepthBuffer && o.enable(3), w.skinning && o.enable(4), w.morphTargets && o.enable(5), w.morphNormals && o.enable(6), w.morphColors && o.enable(7), w.premultipliedAlpha && o.enable(8), w.shadowMapEnabled && o.enable(9), w.physicallyCorrectLights && o.enable(10), w.doubleSided && o.enable(11), w.flipSided && o.enable(12), w.useDepthPacking && o.enable(13), w.dithering && o.enable(14), w.specularIntensityMap && o.enable(15), w.specularColorMap && o.enable(16), w.transmission && o.enable(17), w.transmissionMap && o.enable(18), w.thicknessMap && o.enable(19), w.sheen && o.enable(20), w.sheenColorMap && o.enable(21), w.sheenRoughnessMap && o.enable(22), w.decodeVideoTexture && o.enable(23), w.opaque && o.enable(24), _.push(o.mask);
    }(y, m), y.push(i.outputEncoding)), y.push(m.customProgramCacheKey), y.join();
  }, getUniforms: function(m) {
    const y = v[m.type];
    let _;
    if (y) {
      const w = Pn[y];
      _ = Jn.clone(w.uniforms);
    } else
      _ = m.uniforms;
    return _;
  }, acquireProgram: function(m, y) {
    let _;
    for (let w = 0, b = c.length; w < b; w++) {
      const T = c[w];
      if (T.cacheKey === y) {
        _ = T, ++_.usedTimes;
        break;
      }
    }
    return _ === void 0 && (_ = new NF(i, y, m, s), c.push(_)), _;
  }, releaseProgram: function(m) {
    if (--m.usedTimes == 0) {
      const y = c.indexOf(m);
      c[y] = c[c.length - 1], c.pop(), m.destroy();
    }
  }, releaseShaderCache: function(m) {
    l.remove(m);
  }, programs: c, dispose: function() {
    l.dispose();
  } };
}
function jF() {
  let i = /* @__PURE__ */ new WeakMap();
  return { get: function(t) {
    let e = i.get(t);
    return e === void 0 && (e = {}, i.set(t, e)), e;
  }, remove: function(t) {
    i.delete(t);
  }, update: function(t, e, n) {
    i.get(t)[e] = n;
  }, dispose: function() {
    i = /* @__PURE__ */ new WeakMap();
  } };
}
function GF(i, t) {
  return i.groupOrder !== t.groupOrder ? i.groupOrder - t.groupOrder : i.renderOrder !== t.renderOrder ? i.renderOrder - t.renderOrder : i.material.id !== t.material.id ? i.material.id - t.material.id : i.z !== t.z ? i.z - t.z : i.id - t.id;
}
function YT(i, t) {
  return i.groupOrder !== t.groupOrder ? i.groupOrder - t.groupOrder : i.renderOrder !== t.renderOrder ? i.renderOrder - t.renderOrder : i.z !== t.z ? t.z - i.z : i.id - t.id;
}
function JT() {
  const i = [];
  let t = 0;
  const e = [], n = [], r = [];
  function s(a, o, l, c, u, h) {
    let p = i[t];
    return p === void 0 ? (p = { id: a.id, object: a, geometry: o, material: l, groupOrder: c, renderOrder: a.renderOrder, z: u, group: h }, i[t] = p) : (p.id = a.id, p.object = a, p.geometry = o, p.material = l, p.groupOrder = c, p.renderOrder = a.renderOrder, p.z = u, p.group = h), t++, p;
  }
  return { opaque: e, transmissive: n, transparent: r, init: function() {
    t = 0, e.length = 0, n.length = 0, r.length = 0;
  }, push: function(a, o, l, c, u, h) {
    const p = s(a, o, l, c, u, h);
    l.transmission > 0 ? n.push(p) : l.transparent === !0 ? r.push(p) : e.push(p);
  }, unshift: function(a, o, l, c, u, h) {
    const p = s(a, o, l, c, u, h);
    l.transmission > 0 ? n.unshift(p) : l.transparent === !0 ? r.unshift(p) : e.unshift(p);
  }, finish: function() {
    for (let a = t, o = i.length; a < o; a++) {
      const l = i[a];
      if (l.id === null)
        break;
      l.id = null, l.object = null, l.geometry = null, l.material = null, l.group = null;
    }
  }, sort: function(a, o) {
    e.length > 1 && e.sort(a || GF), n.length > 1 && n.sort(o || YT), r.length > 1 && r.sort(o || YT);
  } };
}
function WF() {
  let i = /* @__PURE__ */ new WeakMap();
  return { get: function(t, e) {
    const n = i.get(t);
    let r;
    return n === void 0 ? (r = new JT(), i.set(t, [r])) : e >= n.length ? (r = new JT(), n.push(r)) : r = n[e], r;
  }, dispose: function() {
    i = /* @__PURE__ */ new WeakMap();
  } };
}
function ZF() {
  const i = {};
  return { get: function(t) {
    if (i[t.id] !== void 0)
      return i[t.id];
    let e;
    switch (t.type) {
      case "DirectionalLight":
        e = { direction: new D(), color: new Ht() };
        break;
      case "SpotLight":
        e = { position: new D(), direction: new D(), color: new Ht(), distance: 0, coneCos: 0, penumbraCos: 0, decay: 0 };
        break;
      case "PointLight":
        e = { position: new D(), color: new Ht(), distance: 0, decay: 0 };
        break;
      case "HemisphereLight":
        e = { direction: new D(), skyColor: new Ht(), groundColor: new Ht() };
        break;
      case "RectAreaLight":
        e = { color: new Ht(), position: new D(), halfWidth: new D(), halfHeight: new D() };
    }
    return i[t.id] = e, e;
  } };
}
let qF = 0;
function XF(i, t) {
  return (t.castShadow ? 2 : 0) - (i.castShadow ? 2 : 0) + (t.map ? 1 : 0) - (i.map ? 1 : 0);
}
function YF(i, t) {
  const e = new ZF(), n = function() {
    const l = {};
    return { get: function(c) {
      if (l[c.id] !== void 0)
        return l[c.id];
      let u;
      switch (c.type) {
        case "DirectionalLight":
        case "SpotLight":
          u = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new wt() };
          break;
        case "PointLight":
          u = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new wt(), shadowCameraNear: 1, shadowCameraFar: 1e3 };
      }
      return l[c.id] = u, u;
    } };
  }(), r = { version: 0, hash: { directionalLength: -1, pointLength: -1, spotLength: -1, rectAreaLength: -1, hemiLength: -1, numDirectionalShadows: -1, numPointShadows: -1, numSpotShadows: -1, numSpotMaps: -1 }, ambient: [0, 0, 0], probe: [], directional: [], directionalShadow: [], directionalShadowMap: [], directionalShadowMatrix: [], spot: [], spotLightMap: [], spotShadow: [], spotShadowMap: [], spotLightMatrix: [], rectArea: [], rectAreaLTC1: null, rectAreaLTC2: null, point: [], pointShadow: [], pointShadowMap: [], pointShadowMatrix: [], hemi: [], numSpotLightShadowsWithMaps: 0 };
  for (let l = 0; l < 9; l++)
    r.probe.push(new D());
  const s = new D(), a = new Vt(), o = new Vt();
  return { setup: function(l, c) {
    let u = 0, h = 0, p = 0;
    for (let k = 0; k < 9; k++)
      r.probe[k].set(0, 0, 0);
    let f = 0, v = 0, m = 0, y = 0, _ = 0, w = 0, b = 0, T = 0, M = 0, A = 0;
    l.sort(XF);
    const C = c !== !0 ? Math.PI : 1;
    for (let k = 0, R = l.length; k < R; k++) {
      const L = l[k], E = L.color, q = L.intensity, it = L.distance, rt = L.shadow && L.shadow.map ? L.shadow.map.texture : null;
      if (L.isAmbientLight)
        u += E.r * q * C, h += E.g * q * C, p += E.b * q * C;
      else if (L.isLightProbe)
        for (let ft = 0; ft < 9; ft++)
          r.probe[ft].addScaledVector(L.sh.coefficients[ft], q);
      else if (L.isDirectionalLight) {
        const ft = e.get(L);
        if (ft.color.copy(L.color).multiplyScalar(L.intensity * C), L.castShadow) {
          const nt = L.shadow, vt = n.get(L);
          vt.shadowBias = nt.bias, vt.shadowNormalBias = nt.normalBias, vt.shadowRadius = nt.radius, vt.shadowMapSize = nt.mapSize, r.directionalShadow[f] = vt, r.directionalShadowMap[f] = rt, r.directionalShadowMatrix[f] = L.shadow.matrix, w++;
        }
        r.directional[f] = ft, f++;
      } else if (L.isSpotLight) {
        const ft = e.get(L);
        ft.position.setFromMatrixPosition(L.matrixWorld), ft.color.copy(E).multiplyScalar(q * C), ft.distance = it, ft.coneCos = Math.cos(L.angle), ft.penumbraCos = Math.cos(L.angle * (1 - L.penumbra)), ft.decay = L.decay, r.spot[m] = ft;
        const nt = L.shadow;
        if (L.map && (r.spotLightMap[M] = L.map, M++, nt.updateMatrices(L), L.castShadow && A++), r.spotLightMatrix[m] = nt.matrix, L.castShadow) {
          const vt = n.get(L);
          vt.shadowBias = nt.bias, vt.shadowNormalBias = nt.normalBias, vt.shadowRadius = nt.radius, vt.shadowMapSize = nt.mapSize, r.spotShadow[m] = vt, r.spotShadowMap[m] = rt, T++;
        }
        m++;
      } else if (L.isRectAreaLight) {
        const ft = e.get(L);
        ft.color.copy(E).multiplyScalar(q), ft.halfWidth.set(0.5 * L.width, 0, 0), ft.halfHeight.set(0, 0.5 * L.height, 0), r.rectArea[y] = ft, y++;
      } else if (L.isPointLight) {
        const ft = e.get(L);
        if (ft.color.copy(L.color).multiplyScalar(L.intensity * C), ft.distance = L.distance, ft.decay = L.decay, L.castShadow) {
          const nt = L.shadow, vt = n.get(L);
          vt.shadowBias = nt.bias, vt.shadowNormalBias = nt.normalBias, vt.shadowRadius = nt.radius, vt.shadowMapSize = nt.mapSize, vt.shadowCameraNear = nt.camera.near, vt.shadowCameraFar = nt.camera.far, r.pointShadow[v] = vt, r.pointShadowMap[v] = rt, r.pointShadowMatrix[v] = L.shadow.matrix, b++;
        }
        r.point[v] = ft, v++;
      } else if (L.isHemisphereLight) {
        const ft = e.get(L);
        ft.skyColor.copy(L.color).multiplyScalar(q * C), ft.groundColor.copy(L.groundColor).multiplyScalar(q * C), r.hemi[_] = ft, _++;
      }
    }
    y > 0 && (t.isWebGL2 || i.has("OES_texture_float_linear") === !0 ? (r.rectAreaLTC1 = Xt.LTC_FLOAT_1, r.rectAreaLTC2 = Xt.LTC_FLOAT_2) : i.has("OES_texture_half_float_linear") === !0 ? (r.rectAreaLTC1 = Xt.LTC_HALF_1, r.rectAreaLTC2 = Xt.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), r.ambient[0] = u, r.ambient[1] = h, r.ambient[2] = p;
    const I = r.hash;
    I.directionalLength === f && I.pointLength === v && I.spotLength === m && I.rectAreaLength === y && I.hemiLength === _ && I.numDirectionalShadows === w && I.numPointShadows === b && I.numSpotShadows === T && I.numSpotMaps === M || (r.directional.length = f, r.spot.length = m, r.rectArea.length = y, r.point.length = v, r.hemi.length = _, r.directionalShadow.length = w, r.directionalShadowMap.length = w, r.pointShadow.length = b, r.pointShadowMap.length = b, r.spotShadow.length = T, r.spotShadowMap.length = T, r.directionalShadowMatrix.length = w, r.pointShadowMatrix.length = b, r.spotLightMatrix.length = T + M - A, r.spotLightMap.length = M, r.numSpotLightShadowsWithMaps = A, I.directionalLength = f, I.pointLength = v, I.spotLength = m, I.rectAreaLength = y, I.hemiLength = _, I.numDirectionalShadows = w, I.numPointShadows = b, I.numSpotShadows = T, I.numSpotMaps = M, r.version = qF++);
  }, setupView: function(l, c) {
    let u = 0, h = 0, p = 0, f = 0, v = 0;
    const m = c.matrixWorldInverse;
    for (let y = 0, _ = l.length; y < _; y++) {
      const w = l[y];
      if (w.isDirectionalLight) {
        const b = r.directional[u];
        b.direction.setFromMatrixPosition(w.matrixWorld), s.setFromMatrixPosition(w.target.matrixWorld), b.direction.sub(s), b.direction.transformDirection(m), u++;
      } else if (w.isSpotLight) {
        const b = r.spot[p];
        b.position.setFromMatrixPosition(w.matrixWorld), b.position.applyMatrix4(m), b.direction.setFromMatrixPosition(w.matrixWorld), s.setFromMatrixPosition(w.target.matrixWorld), b.direction.sub(s), b.direction.transformDirection(m), p++;
      } else if (w.isRectAreaLight) {
        const b = r.rectArea[f];
        b.position.setFromMatrixPosition(w.matrixWorld), b.position.applyMatrix4(m), o.identity(), a.copy(w.matrixWorld), a.premultiply(m), o.extractRotation(a), b.halfWidth.set(0.5 * w.width, 0, 0), b.halfHeight.set(0, 0.5 * w.height, 0), b.halfWidth.applyMatrix4(o), b.halfHeight.applyMatrix4(o), f++;
      } else if (w.isPointLight) {
        const b = r.point[h];
        b.position.setFromMatrixPosition(w.matrixWorld), b.position.applyMatrix4(m), h++;
      } else if (w.isHemisphereLight) {
        const b = r.hemi[v];
        b.direction.setFromMatrixPosition(w.matrixWorld), b.direction.transformDirection(m), v++;
      }
    }
  }, state: r };
}
function KT(i, t) {
  const e = new YF(i, t), n = [], r = [];
  return { init: function() {
    n.length = 0, r.length = 0;
  }, state: { lightsArray: n, shadowsArray: r, lights: e }, setupLights: function(s) {
    e.setup(n, s);
  }, setupLightsView: function(s) {
    e.setupView(n, s);
  }, pushLight: function(s) {
    n.push(s);
  }, pushShadow: function(s) {
    r.push(s);
  } };
}
function JF(i, t) {
  let e = /* @__PURE__ */ new WeakMap();
  return { get: function(n, r = 0) {
    const s = e.get(n);
    let a;
    return s === void 0 ? (a = new KT(i, t), e.set(n, [a])) : r >= s.length ? (a = new KT(i, t), s.push(a)) : a = s[r], a;
  }, dispose: function() {
    e = /* @__PURE__ */ new WeakMap();
  } };
}
class n0 extends Kr {
  constructor(t) {
    super(), this.isMeshDepthMaterial = !0, this.type = "MeshDepthMaterial", this.depthPacking = 3200, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(t);
  }
  copy(t) {
    return super.copy(t), this.depthPacking = t.depthPacking, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this;
  }
}
class Fb extends Kr {
  constructor(t) {
    super(), this.isMeshDistanceMaterial = !0, this.type = "MeshDistanceMaterial", this.referencePosition = new D(), this.nearDistance = 1, this.farDistance = 1e3, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(t);
  }
  copy(t) {
    return super.copy(t), this.referencePosition.copy(t.referencePosition), this.nearDistance = t.nearDistance, this.farDistance = t.farDistance, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this;
  }
}
const KF = `void main() {
	gl_Position = vec4( position, 1.0 );
}`, $F = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function QF(i, t, e) {
  let n = new t0();
  const r = new wt(), s = new wt(), a = new ze(), o = new n0({ depthPacking: 3201 }), l = new Fb(), c = {}, u = e.maxTextureSize, h = { 0: 1, 1: 0, 2: 2 }, p = new Gn({ defines: { VSM_SAMPLES: 8 }, uniforms: { shadow_pass: { value: null }, resolution: { value: new wt() }, radius: { value: 4 } }, vertexShader: KF, fragmentShader: $F }), f = p.clone();
  f.defines.HORIZONTAL_PASS = 1;
  const v = new _e();
  v.setAttribute("position", new Ze(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3));
  const m = new Nt(v, p), y = this;
  function _(T, M) {
    const A = t.update(m);
    p.defines.VSM_SAMPLES !== T.blurSamples && (p.defines.VSM_SAMPLES = T.blurSamples, f.defines.VSM_SAMPLES = T.blurSamples, p.needsUpdate = !0, f.needsUpdate = !0), T.mapPass === null && (T.mapPass = new ir(r.x, r.y)), p.uniforms.shadow_pass.value = T.map.texture, p.uniforms.resolution.value = T.mapSize, p.uniforms.radius.value = T.radius, i.setRenderTarget(T.mapPass), i.clear(), i.renderBufferDirect(M, null, A, p, m, null), f.uniforms.shadow_pass.value = T.mapPass.texture, f.uniforms.resolution.value = T.mapSize, f.uniforms.radius.value = T.radius, i.setRenderTarget(T.map), i.clear(), i.renderBufferDirect(M, null, A, f, m, null);
  }
  function w(T, M, A, C, I, k) {
    let R = null;
    const L = A.isPointLight === !0 ? T.customDistanceMaterial : T.customDepthMaterial;
    if (L !== void 0)
      R = L;
    else if (R = A.isPointLight === !0 ? l : o, i.localClippingEnabled && M.clipShadows === !0 && Array.isArray(M.clippingPlanes) && M.clippingPlanes.length !== 0 || M.displacementMap && M.displacementScale !== 0 || M.alphaMap && M.alphaTest > 0 || M.map && M.alphaTest > 0) {
      const E = R.uuid, q = M.uuid;
      let it = c[E];
      it === void 0 && (it = {}, c[E] = it);
      let rt = it[q];
      rt === void 0 && (rt = R.clone(), it[q] = rt), R = rt;
    }
    return R.visible = M.visible, R.wireframe = M.wireframe, R.side = k === 3 ? M.shadowSide !== null ? M.shadowSide : M.side : M.shadowSide !== null ? M.shadowSide : h[M.side], R.alphaMap = M.alphaMap, R.alphaTest = M.alphaTest, R.map = M.map, R.clipShadows = M.clipShadows, R.clippingPlanes = M.clippingPlanes, R.clipIntersection = M.clipIntersection, R.displacementMap = M.displacementMap, R.displacementScale = M.displacementScale, R.displacementBias = M.displacementBias, R.wireframeLinewidth = M.wireframeLinewidth, R.linewidth = M.linewidth, A.isPointLight === !0 && R.isMeshDistanceMaterial === !0 && (R.referencePosition.setFromMatrixPosition(A.matrixWorld), R.nearDistance = C, R.farDistance = I), R;
  }
  function b(T, M, A, C, I) {
    if (T.visible === !1)
      return;
    if (T.layers.test(M.layers) && (T.isMesh || T.isLine || T.isPoints) && (T.castShadow || T.receiveShadow && I === 3) && (!T.frustumCulled || n.intersectsObject(T))) {
      T.modelViewMatrix.multiplyMatrices(A.matrixWorldInverse, T.matrixWorld);
      const R = t.update(T), L = T.material;
      if (Array.isArray(L)) {
        const E = R.groups;
        for (let q = 0, it = E.length; q < it; q++) {
          const rt = E[q], ft = L[rt.materialIndex];
          if (ft && ft.visible) {
            const nt = w(T, ft, C, A.near, A.far, I);
            i.renderBufferDirect(A, null, R, nt, T, rt);
          }
        }
      } else if (L.visible) {
        const E = w(T, L, C, A.near, A.far, I);
        i.renderBufferDirect(A, null, R, E, T, null);
      }
    }
    const k = T.children;
    for (let R = 0, L = k.length; R < L; R++)
      b(k[R], M, A, C, I);
  }
  this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = 1, this.render = function(T, M, A) {
    if (y.enabled === !1 || y.autoUpdate === !1 && y.needsUpdate === !1 || T.length === 0)
      return;
    const C = i.getRenderTarget(), I = i.getActiveCubeFace(), k = i.getActiveMipmapLevel(), R = i.state;
    R.setBlending(0), R.buffers.color.setClear(1, 1, 1, 1), R.buffers.depth.setTest(!0), R.setScissorTest(!1);
    for (let L = 0, E = T.length; L < E; L++) {
      const q = T[L], it = q.shadow;
      if (it === void 0) {
        console.warn("THREE.WebGLShadowMap:", q, "has no shadow.");
        continue;
      }
      if (it.autoUpdate === !1 && it.needsUpdate === !1)
        continue;
      r.copy(it.mapSize);
      const rt = it.getFrameExtents();
      if (r.multiply(rt), s.copy(it.mapSize), (r.x > u || r.y > u) && (r.x > u && (s.x = Math.floor(u / rt.x), r.x = s.x * rt.x, it.mapSize.x = s.x), r.y > u && (s.y = Math.floor(u / rt.y), r.y = s.y * rt.y, it.mapSize.y = s.y)), it.map === null) {
        const nt = this.type !== 3 ? { minFilter: 1003, magFilter: 1003 } : {};
        it.map = new ir(r.x, r.y, nt), it.map.texture.name = q.name + ".shadowMap", it.camera.updateProjectionMatrix();
      }
      i.setRenderTarget(it.map), i.clear();
      const ft = it.getViewportCount();
      for (let nt = 0; nt < ft; nt++) {
        const vt = it.getViewport(nt);
        a.set(s.x * vt.x, s.y * vt.y, s.x * vt.z, s.y * vt.w), R.viewport(a), it.updateMatrices(q, nt), n = it.getFrustum(), b(M, A, it.camera, q, this.type);
      }
      it.isPointLightShadow !== !0 && this.type === 3 && _(it, A), it.needsUpdate = !1;
    }
    y.needsUpdate = !1, i.setRenderTarget(C, I, k);
  };
}
function tU(i, t, e) {
  const n = e.isWebGL2, r = new function() {
    let S = !1;
    const Z = new ze();
    let G = null;
    const F = new ze(0, 0, 0, 0);
    return { setMask: function(z) {
      G === z || S || (i.colorMask(z, z, z, z), G = z);
    }, setLocked: function(z) {
      S = z;
    }, setClear: function(z, Y, pt, ht, lt) {
      lt === !0 && (z *= ht, Y *= ht, pt *= ht), Z.set(z, Y, pt, ht), F.equals(Z) === !1 && (i.clearColor(z, Y, pt, ht), F.copy(Z));
    }, reset: function() {
      S = !1, G = null, F.set(-1, 0, 0, 0);
    } };
  }(), s = new function() {
    let S = !1, Z = null, G = null, F = null;
    return { setTest: function(z) {
      z ? Mt(2929) : At(2929);
    }, setMask: function(z) {
      Z === z || S || (i.depthMask(z), Z = z);
    }, setFunc: function(z) {
      if (G !== z) {
        switch (z) {
          case 0:
            i.depthFunc(512);
            break;
          case 1:
            i.depthFunc(519);
            break;
          case 2:
            i.depthFunc(513);
            break;
          case 3:
            i.depthFunc(515);
            break;
          case 4:
            i.depthFunc(514);
            break;
          case 5:
            i.depthFunc(518);
            break;
          case 6:
            i.depthFunc(516);
            break;
          case 7:
            i.depthFunc(517);
            break;
          default:
            i.depthFunc(515);
        }
        G = z;
      }
    }, setLocked: function(z) {
      S = z;
    }, setClear: function(z) {
      F !== z && (i.clearDepth(z), F = z);
    }, reset: function() {
      S = !1, Z = null, G = null, F = null;
    } };
  }(), a = new function() {
    let S = !1, Z = null, G = null, F = null, z = null, Y = null, pt = null, ht = null, lt = null;
    return { setTest: function(yt) {
      S || (yt ? Mt(2960) : At(2960));
    }, setMask: function(yt) {
      Z === yt || S || (i.stencilMask(yt), Z = yt);
    }, setFunc: function(yt, O, V) {
      G === yt && F === O && z === V || (i.stencilFunc(yt, O, V), G = yt, F = O, z = V);
    }, setOp: function(yt, O, V) {
      Y === yt && pt === O && ht === V || (i.stencilOp(yt, O, V), Y = yt, pt = O, ht = V);
    }, setLocked: function(yt) {
      S = yt;
    }, setClear: function(yt) {
      lt !== yt && (i.clearStencil(yt), lt = yt);
    }, reset: function() {
      S = !1, Z = null, G = null, F = null, z = null, Y = null, pt = null, ht = null, lt = null;
    } };
  }(), o = /* @__PURE__ */ new WeakMap(), l = /* @__PURE__ */ new WeakMap();
  let c = {}, u = {}, h = /* @__PURE__ */ new WeakMap(), p = [], f = null, v = !1, m = null, y = null, _ = null, w = null, b = null, T = null, M = null, A = !1, C = null, I = null, k = null, R = null, L = null;
  const E = i.getParameter(35661);
  let q = !1, it = 0;
  const rt = i.getParameter(7938);
  rt.indexOf("WebGL") !== -1 ? (it = parseFloat(/^WebGL (\d)/.exec(rt)[1]), q = it >= 1) : rt.indexOf("OpenGL ES") !== -1 && (it = parseFloat(/^OpenGL ES (\d)/.exec(rt)[1]), q = it >= 2);
  let ft = null, nt = {};
  const vt = i.getParameter(3088), $ = i.getParameter(2978), W = new ze().fromArray(vt), ct = new ze().fromArray($);
  function mt(S, Z, G) {
    const F = new Uint8Array(4), z = i.createTexture();
    i.bindTexture(S, z), i.texParameteri(S, 10241, 9728), i.texParameteri(S, 10240, 9728);
    for (let Y = 0; Y < G; Y++)
      i.texImage2D(Z + Y, 0, 6408, 1, 1, 0, 6408, 5121, F);
    return z;
  }
  const dt = {};
  function Mt(S) {
    c[S] !== !0 && (i.enable(S), c[S] = !0);
  }
  function At(S) {
    c[S] !== !1 && (i.disable(S), c[S] = !1);
  }
  dt[3553] = mt(3553, 3553, 1), dt[34067] = mt(34067, 34069, 6), r.setClear(0, 0, 0, 1), s.setClear(1), a.setClear(0), Mt(2929), s.setFunc(3), et(!1), J(1), Mt(2884), st(0);
  const H = { 100: 32774, 101: 32778, 102: 32779 };
  if (n)
    H[103] = 32775, H[104] = 32776;
  else {
    const S = t.get("EXT_blend_minmax");
    S !== null && (H[103] = S.MIN_EXT, H[104] = S.MAX_EXT);
  }
  const N = { 200: 0, 201: 1, 202: 768, 204: 770, 210: 776, 208: 774, 206: 772, 203: 769, 205: 771, 209: 775, 207: 773 };
  function st(S, Z, G, F, z, Y, pt, ht) {
    if (S !== 0) {
      if (v === !1 && (Mt(3042), v = !0), S === 5)
        z = z || Z, Y = Y || G, pt = pt || F, Z === y && z === b || (i.blendEquationSeparate(H[Z], H[z]), y = Z, b = z), G === _ && F === w && Y === T && pt === M || (i.blendFuncSeparate(N[G], N[F], N[Y], N[pt]), _ = G, w = F, T = Y, M = pt), m = S, A = !1;
      else if (S !== m || ht !== A) {
        if (y === 100 && b === 100 || (i.blendEquation(32774), y = 100, b = 100), ht)
          switch (S) {
            case 1:
              i.blendFuncSeparate(1, 771, 1, 771);
              break;
            case 2:
              i.blendFunc(1, 1);
              break;
            case 3:
              i.blendFuncSeparate(0, 769, 0, 1);
              break;
            case 4:
              i.blendFuncSeparate(0, 768, 0, 770);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", S);
          }
        else
          switch (S) {
            case 1:
              i.blendFuncSeparate(770, 771, 1, 771);
              break;
            case 2:
              i.blendFunc(770, 1);
              break;
            case 3:
              i.blendFuncSeparate(0, 769, 0, 1);
              break;
            case 4:
              i.blendFunc(0, 768);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", S);
          }
        _ = null, w = null, T = null, M = null, m = S, A = ht;
      }
    } else
      v === !0 && (At(3042), v = !1);
  }
  function et(S) {
    C !== S && (S ? i.frontFace(2304) : i.frontFace(2305), C = S);
  }
  function J(S) {
    S !== 0 ? (Mt(2884), S !== I && (S === 1 ? i.cullFace(1029) : S === 2 ? i.cullFace(1028) : i.cullFace(1032))) : At(2884), I = S;
  }
  function K(S, Z, G) {
    S ? (Mt(32823), R === Z && L === G || (i.polygonOffset(Z, G), R = Z, L = G)) : At(32823);
  }
  return { buffers: { color: r, depth: s, stencil: a }, enable: Mt, disable: At, bindFramebuffer: function(S, Z) {
    return u[S] !== Z && (i.bindFramebuffer(S, Z), u[S] = Z, n && (S === 36009 && (u[36160] = Z), S === 36160 && (u[36009] = Z)), !0);
  }, drawBuffers: function(S, Z) {
    let G = p, F = !1;
    if (S)
      if (G = h.get(Z), G === void 0 && (G = [], h.set(Z, G)), S.isWebGLMultipleRenderTargets) {
        const z = S.texture;
        if (G.length !== z.length || G[0] !== 36064) {
          for (let Y = 0, pt = z.length; Y < pt; Y++)
            G[Y] = 36064 + Y;
          G.length = z.length, F = !0;
        }
      } else
        G[0] !== 36064 && (G[0] = 36064, F = !0);
    else
      G[0] !== 1029 && (G[0] = 1029, F = !0);
    F && (e.isWebGL2 ? i.drawBuffers(G) : t.get("WEBGL_draw_buffers").drawBuffersWEBGL(G));
  }, useProgram: function(S) {
    return f !== S && (i.useProgram(S), f = S, !0);
  }, setBlending: st, setMaterial: function(S, Z) {
    S.side === 2 ? At(2884) : Mt(2884);
    let G = S.side === 1;
    Z && (G = !G), et(G), S.blending === 1 && S.transparent === !1 ? st(0) : st(S.blending, S.blendEquation, S.blendSrc, S.blendDst, S.blendEquationAlpha, S.blendSrcAlpha, S.blendDstAlpha, S.premultipliedAlpha), s.setFunc(S.depthFunc), s.setTest(S.depthTest), s.setMask(S.depthWrite), r.setMask(S.colorWrite);
    const F = S.stencilWrite;
    a.setTest(F), F && (a.setMask(S.stencilWriteMask), a.setFunc(S.stencilFunc, S.stencilRef, S.stencilFuncMask), a.setOp(S.stencilFail, S.stencilZFail, S.stencilZPass)), K(S.polygonOffset, S.polygonOffsetFactor, S.polygonOffsetUnits), S.alphaToCoverage === !0 ? Mt(32926) : At(32926);
  }, setFlipSided: et, setCullFace: J, setLineWidth: function(S) {
    S !== k && (q && i.lineWidth(S), k = S);
  }, setPolygonOffset: K, setScissorTest: function(S) {
    S ? Mt(3089) : At(3089);
  }, activeTexture: function(S) {
    S === void 0 && (S = 33984 + E - 1), ft !== S && (i.activeTexture(S), ft = S);
  }, bindTexture: function(S, Z, G) {
    G === void 0 && (G = ft === null ? 33984 + E - 1 : ft);
    let F = nt[G];
    F === void 0 && (F = { type: void 0, texture: void 0 }, nt[G] = F), F.type === S && F.texture === Z || (ft !== G && (i.activeTexture(G), ft = G), i.bindTexture(S, Z || dt[S]), F.type = S, F.texture = Z);
  }, unbindTexture: function() {
    const S = nt[ft];
    S !== void 0 && S.type !== void 0 && (i.bindTexture(S.type, null), S.type = void 0, S.texture = void 0);
  }, compressedTexImage2D: function() {
    try {
      i.compressedTexImage2D.apply(i, arguments);
    } catch (S) {
      console.error("THREE.WebGLState:", S);
    }
  }, compressedTexImage3D: function() {
    try {
      i.compressedTexImage3D.apply(i, arguments);
    } catch (S) {
      console.error("THREE.WebGLState:", S);
    }
  }, texImage2D: function() {
    try {
      i.texImage2D.apply(i, arguments);
    } catch (S) {
      console.error("THREE.WebGLState:", S);
    }
  }, texImage3D: function() {
    try {
      i.texImage3D.apply(i, arguments);
    } catch (S) {
      console.error("THREE.WebGLState:", S);
    }
  }, updateUBOMapping: function(S, Z) {
    let G = l.get(Z);
    G === void 0 && (G = /* @__PURE__ */ new WeakMap(), l.set(Z, G));
    let F = G.get(S);
    F === void 0 && (F = i.getUniformBlockIndex(Z, S.name), G.set(S, F));
  }, uniformBlockBinding: function(S, Z) {
    const G = l.get(Z).get(S);
    o.get(Z) !== G && (i.uniformBlockBinding(Z, G, S.__bindingPointIndex), o.set(Z, G));
  }, texStorage2D: function() {
    try {
      i.texStorage2D.apply(i, arguments);
    } catch (S) {
      console.error("THREE.WebGLState:", S);
    }
  }, texStorage3D: function() {
    try {
      i.texStorage3D.apply(i, arguments);
    } catch (S) {
      console.error("THREE.WebGLState:", S);
    }
  }, texSubImage2D: function() {
    try {
      i.texSubImage2D.apply(i, arguments);
    } catch (S) {
      console.error("THREE.WebGLState:", S);
    }
  }, texSubImage3D: function() {
    try {
      i.texSubImage3D.apply(i, arguments);
    } catch (S) {
      console.error("THREE.WebGLState:", S);
    }
  }, compressedTexSubImage2D: function() {
    try {
      i.compressedTexSubImage2D.apply(i, arguments);
    } catch (S) {
      console.error("THREE.WebGLState:", S);
    }
  }, compressedTexSubImage3D: function() {
    try {
      i.compressedTexSubImage3D.apply(i, arguments);
    } catch (S) {
      console.error("THREE.WebGLState:", S);
    }
  }, scissor: function(S) {
    W.equals(S) === !1 && (i.scissor(S.x, S.y, S.z, S.w), W.copy(S));
  }, viewport: function(S) {
    ct.equals(S) === !1 && (i.viewport(S.x, S.y, S.z, S.w), ct.copy(S));
  }, reset: function() {
    i.disable(3042), i.disable(2884), i.disable(2929), i.disable(32823), i.disable(3089), i.disable(2960), i.disable(32926), i.blendEquation(32774), i.blendFunc(1, 0), i.blendFuncSeparate(1, 0, 1, 0), i.colorMask(!0, !0, !0, !0), i.clearColor(0, 0, 0, 0), i.depthMask(!0), i.depthFunc(513), i.clearDepth(1), i.stencilMask(4294967295), i.stencilFunc(519, 0, 4294967295), i.stencilOp(7680, 7680, 7680), i.clearStencil(0), i.cullFace(1029), i.frontFace(2305), i.polygonOffset(0, 0), i.activeTexture(33984), i.bindFramebuffer(36160, null), n === !0 && (i.bindFramebuffer(36009, null), i.bindFramebuffer(36008, null)), i.useProgram(null), i.lineWidth(1), i.scissor(0, 0, i.canvas.width, i.canvas.height), i.viewport(0, 0, i.canvas.width, i.canvas.height), c = {}, ft = null, nt = {}, u = {}, h = /* @__PURE__ */ new WeakMap(), p = [], f = null, v = !1, m = null, y = null, _ = null, w = null, b = null, T = null, M = null, A = !1, C = null, I = null, k = null, R = null, L = null, W.set(0, 0, i.canvas.width, i.canvas.height), ct.set(0, 0, i.canvas.width, i.canvas.height), r.reset(), s.reset(), a.reset();
  } };
}
function eU(i, t, e, n, r, s, a) {
  const o = r.isWebGL2, l = r.maxTextures, c = r.maxCubemapSize, u = r.maxTextureSize, h = r.maxSamples, p = t.has("WEBGL_multisampled_render_to_texture") ? t.get("WEBGL_multisampled_render_to_texture") : null, f = typeof navigator < "u" && /OculusBrowser/g.test(navigator.userAgent), v = /* @__PURE__ */ new WeakMap();
  let m;
  const y = /* @__PURE__ */ new WeakMap();
  let _ = !1;
  try {
    _ = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch {
  }
  function w(H, N) {
    return _ ? new OffscreenCanvas(H, N) : Xd("canvas");
  }
  function b(H, N, st, et) {
    let J = 1;
    if ((H.width > et || H.height > et) && (J = et / Math.max(H.width, H.height)), J < 1 || N === !0) {
      if (typeof HTMLImageElement < "u" && H instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && H instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && H instanceof ImageBitmap) {
        const K = N ? xv : Math.floor, S = K(J * H.width), Z = K(J * H.height);
        m === void 0 && (m = w(S, Z));
        const G = st ? w(S, Z) : m;
        return G.width = S, G.height = Z, G.getContext("2d").drawImage(H, 0, 0, S, Z), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + H.width + "x" + H.height + ") to (" + S + "x" + Z + ")."), G;
      }
      return "data" in H && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + H.width + "x" + H.height + ")."), H;
    }
    return H;
  }
  function T(H) {
    return tx(H.width) && tx(H.height);
  }
  function M(H, N) {
    return H.generateMipmaps && N && H.minFilter !== 1003 && H.minFilter !== 1006;
  }
  function A(H) {
    i.generateMipmap(H);
  }
  function C(H, N, st, et, J = !1) {
    if (o === !1)
      return N;
    if (H !== null) {
      if (i[H] !== void 0)
        return i[H];
      console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + H + "'");
    }
    let K = N;
    return N === 6403 && (st === 5126 && (K = 33326), st === 5131 && (K = 33325), st === 5121 && (K = 33321)), N === 33319 && (st === 5126 && (K = 33328), st === 5131 && (K = 33327), st === 5121 && (K = 33323)), N === 6408 && (st === 5126 && (K = 34836), st === 5131 && (K = 34842), st === 5121 && (K = et === 3001 && J === !1 ? 35907 : 32856), st === 32819 && (K = 32854), st === 32820 && (K = 32855)), K !== 33325 && K !== 33326 && K !== 33327 && K !== 33328 && K !== 34842 && K !== 34836 || t.get("EXT_color_buffer_float"), K;
  }
  function I(H, N, st) {
    return M(H, st) === !0 || H.isFramebufferTexture && H.minFilter !== 1003 && H.minFilter !== 1006 ? Math.log2(Math.max(N.width, N.height)) + 1 : H.mipmaps !== void 0 && H.mipmaps.length > 0 ? H.mipmaps.length : H.isCompressedTexture && Array.isArray(H.image) ? N.mipmaps.length : 1;
  }
  function k(H) {
    return H === 1003 || H === 1004 || H === 1005 ? 9728 : 9729;
  }
  function R(H) {
    const N = H.target;
    N.removeEventListener("dispose", R), function(st) {
      const et = n.get(st);
      if (et.__webglInit === void 0)
        return;
      const J = st.source, K = y.get(J);
      if (K) {
        const S = K[et.__cacheKey];
        S.usedTimes--, S.usedTimes === 0 && E(st), Object.keys(K).length === 0 && y.delete(J);
      }
      n.remove(st);
    }(N), N.isVideoTexture && v.delete(N);
  }
  function L(H) {
    const N = H.target;
    N.removeEventListener("dispose", L), function(st) {
      const et = st.texture, J = n.get(st), K = n.get(et);
      if (K.__webglTexture !== void 0 && (i.deleteTexture(K.__webglTexture), a.memory.textures--), st.depthTexture && st.depthTexture.dispose(), st.isWebGLCubeRenderTarget)
        for (let S = 0; S < 6; S++)
          i.deleteFramebuffer(J.__webglFramebuffer[S]), J.__webglDepthbuffer && i.deleteRenderbuffer(J.__webglDepthbuffer[S]);
      else {
        if (i.deleteFramebuffer(J.__webglFramebuffer), J.__webglDepthbuffer && i.deleteRenderbuffer(J.__webglDepthbuffer), J.__webglMultisampledFramebuffer && i.deleteFramebuffer(J.__webglMultisampledFramebuffer), J.__webglColorRenderbuffer)
          for (let S = 0; S < J.__webglColorRenderbuffer.length; S++)
            J.__webglColorRenderbuffer[S] && i.deleteRenderbuffer(J.__webglColorRenderbuffer[S]);
        J.__webglDepthRenderbuffer && i.deleteRenderbuffer(J.__webglDepthRenderbuffer);
      }
      if (st.isWebGLMultipleRenderTargets)
        for (let S = 0, Z = et.length; S < Z; S++) {
          const G = n.get(et[S]);
          G.__webglTexture && (i.deleteTexture(G.__webglTexture), a.memory.textures--), n.remove(et[S]);
        }
      n.remove(et), n.remove(st);
    }(N);
  }
  function E(H) {
    const N = n.get(H);
    i.deleteTexture(N.__webglTexture);
    const st = H.source;
    delete y.get(st)[N.__cacheKey], a.memory.textures--;
  }
  let q = 0;
  function it(H, N) {
    const st = n.get(H);
    if (H.isVideoTexture && function(et) {
      const J = a.render.frame;
      v.get(et) !== J && (v.set(et, J), et.update());
    }(H), H.isRenderTargetTexture === !1 && H.version > 0 && st.__version !== H.version) {
      const et = H.image;
      if (et === null)
        console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
      else {
        if (et.complete !== !1)
          return void $(st, H, N);
        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
      }
    }
    e.bindTexture(3553, st.__webglTexture, 33984 + N);
  }
  const rt = { 1e3: 10497, 1001: 33071, 1002: 33648 }, ft = { 1003: 9728, 1004: 9984, 1005: 9986, 1006: 9729, 1007: 9985, 1008: 9987 };
  function nt(H, N, st) {
    if (st ? (i.texParameteri(H, 10242, rt[N.wrapS]), i.texParameteri(H, 10243, rt[N.wrapT]), H !== 32879 && H !== 35866 || i.texParameteri(H, 32882, rt[N.wrapR]), i.texParameteri(H, 10240, ft[N.magFilter]), i.texParameteri(H, 10241, ft[N.minFilter])) : (i.texParameteri(H, 10242, 33071), i.texParameteri(H, 10243, 33071), H !== 32879 && H !== 35866 || i.texParameteri(H, 32882, 33071), N.wrapS === 1001 && N.wrapT === 1001 || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), i.texParameteri(H, 10240, k(N.magFilter)), i.texParameteri(H, 10241, k(N.minFilter)), N.minFilter !== 1003 && N.minFilter !== 1006 && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), t.has("EXT_texture_filter_anisotropic") === !0) {
      const et = t.get("EXT_texture_filter_anisotropic");
      if (N.magFilter === 1003 || N.minFilter !== 1005 && N.minFilter !== 1008 || N.type === 1015 && t.has("OES_texture_float_linear") === !1 || o === !1 && N.type === 1016 && t.has("OES_texture_half_float_linear") === !1)
        return;
      (N.anisotropy > 1 || n.get(N).__currentAnisotropy) && (i.texParameterf(H, et.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(N.anisotropy, r.getMaxAnisotropy())), n.get(N).__currentAnisotropy = N.anisotropy);
    }
  }
  function vt(H, N) {
    let st = !1;
    H.__webglInit === void 0 && (H.__webglInit = !0, N.addEventListener("dispose", R));
    const et = N.source;
    let J = y.get(et);
    J === void 0 && (J = {}, y.set(et, J));
    const K = function(S) {
      const Z = [];
      return Z.push(S.wrapS), Z.push(S.wrapT), Z.push(S.wrapR || 0), Z.push(S.magFilter), Z.push(S.minFilter), Z.push(S.anisotropy), Z.push(S.internalFormat), Z.push(S.format), Z.push(S.type), Z.push(S.generateMipmaps), Z.push(S.premultiplyAlpha), Z.push(S.flipY), Z.push(S.unpackAlignment), Z.push(S.encoding), Z.join();
    }(N);
    if (K !== H.__cacheKey) {
      J[K] === void 0 && (J[K] = { texture: i.createTexture(), usedTimes: 0 }, a.memory.textures++, st = !0), J[K].usedTimes++;
      const S = J[H.__cacheKey];
      S !== void 0 && (J[H.__cacheKey].usedTimes--, S.usedTimes === 0 && E(N)), H.__cacheKey = K, H.__webglTexture = J[K].texture;
    }
    return st;
  }
  function $(H, N, st) {
    let et = 3553;
    (N.isDataArrayTexture || N.isCompressedArrayTexture) && (et = 35866), N.isData3DTexture && (et = 32879);
    const J = vt(H, N), K = N.source;
    e.bindTexture(et, H.__webglTexture, 33984 + st);
    const S = n.get(K);
    if (K.version !== S.__version || J === !0) {
      e.activeTexture(33984 + st), i.pixelStorei(37440, N.flipY), i.pixelStorei(37441, N.premultiplyAlpha), i.pixelStorei(3317, N.unpackAlignment), i.pixelStorei(37443, 0);
      const Z = function(tt) {
        return !o && (tt.wrapS !== 1001 || tt.wrapT !== 1001 || tt.minFilter !== 1003 && tt.minFilter !== 1006);
      }(N) && T(N.image) === !1;
      let G = b(N.image, Z, !1, u);
      G = At(N, G);
      const F = T(G) || o, z = s.convert(N.format, N.encoding);
      let Y, pt = s.convert(N.type), ht = C(N.internalFormat, z, pt, N.encoding, N.isVideoTexture);
      nt(et, N, F);
      const lt = N.mipmaps, yt = o && N.isVideoTexture !== !0, O = S.__version === void 0 || J === !0, V = I(N, G, F);
      if (N.isDepthTexture)
        ht = 6402, o ? ht = N.type === 1015 ? 36012 : N.type === 1014 ? 33190 : N.type === 1020 ? 35056 : 33189 : N.type === 1015 && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), N.format === 1026 && ht === 6402 && N.type !== 1012 && N.type !== 1014 && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), N.type = 1014, pt = s.convert(N.type)), N.format === 1027 && ht === 6402 && (ht = 34041, N.type !== 1020 && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), N.type = 1020, pt = s.convert(N.type))), O && (yt ? e.texStorage2D(3553, 1, ht, G.width, G.height) : e.texImage2D(3553, 0, ht, G.width, G.height, 0, z, pt, null));
      else if (N.isDataTexture)
        if (lt.length > 0 && F) {
          yt && O && e.texStorage2D(3553, V, ht, lt[0].width, lt[0].height);
          for (let tt = 0, gt = lt.length; tt < gt; tt++)
            Y = lt[tt], yt ? e.texSubImage2D(3553, tt, 0, 0, Y.width, Y.height, z, pt, Y.data) : e.texImage2D(3553, tt, ht, Y.width, Y.height, 0, z, pt, Y.data);
          N.generateMipmaps = !1;
        } else
          yt ? (O && e.texStorage2D(3553, V, ht, G.width, G.height), e.texSubImage2D(3553, 0, 0, 0, G.width, G.height, z, pt, G.data)) : e.texImage2D(3553, 0, ht, G.width, G.height, 0, z, pt, G.data);
      else if (N.isCompressedTexture)
        if (N.isCompressedArrayTexture) {
          yt && O && e.texStorage3D(35866, V, ht, lt[0].width, lt[0].height, G.depth);
          for (let tt = 0, gt = lt.length; tt < gt; tt++)
            Y = lt[tt], N.format !== 1023 ? z !== null ? yt ? e.compressedTexSubImage3D(35866, tt, 0, 0, 0, Y.width, Y.height, G.depth, z, Y.data, 0, 0) : e.compressedTexImage3D(35866, tt, ht, Y.width, Y.height, G.depth, 0, Y.data, 0, 0) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : yt ? e.texSubImage3D(35866, tt, 0, 0, 0, Y.width, Y.height, G.depth, z, pt, Y.data) : e.texImage3D(35866, tt, ht, Y.width, Y.height, G.depth, 0, z, pt, Y.data);
        } else {
          yt && O && e.texStorage2D(3553, V, ht, lt[0].width, lt[0].height);
          for (let tt = 0, gt = lt.length; tt < gt; tt++)
            Y = lt[tt], N.format !== 1023 ? z !== null ? yt ? e.compressedTexSubImage2D(3553, tt, 0, 0, Y.width, Y.height, z, Y.data) : e.compressedTexImage2D(3553, tt, ht, Y.width, Y.height, 0, Y.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : yt ? e.texSubImage2D(3553, tt, 0, 0, Y.width, Y.height, z, pt, Y.data) : e.texImage2D(3553, tt, ht, Y.width, Y.height, 0, z, pt, Y.data);
        }
      else if (N.isDataArrayTexture)
        yt ? (O && e.texStorage3D(35866, V, ht, G.width, G.height, G.depth), e.texSubImage3D(35866, 0, 0, 0, 0, G.width, G.height, G.depth, z, pt, G.data)) : e.texImage3D(35866, 0, ht, G.width, G.height, G.depth, 0, z, pt, G.data);
      else if (N.isData3DTexture)
        yt ? (O && e.texStorage3D(32879, V, ht, G.width, G.height, G.depth), e.texSubImage3D(32879, 0, 0, 0, 0, G.width, G.height, G.depth, z, pt, G.data)) : e.texImage3D(32879, 0, ht, G.width, G.height, G.depth, 0, z, pt, G.data);
      else if (N.isFramebufferTexture) {
        if (O)
          if (yt)
            e.texStorage2D(3553, V, ht, G.width, G.height);
          else {
            let tt = G.width, gt = G.height;
            for (let Tt = 0; Tt < V; Tt++)
              e.texImage2D(3553, Tt, ht, tt, gt, 0, z, pt, null), tt >>= 1, gt >>= 1;
          }
      } else if (lt.length > 0 && F) {
        yt && O && e.texStorage2D(3553, V, ht, lt[0].width, lt[0].height);
        for (let tt = 0, gt = lt.length; tt < gt; tt++)
          Y = lt[tt], yt ? e.texSubImage2D(3553, tt, 0, 0, z, pt, Y) : e.texImage2D(3553, tt, ht, z, pt, Y);
        N.generateMipmaps = !1;
      } else
        yt ? (O && e.texStorage2D(3553, V, ht, G.width, G.height), e.texSubImage2D(3553, 0, 0, 0, z, pt, G)) : e.texImage2D(3553, 0, ht, z, pt, G);
      M(N, F) && A(et), S.__version = K.version, N.onUpdate && N.onUpdate(N);
    }
    H.__version = N.version;
  }
  function W(H, N, st, et, J) {
    const K = s.convert(st.format, st.encoding), S = s.convert(st.type), Z = C(st.internalFormat, K, S, st.encoding);
    n.get(N).__hasExternalTextures || (J === 32879 || J === 35866 ? e.texImage3D(J, 0, Z, N.width, N.height, N.depth, 0, K, S, null) : e.texImage2D(J, 0, Z, N.width, N.height, 0, K, S, null)), e.bindFramebuffer(36160, H), Mt(N) ? p.framebufferTexture2DMultisampleEXT(36160, et, J, n.get(st).__webglTexture, 0, dt(N)) : (J === 3553 || J >= 34069 && J <= 34074) && i.framebufferTexture2D(36160, et, J, n.get(st).__webglTexture, 0), e.bindFramebuffer(36160, null);
  }
  function ct(H, N, st) {
    if (i.bindRenderbuffer(36161, H), N.depthBuffer && !N.stencilBuffer) {
      let et = 33189;
      if (st || Mt(N)) {
        const J = N.depthTexture;
        J && J.isDepthTexture && (J.type === 1015 ? et = 36012 : J.type === 1014 && (et = 33190));
        const K = dt(N);
        Mt(N) ? p.renderbufferStorageMultisampleEXT(36161, K, et, N.width, N.height) : i.renderbufferStorageMultisample(36161, K, et, N.width, N.height);
      } else
        i.renderbufferStorage(36161, et, N.width, N.height);
      i.framebufferRenderbuffer(36160, 36096, 36161, H);
    } else if (N.depthBuffer && N.stencilBuffer) {
      const et = dt(N);
      st && Mt(N) === !1 ? i.renderbufferStorageMultisample(36161, et, 35056, N.width, N.height) : Mt(N) ? p.renderbufferStorageMultisampleEXT(36161, et, 35056, N.width, N.height) : i.renderbufferStorage(36161, 34041, N.width, N.height), i.framebufferRenderbuffer(36160, 33306, 36161, H);
    } else {
      const et = N.isWebGLMultipleRenderTargets === !0 ? N.texture : [N.texture];
      for (let J = 0; J < et.length; J++) {
        const K = et[J], S = s.convert(K.format, K.encoding), Z = s.convert(K.type), G = C(K.internalFormat, S, Z, K.encoding), F = dt(N);
        st && Mt(N) === !1 ? i.renderbufferStorageMultisample(36161, F, G, N.width, N.height) : Mt(N) ? p.renderbufferStorageMultisampleEXT(36161, F, G, N.width, N.height) : i.renderbufferStorage(36161, G, N.width, N.height);
      }
    }
    i.bindRenderbuffer(36161, null);
  }
  function mt(H) {
    const N = n.get(H), st = H.isWebGLCubeRenderTarget === !0;
    if (H.depthTexture && !N.__autoAllocateDepthBuffer) {
      if (st)
        throw new Error("target.depthTexture not supported in Cube render targets");
      (function(et, J) {
        if (J && J.isWebGLCubeRenderTarget)
          throw new Error("Depth Texture with cube render targets is not supported");
        if (e.bindFramebuffer(36160, et), !J.depthTexture || !J.depthTexture.isDepthTexture)
          throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
        n.get(J.depthTexture).__webglTexture && J.depthTexture.image.width === J.width && J.depthTexture.image.height === J.height || (J.depthTexture.image.width = J.width, J.depthTexture.image.height = J.height, J.depthTexture.needsUpdate = !0), it(J.depthTexture, 0);
        const K = n.get(J.depthTexture).__webglTexture, S = dt(J);
        if (J.depthTexture.format === 1026)
          Mt(J) ? p.framebufferTexture2DMultisampleEXT(36160, 36096, 3553, K, 0, S) : i.framebufferTexture2D(36160, 36096, 3553, K, 0);
        else {
          if (J.depthTexture.format !== 1027)
            throw new Error("Unknown depthTexture format");
          Mt(J) ? p.framebufferTexture2DMultisampleEXT(36160, 33306, 3553, K, 0, S) : i.framebufferTexture2D(36160, 33306, 3553, K, 0);
        }
      })(N.__webglFramebuffer, H);
    } else if (st) {
      N.__webglDepthbuffer = [];
      for (let et = 0; et < 6; et++)
        e.bindFramebuffer(36160, N.__webglFramebuffer[et]), N.__webglDepthbuffer[et] = i.createRenderbuffer(), ct(N.__webglDepthbuffer[et], H, !1);
    } else
      e.bindFramebuffer(36160, N.__webglFramebuffer), N.__webglDepthbuffer = i.createRenderbuffer(), ct(N.__webglDepthbuffer, H, !1);
    e.bindFramebuffer(36160, null);
  }
  function dt(H) {
    return Math.min(h, H.samples);
  }
  function Mt(H) {
    const N = n.get(H);
    return o && H.samples > 0 && t.has("WEBGL_multisampled_render_to_texture") === !0 && N.__useRenderToTexture !== !1;
  }
  function At(H, N) {
    const st = H.encoding, et = H.format, J = H.type;
    return H.isCompressedTexture === !0 || H.isVideoTexture === !0 || H.format === 1035 || st !== 3e3 && (st === 3001 ? o === !1 ? t.has("EXT_sRGB") === !0 && et === 1023 ? (H.format = 1035, H.minFilter = 1006, H.generateMipmaps = !1) : N = kb.sRGBToLinear(N) : et === 1023 && J === 1009 || console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture encoding:", st)), N;
  }
  this.allocateTextureUnit = function() {
    const H = q;
    return H >= l && console.warn("THREE.WebGLTextures: Trying to use " + H + " texture units while this GPU supports only " + l), q += 1, H;
  }, this.resetTextureUnits = function() {
    q = 0;
  }, this.setTexture2D = it, this.setTexture2DArray = function(H, N) {
    const st = n.get(H);
    H.version > 0 && st.__version !== H.version ? $(st, H, N) : e.bindTexture(35866, st.__webglTexture, 33984 + N);
  }, this.setTexture3D = function(H, N) {
    const st = n.get(H);
    H.version > 0 && st.__version !== H.version ? $(st, H, N) : e.bindTexture(32879, st.__webglTexture, 33984 + N);
  }, this.setTextureCube = function(H, N) {
    const st = n.get(H);
    H.version > 0 && st.__version !== H.version ? function(et, J, K) {
      if (J.image.length !== 6)
        return;
      const S = vt(et, J), Z = J.source;
      e.bindTexture(34067, et.__webglTexture, 33984 + K);
      const G = n.get(Z);
      if (Z.version !== G.__version || S === !0) {
        e.activeTexture(33984 + K), i.pixelStorei(37440, J.flipY), i.pixelStorei(37441, J.premultiplyAlpha), i.pixelStorei(3317, J.unpackAlignment), i.pixelStorei(37443, 0);
        const F = J.isCompressedTexture || J.image[0].isCompressedTexture, z = J.image[0] && J.image[0].isDataTexture, Y = [];
        for (let ot = 0; ot < 6; ot++)
          Y[ot] = F || z ? z ? J.image[ot].image : J.image[ot] : b(J.image[ot], !1, !0, c), Y[ot] = At(J, Y[ot]);
        const pt = Y[0], ht = T(pt) || o, lt = s.convert(J.format, J.encoding), yt = s.convert(J.type), O = C(J.internalFormat, lt, yt, J.encoding), V = o && J.isVideoTexture !== !0, tt = G.__version === void 0 || S === !0;
        let gt, Tt = I(J, pt, ht);
        if (nt(34067, J, ht), F) {
          V && tt && e.texStorage2D(34067, Tt, O, pt.width, pt.height);
          for (let ot = 0; ot < 6; ot++) {
            gt = Y[ot].mipmaps;
            for (let St = 0; St < gt.length; St++) {
              const It = gt[St];
              J.format !== 1023 ? lt !== null ? V ? e.compressedTexSubImage2D(34069 + ot, St, 0, 0, It.width, It.height, lt, It.data) : e.compressedTexImage2D(34069 + ot, St, O, It.width, It.height, 0, It.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : V ? e.texSubImage2D(34069 + ot, St, 0, 0, It.width, It.height, lt, yt, It.data) : e.texImage2D(34069 + ot, St, O, It.width, It.height, 0, lt, yt, It.data);
            }
          }
        } else {
          gt = J.mipmaps, V && tt && (gt.length > 0 && Tt++, e.texStorage2D(34067, Tt, O, Y[0].width, Y[0].height));
          for (let ot = 0; ot < 6; ot++)
            if (z) {
              V ? e.texSubImage2D(34069 + ot, 0, 0, 0, Y[ot].width, Y[ot].height, lt, yt, Y[ot].data) : e.texImage2D(34069 + ot, 0, O, Y[ot].width, Y[ot].height, 0, lt, yt, Y[ot].data);
              for (let St = 0; St < gt.length; St++) {
                const It = gt[St].image[ot].image;
                V ? e.texSubImage2D(34069 + ot, St + 1, 0, 0, It.width, It.height, lt, yt, It.data) : e.texImage2D(34069 + ot, St + 1, O, It.width, It.height, 0, lt, yt, It.data);
              }
            } else {
              V ? e.texSubImage2D(34069 + ot, 0, 0, 0, lt, yt, Y[ot]) : e.texImage2D(34069 + ot, 0, O, lt, yt, Y[ot]);
              for (let St = 0; St < gt.length; St++) {
                const It = gt[St];
                V ? e.texSubImage2D(34069 + ot, St + 1, 0, 0, lt, yt, It.image[ot]) : e.texImage2D(34069 + ot, St + 1, O, lt, yt, It.image[ot]);
              }
            }
        }
        M(J, ht) && A(34067), G.__version = Z.version, J.onUpdate && J.onUpdate(J);
      }
      et.__version = J.version;
    }(st, H, N) : e.bindTexture(34067, st.__webglTexture, 33984 + N);
  }, this.rebindTextures = function(H, N, st) {
    const et = n.get(H);
    N !== void 0 && W(et.__webglFramebuffer, H, H.texture, 36064, 3553), st !== void 0 && mt(H);
  }, this.setupRenderTarget = function(H) {
    const N = H.texture, st = n.get(H), et = n.get(N);
    H.addEventListener("dispose", L), H.isWebGLMultipleRenderTargets !== !0 && (et.__webglTexture === void 0 && (et.__webglTexture = i.createTexture()), et.__version = N.version, a.memory.textures++);
    const J = H.isWebGLCubeRenderTarget === !0, K = H.isWebGLMultipleRenderTargets === !0, S = T(H) || o;
    if (J) {
      st.__webglFramebuffer = [];
      for (let Z = 0; Z < 6; Z++)
        st.__webglFramebuffer[Z] = i.createFramebuffer();
    } else {
      if (st.__webglFramebuffer = i.createFramebuffer(), K)
        if (r.drawBuffers) {
          const Z = H.texture;
          for (let G = 0, F = Z.length; G < F; G++) {
            const z = n.get(Z[G]);
            z.__webglTexture === void 0 && (z.__webglTexture = i.createTexture(), a.memory.textures++);
          }
        } else
          console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
      if (o && H.samples > 0 && Mt(H) === !1) {
        const Z = K ? N : [N];
        st.__webglMultisampledFramebuffer = i.createFramebuffer(), st.__webglColorRenderbuffer = [], e.bindFramebuffer(36160, st.__webglMultisampledFramebuffer);
        for (let G = 0; G < Z.length; G++) {
          const F = Z[G];
          st.__webglColorRenderbuffer[G] = i.createRenderbuffer(), i.bindRenderbuffer(36161, st.__webglColorRenderbuffer[G]);
          const z = s.convert(F.format, F.encoding), Y = s.convert(F.type), pt = C(F.internalFormat, z, Y, F.encoding, H.isXRRenderTarget === !0), ht = dt(H);
          i.renderbufferStorageMultisample(36161, ht, pt, H.width, H.height), i.framebufferRenderbuffer(36160, 36064 + G, 36161, st.__webglColorRenderbuffer[G]);
        }
        i.bindRenderbuffer(36161, null), H.depthBuffer && (st.__webglDepthRenderbuffer = i.createRenderbuffer(), ct(st.__webglDepthRenderbuffer, H, !0)), e.bindFramebuffer(36160, null);
      }
    }
    if (J) {
      e.bindTexture(34067, et.__webglTexture), nt(34067, N, S);
      for (let Z = 0; Z < 6; Z++)
        W(st.__webglFramebuffer[Z], H, N, 36064, 34069 + Z);
      M(N, S) && A(34067), e.unbindTexture();
    } else if (K) {
      const Z = H.texture;
      for (let G = 0, F = Z.length; G < F; G++) {
        const z = Z[G], Y = n.get(z);
        e.bindTexture(3553, Y.__webglTexture), nt(3553, z, S), W(st.__webglFramebuffer, H, z, 36064 + G, 3553), M(z, S) && A(3553);
      }
      e.unbindTexture();
    } else {
      let Z = 3553;
      (H.isWebGL3DRenderTarget || H.isWebGLArrayRenderTarget) && (o ? Z = H.isWebGL3DRenderTarget ? 32879 : 35866 : console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")), e.bindTexture(Z, et.__webglTexture), nt(Z, N, S), W(st.__webglFramebuffer, H, N, 36064, Z), M(N, S) && A(Z), e.unbindTexture();
    }
    H.depthBuffer && mt(H);
  }, this.updateRenderTargetMipmap = function(H) {
    const N = T(H) || o, st = H.isWebGLMultipleRenderTargets === !0 ? H.texture : [H.texture];
    for (let et = 0, J = st.length; et < J; et++) {
      const K = st[et];
      if (M(K, N)) {
        const S = H.isWebGLCubeRenderTarget ? 34067 : 3553, Z = n.get(K).__webglTexture;
        e.bindTexture(S, Z), A(S), e.unbindTexture();
      }
    }
  }, this.updateMultisampleRenderTarget = function(H) {
    if (o && H.samples > 0 && Mt(H) === !1) {
      const N = H.isWebGLMultipleRenderTargets ? H.texture : [H.texture], st = H.width, et = H.height;
      let J = 16384;
      const K = [], S = H.stencilBuffer ? 33306 : 36096, Z = n.get(H), G = H.isWebGLMultipleRenderTargets === !0;
      if (G)
        for (let F = 0; F < N.length; F++)
          e.bindFramebuffer(36160, Z.__webglMultisampledFramebuffer), i.framebufferRenderbuffer(36160, 36064 + F, 36161, null), e.bindFramebuffer(36160, Z.__webglFramebuffer), i.framebufferTexture2D(36009, 36064 + F, 3553, null, 0);
      e.bindFramebuffer(36008, Z.__webglMultisampledFramebuffer), e.bindFramebuffer(36009, Z.__webglFramebuffer);
      for (let F = 0; F < N.length; F++) {
        K.push(36064 + F), H.depthBuffer && K.push(S);
        const z = Z.__ignoreDepthValues !== void 0 && Z.__ignoreDepthValues;
        if (z === !1 && (H.depthBuffer && (J |= 256), H.stencilBuffer && (J |= 1024)), G && i.framebufferRenderbuffer(36008, 36064, 36161, Z.__webglColorRenderbuffer[F]), z === !0 && (i.invalidateFramebuffer(36008, [S]), i.invalidateFramebuffer(36009, [S])), G) {
          const Y = n.get(N[F]).__webglTexture;
          i.framebufferTexture2D(36009, 36064, 3553, Y, 0);
        }
        i.blitFramebuffer(0, 0, st, et, 0, 0, st, et, J, 9728), f && i.invalidateFramebuffer(36008, K);
      }
      if (e.bindFramebuffer(36008, null), e.bindFramebuffer(36009, null), G)
        for (let F = 0; F < N.length; F++) {
          e.bindFramebuffer(36160, Z.__webglMultisampledFramebuffer), i.framebufferRenderbuffer(36160, 36064 + F, 36161, Z.__webglColorRenderbuffer[F]);
          const z = n.get(N[F]).__webglTexture;
          e.bindFramebuffer(36160, Z.__webglFramebuffer), i.framebufferTexture2D(36009, 36064 + F, 3553, z, 0);
        }
      e.bindFramebuffer(36009, Z.__webglMultisampledFramebuffer);
    }
  }, this.setupDepthRenderbuffer = mt, this.setupFrameBufferTexture = W, this.useMultisampledRTT = Mt;
}
function PI(i, t, e) {
  const n = e.isWebGL2;
  return { convert: function(r, s = null) {
    let a;
    if (r === 1009)
      return 5121;
    if (r === 1017)
      return 32819;
    if (r === 1018)
      return 32820;
    if (r === 1010)
      return 5120;
    if (r === 1011)
      return 5122;
    if (r === 1012)
      return 5123;
    if (r === 1013)
      return 5124;
    if (r === 1014)
      return 5125;
    if (r === 1015)
      return 5126;
    if (r === 1016)
      return n ? 5131 : (a = t.get("OES_texture_half_float"), a !== null ? a.HALF_FLOAT_OES : null);
    if (r === 1021)
      return 6406;
    if (r === 1023)
      return 6408;
    if (r === 1024)
      return 6409;
    if (r === 1025)
      return 6410;
    if (r === 1026)
      return 6402;
    if (r === 1027)
      return 34041;
    if (r === 1035)
      return a = t.get("EXT_sRGB"), a !== null ? a.SRGB_ALPHA_EXT : null;
    if (r === 1028)
      return 6403;
    if (r === 1029)
      return 36244;
    if (r === 1030)
      return 33319;
    if (r === 1031)
      return 33320;
    if (r === 1033)
      return 36249;
    if (r === 33776 || r === 33777 || r === 33778 || r === 33779)
      if (s === 3001) {
        if (a = t.get("WEBGL_compressed_texture_s3tc_srgb"), a === null)
          return null;
        if (r === 33776)
          return a.COMPRESSED_SRGB_S3TC_DXT1_EXT;
        if (r === 33777)
          return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
        if (r === 33778)
          return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
        if (r === 33779)
          return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
      } else {
        if (a = t.get("WEBGL_compressed_texture_s3tc"), a === null)
          return null;
        if (r === 33776)
          return a.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (r === 33777)
          return a.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (r === 33778)
          return a.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (r === 33779)
          return a.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      }
    if (r === 35840 || r === 35841 || r === 35842 || r === 35843) {
      if (a = t.get("WEBGL_compressed_texture_pvrtc"), a === null)
        return null;
      if (r === 35840)
        return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
      if (r === 35841)
        return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
      if (r === 35842)
        return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
      if (r === 35843)
        return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
    }
    if (r === 36196)
      return a = t.get("WEBGL_compressed_texture_etc1"), a !== null ? a.COMPRESSED_RGB_ETC1_WEBGL : null;
    if (r === 37492 || r === 37496) {
      if (a = t.get("WEBGL_compressed_texture_etc"), a === null)
        return null;
      if (r === 37492)
        return s === 3001 ? a.COMPRESSED_SRGB8_ETC2 : a.COMPRESSED_RGB8_ETC2;
      if (r === 37496)
        return s === 3001 ? a.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : a.COMPRESSED_RGBA8_ETC2_EAC;
    }
    if (r === 37808 || r === 37809 || r === 37810 || r === 37811 || r === 37812 || r === 37813 || r === 37814 || r === 37815 || r === 37816 || r === 37817 || r === 37818 || r === 37819 || r === 37820 || r === 37821) {
      if (a = t.get("WEBGL_compressed_texture_astc"), a === null)
        return null;
      if (r === 37808)
        return s === 3001 ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : a.COMPRESSED_RGBA_ASTC_4x4_KHR;
      if (r === 37809)
        return s === 3001 ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : a.COMPRESSED_RGBA_ASTC_5x4_KHR;
      if (r === 37810)
        return s === 3001 ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : a.COMPRESSED_RGBA_ASTC_5x5_KHR;
      if (r === 37811)
        return s === 3001 ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : a.COMPRESSED_RGBA_ASTC_6x5_KHR;
      if (r === 37812)
        return s === 3001 ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : a.COMPRESSED_RGBA_ASTC_6x6_KHR;
      if (r === 37813)
        return s === 3001 ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : a.COMPRESSED_RGBA_ASTC_8x5_KHR;
      if (r === 37814)
        return s === 3001 ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : a.COMPRESSED_RGBA_ASTC_8x6_KHR;
      if (r === 37815)
        return s === 3001 ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : a.COMPRESSED_RGBA_ASTC_8x8_KHR;
      if (r === 37816)
        return s === 3001 ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : a.COMPRESSED_RGBA_ASTC_10x5_KHR;
      if (r === 37817)
        return s === 3001 ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : a.COMPRESSED_RGBA_ASTC_10x6_KHR;
      if (r === 37818)
        return s === 3001 ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : a.COMPRESSED_RGBA_ASTC_10x8_KHR;
      if (r === 37819)
        return s === 3001 ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : a.COMPRESSED_RGBA_ASTC_10x10_KHR;
      if (r === 37820)
        return s === 3001 ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : a.COMPRESSED_RGBA_ASTC_12x10_KHR;
      if (r === 37821)
        return s === 3001 ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : a.COMPRESSED_RGBA_ASTC_12x12_KHR;
    }
    if (r === 36492) {
      if (a = t.get("EXT_texture_compression_bptc"), a === null)
        return null;
      if (r === 36492)
        return s === 3001 ? a.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : a.COMPRESSED_RGBA_BPTC_UNORM_EXT;
    }
    if (r === 36283 || r === 36284 || r === 36285 || r === 36286) {
      if (a = t.get("EXT_texture_compression_rgtc"), a === null)
        return null;
      if (r === 36492)
        return a.COMPRESSED_RED_RGTC1_EXT;
      if (r === 36284)
        return a.COMPRESSED_SIGNED_RED_RGTC1_EXT;
      if (r === 36285)
        return a.COMPRESSED_RED_GREEN_RGTC2_EXT;
      if (r === 36286)
        return a.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
    }
    return r === 1020 ? n ? 34042 : (a = t.get("WEBGL_depth_texture"), a !== null ? a.UNSIGNED_INT_24_8_WEBGL : null) : i[r] !== void 0 ? i[r] : null;
  } };
}
class DI extends Cr {
  constructor(t = []) {
    super(), this.isArrayCamera = !0, this.cameras = t;
  }
}
class bi extends Ue {
  constructor() {
    super(), this.isGroup = !0, this.type = "Group";
  }
}
const nU = { type: "move" };
class f_ {
  constructor() {
    this._targetRay = null, this._grip = null, this._hand = null;
  }
  getHandSpace() {
    return this._hand === null && (this._hand = new bi(), this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = { pinching: !1 }), this._hand;
  }
  getTargetRaySpace() {
    return this._targetRay === null && (this._targetRay = new bi(), this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new D(), this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new D()), this._targetRay;
  }
  getGripSpace() {
    return this._grip === null && (this._grip = new bi(), this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new D(), this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new D()), this._grip;
  }
  dispatchEvent(t) {
    return this._targetRay !== null && this._targetRay.dispatchEvent(t), this._grip !== null && this._grip.dispatchEvent(t), this._hand !== null && this._hand.dispatchEvent(t), this;
  }
  connect(t) {
    if (t && t.hand) {
      const e = this._hand;
      if (e)
        for (const n of t.hand.values())
          this._getHandJoint(e, n);
    }
    return this.dispatchEvent({ type: "connected", data: t }), this;
  }
  disconnect(t) {
    return this.dispatchEvent({ type: "disconnected", data: t }), this._targetRay !== null && (this._targetRay.visible = !1), this._grip !== null && (this._grip.visible = !1), this._hand !== null && (this._hand.visible = !1), this;
  }
  update(t, e, n) {
    let r = null, s = null, a = null;
    const o = this._targetRay, l = this._grip, c = this._hand;
    if (t && e.session.visibilityState !== "visible-blurred") {
      if (c && t.hand) {
        a = !0;
        for (const m of t.hand.values()) {
          const y = e.getJointPose(m, n), _ = this._getHandJoint(c, m);
          y !== null && (_.matrix.fromArray(y.transform.matrix), _.matrix.decompose(_.position, _.rotation, _.scale), _.jointRadius = y.radius), _.visible = y !== null;
        }
        const u = c.joints["index-finger-tip"], h = c.joints["thumb-tip"], p = u.position.distanceTo(h.position), f = 0.02, v = 5e-3;
        c.inputState.pinching && p > f + v ? (c.inputState.pinching = !1, this.dispatchEvent({ type: "pinchend", handedness: t.handedness, target: this })) : !c.inputState.pinching && p <= f - v && (c.inputState.pinching = !0, this.dispatchEvent({ type: "pinchstart", handedness: t.handedness, target: this }));
      } else
        l !== null && t.gripSpace && (s = e.getPose(t.gripSpace, n), s !== null && (l.matrix.fromArray(s.transform.matrix), l.matrix.decompose(l.position, l.rotation, l.scale), s.linearVelocity ? (l.hasLinearVelocity = !0, l.linearVelocity.copy(s.linearVelocity)) : l.hasLinearVelocity = !1, s.angularVelocity ? (l.hasAngularVelocity = !0, l.angularVelocity.copy(s.angularVelocity)) : l.hasAngularVelocity = !1));
      o !== null && (r = e.getPose(t.targetRaySpace, n), r === null && s !== null && (r = s), r !== null && (o.matrix.fromArray(r.transform.matrix), o.matrix.decompose(o.position, o.rotation, o.scale), r.linearVelocity ? (o.hasLinearVelocity = !0, o.linearVelocity.copy(r.linearVelocity)) : o.hasLinearVelocity = !1, r.angularVelocity ? (o.hasAngularVelocity = !0, o.angularVelocity.copy(r.angularVelocity)) : o.hasAngularVelocity = !1, this.dispatchEvent(nU)));
    }
    return o !== null && (o.visible = r !== null), l !== null && (l.visible = s !== null), c !== null && (c.visible = a !== null), this;
  }
  _getHandJoint(t, e) {
    if (t.joints[e.jointName] === void 0) {
      const n = new bi();
      n.matrixAutoUpdate = !1, n.visible = !1, t.joints[e.jointName] = n, t.add(n);
    }
    return t.joints[e.jointName];
  }
}
class RI extends Yn {
  constructor(t, e, n, r, s, a, o, l, c, u) {
    if ((u = u !== void 0 ? u : 1026) !== 1026 && u !== 1027)
      throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
    n === void 0 && u === 1026 && (n = 1014), n === void 0 && u === 1027 && (n = 1020), super(null, r, s, a, o, l, u, n, c), this.isDepthTexture = !0, this.image = { width: t, height: e }, this.magFilter = o !== void 0 ? o : 1003, this.minFilter = l !== void 0 ? l : 1003, this.flipY = !1, this.generateMipmaps = !1;
  }
}
class rU extends Ga {
  constructor(t, e) {
    super();
    const n = this;
    let r = null, s = 1, a = null, o = "local-floor", l = 1, c = null, u = null, h = null, p = null, f = null, v = null;
    const m = e.getContextAttributes();
    let y = null, _ = null;
    const w = [], b = [], T = /* @__PURE__ */ new Set(), M = /* @__PURE__ */ new Map(), A = new Cr();
    A.layers.enable(1), A.viewport = new ze();
    const C = new Cr();
    C.layers.enable(2), C.viewport = new ze();
    const I = [A, C], k = new DI();
    k.layers.enable(1), k.layers.enable(2);
    let R = null, L = null;
    function E(W) {
      const ct = b.indexOf(W.inputSource);
      if (ct === -1)
        return;
      const mt = w[ct];
      mt !== void 0 && mt.dispatchEvent({ type: W.type, data: W.inputSource });
    }
    function q() {
      r.removeEventListener("select", E), r.removeEventListener("selectstart", E), r.removeEventListener("selectend", E), r.removeEventListener("squeeze", E), r.removeEventListener("squeezestart", E), r.removeEventListener("squeezeend", E), r.removeEventListener("end", q), r.removeEventListener("inputsourceschange", it);
      for (let W = 0; W < w.length; W++) {
        const ct = b[W];
        ct !== null && (b[W] = null, w[W].disconnect(ct));
      }
      R = null, L = null, t.setRenderTarget(y), f = null, p = null, h = null, r = null, _ = null, $.stop(), n.isPresenting = !1, n.dispatchEvent({ type: "sessionend" });
    }
    function it(W) {
      for (let ct = 0; ct < W.removed.length; ct++) {
        const mt = W.removed[ct], dt = b.indexOf(mt);
        dt >= 0 && (b[dt] = null, w[dt].disconnect(mt));
      }
      for (let ct = 0; ct < W.added.length; ct++) {
        const mt = W.added[ct];
        let dt = b.indexOf(mt);
        if (dt === -1) {
          for (let At = 0; At < w.length; At++) {
            if (At >= b.length) {
              b.push(mt), dt = At;
              break;
            }
            if (b[At] === null) {
              b[At] = mt, dt = At;
              break;
            }
          }
          if (dt === -1)
            break;
        }
        const Mt = w[dt];
        Mt && Mt.connect(mt);
      }
    }
    this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function(W) {
      let ct = w[W];
      return ct === void 0 && (ct = new f_(), w[W] = ct), ct.getTargetRaySpace();
    }, this.getControllerGrip = function(W) {
      let ct = w[W];
      return ct === void 0 && (ct = new f_(), w[W] = ct), ct.getGripSpace();
    }, this.getHand = function(W) {
      let ct = w[W];
      return ct === void 0 && (ct = new f_(), w[W] = ct), ct.getHandSpace();
    }, this.setFramebufferScaleFactor = function(W) {
      s = W, n.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
    }, this.setReferenceSpaceType = function(W) {
      o = W, n.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
    }, this.getReferenceSpace = function() {
      return c || a;
    }, this.setReferenceSpace = function(W) {
      c = W;
    }, this.getBaseLayer = function() {
      return p !== null ? p : f;
    }, this.getBinding = function() {
      return h;
    }, this.getFrame = function() {
      return v;
    }, this.getSession = function() {
      return r;
    }, this.setSession = async function(W) {
      if (r = W, r !== null) {
        if (y = t.getRenderTarget(), r.addEventListener("select", E), r.addEventListener("selectstart", E), r.addEventListener("selectend", E), r.addEventListener("squeeze", E), r.addEventListener("squeezestart", E), r.addEventListener("squeezeend", E), r.addEventListener("end", q), r.addEventListener("inputsourceschange", it), m.xrCompatible !== !0 && await e.makeXRCompatible(), r.renderState.layers === void 0 || t.capabilities.isWebGL2 === !1) {
          const ct = { antialias: r.renderState.layers !== void 0 || m.antialias, alpha: m.alpha, depth: m.depth, stencil: m.stencil, framebufferScaleFactor: s };
          f = new XRWebGLLayer(r, e, ct), r.updateRenderState({ baseLayer: f }), _ = new ir(f.framebufferWidth, f.framebufferHeight, { format: 1023, type: 1009, encoding: t.outputEncoding, stencilBuffer: m.stencil });
        } else {
          let ct = null, mt = null, dt = null;
          m.depth && (dt = m.stencil ? 35056 : 33190, ct = m.stencil ? 1027 : 1026, mt = m.stencil ? 1020 : 1014);
          const Mt = { colorFormat: 32856, depthFormat: dt, scaleFactor: s };
          h = new XRWebGLBinding(r, e), p = h.createProjectionLayer(Mt), r.updateRenderState({ layers: [p] }), _ = new ir(p.textureWidth, p.textureHeight, { format: 1023, type: 1009, depthTexture: new RI(p.textureWidth, p.textureHeight, mt, void 0, void 0, void 0, void 0, void 0, void 0, ct), stencilBuffer: m.stencil, encoding: t.outputEncoding, samples: m.antialias ? 4 : 0 }), t.properties.get(_).__ignoreDepthValues = p.ignoreDepthValues;
        }
        _.isXRRenderTarget = !0, this.setFoveation(l), c = null, a = await r.requestReferenceSpace(o), $.setContext(r), $.start(), n.isPresenting = !0, n.dispatchEvent({ type: "sessionstart" });
      }
    };
    const rt = new D(), ft = new D();
    function nt(W, ct) {
      ct === null ? W.matrixWorld.copy(W.matrix) : W.matrixWorld.multiplyMatrices(ct.matrixWorld, W.matrix), W.matrixWorldInverse.copy(W.matrixWorld).invert();
    }
    this.updateCamera = function(W) {
      if (r === null)
        return;
      k.near = C.near = A.near = W.near, k.far = C.far = A.far = W.far, R === k.near && L === k.far || (r.updateRenderState({ depthNear: k.near, depthFar: k.far }), R = k.near, L = k.far);
      const ct = W.parent, mt = k.cameras;
      nt(k, ct);
      for (let Mt = 0; Mt < mt.length; Mt++)
        nt(mt[Mt], ct);
      k.matrixWorld.decompose(k.position, k.quaternion, k.scale), W.matrix.copy(k.matrix), W.matrix.decompose(W.position, W.quaternion, W.scale);
      const dt = W.children;
      for (let Mt = 0, At = dt.length; Mt < At; Mt++)
        dt[Mt].updateMatrixWorld(!0);
      mt.length === 2 ? function(Mt, At, H) {
        rt.setFromMatrixPosition(At.matrixWorld), ft.setFromMatrixPosition(H.matrixWorld);
        const N = rt.distanceTo(ft), st = At.projectionMatrix.elements, et = H.projectionMatrix.elements, J = st[14] / (st[10] - 1), K = st[14] / (st[10] + 1), S = (st[9] + 1) / st[5], Z = (st[9] - 1) / st[5], G = (st[8] - 1) / st[0], F = (et[8] + 1) / et[0], z = J * G, Y = J * F, pt = N / (-G + F), ht = pt * -G;
        At.matrixWorld.decompose(Mt.position, Mt.quaternion, Mt.scale), Mt.translateX(ht), Mt.translateZ(pt), Mt.matrixWorld.compose(Mt.position, Mt.quaternion, Mt.scale), Mt.matrixWorldInverse.copy(Mt.matrixWorld).invert();
        const lt = J + pt, yt = K + pt, O = z - ht, V = Y + (N - ht), tt = S * K / yt * lt, gt = Z * K / yt * lt;
        Mt.projectionMatrix.makePerspective(O, V, tt, gt, lt, yt);
      }(k, A, C) : k.projectionMatrix.copy(A.projectionMatrix);
    }, this.getCamera = function() {
      return k;
    }, this.getFoveation = function() {
      if (p !== null || f !== null)
        return l;
    }, this.setFoveation = function(W) {
      l = W, p !== null && (p.fixedFoveation = W), f !== null && f.fixedFoveation !== void 0 && (f.fixedFoveation = W);
    }, this.getPlanes = function() {
      return T;
    };
    let vt = null;
    const $ = new MI();
    $.setAnimationLoop(function(W, ct) {
      if (u = ct.getViewerPose(c || a), v = ct, u !== null) {
        const mt = u.views;
        f !== null && (t.setRenderTargetFramebuffer(_, f.framebuffer), t.setRenderTarget(_));
        let dt = !1;
        mt.length !== k.cameras.length && (k.cameras.length = 0, dt = !0);
        for (let Mt = 0; Mt < mt.length; Mt++) {
          const At = mt[Mt];
          let H = null;
          if (f !== null)
            H = f.getViewport(At);
          else {
            const st = h.getViewSubImage(p, At);
            H = st.viewport, Mt === 0 && (t.setRenderTargetTextures(_, st.colorTexture, p.ignoreDepthValues ? void 0 : st.depthStencilTexture), t.setRenderTarget(_));
          }
          let N = I[Mt];
          N === void 0 && (N = new Cr(), N.layers.enable(Mt), N.viewport = new ze(), I[Mt] = N), N.matrix.fromArray(At.transform.matrix), N.projectionMatrix.fromArray(At.projectionMatrix), N.viewport.set(H.x, H.y, H.width, H.height), Mt === 0 && k.matrix.copy(N.matrix), dt === !0 && k.cameras.push(N);
        }
      }
      for (let mt = 0; mt < w.length; mt++) {
        const dt = b[mt], Mt = w[mt];
        dt !== null && Mt !== void 0 && Mt.update(dt, ct, c || a);
      }
      if (vt && vt(W, ct), ct.detectedPlanes) {
        n.dispatchEvent({ type: "planesdetected", data: ct.detectedPlanes });
        let mt = null;
        for (const dt of T)
          ct.detectedPlanes.has(dt) || (mt === null && (mt = []), mt.push(dt));
        if (mt !== null)
          for (const dt of mt)
            T.delete(dt), M.delete(dt), n.dispatchEvent({ type: "planeremoved", data: dt });
        for (const dt of ct.detectedPlanes)
          if (T.has(dt)) {
            const Mt = M.get(dt);
            dt.lastChangedTime > Mt && (M.set(dt, dt.lastChangedTime), n.dispatchEvent({ type: "planechanged", data: dt }));
          } else
            T.add(dt), M.set(dt, ct.lastChangedTime), n.dispatchEvent({ type: "planeadded", data: dt });
      }
      v = null;
    }), this.setAnimationLoop = function(W) {
      vt = W;
    }, this.dispose = function() {
    };
  }
}
function iU(i, t) {
  function e(n, r) {
    n.opacity.value = r.opacity, r.color && n.diffuse.value.copy(r.color), r.emissive && n.emissive.value.copy(r.emissive).multiplyScalar(r.emissiveIntensity), r.map && (n.map.value = r.map), r.alphaMap && (n.alphaMap.value = r.alphaMap), r.bumpMap && (n.bumpMap.value = r.bumpMap, n.bumpScale.value = r.bumpScale, r.side === 1 && (n.bumpScale.value *= -1)), r.displacementMap && (n.displacementMap.value = r.displacementMap, n.displacementScale.value = r.displacementScale, n.displacementBias.value = r.displacementBias), r.emissiveMap && (n.emissiveMap.value = r.emissiveMap), r.normalMap && (n.normalMap.value = r.normalMap, n.normalScale.value.copy(r.normalScale), r.side === 1 && n.normalScale.value.negate()), r.specularMap && (n.specularMap.value = r.specularMap), r.alphaTest > 0 && (n.alphaTest.value = r.alphaTest);
    const s = t.get(r).envMap;
    if (s && (n.envMap.value = s, n.flipEnvMap.value = s.isCubeTexture && s.isRenderTargetTexture === !1 ? -1 : 1, n.reflectivity.value = r.reflectivity, n.ior.value = r.ior, n.refractionRatio.value = r.refractionRatio), r.lightMap) {
      n.lightMap.value = r.lightMap;
      const l = i.physicallyCorrectLights !== !0 ? Math.PI : 1;
      n.lightMapIntensity.value = r.lightMapIntensity * l;
    }
    let a, o;
    r.aoMap && (n.aoMap.value = r.aoMap, n.aoMapIntensity.value = r.aoMapIntensity), r.map ? a = r.map : r.specularMap ? a = r.specularMap : r.displacementMap ? a = r.displacementMap : r.normalMap ? a = r.normalMap : r.bumpMap ? a = r.bumpMap : r.roughnessMap ? a = r.roughnessMap : r.metalnessMap ? a = r.metalnessMap : r.alphaMap ? a = r.alphaMap : r.emissiveMap ? a = r.emissiveMap : r.clearcoatMap ? a = r.clearcoatMap : r.clearcoatNormalMap ? a = r.clearcoatNormalMap : r.clearcoatRoughnessMap ? a = r.clearcoatRoughnessMap : r.iridescenceMap ? a = r.iridescenceMap : r.iridescenceThicknessMap ? a = r.iridescenceThicknessMap : r.specularIntensityMap ? a = r.specularIntensityMap : r.specularColorMap ? a = r.specularColorMap : r.transmissionMap ? a = r.transmissionMap : r.thicknessMap ? a = r.thicknessMap : r.sheenColorMap ? a = r.sheenColorMap : r.sheenRoughnessMap && (a = r.sheenRoughnessMap), a !== void 0 && (a.isWebGLRenderTarget && (a = a.texture), a.matrixAutoUpdate === !0 && a.updateMatrix(), n.uvTransform.value.copy(a.matrix)), r.aoMap ? o = r.aoMap : r.lightMap && (o = r.lightMap), o !== void 0 && (o.isWebGLRenderTarget && (o = o.texture), o.matrixAutoUpdate === !0 && o.updateMatrix(), n.uv2Transform.value.copy(o.matrix));
  }
  return { refreshFogUniforms: function(n, r) {
    r.color.getRGB(n.fogColor.value, xI(i)), r.isFog ? (n.fogNear.value = r.near, n.fogFar.value = r.far) : r.isFogExp2 && (n.fogDensity.value = r.density);
  }, refreshMaterialUniforms: function(n, r, s, a, o) {
    r.isMeshBasicMaterial || r.isMeshLambertMaterial ? e(n, r) : r.isMeshToonMaterial ? (e(n, r), function(l, c) {
      c.gradientMap && (l.gradientMap.value = c.gradientMap);
    }(n, r)) : r.isMeshPhongMaterial ? (e(n, r), function(l, c) {
      l.specular.value.copy(c.specular), l.shininess.value = Math.max(c.shininess, 1e-4);
    }(n, r)) : r.isMeshStandardMaterial ? (e(n, r), function(l, c) {
      l.roughness.value = c.roughness, l.metalness.value = c.metalness, c.roughnessMap && (l.roughnessMap.value = c.roughnessMap), c.metalnessMap && (l.metalnessMap.value = c.metalnessMap), t.get(c).envMap && (l.envMapIntensity.value = c.envMapIntensity);
    }(n, r), r.isMeshPhysicalMaterial && function(l, c, u) {
      l.ior.value = c.ior, c.sheen > 0 && (l.sheenColor.value.copy(c.sheenColor).multiplyScalar(c.sheen), l.sheenRoughness.value = c.sheenRoughness, c.sheenColorMap && (l.sheenColorMap.value = c.sheenColorMap), c.sheenRoughnessMap && (l.sheenRoughnessMap.value = c.sheenRoughnessMap)), c.clearcoat > 0 && (l.clearcoat.value = c.clearcoat, l.clearcoatRoughness.value = c.clearcoatRoughness, c.clearcoatMap && (l.clearcoatMap.value = c.clearcoatMap), c.clearcoatRoughnessMap && (l.clearcoatRoughnessMap.value = c.clearcoatRoughnessMap), c.clearcoatNormalMap && (l.clearcoatNormalScale.value.copy(c.clearcoatNormalScale), l.clearcoatNormalMap.value = c.clearcoatNormalMap, c.side === 1 && l.clearcoatNormalScale.value.negate())), c.iridescence > 0 && (l.iridescence.value = c.iridescence, l.iridescenceIOR.value = c.iridescenceIOR, l.iridescenceThicknessMinimum.value = c.iridescenceThicknessRange[0], l.iridescenceThicknessMaximum.value = c.iridescenceThicknessRange[1], c.iridescenceMap && (l.iridescenceMap.value = c.iridescenceMap), c.iridescenceThicknessMap && (l.iridescenceThicknessMap.value = c.iridescenceThicknessMap)), c.transmission > 0 && (l.transmission.value = c.transmission, l.transmissionSamplerMap.value = u.texture, l.transmissionSamplerSize.value.set(u.width, u.height), c.transmissionMap && (l.transmissionMap.value = c.transmissionMap), l.thickness.value = c.thickness, c.thicknessMap && (l.thicknessMap.value = c.thicknessMap), l.attenuationDistance.value = c.attenuationDistance, l.attenuationColor.value.copy(c.attenuationColor)), l.specularIntensity.value = c.specularIntensity, l.specularColor.value.copy(c.specularColor), c.specularIntensityMap && (l.specularIntensityMap.value = c.specularIntensityMap), c.specularColorMap && (l.specularColorMap.value = c.specularColorMap);
    }(n, r, o)) : r.isMeshMatcapMaterial ? (e(n, r), function(l, c) {
      c.matcap && (l.matcap.value = c.matcap);
    }(n, r)) : r.isMeshDepthMaterial ? e(n, r) : r.isMeshDistanceMaterial ? (e(n, r), function(l, c) {
      l.referencePosition.value.copy(c.referencePosition), l.nearDistance.value = c.nearDistance, l.farDistance.value = c.farDistance;
    }(n, r)) : r.isMeshNormalMaterial ? e(n, r) : r.isLineBasicMaterial ? (function(l, c) {
      l.diffuse.value.copy(c.color), l.opacity.value = c.opacity;
    }(n, r), r.isLineDashedMaterial && function(l, c) {
      l.dashSize.value = c.dashSize, l.totalSize.value = c.dashSize + c.gapSize, l.scale.value = c.scale;
    }(n, r)) : r.isPointsMaterial ? function(l, c, u, h) {
      l.diffuse.value.copy(c.color), l.opacity.value = c.opacity, l.size.value = c.size * u, l.scale.value = 0.5 * h, c.map && (l.map.value = c.map), c.alphaMap && (l.alphaMap.value = c.alphaMap), c.alphaTest > 0 && (l.alphaTest.value = c.alphaTest);
      let p;
      c.map ? p = c.map : c.alphaMap && (p = c.alphaMap), p !== void 0 && (p.matrixAutoUpdate === !0 && p.updateMatrix(), l.uvTransform.value.copy(p.matrix));
    }(n, r, s, a) : r.isSpriteMaterial ? function(l, c) {
      l.diffuse.value.copy(c.color), l.opacity.value = c.opacity, l.rotation.value = c.rotation, c.map && (l.map.value = c.map), c.alphaMap && (l.alphaMap.value = c.alphaMap), c.alphaTest > 0 && (l.alphaTest.value = c.alphaTest);
      let u;
      c.map ? u = c.map : c.alphaMap && (u = c.alphaMap), u !== void 0 && (u.matrixAutoUpdate === !0 && u.updateMatrix(), l.uvTransform.value.copy(u.matrix));
    }(n, r) : r.isShadowMaterial ? (n.color.value.copy(r.color), n.opacity.value = r.opacity) : r.isShaderMaterial && (r.uniformsNeedUpdate = !1);
  } };
}
function sU(i, t, e, n) {
  let r = {}, s = {}, a = [];
  const o = e.isWebGL2 ? i.getParameter(35375) : 0;
  function l(h, p, f) {
    const v = h.value;
    if (f[p] === void 0) {
      if (typeof v == "number")
        f[p] = v;
      else {
        const m = Array.isArray(v) ? v : [v], y = [];
        for (let _ = 0; _ < m.length; _++)
          y.push(m[_].clone());
        f[p] = y;
      }
      return !0;
    }
    if (typeof v == "number") {
      if (f[p] !== v)
        return f[p] = v, !0;
    } else {
      const m = Array.isArray(f[p]) ? f[p] : [f[p]], y = Array.isArray(v) ? v : [v];
      for (let _ = 0; _ < m.length; _++) {
        const w = m[_];
        if (w.equals(y[_]) === !1)
          return w.copy(y[_]), !0;
      }
    }
    return !1;
  }
  function c(h) {
    const p = { boundary: 0, storage: 0 };
    return typeof h == "number" ? (p.boundary = 4, p.storage = 4) : h.isVector2 ? (p.boundary = 8, p.storage = 8) : h.isVector3 || h.isColor ? (p.boundary = 16, p.storage = 12) : h.isVector4 ? (p.boundary = 16, p.storage = 16) : h.isMatrix3 ? (p.boundary = 48, p.storage = 48) : h.isMatrix4 ? (p.boundary = 64, p.storage = 64) : h.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", h), p;
  }
  function u(h) {
    const p = h.target;
    p.removeEventListener("dispose", u);
    const f = a.indexOf(p.__bindingPointIndex);
    a.splice(f, 1), i.deleteBuffer(r[p.id]), delete r[p.id], delete s[p.id];
  }
  return { bind: function(h, p) {
    const f = p.program;
    n.uniformBlockBinding(h, f);
  }, update: function(h, p) {
    let f = r[h.id];
    f === void 0 && (function(y) {
      const _ = y.uniforms;
      let w = 0;
      const b = 16;
      let T = 0;
      for (let M = 0, A = _.length; M < A; M++) {
        const C = _[M], I = { boundary: 0, storage: 0 }, k = Array.isArray(C.value) ? C.value : [C.value];
        for (let R = 0, L = k.length; R < L; R++) {
          const E = c(k[R]);
          I.boundary += E.boundary, I.storage += E.storage;
        }
        C.__data = new Float32Array(I.storage / Float32Array.BYTES_PER_ELEMENT), C.__offset = w, M > 0 && (T = w % b, T !== 0 && b - T - I.boundary < 0 && (w += b - T, C.__offset = w)), w += I.storage;
      }
      T = w % b, T > 0 && (w += b - T), y.__size = w, y.__cache = {};
    }(h), f = function(y) {
      const _ = function() {
        for (let M = 0; M < o; M++)
          if (a.indexOf(M) === -1)
            return a.push(M), M;
        return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0;
      }();
      y.__bindingPointIndex = _;
      const w = i.createBuffer(), b = y.__size, T = y.usage;
      return i.bindBuffer(35345, w), i.bufferData(35345, b, T), i.bindBuffer(35345, null), i.bindBufferBase(35345, _, w), w;
    }(h), r[h.id] = f, h.addEventListener("dispose", u));
    const v = p.program;
    n.updateUBOMapping(h, v);
    const m = t.render.frame;
    s[h.id] !== m && (function(y) {
      const _ = r[y.id], w = y.uniforms, b = y.__cache;
      i.bindBuffer(35345, _);
      for (let T = 0, M = w.length; T < M; T++) {
        const A = w[T];
        if (l(A, T, b) === !0) {
          const C = A.__offset, I = Array.isArray(A.value) ? A.value : [A.value];
          let k = 0;
          for (let R = 0; R < I.length; R++) {
            const L = I[R], E = c(L);
            typeof L == "number" ? (A.__data[0] = L, i.bufferSubData(35345, C + k, A.__data)) : L.isMatrix3 ? (A.__data[0] = L.elements[0], A.__data[1] = L.elements[1], A.__data[2] = L.elements[2], A.__data[3] = L.elements[0], A.__data[4] = L.elements[3], A.__data[5] = L.elements[4], A.__data[6] = L.elements[5], A.__data[7] = L.elements[0], A.__data[8] = L.elements[6], A.__data[9] = L.elements[7], A.__data[10] = L.elements[8], A.__data[11] = L.elements[0]) : (L.toArray(A.__data, k), k += E.storage / Float32Array.BYTES_PER_ELEMENT);
          }
          i.bufferSubData(35345, C, A.__data);
        }
      }
      i.bindBuffer(35345, null);
    }(h), s[h.id] = m);
  }, dispose: function() {
    for (const h in r)
      i.deleteBuffer(r[h]);
    a = [], r = {}, s = {};
  } };
}
function Ub(i = {}) {
  this.isWebGLRenderer = !0;
  const t = i.canvas !== void 0 ? i.canvas : function() {
    const Q = Xd("canvas");
    return Q.style.display = "block", Q;
  }(), e = i.context !== void 0 ? i.context : null, n = i.depth === void 0 || i.depth, r = i.stencil === void 0 || i.stencil, s = i.antialias !== void 0 && i.antialias, a = i.premultipliedAlpha === void 0 || i.premultipliedAlpha, o = i.preserveDrawingBuffer !== void 0 && i.preserveDrawingBuffer, l = i.powerPreference !== void 0 ? i.powerPreference : "default", c = i.failIfMajorPerformanceCaveat !== void 0 && i.failIfMajorPerformanceCaveat;
  let u;
  u = e !== null ? e.getContextAttributes().alpha : i.alpha !== void 0 && i.alpha;
  let h = null, p = null;
  const f = [], v = [];
  this.domElement = t, this.debug = { checkShaderErrors: !0 }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.outputEncoding = 3e3, this.physicallyCorrectLights = !1, this.toneMapping = 0, this.toneMappingExposure = 1;
  const m = this;
  let y = !1, _ = 0, w = 0, b = null, T = -1, M = null;
  const A = new ze(), C = new ze();
  let I = null, k = t.width, R = t.height, L = 1, E = null, q = null;
  const it = new ze(0, 0, k, R), rt = new ze(0, 0, k, R);
  let ft = !1;
  const nt = new t0();
  let vt = !1, $ = !1, W = null;
  const ct = new Vt(), mt = new wt(), dt = new D(), Mt = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: !0 };
  function At() {
    return b === null ? L : 1;
  }
  let H, N, st, et, J, K, S, Z, G, F, z, Y, pt, ht, lt, yt, O, V, tt, gt, Tt, ot, St, It, xt = e;
  function Ft(Q, Et) {
    for (let Pt = 0; Pt < Q.length; Pt++) {
      const Dt = Q[Pt], kt = t.getContext(Dt, Et);
      if (kt !== null)
        return kt;
    }
    return null;
  }
  try {
    const Q = { alpha: !0, depth: n, stencil: r, antialias: s, premultipliedAlpha: a, preserveDrawingBuffer: o, powerPreference: l, failIfMajorPerformanceCaveat: c };
    if ("setAttribute" in t && t.setAttribute("data-engine", `three.js r${wv}`), t.addEventListener("webglcontextlost", qt, !1), t.addEventListener("webglcontextrestored", $t, !1), t.addEventListener("webglcontextcreationerror", fe, !1), xt === null) {
      const Et = ["webgl2", "webgl", "experimental-webgl"];
      if (m.isWebGL1Renderer === !0 && Et.shift(), xt = Ft(Et, Q), xt === null)
        throw Ft(Et) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
    }
    xt.getShaderPrecisionFormat === void 0 && (xt.getShaderPrecisionFormat = function() {
      return { rangeMin: 1, rangeMax: 1, precision: 1 };
    });
  } catch (Q) {
    throw console.error("THREE.WebGLRenderer: " + Q.message), Q;
  }
  function Kt() {
    H = new BN(xt), N = new RN(xt, H, i), H.init(N), ot = new PI(xt, H, N), st = new tU(xt, H, N), et = new NN(), J = new jF(), K = new eU(xt, H, st, J, N, ot, et), S = new ON(m), Z = new LN(m), G = new AN(xt, N), St = new PN(xt, H, G, N), F = new zN(xt, G, et, St), z = new HN(xt, F, G, et), tt = new VN(xt, N, K), yt = new IN(J), Y = new HF(m, S, Z, H, N, St, yt), pt = new iU(m, J), ht = new WF(), lt = new JF(H, N), V = new CN(m, S, Z, st, z, u, a), O = new QF(m, z, N), It = new sU(xt, et, N, st), gt = new DN(xt, H, et, N), Tt = new kN(xt, H, et, N), et.programs = Y.programs, m.capabilities = N, m.extensions = H, m.properties = J, m.renderLists = ht, m.shadowMap = O, m.state = st, m.info = et;
  }
  Kt();
  const jt = new rU(m, xt);
  function qt(Q) {
    Q.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), y = !0;
  }
  function $t() {
    console.log("THREE.WebGLRenderer: Context Restored."), y = !1;
    const Q = et.autoReset, Et = O.enabled, Pt = O.autoUpdate, Dt = O.needsUpdate, kt = O.type;
    Kt(), et.autoReset = Q, O.enabled = Et, O.autoUpdate = Pt, O.needsUpdate = Dt, O.type = kt;
  }
  function fe(Q) {
    console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", Q.statusMessage);
  }
  function Yt(Q) {
    const Et = Q.target;
    Et.removeEventListener("dispose", Yt), function(Pt) {
      (function(Dt) {
        const kt = J.get(Dt).programs;
        kt !== void 0 && (kt.forEach(function(re) {
          Y.releaseProgram(re);
        }), Dt.isShaderMaterial && Y.releaseShaderCache(Dt));
      })(Pt), J.remove(Pt);
    }(Et);
  }
  this.xr = jt, this.getContext = function() {
    return xt;
  }, this.getContextAttributes = function() {
    return xt.getContextAttributes();
  }, this.forceContextLoss = function() {
    const Q = H.get("WEBGL_lose_context");
    Q && Q.loseContext();
  }, this.forceContextRestore = function() {
    const Q = H.get("WEBGL_lose_context");
    Q && Q.restoreContext();
  }, this.getPixelRatio = function() {
    return L;
  }, this.setPixelRatio = function(Q) {
    Q !== void 0 && (L = Q, this.setSize(k, R, !1));
  }, this.getSize = function(Q) {
    return Q.set(k, R);
  }, this.setSize = function(Q, Et, Pt) {
    jt.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (k = Q, R = Et, t.width = Math.floor(Q * L), t.height = Math.floor(Et * L), Pt !== !1 && (t.style.width = Q + "px", t.style.height = Et + "px"), this.setViewport(0, 0, Q, Et));
  }, this.getDrawingBufferSize = function(Q) {
    return Q.set(k * L, R * L).floor();
  }, this.setDrawingBufferSize = function(Q, Et, Pt) {
    k = Q, R = Et, L = Pt, t.width = Math.floor(Q * Pt), t.height = Math.floor(Et * Pt), this.setViewport(0, 0, Q, Et);
  }, this.getCurrentViewport = function(Q) {
    return Q.copy(A);
  }, this.getViewport = function(Q) {
    return Q.copy(it);
  }, this.setViewport = function(Q, Et, Pt, Dt) {
    Q.isVector4 ? it.set(Q.x, Q.y, Q.z, Q.w) : it.set(Q, Et, Pt, Dt), st.viewport(A.copy(it).multiplyScalar(L).floor());
  }, this.getScissor = function(Q) {
    return Q.copy(rt);
  }, this.setScissor = function(Q, Et, Pt, Dt) {
    Q.isVector4 ? rt.set(Q.x, Q.y, Q.z, Q.w) : rt.set(Q, Et, Pt, Dt), st.scissor(C.copy(rt).multiplyScalar(L).floor());
  }, this.getScissorTest = function() {
    return ft;
  }, this.setScissorTest = function(Q) {
    st.setScissorTest(ft = Q);
  }, this.setOpaqueSort = function(Q) {
    E = Q;
  }, this.setTransparentSort = function(Q) {
    q = Q;
  }, this.getClearColor = function(Q) {
    return Q.copy(V.getClearColor());
  }, this.setClearColor = function() {
    V.setClearColor.apply(V, arguments);
  }, this.getClearAlpha = function() {
    return V.getClearAlpha();
  }, this.setClearAlpha = function() {
    V.setClearAlpha.apply(V, arguments);
  }, this.clear = function(Q = !0, Et = !0, Pt = !0) {
    let Dt = 0;
    Q && (Dt |= 16384), Et && (Dt |= 256), Pt && (Dt |= 1024), xt.clear(Dt);
  }, this.clearColor = function() {
    this.clear(!0, !1, !1);
  }, this.clearDepth = function() {
    this.clear(!1, !0, !1);
  }, this.clearStencil = function() {
    this.clear(!1, !1, !0);
  }, this.dispose = function() {
    t.removeEventListener("webglcontextlost", qt, !1), t.removeEventListener("webglcontextrestored", $t, !1), t.removeEventListener("webglcontextcreationerror", fe, !1), ht.dispose(), lt.dispose(), J.dispose(), S.dispose(), Z.dispose(), z.dispose(), St.dispose(), It.dispose(), Y.dispose(), jt.dispose(), jt.removeEventListener("sessionstart", oe), jt.removeEventListener("sessionend", ce), W && (W.dispose(), W = null), Ve.stop();
  }, this.renderBufferDirect = function(Q, Et, Pt, Dt, kt, re) {
    Et === null && (Et = Mt);
    const we = kt.isMesh && kt.matrixWorld.determinant() < 0, de = function(wn, $n, hr, Se, ar) {
      $n.isScene !== !0 && ($n = Mt), K.resetTextureUnits();
      const vu = $n.fog, O0 = Se.isMeshStandardMaterial ? $n.environment : null, yu = b === null ? m.outputEncoding : b.isXRRenderTarget === !0 ? b.texture.encoding : 3e3, lc = (Se.isMeshStandardMaterial ? Z : S).get(Se.envMap || O0), L0 = Se.vertexColors === !0 && !!hr.attributes.color && hr.attributes.color.itemSize === 4, B0 = !!Se.normalMap && !!hr.attributes.tangent, z0 = !!hr.morphAttributes.position, k0 = !!hr.morphAttributes.normal, fn = !!hr.morphAttributes.color, hn = Se.toneMapped ? m.toneMapping : 0, Zp = hr.morphAttributes.position || hr.morphAttributes.normal || hr.morphAttributes.color, N0 = Zp !== void 0 ? Zp.length : 0, en = J.get(Se), qp = p.state.lights;
      if (vt === !0 && ($ === !0 || wn !== M)) {
        const zr = wn === M && Se.id === T;
        yt.setState(Se, wn, zr);
      }
      let us = !1;
      Se.version === en.__version ? en.needsLights && en.lightsStateVersion !== qp.state.version || en.outputEncoding !== yu || ar.isInstancedMesh && en.instancing === !1 ? us = !0 : ar.isInstancedMesh || en.instancing !== !0 ? ar.isSkinnedMesh && en.skinning === !1 ? us = !0 : ar.isSkinnedMesh || en.skinning !== !0 ? en.envMap !== lc || Se.fog === !0 && en.fog !== vu ? us = !0 : en.numClippingPlanes === void 0 || en.numClippingPlanes === yt.numPlanes && en.numIntersection === yt.numIntersection ? (en.vertexAlphas !== L0 || en.vertexTangents !== B0 || en.morphTargets !== z0 || en.morphNormals !== k0 || en.morphColors !== fn || en.toneMapping !== hn || N.isWebGL2 === !0 && en.morphTargetsCount !== N0) && (us = !0) : us = !0 : us = !0 : us = !0 : (us = !0, en.__version = Se.version);
      let En = en.currentProgram;
      us === !0 && (En = Kn(Se, $n, ar));
      let cc = !1, Ei = !1, hc = !1;
      const ur = En.getUniforms(), or = en.uniforms;
      if (st.useProgram(En.program) && (cc = !0, Ei = !0, hc = !0), Se.id !== T && (T = Se.id, Ei = !0), cc || M !== wn) {
        if (ur.setValue(xt, "projectionMatrix", wn.projectionMatrix), N.logarithmicDepthBuffer && ur.setValue(xt, "logDepthBufFC", 2 / (Math.log(wn.far + 1) / Math.LN2)), M !== wn && (M = wn, Ei = !0, hc = !0), Se.isShaderMaterial || Se.isMeshPhongMaterial || Se.isMeshToonMaterial || Se.isMeshStandardMaterial || Se.envMap) {
          const zr = ur.map.cameraPosition;
          zr !== void 0 && zr.setValue(xt, dt.setFromMatrixPosition(wn.matrixWorld));
        }
        (Se.isMeshPhongMaterial || Se.isMeshToonMaterial || Se.isMeshLambertMaterial || Se.isMeshBasicMaterial || Se.isMeshStandardMaterial || Se.isShaderMaterial) && ur.setValue(xt, "isOrthographic", wn.isOrthographicCamera === !0), (Se.isMeshPhongMaterial || Se.isMeshToonMaterial || Se.isMeshLambertMaterial || Se.isMeshBasicMaterial || Se.isMeshStandardMaterial || Se.isShaderMaterial || Se.isShadowMaterial || ar.isSkinnedMesh) && ur.setValue(xt, "viewMatrix", wn.matrixWorldInverse);
      }
      if (ar.isSkinnedMesh) {
        ur.setOptional(xt, ar, "bindMatrix"), ur.setOptional(xt, ar, "bindMatrixInverse");
        const zr = ar.skeleton;
        zr && (N.floatVertexTextures ? (zr.boneTexture === null && zr.computeBoneTexture(), ur.setValue(xt, "boneTexture", zr.boneTexture, K), ur.setValue(xt, "boneTextureSize", zr.boneTextureSize)) : console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."));
      }
      const uc = hr.morphAttributes;
      (uc.position !== void 0 || uc.normal !== void 0 || uc.color !== void 0 && N.isWebGL2 === !0) && tt.update(ar, hr, Se, En), (Ei || en.receiveShadow !== ar.receiveShadow) && (en.receiveShadow = ar.receiveShadow, ur.setValue(xt, "receiveShadow", ar.receiveShadow)), Se.isMeshGouraudMaterial && Se.envMap !== null && (or.envMap.value = lc, or.flipEnvMap.value = lc.isCubeTexture && lc.isRenderTargetTexture === !1 ? -1 : 1), Ei && (ur.setValue(xt, "toneMappingExposure", m.toneMappingExposure), en.needsLights && (mi = hc, (Ai = or).ambientLightColor.needsUpdate = mi, Ai.lightProbe.needsUpdate = mi, Ai.directionalLights.needsUpdate = mi, Ai.directionalLightShadows.needsUpdate = mi, Ai.pointLights.needsUpdate = mi, Ai.pointLightShadows.needsUpdate = mi, Ai.spotLights.needsUpdate = mi, Ai.spotLightShadows.needsUpdate = mi, Ai.rectAreaLights.needsUpdate = mi, Ai.hemisphereLights.needsUpdate = mi), vu && Se.fog === !0 && pt.refreshFogUniforms(or, vu), pt.refreshMaterialUniforms(or, Se, L, R, W), tv.upload(xt, en.uniformsList, or, K));
      var Ai, mi;
      if (Se.isShaderMaterial && Se.uniformsNeedUpdate === !0 && (tv.upload(xt, en.uniformsList, or, K), Se.uniformsNeedUpdate = !1), Se.isSpriteMaterial && ur.setValue(xt, "center", ar.center), ur.setValue(xt, "modelViewMatrix", ar.modelViewMatrix), ur.setValue(xt, "normalMatrix", ar.normalMatrix), ur.setValue(xt, "modelMatrix", ar.matrixWorld), Se.isShaderMaterial || Se.isRawShaderMaterial) {
        const zr = Se.uniformsGroups;
        for (let dc = 0, Xp = zr.length; dc < Xp; dc++)
          if (N.isWebGL2) {
            const kr = zr[dc];
            It.update(kr, En), It.bind(kr, En);
          } else
            console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.");
      }
      return En;
    }(Q, Et, Pt, Dt, kt);
    st.setMaterial(Dt, we);
    let Re = Pt.index, Ge = 1;
    Dt.wireframe === !0 && (Re = F.getWireframeAttribute(Pt), Ge = 2);
    const ie = Pt.drawRange, xe = Pt.attributes.position;
    let _n = ie.start * Ge, cn = (ie.start + ie.count) * Ge;
    re !== null && (_n = Math.max(_n, re.start * Ge), cn = Math.min(cn, (re.start + re.count) * Ge)), Re !== null ? (_n = Math.max(_n, 0), cn = Math.min(cn, Re.count)) : xe != null && (_n = Math.max(_n, 0), cn = Math.min(cn, xe.count));
    const be = cn - _n;
    if (be < 0 || be === 1 / 0)
      return;
    let We;
    St.setup(kt, Dt, de, Pt, Re);
    let Qe = gt;
    if (Re !== null && (We = G.get(Re), Qe = Tt, Qe.setIndex(We)), kt.isMesh)
      Dt.wireframe === !0 ? (st.setLineWidth(Dt.wireframeLinewidth * At()), Qe.setMode(1)) : Qe.setMode(4);
    else if (kt.isLine) {
      let wn = Dt.linewidth;
      wn === void 0 && (wn = 1), st.setLineWidth(wn * At()), kt.isLineSegments ? Qe.setMode(1) : kt.isLineLoop ? Qe.setMode(2) : Qe.setMode(3);
    } else
      kt.isPoints ? Qe.setMode(0) : kt.isSprite && Qe.setMode(4);
    if (kt.isInstancedMesh)
      Qe.renderInstances(_n, be, kt.count);
    else if (Pt.isInstancedBufferGeometry) {
      const wn = Pt._maxInstanceCount !== void 0 ? Pt._maxInstanceCount : 1 / 0, $n = Math.min(Pt.instanceCount, wn);
      Qe.renderInstances(_n, be, $n);
    } else
      Qe.render(_n, be);
  }, this.compile = function(Q, Et) {
    function Pt(Dt, kt, re) {
      Dt.transparent === !0 && Dt.side === 2 && Dt.forceSinglePass === !1 ? (Dt.side = 1, Dt.needsUpdate = !0, Kn(Dt, kt, re), Dt.side = 0, Dt.needsUpdate = !0, Kn(Dt, kt, re), Dt.side = 2) : Kn(Dt, kt, re);
    }
    p = lt.get(Q), p.init(), v.push(p), Q.traverseVisible(function(Dt) {
      Dt.isLight && Dt.layers.test(Et.layers) && (p.pushLight(Dt), Dt.castShadow && p.pushShadow(Dt));
    }), p.setupLights(m.physicallyCorrectLights), Q.traverse(function(Dt) {
      const kt = Dt.material;
      if (kt)
        if (Array.isArray(kt))
          for (let re = 0; re < kt.length; re++)
            Pt(kt[re], Q, Dt);
        else
          Pt(kt, Q, Dt);
    }), v.pop(), p = null;
  };
  let te = null;
  function oe() {
    Ve.stop();
  }
  function ce() {
    Ve.start();
  }
  const Ve = new MI();
  function sn(Q, Et, Pt, Dt) {
    if (Q.visible === !1)
      return;
    if (Q.layers.test(Et.layers)) {
      if (Q.isGroup)
        Pt = Q.renderOrder;
      else if (Q.isLOD)
        Q.autoUpdate === !0 && Q.update(Et);
      else if (Q.isLight)
        p.pushLight(Q), Q.castShadow && p.pushShadow(Q);
      else if (Q.isSprite) {
        if (!Q.frustumCulled || nt.intersectsSprite(Q)) {
          Dt && dt.setFromMatrixPosition(Q.matrixWorld).applyMatrix4(ct);
          const re = z.update(Q), we = Q.material;
          we.visible && h.push(Q, re, we, Pt, dt.z, null);
        }
      } else if ((Q.isMesh || Q.isLine || Q.isPoints) && (Q.isSkinnedMesh && Q.skeleton.frame !== et.render.frame && (Q.skeleton.update(), Q.skeleton.frame = et.render.frame), !Q.frustumCulled || nt.intersectsObject(Q))) {
        Dt && dt.setFromMatrixPosition(Q.matrixWorld).applyMatrix4(ct);
        const re = z.update(Q), we = Q.material;
        if (Array.isArray(we)) {
          const de = re.groups;
          for (let Re = 0, Ge = de.length; Re < Ge; Re++) {
            const ie = de[Re], xe = we[ie.materialIndex];
            xe && xe.visible && h.push(Q, re, xe, Pt, dt.z, ie);
          }
        } else
          we.visible && h.push(Q, re, we, Pt, dt.z, null);
      }
    }
    const kt = Q.children;
    for (let re = 0, we = kt.length; re < we; re++)
      sn(kt[re], Et, Pt, Dt);
  }
  function he(Q, Et, Pt, Dt) {
    const kt = Q.opaque, re = Q.transmissive, we = Q.transparent;
    p.setupLightsView(Pt), vt === !0 && yt.setGlobalState(m.clippingPlanes, Pt), re.length > 0 && function(de, Re, Ge) {
      const ie = N.isWebGL2;
      W === null && (W = new ir(1, 1, { generateMipmaps: !0, type: H.has("EXT_color_buffer_half_float") ? 1016 : 1009, minFilter: 1008, samples: ie && s === !0 ? 4 : 0 })), m.getDrawingBufferSize(mt), ie ? W.setSize(mt.x, mt.y) : W.setSize(xv(mt.x), xv(mt.y));
      const xe = m.getRenderTarget();
      m.setRenderTarget(W), m.clear();
      const _n = m.toneMapping;
      m.toneMapping = 0, Te(de, Re, Ge), m.toneMapping = _n, K.updateMultisampleRenderTarget(W), K.updateRenderTargetMipmap(W), m.setRenderTarget(xe);
    }(kt, Et, Pt), Dt && st.viewport(A.copy(Dt)), kt.length > 0 && Te(kt, Et, Pt), re.length > 0 && Te(re, Et, Pt), we.length > 0 && Te(we, Et, Pt), st.buffers.depth.setTest(!0), st.buffers.depth.setMask(!0), st.buffers.color.setMask(!0), st.setPolygonOffset(!1);
  }
  function Te(Q, Et, Pt) {
    const Dt = Et.isScene === !0 ? Et.overrideMaterial : null;
    for (let kt = 0, re = Q.length; kt < re; kt++) {
      const we = Q[kt], de = we.object, Re = we.geometry, Ge = Dt === null ? we.material : Dt, ie = we.group;
      de.layers.test(Pt.layers) && Tn(de, Et, Pt, Re, Ge, ie);
    }
  }
  function Tn(Q, Et, Pt, Dt, kt, re) {
    Q.onBeforeRender(m, Et, Pt, Dt, kt, re), Q.modelViewMatrix.multiplyMatrices(Pt.matrixWorldInverse, Q.matrixWorld), Q.normalMatrix.getNormalMatrix(Q.modelViewMatrix), kt.onBeforeRender(m, Et, Pt, Dt, Q, re), kt.transparent === !0 && kt.side === 2 && kt.forceSinglePass === !1 ? (kt.side = 1, kt.needsUpdate = !0, m.renderBufferDirect(Pt, Et, Dt, kt, Q, re), kt.side = 0, kt.needsUpdate = !0, m.renderBufferDirect(Pt, Et, Dt, kt, Q, re), kt.side = 2) : m.renderBufferDirect(Pt, Et, Dt, kt, Q, re), Q.onAfterRender(m, Et, Pt, Dt, kt, re);
  }
  function Kn(Q, Et, Pt) {
    Et.isScene !== !0 && (Et = Mt);
    const Dt = J.get(Q), kt = p.state.lights, re = p.state.shadowsArray, we = kt.state.version, de = Y.getParameters(Q, kt.state, re, Et, Pt), Re = Y.getProgramCacheKey(de);
    let Ge = Dt.programs;
    Dt.environment = Q.isMeshStandardMaterial ? Et.environment : null, Dt.fog = Et.fog, Dt.envMap = (Q.isMeshStandardMaterial ? Z : S).get(Q.envMap || Dt.environment), Ge === void 0 && (Q.addEventListener("dispose", Yt), Ge = /* @__PURE__ */ new Map(), Dt.programs = Ge);
    let ie = Ge.get(Re);
    if (ie !== void 0) {
      if (Dt.currentProgram === ie && Dt.lightsStateVersion === we)
        return cr(Q, de), ie;
    } else
      de.uniforms = Y.getUniforms(Q), Q.onBuild(Pt, de, m), Q.onBeforeCompile(de, m), ie = Y.acquireProgram(de, Re), Ge.set(Re, ie), Dt.uniforms = de.uniforms;
    const xe = Dt.uniforms;
    (Q.isShaderMaterial || Q.isRawShaderMaterial) && Q.clipping !== !0 || (xe.clippingPlanes = yt.uniform), cr(Q, de), Dt.needsLights = function(be) {
      return be.isMeshLambertMaterial || be.isMeshToonMaterial || be.isMeshPhongMaterial || be.isMeshStandardMaterial || be.isShadowMaterial || be.isShaderMaterial && be.lights === !0;
    }(Q), Dt.lightsStateVersion = we, Dt.needsLights && (xe.ambientLightColor.value = kt.state.ambient, xe.lightProbe.value = kt.state.probe, xe.directionalLights.value = kt.state.directional, xe.directionalLightShadows.value = kt.state.directionalShadow, xe.spotLights.value = kt.state.spot, xe.spotLightShadows.value = kt.state.spotShadow, xe.rectAreaLights.value = kt.state.rectArea, xe.ltc_1.value = kt.state.rectAreaLTC1, xe.ltc_2.value = kt.state.rectAreaLTC2, xe.pointLights.value = kt.state.point, xe.pointLightShadows.value = kt.state.pointShadow, xe.hemisphereLights.value = kt.state.hemi, xe.directionalShadowMap.value = kt.state.directionalShadowMap, xe.directionalShadowMatrix.value = kt.state.directionalShadowMatrix, xe.spotShadowMap.value = kt.state.spotShadowMap, xe.spotLightMatrix.value = kt.state.spotLightMatrix, xe.spotLightMap.value = kt.state.spotLightMap, xe.pointShadowMap.value = kt.state.pointShadowMap, xe.pointShadowMatrix.value = kt.state.pointShadowMatrix);
    const _n = ie.getUniforms(), cn = tv.seqWithValue(_n.seq, xe);
    return Dt.currentProgram = ie, Dt.uniformsList = cn, ie;
  }
  function cr(Q, Et) {
    const Pt = J.get(Q);
    Pt.outputEncoding = Et.outputEncoding, Pt.instancing = Et.instancing, Pt.skinning = Et.skinning, Pt.morphTargets = Et.morphTargets, Pt.morphNormals = Et.morphNormals, Pt.morphColors = Et.morphColors, Pt.morphTargetsCount = Et.morphTargetsCount, Pt.numClippingPlanes = Et.numClippingPlanes, Pt.numIntersection = Et.numClipIntersection, Pt.vertexAlphas = Et.vertexAlphas, Pt.vertexTangents = Et.vertexTangents, Pt.toneMapping = Et.toneMapping;
  }
  Ve.setAnimationLoop(function(Q) {
    te && te(Q);
  }), typeof self < "u" && Ve.setContext(self), this.setAnimationLoop = function(Q) {
    te = Q, jt.setAnimationLoop(Q), Q === null ? Ve.stop() : Ve.start();
  }, jt.addEventListener("sessionstart", oe), jt.addEventListener("sessionend", ce), this.render = function(Q, Et) {
    if (Et !== void 0 && Et.isCamera !== !0)
      return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
    if (y === !0)
      return;
    Q.matrixWorldAutoUpdate === !0 && Q.updateMatrixWorld(), Et.parent === null && Et.matrixWorldAutoUpdate === !0 && Et.updateMatrixWorld(), jt.enabled === !0 && jt.isPresenting === !0 && (jt.cameraAutoUpdate === !0 && jt.updateCamera(Et), Et = jt.getCamera()), Q.isScene === !0 && Q.onBeforeRender(m, Q, Et, b), p = lt.get(Q, v.length), p.init(), v.push(p), ct.multiplyMatrices(Et.projectionMatrix, Et.matrixWorldInverse), nt.setFromProjectionMatrix(ct), $ = this.localClippingEnabled, vt = yt.init(this.clippingPlanes, $), h = ht.get(Q, f.length), h.init(), f.push(h), sn(Q, Et, 0, m.sortObjects), h.finish(), m.sortObjects === !0 && h.sort(E, q), vt === !0 && yt.beginShadows();
    const Pt = p.state.shadowsArray;
    if (O.render(Pt, Q, Et), vt === !0 && yt.endShadows(), this.info.autoReset === !0 && this.info.reset(), V.render(h, Q), p.setupLights(m.physicallyCorrectLights), Et.isArrayCamera) {
      const Dt = Et.cameras;
      for (let kt = 0, re = Dt.length; kt < re; kt++) {
        const we = Dt[kt];
        he(h, Q, we, we.viewport);
      }
    } else
      he(h, Q, Et);
    b !== null && (K.updateMultisampleRenderTarget(b), K.updateRenderTargetMipmap(b)), Q.isScene === !0 && Q.onAfterRender(m, Q, Et), St.resetDefaultState(), T = -1, M = null, v.pop(), p = v.length > 0 ? v[v.length - 1] : null, f.pop(), h = f.length > 0 ? f[f.length - 1] : null;
  }, this.getActiveCubeFace = function() {
    return _;
  }, this.getActiveMipmapLevel = function() {
    return w;
  }, this.getRenderTarget = function() {
    return b;
  }, this.setRenderTargetTextures = function(Q, Et, Pt) {
    J.get(Q.texture).__webglTexture = Et, J.get(Q.depthTexture).__webglTexture = Pt;
    const Dt = J.get(Q);
    Dt.__hasExternalTextures = !0, Dt.__hasExternalTextures && (Dt.__autoAllocateDepthBuffer = Pt === void 0, Dt.__autoAllocateDepthBuffer || H.has("WEBGL_multisampled_render_to_texture") === !0 && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), Dt.__useRenderToTexture = !1));
  }, this.setRenderTargetFramebuffer = function(Q, Et) {
    const Pt = J.get(Q);
    Pt.__webglFramebuffer = Et, Pt.__useDefaultFramebuffer = Et === void 0;
  }, this.setRenderTarget = function(Q, Et = 0, Pt = 0) {
    b = Q, _ = Et, w = Pt;
    let Dt = !0, kt = null, re = !1, we = !1;
    if (Q) {
      const de = J.get(Q);
      de.__useDefaultFramebuffer !== void 0 ? (st.bindFramebuffer(36160, null), Dt = !1) : de.__webglFramebuffer === void 0 ? K.setupRenderTarget(Q) : de.__hasExternalTextures && K.rebindTextures(Q, J.get(Q.texture).__webglTexture, J.get(Q.depthTexture).__webglTexture);
      const Re = Q.texture;
      (Re.isData3DTexture || Re.isDataArrayTexture || Re.isCompressedArrayTexture) && (we = !0);
      const Ge = J.get(Q).__webglFramebuffer;
      Q.isWebGLCubeRenderTarget ? (kt = Ge[Et], re = !0) : kt = N.isWebGL2 && Q.samples > 0 && K.useMultisampledRTT(Q) === !1 ? J.get(Q).__webglMultisampledFramebuffer : Ge, A.copy(Q.viewport), C.copy(Q.scissor), I = Q.scissorTest;
    } else
      A.copy(it).multiplyScalar(L).floor(), C.copy(rt).multiplyScalar(L).floor(), I = ft;
    if (st.bindFramebuffer(36160, kt) && N.drawBuffers && Dt && st.drawBuffers(Q, kt), st.viewport(A), st.scissor(C), st.setScissorTest(I), re) {
      const de = J.get(Q.texture);
      xt.framebufferTexture2D(36160, 36064, 34069 + Et, de.__webglTexture, Pt);
    } else if (we) {
      const de = J.get(Q.texture), Re = Et || 0;
      xt.framebufferTextureLayer(36160, 36064, de.__webglTexture, Pt || 0, Re);
    }
    T = -1;
  }, this.readRenderTargetPixels = function(Q, Et, Pt, Dt, kt, re, we) {
    if (!Q || !Q.isWebGLRenderTarget)
      return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
    let de = J.get(Q).__webglFramebuffer;
    if (Q.isWebGLCubeRenderTarget && we !== void 0 && (de = de[we]), de) {
      st.bindFramebuffer(36160, de);
      try {
        const Re = Q.texture, Ge = Re.format, ie = Re.type;
        if (Ge !== 1023 && ot.convert(Ge) !== xt.getParameter(35739))
          return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
        const xe = ie === 1016 && (H.has("EXT_color_buffer_half_float") || N.isWebGL2 && H.has("EXT_color_buffer_float"));
        if (!(ie === 1009 || ot.convert(ie) === xt.getParameter(35738) || ie === 1015 && (N.isWebGL2 || H.has("OES_texture_float") || H.has("WEBGL_color_buffer_float")) || xe))
          return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
        Et >= 0 && Et <= Q.width - Dt && Pt >= 0 && Pt <= Q.height - kt && xt.readPixels(Et, Pt, Dt, kt, ot.convert(Ge), ot.convert(ie), re);
      } finally {
        const Re = b !== null ? J.get(b).__webglFramebuffer : null;
        st.bindFramebuffer(36160, Re);
      }
    }
  }, this.copyFramebufferToTexture = function(Q, Et, Pt = 0) {
    const Dt = Math.pow(2, -Pt), kt = Math.floor(Et.image.width * Dt), re = Math.floor(Et.image.height * Dt);
    K.setTexture2D(Et, 0), xt.copyTexSubImage2D(3553, Pt, 0, 0, Q.x, Q.y, kt, re), st.unbindTexture();
  }, this.copyTextureToTexture = function(Q, Et, Pt, Dt = 0) {
    const kt = Et.image.width, re = Et.image.height, we = ot.convert(Pt.format), de = ot.convert(Pt.type);
    K.setTexture2D(Pt, 0), xt.pixelStorei(37440, Pt.flipY), xt.pixelStorei(37441, Pt.premultiplyAlpha), xt.pixelStorei(3317, Pt.unpackAlignment), Et.isDataTexture ? xt.texSubImage2D(3553, Dt, Q.x, Q.y, kt, re, we, de, Et.image.data) : Et.isCompressedTexture ? xt.compressedTexSubImage2D(3553, Dt, Q.x, Q.y, Et.mipmaps[0].width, Et.mipmaps[0].height, we, Et.mipmaps[0].data) : xt.texSubImage2D(3553, Dt, Q.x, Q.y, we, de, Et.image), Dt === 0 && Pt.generateMipmaps && xt.generateMipmap(3553), st.unbindTexture();
  }, this.copyTextureToTexture3D = function(Q, Et, Pt, Dt, kt = 0) {
    if (m.isWebGL1Renderer)
      return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
    const re = Q.max.x - Q.min.x + 1, we = Q.max.y - Q.min.y + 1, de = Q.max.z - Q.min.z + 1, Re = ot.convert(Dt.format), Ge = ot.convert(Dt.type);
    let ie;
    if (Dt.isData3DTexture)
      K.setTexture3D(Dt, 0), ie = 32879;
    else {
      if (!Dt.isDataArrayTexture)
        return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
      K.setTexture2DArray(Dt, 0), ie = 35866;
    }
    xt.pixelStorei(37440, Dt.flipY), xt.pixelStorei(37441, Dt.premultiplyAlpha), xt.pixelStorei(3317, Dt.unpackAlignment);
    const xe = xt.getParameter(3314), _n = xt.getParameter(32878), cn = xt.getParameter(3316), be = xt.getParameter(3315), We = xt.getParameter(32877), Qe = Pt.isCompressedTexture ? Pt.mipmaps[0] : Pt.image;
    xt.pixelStorei(3314, Qe.width), xt.pixelStorei(32878, Qe.height), xt.pixelStorei(3316, Q.min.x), xt.pixelStorei(3315, Q.min.y), xt.pixelStorei(32877, Q.min.z), Pt.isDataTexture || Pt.isData3DTexture ? xt.texSubImage3D(ie, kt, Et.x, Et.y, Et.z, re, we, de, Re, Ge, Qe.data) : Pt.isCompressedArrayTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."), xt.compressedTexSubImage3D(ie, kt, Et.x, Et.y, Et.z, re, we, de, Re, Qe.data)) : xt.texSubImage3D(ie, kt, Et.x, Et.y, Et.z, re, we, de, Re, Ge, Qe), xt.pixelStorei(3314, xe), xt.pixelStorei(32878, _n), xt.pixelStorei(3316, cn), xt.pixelStorei(3315, be), xt.pixelStorei(32877, We), kt === 0 && Dt.generateMipmaps && xt.generateMipmap(ie), st.unbindTexture();
  }, this.initTexture = function(Q) {
    Q.isCubeTexture ? K.setTextureCube(Q, 0) : Q.isData3DTexture ? K.setTexture3D(Q, 0) : Q.isDataArrayTexture || Q.isCompressedArrayTexture ? K.setTexture2DArray(Q, 0) : K.setTexture2D(Q, 0), st.unbindTexture();
  }, this.resetState = function() {
    _ = 0, w = 0, b = null, st.reset(), St.reset();
  }, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
}
class II extends Ub {
}
II.prototype.isWebGL1Renderer = !0;
class Sv {
  constructor(t, e = 25e-5) {
    this.isFogExp2 = !0, this.name = "", this.color = new Ht(t), this.density = e;
  }
  clone() {
    return new Sv(this.color, this.density);
  }
  toJSON() {
    return { type: "FogExp2", color: this.color.getHex(), density: this.density };
  }
}
class Mv {
  constructor(t, e = 1, n = 1e3) {
    this.isFog = !0, this.name = "", this.color = new Ht(t), this.near = e, this.far = n;
  }
  clone() {
    return new Mv(this.color, this.near, this.far);
  }
  toJSON() {
    return { type: "Fog", color: this.color.getHex(), near: this.near, far: this.far };
  }
}
class Tv extends Ue {
  constructor() {
    super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.overrideMaterial = null, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  copy(t, e) {
    return super.copy(t, e), t.background !== null && (this.background = t.background.clone()), t.environment !== null && (this.environment = t.environment.clone()), t.fog !== null && (this.fog = t.fog.clone()), this.backgroundBlurriness = t.backgroundBlurriness, this.backgroundIntensity = t.backgroundIntensity, t.overrideMaterial !== null && (this.overrideMaterial = t.overrideMaterial.clone()), this.matrixAutoUpdate = t.matrixAutoUpdate, this;
  }
  toJSON(t) {
    const e = super.toJSON(t);
    return this.fog !== null && (e.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (e.object.backgroundBlurriness = this.backgroundBlurriness), this.backgroundIntensity !== 1 && (e.object.backgroundIntensity = this.backgroundIntensity), e;
  }
  get autoUpdate() {
    return console.warn("THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."), this.matrixWorldAutoUpdate;
  }
  set autoUpdate(t) {
    console.warn("THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."), this.matrixWorldAutoUpdate = t;
  }
}
class r0 {
  constructor(t, e) {
    this.isInterleavedBuffer = !0, this.array = t, this.stride = e, this.count = t !== void 0 ? t.length / e : 0, this.usage = 35044, this.updateRange = { offset: 0, count: -1 }, this.version = 0, this.uuid = Vi();
  }
  onUploadCallback() {
  }
  set needsUpdate(t) {
    t === !0 && this.version++;
  }
  setUsage(t) {
    return this.usage = t, this;
  }
  copy(t) {
    return this.array = new t.array.constructor(t.array), this.count = t.count, this.stride = t.stride, this.usage = t.usage, this;
  }
  copyAt(t, e, n) {
    t *= this.stride, n *= e.stride;
    for (let r = 0, s = this.stride; r < s; r++)
      this.array[t + r] = e.array[n + r];
    return this;
  }
  set(t, e = 0) {
    return this.array.set(t, e), this;
  }
  clone(t) {
    t.arrayBuffers === void 0 && (t.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Vi()), t.arrayBuffers[this.array.buffer._uuid] === void 0 && (t.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
    const e = new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]), n = new this.constructor(e, this.stride);
    return n.setUsage(this.usage), n;
  }
  onUpload(t) {
    return this.onUploadCallback = t, this;
  }
  toJSON(t) {
    return t.arrayBuffers === void 0 && (t.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Vi()), t.arrayBuffers[this.array.buffer._uuid] === void 0 && (t.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), { uuid: this.uuid, buffer: this.array.buffer._uuid, type: this.array.constructor.name, stride: this.stride };
  }
}
const ii = new D();
class Lr {
  constructor(t, e, n, r = !1) {
    this.isInterleavedBufferAttribute = !0, this.name = "", this.data = t, this.itemSize = e, this.offset = n, this.normalized = r;
  }
  get count() {
    return this.data.count;
  }
  get array() {
    return this.data.array;
  }
  set needsUpdate(t) {
    this.data.needsUpdate = t;
  }
  applyMatrix4(t) {
    for (let e = 0, n = this.data.count; e < n; e++)
      ii.fromBufferAttribute(this, e), ii.applyMatrix4(t), this.setXYZ(e, ii.x, ii.y, ii.z);
    return this;
  }
  applyNormalMatrix(t) {
    for (let e = 0, n = this.count; e < n; e++)
      ii.fromBufferAttribute(this, e), ii.applyNormalMatrix(t), this.setXYZ(e, ii.x, ii.y, ii.z);
    return this;
  }
  transformDirection(t) {
    for (let e = 0, n = this.count; e < n; e++)
      ii.fromBufferAttribute(this, e), ii.transformDirection(t), this.setXYZ(e, ii.x, ii.y, ii.z);
    return this;
  }
  setX(t, e) {
    return this.normalized && (e = vn(e, this.array)), this.data.array[t * this.data.stride + this.offset] = e, this;
  }
  setY(t, e) {
    return this.normalized && (e = vn(e, this.array)), this.data.array[t * this.data.stride + this.offset + 1] = e, this;
  }
  setZ(t, e) {
    return this.normalized && (e = vn(e, this.array)), this.data.array[t * this.data.stride + this.offset + 2] = e, this;
  }
  setW(t, e) {
    return this.normalized && (e = vn(e, this.array)), this.data.array[t * this.data.stride + this.offset + 3] = e, this;
  }
  getX(t) {
    let e = this.data.array[t * this.data.stride + this.offset];
    return this.normalized && (e = Na(e, this.array)), e;
  }
  getY(t) {
    let e = this.data.array[t * this.data.stride + this.offset + 1];
    return this.normalized && (e = Na(e, this.array)), e;
  }
  getZ(t) {
    let e = this.data.array[t * this.data.stride + this.offset + 2];
    return this.normalized && (e = Na(e, this.array)), e;
  }
  getW(t) {
    let e = this.data.array[t * this.data.stride + this.offset + 3];
    return this.normalized && (e = Na(e, this.array)), e;
  }
  setXY(t, e, n) {
    return t = t * this.data.stride + this.offset, this.normalized && (e = vn(e, this.array), n = vn(n, this.array)), this.data.array[t + 0] = e, this.data.array[t + 1] = n, this;
  }
  setXYZ(t, e, n, r) {
    return t = t * this.data.stride + this.offset, this.normalized && (e = vn(e, this.array), n = vn(n, this.array), r = vn(r, this.array)), this.data.array[t + 0] = e, this.data.array[t + 1] = n, this.data.array[t + 2] = r, this;
  }
  setXYZW(t, e, n, r, s) {
    return t = t * this.data.stride + this.offset, this.normalized && (e = vn(e, this.array), n = vn(n, this.array), r = vn(r, this.array), s = vn(s, this.array)), this.data.array[t + 0] = e, this.data.array[t + 1] = n, this.data.array[t + 2] = r, this.data.array[t + 3] = s, this;
  }
  clone(t) {
    if (t === void 0) {
      console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
      const e = [];
      for (let n = 0; n < this.count; n++) {
        const r = n * this.data.stride + this.offset;
        for (let s = 0; s < this.itemSize; s++)
          e.push(this.data.array[r + s]);
      }
      return new Ze(new this.array.constructor(e), this.itemSize, this.normalized);
    }
    return t.interleavedBuffers === void 0 && (t.interleavedBuffers = {}), t.interleavedBuffers[this.data.uuid] === void 0 && (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)), new Lr(t.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
  }
  toJSON(t) {
    if (t === void 0) {
      console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
      const e = [];
      for (let n = 0; n < this.count; n++) {
        const r = n * this.data.stride + this.offset;
        for (let s = 0; s < this.itemSize; s++)
          e.push(this.data.array[r + s]);
      }
      return { itemSize: this.itemSize, type: this.array.constructor.name, array: e, normalized: this.normalized };
    }
    return t.interleavedBuffers === void 0 && (t.interleavedBuffers = {}), t.interleavedBuffers[this.data.uuid] === void 0 && (t.interleavedBuffers[this.data.uuid] = this.data.toJSON(t)), { isInterleavedBufferAttribute: !0, itemSize: this.itemSize, data: this.data.uuid, offset: this.offset, normalized: this.normalized };
  }
}
class Vb extends Kr {
  constructor(t) {
    super(), this.isSpriteMaterial = !0, this.type = "SpriteMaterial", this.color = new Ht(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.fog = !0, this.setValues(t);
  }
  copy(t) {
    return super.copy(t), this.color.copy(t.color), this.map = t.map, this.alphaMap = t.alphaMap, this.rotation = t.rotation, this.sizeAttenuation = t.sizeAttenuation, this.fog = t.fog, this;
  }
}
let Fc;
const ju = new D(), Uc = new D(), Vc = new D(), Hc = new wt(), Gu = new wt(), OI = new Vt(), am = new D(), Wu = new D(), om = new D(), $T = new wt(), m_ = new wt(), QT = new wt();
class tE extends Ue {
  constructor(t) {
    if (super(), this.isSprite = !0, this.type = "Sprite", Fc === void 0) {
      Fc = new _e();
      const e = new Float32Array([-0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5, 0, 0, 1]), n = new r0(e, 5);
      Fc.setIndex([0, 1, 2, 0, 2, 3]), Fc.setAttribute("position", new Lr(n, 3, 0, !1)), Fc.setAttribute("uv", new Lr(n, 2, 3, !1));
    }
    this.geometry = Fc, this.material = t !== void 0 ? t : new Vb(), this.center = new wt(0.5, 0.5);
  }
  raycast(t, e) {
    t.camera === null && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), Uc.setFromMatrixScale(this.matrixWorld), OI.copy(t.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(t.camera.matrixWorldInverse, this.matrixWorld), Vc.setFromMatrixPosition(this.modelViewMatrix), t.camera.isPerspectiveCamera && this.material.sizeAttenuation === !1 && Uc.multiplyScalar(-Vc.z);
    const n = this.material.rotation;
    let r, s;
    n !== 0 && (s = Math.cos(n), r = Math.sin(n));
    const a = this.center;
    lm(am.set(-0.5, -0.5, 0), Vc, a, Uc, r, s), lm(Wu.set(0.5, -0.5, 0), Vc, a, Uc, r, s), lm(om.set(0.5, 0.5, 0), Vc, a, Uc, r, s), $T.set(0, 0), m_.set(1, 0), QT.set(1, 1);
    let o = t.ray.intersectTriangle(am, Wu, om, !1, ju);
    if (o === null && (lm(Wu.set(-0.5, 0.5, 0), Vc, a, Uc, r, s), m_.set(0, 1), o = t.ray.intersectTriangle(am, om, Wu, !1, ju), o === null))
      return;
    const l = t.ray.origin.distanceTo(ju);
    l < t.near || l > t.far || e.push({ distance: l, point: ju.clone(), uv: Pr.getUV(ju, am, Wu, om, $T, m_, QT, new wt()), face: null, object: this });
  }
  copy(t, e) {
    return super.copy(t, e), t.center !== void 0 && this.center.copy(t.center), this.material = t.material, this;
  }
}
function lm(i, t, e, n, r, s) {
  Hc.subVectors(i, e).addScalar(0.5).multiply(n), r !== void 0 ? (Gu.x = s * Hc.x - r * Hc.y, Gu.y = r * Hc.x + s * Hc.y) : Gu.copy(Hc), i.copy(t), i.x += Gu.x, i.y += Gu.y, i.applyMatrix4(OI);
}
const cm = new D(), eE = new D();
class nE extends Ue {
  constructor() {
    super(), this._currentLevel = 0, this.type = "LOD", Object.defineProperties(this, { levels: { enumerable: !0, value: [] }, isLOD: { value: !0 } }), this.autoUpdate = !0;
  }
  copy(t) {
    super.copy(t, !1);
    const e = t.levels;
    for (let n = 0, r = e.length; n < r; n++) {
      const s = e[n];
      this.addLevel(s.object.clone(), s.distance, s.hysteresis);
    }
    return this.autoUpdate = t.autoUpdate, this;
  }
  addLevel(t, e = 0, n = 0) {
    e = Math.abs(e);
    const r = this.levels;
    let s;
    for (s = 0; s < r.length && !(e < r[s].distance); s++)
      ;
    return r.splice(s, 0, { distance: e, hysteresis: n, object: t }), this.add(t), this;
  }
  getCurrentLevel() {
    return this._currentLevel;
  }
  getObjectForDistance(t) {
    const e = this.levels;
    if (e.length > 0) {
      let n, r;
      for (n = 1, r = e.length; n < r; n++) {
        let s = e[n].distance;
        if (e[n].object.visible && (s -= s * e[n].hysteresis), t < s)
          break;
      }
      return e[n - 1].object;
    }
    return null;
  }
  raycast(t, e) {
    if (this.levels.length > 0) {
      cm.setFromMatrixPosition(this.matrixWorld);
      const n = t.ray.origin.distanceTo(cm);
      this.getObjectForDistance(n).raycast(t, e);
    }
  }
  update(t) {
    const e = this.levels;
    if (e.length > 1) {
      cm.setFromMatrixPosition(t.matrixWorld), eE.setFromMatrixPosition(this.matrixWorld);
      const n = cm.distanceTo(eE) / t.zoom;
      let r, s;
      for (e[0].object.visible = !0, r = 1, s = e.length; r < s; r++) {
        let a = e[r].distance;
        if (e[r].object.visible && (a -= a * e[r].hysteresis), !(n >= a))
          break;
        e[r - 1].object.visible = !1, e[r].object.visible = !0;
      }
      for (this._currentLevel = r - 1; r < s; r++)
        e[r].object.visible = !1;
    }
  }
  toJSON(t) {
    const e = super.toJSON(t);
    this.autoUpdate === !1 && (e.object.autoUpdate = !1), e.object.levels = [];
    const n = this.levels;
    for (let r = 0, s = n.length; r < s; r++) {
      const a = n[r];
      e.object.levels.push({ object: a.object.uuid, distance: a.distance, hysteresis: a.hysteresis });
    }
    return e;
  }
}
const rE = new D(), iE = new ze(), sE = new ze(), aU = new D(), aE = new Vt();
class oE extends Nt {
  constructor(t, e) {
    super(t, e), this.isSkinnedMesh = !0, this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new Vt(), this.bindMatrixInverse = new Vt();
  }
  copy(t, e) {
    return super.copy(t, e), this.bindMode = t.bindMode, this.bindMatrix.copy(t.bindMatrix), this.bindMatrixInverse.copy(t.bindMatrixInverse), this.skeleton = t.skeleton, this;
  }
  bind(t, e) {
    this.skeleton = t, e === void 0 && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), e = this.matrixWorld), this.bindMatrix.copy(e), this.bindMatrixInverse.copy(e).invert();
  }
  pose() {
    this.skeleton.pose();
  }
  normalizeSkinWeights() {
    const t = new ze(), e = this.geometry.attributes.skinWeight;
    for (let n = 0, r = e.count; n < r; n++) {
      t.fromBufferAttribute(e, n);
      const s = 1 / t.manhattanLength();
      s !== 1 / 0 ? t.multiplyScalar(s) : t.set(1, 0, 0, 0), e.setXYZW(n, t.x, t.y, t.z, t.w);
    }
  }
  updateMatrixWorld(t) {
    super.updateMatrixWorld(t), this.bindMode === "attached" ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === "detached" ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
  }
  boneTransform(t, e) {
    const n = this.skeleton, r = this.geometry;
    iE.fromBufferAttribute(r.attributes.skinIndex, t), sE.fromBufferAttribute(r.attributes.skinWeight, t), rE.copy(e).applyMatrix4(this.bindMatrix), e.set(0, 0, 0);
    for (let s = 0; s < 4; s++) {
      const a = sE.getComponent(s);
      if (a !== 0) {
        const o = iE.getComponent(s);
        aE.multiplyMatrices(n.bones[o].matrixWorld, n.boneInverses[o]), e.addScaledVector(aU.copy(rE).applyMatrix4(aE), a);
      }
    }
    return e.applyMatrix4(this.bindMatrixInverse);
  }
}
class rx extends Ue {
  constructor() {
    super(), this.isBone = !0, this.type = "Bone";
  }
}
class Ro extends Yn {
  constructor(t = null, e = 1, n = 1, r, s, a, o, l, c = 1003, u = 1003, h, p) {
    super(null, a, o, l, c, u, r, s, h, p), this.isDataTexture = !0, this.image = { data: t, width: e, height: n }, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
  }
}
const lE = new Vt(), oU = new Vt();
class Ev {
  constructor(t = [], e = []) {
    this.uuid = Vi(), this.bones = t.slice(0), this.boneInverses = e, this.boneMatrices = null, this.boneTexture = null, this.boneTextureSize = 0, this.frame = -1, this.init();
  }
  init() {
    const t = this.bones, e = this.boneInverses;
    if (this.boneMatrices = new Float32Array(16 * t.length), e.length === 0)
      this.calculateInverses();
    else if (t.length !== e.length) {
      console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
      for (let n = 0, r = this.bones.length; n < r; n++)
        this.boneInverses.push(new Vt());
    }
  }
  calculateInverses() {
    this.boneInverses.length = 0;
    for (let t = 0, e = this.bones.length; t < e; t++) {
      const n = new Vt();
      this.bones[t] && n.copy(this.bones[t].matrixWorld).invert(), this.boneInverses.push(n);
    }
  }
  pose() {
    for (let t = 0, e = this.bones.length; t < e; t++) {
      const n = this.bones[t];
      n && n.matrixWorld.copy(this.boneInverses[t]).invert();
    }
    for (let t = 0, e = this.bones.length; t < e; t++) {
      const n = this.bones[t];
      n && (n.parent && n.parent.isBone ? (n.matrix.copy(n.parent.matrixWorld).invert(), n.matrix.multiply(n.matrixWorld)) : n.matrix.copy(n.matrixWorld), n.matrix.decompose(n.position, n.quaternion, n.scale));
    }
  }
  update() {
    const t = this.bones, e = this.boneInverses, n = this.boneMatrices, r = this.boneTexture;
    for (let s = 0, a = t.length; s < a; s++) {
      const o = t[s] ? t[s].matrixWorld : oU;
      lE.multiplyMatrices(o, e[s]), lE.toArray(n, 16 * s);
    }
    r !== null && (r.needsUpdate = !0);
  }
  clone() {
    return new Ev(this.bones, this.boneInverses);
  }
  computeBoneTexture() {
    let t = Math.sqrt(4 * this.bones.length);
    t = vI(t), t = Math.max(t, 4);
    const e = new Float32Array(t * t * 4);
    e.set(this.boneMatrices);
    const n = new Ro(e, t, t, 1023, 1015);
    return n.needsUpdate = !0, this.boneMatrices = e, this.boneTexture = n, this.boneTextureSize = t, this;
  }
  getBoneByName(t) {
    for (let e = 0, n = this.bones.length; e < n; e++) {
      const r = this.bones[e];
      if (r.name === t)
        return r;
    }
  }
  dispose() {
    this.boneTexture !== null && (this.boneTexture.dispose(), this.boneTexture = null);
  }
  fromJSON(t, e) {
    this.uuid = t.uuid;
    for (let n = 0, r = t.bones.length; n < r; n++) {
      const s = t.bones[n];
      let a = e[s];
      a === void 0 && (console.warn("THREE.Skeleton: No bone found with UUID:", s), a = new rx()), this.bones.push(a), this.boneInverses.push(new Vt().fromArray(t.boneInverses[n]));
    }
    return this.init(), this;
  }
  toJSON() {
    const t = { metadata: { version: 4.5, type: "Skeleton", generator: "Skeleton.toJSON" }, bones: [], boneInverses: [] };
    t.uuid = this.uuid;
    const e = this.bones, n = this.boneInverses;
    for (let r = 0, s = e.length; r < s; r++) {
      const a = e[r];
      t.bones.push(a.uuid);
      const o = n[r];
      t.boneInverses.push(o.toArray());
    }
    return t;
  }
}
class Dh extends Ze {
  constructor(t, e, n, r = 1) {
    super(t, e, n), this.isInstancedBufferAttribute = !0, this.meshPerAttribute = r;
  }
  copy(t) {
    return super.copy(t), this.meshPerAttribute = t.meshPerAttribute, this;
  }
  toJSON() {
    const t = super.toJSON();
    return t.meshPerAttribute = this.meshPerAttribute, t.isInstancedBufferAttribute = !0, t;
  }
}
const cE = new Vt(), hE = new Vt(), hm = [], lU = new Vt(), Zu = new Nt();
class uE extends Nt {
  constructor(t, e, n) {
    super(t, e), this.isInstancedMesh = !0, this.instanceMatrix = new Dh(new Float32Array(16 * n), 16), this.instanceColor = null, this.count = n, this.frustumCulled = !1;
    for (let r = 0; r < n; r++)
      this.setMatrixAt(r, lU);
  }
  copy(t, e) {
    return super.copy(t, e), this.instanceMatrix.copy(t.instanceMatrix), t.instanceColor !== null && (this.instanceColor = t.instanceColor.clone()), this.count = t.count, this;
  }
  getColorAt(t, e) {
    e.fromArray(this.instanceColor.array, 3 * t);
  }
  getMatrixAt(t, e) {
    e.fromArray(this.instanceMatrix.array, 16 * t);
  }
  raycast(t, e) {
    const n = this.matrixWorld, r = this.count;
    if (Zu.geometry = this.geometry, Zu.material = this.material, Zu.material !== void 0)
      for (let s = 0; s < r; s++) {
        this.getMatrixAt(s, cE), hE.multiplyMatrices(n, cE), Zu.matrixWorld = hE, Zu.raycast(t, hm);
        for (let a = 0, o = hm.length; a < o; a++) {
          const l = hm[a];
          l.instanceId = s, l.object = this, e.push(l);
        }
        hm.length = 0;
      }
  }
  setColorAt(t, e) {
    this.instanceColor === null && (this.instanceColor = new Dh(new Float32Array(3 * this.instanceMatrix.count), 3)), e.toArray(this.instanceColor.array, 3 * t);
  }
  setMatrixAt(t, e) {
    e.toArray(this.instanceMatrix.array, 16 * t);
  }
  updateMorphTargets() {
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class Ar extends Kr {
  constructor(t) {
    super(), this.isLineBasicMaterial = !0, this.type = "LineBasicMaterial", this.color = new Ht(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = !0, this.setValues(t);
  }
  copy(t) {
    return super.copy(t), this.color.copy(t.color), this.linewidth = t.linewidth, this.linecap = t.linecap, this.linejoin = t.linejoin, this.fog = t.fog, this;
  }
}
const dE = new D(), pE = new D(), fE = new Vt(), g_ = new Uo(), um = new Mi();
class Yr extends Ue {
  constructor(t = new _e(), e = new Ar()) {
    super(), this.isLine = !0, this.type = "Line", this.geometry = t, this.material = e, this.updateMorphTargets();
  }
  copy(t, e) {
    return super.copy(t, e), this.material = t.material, this.geometry = t.geometry, this;
  }
  computeLineDistances() {
    const t = this.geometry;
    if (t.index === null) {
      const e = t.attributes.position, n = [0];
      for (let r = 1, s = e.count; r < s; r++)
        dE.fromBufferAttribute(e, r - 1), pE.fromBufferAttribute(e, r), n[r] = n[r - 1], n[r] += dE.distanceTo(pE);
      t.setAttribute("lineDistance", new Wt(n, 1));
    } else
      console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    return this;
  }
  raycast(t, e) {
    const n = this.geometry, r = this.matrixWorld, s = t.params.Line.threshold, a = n.drawRange;
    if (n.boundingSphere === null && n.computeBoundingSphere(), um.copy(n.boundingSphere), um.applyMatrix4(r), um.radius += s, t.ray.intersectsSphere(um) === !1)
      return;
    fE.copy(r).invert(), g_.copy(t.ray).applyMatrix4(fE);
    const o = s / ((this.scale.x + this.scale.y + this.scale.z) / 3), l = o * o, c = new D(), u = new D(), h = new D(), p = new D(), f = this.isLineSegments ? 2 : 1, v = n.index, m = n.attributes.position;
    if (v !== null)
      for (let y = Math.max(0, a.start), _ = Math.min(v.count, a.start + a.count) - 1; y < _; y += f) {
        const w = v.getX(y), b = v.getX(y + 1);
        if (c.fromBufferAttribute(m, w), u.fromBufferAttribute(m, b), g_.distanceSqToSegment(c, u, p, h) > l)
          continue;
        p.applyMatrix4(this.matrixWorld);
        const T = t.ray.origin.distanceTo(p);
        T < t.near || T > t.far || e.push({ distance: T, point: h.clone().applyMatrix4(this.matrixWorld), index: y, face: null, faceIndex: null, object: this });
      }
    else
      for (let y = Math.max(0, a.start), _ = Math.min(m.count, a.start + a.count) - 1; y < _; y += f) {
        if (c.fromBufferAttribute(m, y), u.fromBufferAttribute(m, y + 1), g_.distanceSqToSegment(c, u, p, h) > l)
          continue;
        p.applyMatrix4(this.matrixWorld);
        const w = t.ray.origin.distanceTo(p);
        w < t.near || w > t.far || e.push({ distance: w, point: h.clone().applyMatrix4(this.matrixWorld), index: y, face: null, faceIndex: null, object: this });
      }
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes, e = Object.keys(t);
    if (e.length > 0) {
      const n = t[e[0]];
      if (n !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let r = 0, s = n.length; r < s; r++) {
          const a = n[r].name || String(r);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = r;
        }
      }
    }
  }
}
const mE = new D(), gE = new D();
class Ts extends Yr {
  constructor(t, e) {
    super(t, e), this.isLineSegments = !0, this.type = "LineSegments";
  }
  computeLineDistances() {
    const t = this.geometry;
    if (t.index === null) {
      const e = t.attributes.position, n = [];
      for (let r = 0, s = e.count; r < s; r += 2)
        mE.fromBufferAttribute(e, r), gE.fromBufferAttribute(e, r + 1), n[r] = r === 0 ? 0 : n[r - 1], n[r + 1] = n[r] + mE.distanceTo(gE);
      t.setAttribute("lineDistance", new Wt(n, 1));
    } else
      console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    return this;
  }
}
class vE extends Yr {
  constructor(t, e) {
    super(t, e), this.isLineLoop = !0, this.type = "LineLoop";
  }
}
class i0 extends Kr {
  constructor(t) {
    super(), this.isPointsMaterial = !0, this.type = "PointsMaterial", this.color = new Ht(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.fog = !0, this.setValues(t);
  }
  copy(t) {
    return super.copy(t), this.color.copy(t.color), this.map = t.map, this.alphaMap = t.alphaMap, this.size = t.size, this.sizeAttenuation = t.sizeAttenuation, this.fog = t.fog, this;
  }
}
const yE = new Vt(), ix = new Uo(), dm = new Mi(), pm = new D();
class sx extends Ue {
  constructor(t = new _e(), e = new i0()) {
    super(), this.isPoints = !0, this.type = "Points", this.geometry = t, this.material = e, this.updateMorphTargets();
  }
  copy(t, e) {
    return super.copy(t, e), this.material = t.material, this.geometry = t.geometry, this;
  }
  raycast(t, e) {
    const n = this.geometry, r = this.matrixWorld, s = t.params.Points.threshold, a = n.drawRange;
    if (n.boundingSphere === null && n.computeBoundingSphere(), dm.copy(n.boundingSphere), dm.applyMatrix4(r), dm.radius += s, t.ray.intersectsSphere(dm) === !1)
      return;
    yE.copy(r).invert(), ix.copy(t.ray).applyMatrix4(yE);
    const o = s / ((this.scale.x + this.scale.y + this.scale.z) / 3), l = o * o, c = n.index, u = n.attributes.position;
    if (c !== null)
      for (let h = Math.max(0, a.start), p = Math.min(c.count, a.start + a.count); h < p; h++) {
        const f = c.getX(h);
        pm.fromBufferAttribute(u, f), _E(pm, f, l, r, t, e, this);
      }
    else
      for (let h = Math.max(0, a.start), p = Math.min(u.count, a.start + a.count); h < p; h++)
        pm.fromBufferAttribute(u, h), _E(pm, h, l, r, t, e, this);
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes, e = Object.keys(t);
    if (e.length > 0) {
      const n = t[e[0]];
      if (n !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let r = 0, s = n.length; r < s; r++) {
          const a = n[r].name || String(r);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = r;
        }
      }
    }
  }
}
function _E(i, t, e, n, r, s, a) {
  const o = ix.distanceSqToPoint(i);
  if (o < e) {
    const l = new D();
    ix.closestPointToPoint(i, l), l.applyMatrix4(n);
    const c = r.ray.origin.distanceTo(l);
    if (c < r.near || c > r.far)
      return;
    s.push({ distance: c, distanceToRay: Math.sqrt(o), point: l, index: t, face: null, object: a });
  }
}
class v_ extends Yn {
  constructor(t, e, n, r, s, a, o, l, c, u, h, p) {
    super(null, a, o, l, c, u, r, s, h, p), this.isCompressedTexture = !0, this.image = { width: e, height: n }, this.mipmaps = t, this.flipY = !1, this.generateMipmaps = !1;
  }
}
class Is {
  constructor() {
    this.type = "Curve", this.arcLengthDivisions = 200;
  }
  getPoint() {
    return console.warn("THREE.Curve: .getPoint() not implemented."), null;
  }
  getPointAt(t, e) {
    const n = this.getUtoTmapping(t);
    return this.getPoint(n, e);
  }
  getPoints(t = 5) {
    const e = [];
    for (let n = 0; n <= t; n++)
      e.push(this.getPoint(n / t));
    return e;
  }
  getSpacedPoints(t = 5) {
    const e = [];
    for (let n = 0; n <= t; n++)
      e.push(this.getPointAt(n / t));
    return e;
  }
  getLength() {
    const t = this.getLengths();
    return t[t.length - 1];
  }
  getLengths(t = this.arcLengthDivisions) {
    if (this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate)
      return this.cacheArcLengths;
    this.needsUpdate = !1;
    const e = [];
    let n, r = this.getPoint(0), s = 0;
    e.push(0);
    for (let a = 1; a <= t; a++)
      n = this.getPoint(a / t), s += n.distanceTo(r), e.push(s), r = n;
    return this.cacheArcLengths = e, e;
  }
  updateArcLengths() {
    this.needsUpdate = !0, this.getLengths();
  }
  getUtoTmapping(t, e) {
    const n = this.getLengths();
    let r = 0;
    const s = n.length;
    let a;
    a = e || t * n[s - 1];
    let o, l = 0, c = s - 1;
    for (; l <= c; )
      if (r = Math.floor(l + (c - l) / 2), o = n[r] - a, o < 0)
        l = r + 1;
      else {
        if (!(o > 0)) {
          c = r;
          break;
        }
        c = r - 1;
      }
    if (r = c, n[r] === a)
      return r / (s - 1);
    const u = n[r];
    return (r + (a - u) / (n[r + 1] - u)) / (s - 1);
  }
  getTangent(t, e) {
    let r = t - 1e-4, s = t + 1e-4;
    r < 0 && (r = 0), s > 1 && (s = 1);
    const a = this.getPoint(r), o = this.getPoint(s), l = e || (a.isVector2 ? new wt() : new D());
    return l.copy(o).sub(a).normalize(), l;
  }
  getTangentAt(t, e) {
    const n = this.getUtoTmapping(t);
    return this.getTangent(n, e);
  }
  computeFrenetFrames(t, e) {
    const n = new D(), r = [], s = [], a = [], o = new D(), l = new Vt();
    for (let f = 0; f <= t; f++) {
      const v = f / t;
      r[f] = this.getTangentAt(v, new D());
    }
    s[0] = new D(), a[0] = new D();
    let c = Number.MAX_VALUE;
    const u = Math.abs(r[0].x), h = Math.abs(r[0].y), p = Math.abs(r[0].z);
    u <= c && (c = u, n.set(1, 0, 0)), h <= c && (c = h, n.set(0, 1, 0)), p <= c && n.set(0, 0, 1), o.crossVectors(r[0], n).normalize(), s[0].crossVectors(r[0], o), a[0].crossVectors(r[0], s[0]);
    for (let f = 1; f <= t; f++) {
      if (s[f] = s[f - 1].clone(), a[f] = a[f - 1].clone(), o.crossVectors(r[f - 1], r[f]), o.length() > Number.EPSILON) {
        o.normalize();
        const v = Math.acos(rr(r[f - 1].dot(r[f]), -1, 1));
        s[f].applyMatrix4(l.makeRotationAxis(o, v));
      }
      a[f].crossVectors(r[f], s[f]);
    }
    if (e === !0) {
      let f = Math.acos(rr(s[0].dot(s[t]), -1, 1));
      f /= t, r[0].dot(o.crossVectors(s[0], s[t])) > 0 && (f = -f);
      for (let v = 1; v <= t; v++)
        s[v].applyMatrix4(l.makeRotationAxis(r[v], f * v)), a[v].crossVectors(r[v], s[v]);
    }
    return { tangents: r, normals: s, binormals: a };
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(t) {
    return this.arcLengthDivisions = t.arcLengthDivisions, this;
  }
  toJSON() {
    const t = { metadata: { version: 4.5, type: "Curve", generator: "Curve.toJSON" } };
    return t.arcLengthDivisions = this.arcLengthDivisions, t.type = this.type, t;
  }
  fromJSON(t) {
    return this.arcLengthDivisions = t.arcLengthDivisions, this;
  }
}
class bp extends Is {
  constructor(t = 0, e = 0, n = 1, r = 1, s = 0, a = 2 * Math.PI, o = !1, l = 0) {
    super(), this.isEllipseCurve = !0, this.type = "EllipseCurve", this.aX = t, this.aY = e, this.xRadius = n, this.yRadius = r, this.aStartAngle = s, this.aEndAngle = a, this.aClockwise = o, this.aRotation = l;
  }
  getPoint(t, e) {
    const n = e || new wt(), r = 2 * Math.PI;
    let s = this.aEndAngle - this.aStartAngle;
    const a = Math.abs(s) < Number.EPSILON;
    for (; s < 0; )
      s += r;
    for (; s > r; )
      s -= r;
    s < Number.EPSILON && (s = a ? 0 : r), this.aClockwise !== !0 || a || (s === r ? s = -r : s -= r);
    const o = this.aStartAngle + t * s;
    let l = this.aX + this.xRadius * Math.cos(o), c = this.aY + this.yRadius * Math.sin(o);
    if (this.aRotation !== 0) {
      const u = Math.cos(this.aRotation), h = Math.sin(this.aRotation), p = l - this.aX, f = c - this.aY;
      l = p * u - f * h + this.aX, c = p * h + f * u + this.aY;
    }
    return n.set(l, c);
  }
  copy(t) {
    return super.copy(t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this;
  }
  toJSON() {
    const t = super.toJSON();
    return t.aX = this.aX, t.aY = this.aY, t.xRadius = this.xRadius, t.yRadius = this.yRadius, t.aStartAngle = this.aStartAngle, t.aEndAngle = this.aEndAngle, t.aClockwise = this.aClockwise, t.aRotation = this.aRotation, t;
  }
  fromJSON(t) {
    return super.fromJSON(t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this;
  }
}
class LI extends bp {
  constructor(t, e, n, r, s, a) {
    super(t, e, n, n, r, s, a), this.isArcCurve = !0, this.type = "ArcCurve";
  }
}
function Hb() {
  let i = 0, t = 0, e = 0, n = 0;
  function r(s, a, o, l) {
    i = s, t = o, e = -3 * s + 3 * a - 2 * o - l, n = 2 * s - 2 * a + o + l;
  }
  return { initCatmullRom: function(s, a, o, l, c) {
    r(a, o, c * (o - s), c * (l - a));
  }, initNonuniformCatmullRom: function(s, a, o, l, c, u, h) {
    let p = (a - s) / c - (o - s) / (c + u) + (o - a) / u, f = (o - a) / u - (l - a) / (u + h) + (l - o) / h;
    p *= u, f *= u, r(a, o, p, f);
  }, calc: function(s) {
    const a = s * s;
    return i + t * s + e * a + n * (a * s);
  } };
}
const fm = new D(), y_ = new Hb(), __ = new Hb(), w_ = new Hb();
class BI extends Is {
  constructor(t = [], e = !1, n = "centripetal", r = 0.5) {
    super(), this.isCatmullRomCurve3 = !0, this.type = "CatmullRomCurve3", this.points = t, this.closed = e, this.curveType = n, this.tension = r;
  }
  getPoint(t, e = new D()) {
    const n = e, r = this.points, s = r.length, a = (s - (this.closed ? 0 : 1)) * t;
    let o, l, c = Math.floor(a), u = a - c;
    this.closed ? c += c > 0 ? 0 : (Math.floor(Math.abs(c) / s) + 1) * s : u === 0 && c === s - 1 && (c = s - 2, u = 1), this.closed || c > 0 ? o = r[(c - 1) % s] : (fm.subVectors(r[0], r[1]).add(r[0]), o = fm);
    const h = r[c % s], p = r[(c + 1) % s];
    if (this.closed || c + 2 < s ? l = r[(c + 2) % s] : (fm.subVectors(r[s - 1], r[s - 2]).add(r[s - 1]), l = fm), this.curveType === "centripetal" || this.curveType === "chordal") {
      const f = this.curveType === "chordal" ? 0.5 : 0.25;
      let v = Math.pow(o.distanceToSquared(h), f), m = Math.pow(h.distanceToSquared(p), f), y = Math.pow(p.distanceToSquared(l), f);
      m < 1e-4 && (m = 1), v < 1e-4 && (v = m), y < 1e-4 && (y = m), y_.initNonuniformCatmullRom(o.x, h.x, p.x, l.x, v, m, y), __.initNonuniformCatmullRom(o.y, h.y, p.y, l.y, v, m, y), w_.initNonuniformCatmullRom(o.z, h.z, p.z, l.z, v, m, y);
    } else
      this.curveType === "catmullrom" && (y_.initCatmullRom(o.x, h.x, p.x, l.x, this.tension), __.initCatmullRom(o.y, h.y, p.y, l.y, this.tension), w_.initCatmullRom(o.z, h.z, p.z, l.z, this.tension));
    return n.set(y_.calc(u), __.calc(u), w_.calc(u)), n;
  }
  copy(t) {
    super.copy(t), this.points = [];
    for (let e = 0, n = t.points.length; e < n; e++) {
      const r = t.points[e];
      this.points.push(r.clone());
    }
    return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this;
  }
  toJSON() {
    const t = super.toJSON();
    t.points = [];
    for (let e = 0, n = this.points.length; e < n; e++) {
      const r = this.points[e];
      t.points.push(r.toArray());
    }
    return t.closed = this.closed, t.curveType = this.curveType, t.tension = this.tension, t;
  }
  fromJSON(t) {
    super.fromJSON(t), this.points = [];
    for (let e = 0, n = t.points.length; e < n; e++) {
      const r = t.points[e];
      this.points.push(new D().fromArray(r));
    }
    return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this;
  }
}
function wE(i, t, e, n, r) {
  const s = 0.5 * (n - t), a = 0.5 * (r - e), o = i * i;
  return (2 * e - 2 * n + s + a) * (i * o) + (-3 * e + 3 * n - 2 * s - a) * o + s * i + e;
}
function Rd(i, t, e, n) {
  return function(r, s) {
    const a = 1 - r;
    return a * a * s;
  }(i, t) + function(r, s) {
    return 2 * (1 - r) * r * s;
  }(i, e) + function(r, s) {
    return r * r * s;
  }(i, n);
}
function Id(i, t, e, n, r) {
  return function(s, a) {
    const o = 1 - s;
    return o * o * o * a;
  }(i, t) + function(s, a) {
    const o = 1 - s;
    return 3 * o * o * s * a;
  }(i, e) + function(s, a) {
    return 3 * (1 - s) * s * s * a;
  }(i, n) + function(s, a) {
    return s * s * s * a;
  }(i, r);
}
class jb extends Is {
  constructor(t = new wt(), e = new wt(), n = new wt(), r = new wt()) {
    super(), this.isCubicBezierCurve = !0, this.type = "CubicBezierCurve", this.v0 = t, this.v1 = e, this.v2 = n, this.v3 = r;
  }
  getPoint(t, e = new wt()) {
    const n = e, r = this.v0, s = this.v1, a = this.v2, o = this.v3;
    return n.set(Id(t, r.x, s.x, a.x, o.x), Id(t, r.y, s.y, a.y, o.y)), n;
  }
  copy(t) {
    return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this;
  }
  toJSON() {
    const t = super.toJSON();
    return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t;
  }
  fromJSON(t) {
    return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this;
  }
}
class zI extends Is {
  constructor(t = new D(), e = new D(), n = new D(), r = new D()) {
    super(), this.isCubicBezierCurve3 = !0, this.type = "CubicBezierCurve3", this.v0 = t, this.v1 = e, this.v2 = n, this.v3 = r;
  }
  getPoint(t, e = new D()) {
    const n = e, r = this.v0, s = this.v1, a = this.v2, o = this.v3;
    return n.set(Id(t, r.x, s.x, a.x, o.x), Id(t, r.y, s.y, a.y, o.y), Id(t, r.z, s.z, a.z, o.z)), n;
  }
  copy(t) {
    return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this;
  }
  toJSON() {
    const t = super.toJSON();
    return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t;
  }
  fromJSON(t) {
    return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this;
  }
}
class s0 extends Is {
  constructor(t = new wt(), e = new wt()) {
    super(), this.isLineCurve = !0, this.type = "LineCurve", this.v1 = t, this.v2 = e;
  }
  getPoint(t, e = new wt()) {
    const n = e;
    return t === 1 ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)), n;
  }
  getPointAt(t, e) {
    return this.getPoint(t, e);
  }
  getTangent(t, e) {
    const n = e || new wt();
    return n.copy(this.v2).sub(this.v1).normalize(), n;
  }
  copy(t) {
    return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
  }
  toJSON() {
    const t = super.toJSON();
    return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t;
  }
  fromJSON(t) {
    return super.fromJSON(t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this;
  }
}
class kI extends Is {
  constructor(t = new D(), e = new D()) {
    super(), this.isLineCurve3 = !0, this.type = "LineCurve3", this.v1 = t, this.v2 = e;
  }
  getPoint(t, e = new D()) {
    const n = e;
    return t === 1 ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)), n;
  }
  getPointAt(t, e) {
    return this.getPoint(t, e);
  }
  copy(t) {
    return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
  }
  toJSON() {
    const t = super.toJSON();
    return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t;
  }
  fromJSON(t) {
    return super.fromJSON(t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this;
  }
}
class Gb extends Is {
  constructor(t = new wt(), e = new wt(), n = new wt()) {
    super(), this.isQuadraticBezierCurve = !0, this.type = "QuadraticBezierCurve", this.v0 = t, this.v1 = e, this.v2 = n;
  }
  getPoint(t, e = new wt()) {
    const n = e, r = this.v0, s = this.v1, a = this.v2;
    return n.set(Rd(t, r.x, s.x, a.x), Rd(t, r.y, s.y, a.y)), n;
  }
  copy(t) {
    return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
  }
  toJSON() {
    const t = super.toJSON();
    return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t;
  }
  fromJSON(t) {
    return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this;
  }
}
class Wb extends Is {
  constructor(t = new D(), e = new D(), n = new D()) {
    super(), this.isQuadraticBezierCurve3 = !0, this.type = "QuadraticBezierCurve3", this.v0 = t, this.v1 = e, this.v2 = n;
  }
  getPoint(t, e = new D()) {
    const n = e, r = this.v0, s = this.v1, a = this.v2;
    return n.set(Rd(t, r.x, s.x, a.x), Rd(t, r.y, s.y, a.y), Rd(t, r.z, s.z, a.z)), n;
  }
  copy(t) {
    return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
  }
  toJSON() {
    const t = super.toJSON();
    return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t;
  }
  fromJSON(t) {
    return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this;
  }
}
class Zb extends Is {
  constructor(t = []) {
    super(), this.isSplineCurve = !0, this.type = "SplineCurve", this.points = t;
  }
  getPoint(t, e = new wt()) {
    const n = e, r = this.points, s = (r.length - 1) * t, a = Math.floor(s), o = s - a, l = r[a === 0 ? a : a - 1], c = r[a], u = r[a > r.length - 2 ? r.length - 1 : a + 1], h = r[a > r.length - 3 ? r.length - 1 : a + 2];
    return n.set(wE(o, l.x, c.x, u.x, h.x), wE(o, l.y, c.y, u.y, h.y)), n;
  }
  copy(t) {
    super.copy(t), this.points = [];
    for (let e = 0, n = t.points.length; e < n; e++) {
      const r = t.points[e];
      this.points.push(r.clone());
    }
    return this;
  }
  toJSON() {
    const t = super.toJSON();
    t.points = [];
    for (let e = 0, n = this.points.length; e < n; e++) {
      const r = this.points[e];
      t.points.push(r.toArray());
    }
    return t;
  }
  fromJSON(t) {
    super.fromJSON(t), this.points = [];
    for (let e = 0, n = t.points.length; e < n; e++) {
      const r = t.points[e];
      this.points.push(new wt().fromArray(r));
    }
    return this;
  }
}
var qb = Object.freeze({ __proto__: null, ArcCurve: LI, CatmullRomCurve3: BI, CubicBezierCurve: jb, CubicBezierCurve3: zI, EllipseCurve: bp, LineCurve: s0, LineCurve3: kI, QuadraticBezierCurve: Gb, QuadraticBezierCurve3: Wb, SplineCurve: Zb });
class NI extends Is {
  constructor() {
    super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1;
  }
  add(t) {
    this.curves.push(t);
  }
  closePath() {
    const t = this.curves[0].getPoint(0), e = this.curves[this.curves.length - 1].getPoint(1);
    t.equals(e) || this.curves.push(new s0(e, t));
  }
  getPoint(t, e) {
    const n = t * this.getLength(), r = this.getCurveLengths();
    let s = 0;
    for (; s < r.length; ) {
      if (r[s] >= n) {
        const a = r[s] - n, o = this.curves[s], l = o.getLength(), c = l === 0 ? 0 : 1 - a / l;
        return o.getPointAt(c, e);
      }
      s++;
    }
    return null;
  }
  getLength() {
    const t = this.getCurveLengths();
    return t[t.length - 1];
  }
  updateArcLengths() {
    this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths();
  }
  getCurveLengths() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
      return this.cacheLengths;
    const t = [];
    let e = 0;
    for (let n = 0, r = this.curves.length; n < r; n++)
      e += this.curves[n].getLength(), t.push(e);
    return this.cacheLengths = t, t;
  }
  getSpacedPoints(t = 40) {
    const e = [];
    for (let n = 0; n <= t; n++)
      e.push(this.getPoint(n / t));
    return this.autoClose && e.push(e[0]), e;
  }
  getPoints(t = 12) {
    const e = [];
    let n;
    for (let r = 0, s = this.curves; r < s.length; r++) {
      const a = s[r], o = a.isEllipseCurve ? 2 * t : a.isLineCurve || a.isLineCurve3 ? 1 : a.isSplineCurve ? t * a.points.length : t, l = a.getPoints(o);
      for (let c = 0; c < l.length; c++) {
        const u = l[c];
        n && n.equals(u) || (e.push(u), n = u);
      }
    }
    return this.autoClose && e.length > 1 && !e[e.length - 1].equals(e[0]) && e.push(e[0]), e;
  }
  copy(t) {
    super.copy(t), this.curves = [];
    for (let e = 0, n = t.curves.length; e < n; e++) {
      const r = t.curves[e];
      this.curves.push(r.clone());
    }
    return this.autoClose = t.autoClose, this;
  }
  toJSON() {
    const t = super.toJSON();
    t.autoClose = this.autoClose, t.curves = [];
    for (let e = 0, n = this.curves.length; e < n; e++) {
      const r = this.curves[e];
      t.curves.push(r.toJSON());
    }
    return t;
  }
  fromJSON(t) {
    super.fromJSON(t), this.autoClose = t.autoClose, this.curves = [];
    for (let e = 0, n = t.curves.length; e < n; e++) {
      const r = t.curves[e];
      this.curves.push(new qb[r.type]().fromJSON(r));
    }
    return this;
  }
}
class Jd extends NI {
  constructor(t) {
    super(), this.type = "Path", this.currentPoint = new wt(), t && this.setFromPoints(t);
  }
  setFromPoints(t) {
    this.moveTo(t[0].x, t[0].y);
    for (let e = 1, n = t.length; e < n; e++)
      this.lineTo(t[e].x, t[e].y);
    return this;
  }
  moveTo(t, e) {
    return this.currentPoint.set(t, e), this;
  }
  lineTo(t, e) {
    const n = new s0(this.currentPoint.clone(), new wt(t, e));
    return this.curves.push(n), this.currentPoint.set(t, e), this;
  }
  quadraticCurveTo(t, e, n, r) {
    const s = new Gb(this.currentPoint.clone(), new wt(t, e), new wt(n, r));
    return this.curves.push(s), this.currentPoint.set(n, r), this;
  }
  bezierCurveTo(t, e, n, r, s, a) {
    const o = new jb(this.currentPoint.clone(), new wt(t, e), new wt(n, r), new wt(s, a));
    return this.curves.push(o), this.currentPoint.set(s, a), this;
  }
  splineThru(t) {
    const e = [this.currentPoint.clone()].concat(t), n = new Zb(e);
    return this.curves.push(n), this.currentPoint.copy(t[t.length - 1]), this;
  }
  arc(t, e, n, r, s, a) {
    const o = this.currentPoint.x, l = this.currentPoint.y;
    return this.absarc(t + o, e + l, n, r, s, a), this;
  }
  absarc(t, e, n, r, s, a) {
    return this.absellipse(t, e, n, n, r, s, a), this;
  }
  ellipse(t, e, n, r, s, a, o, l) {
    const c = this.currentPoint.x, u = this.currentPoint.y;
    return this.absellipse(t + c, e + u, n, r, s, a, o, l), this;
  }
  absellipse(t, e, n, r, s, a, o, l) {
    const c = new bp(t, e, n, r, s, a, o, l);
    if (this.curves.length > 0) {
      const h = c.getPoint(0);
      h.equals(this.currentPoint) || this.lineTo(h.x, h.y);
    }
    this.curves.push(c);
    const u = c.getPoint(1);
    return this.currentPoint.copy(u), this;
  }
  copy(t) {
    return super.copy(t), this.currentPoint.copy(t.currentPoint), this;
  }
  toJSON() {
    const t = super.toJSON();
    return t.currentPoint = this.currentPoint.toArray(), t;
  }
  fromJSON(t) {
    return super.fromJSON(t), this.currentPoint.fromArray(t.currentPoint), this;
  }
}
class Uh extends _e {
  constructor(t = [new wt(0, -0.5), new wt(0.5, 0), new wt(0, 0.5)], e = 12, n = 0, r = 2 * Math.PI) {
    super(), this.type = "LatheGeometry", this.parameters = { points: t, segments: e, phiStart: n, phiLength: r }, e = Math.floor(e), r = rr(r, 0, 2 * Math.PI);
    const s = [], a = [], o = [], l = [], c = [], u = 1 / e, h = new D(), p = new wt(), f = new D(), v = new D(), m = new D();
    let y = 0, _ = 0;
    for (let w = 0; w <= t.length - 1; w++)
      switch (w) {
        case 0:
          y = t[w + 1].x - t[w].x, _ = t[w + 1].y - t[w].y, f.x = 1 * _, f.y = -y, f.z = 0 * _, m.copy(f), f.normalize(), l.push(f.x, f.y, f.z);
          break;
        case t.length - 1:
          l.push(m.x, m.y, m.z);
          break;
        default:
          y = t[w + 1].x - t[w].x, _ = t[w + 1].y - t[w].y, f.x = 1 * _, f.y = -y, f.z = 0 * _, v.copy(f), f.x += m.x, f.y += m.y, f.z += m.z, f.normalize(), l.push(f.x, f.y, f.z), m.copy(v);
      }
    for (let w = 0; w <= e; w++) {
      const b = n + w * u * r, T = Math.sin(b), M = Math.cos(b);
      for (let A = 0; A <= t.length - 1; A++) {
        h.x = t[A].x * T, h.y = t[A].y, h.z = t[A].x * M, a.push(h.x, h.y, h.z), p.x = w / e, p.y = A / (t.length - 1), o.push(p.x, p.y);
        const C = l[3 * A + 0] * T, I = l[3 * A + 1], k = l[3 * A + 0] * M;
        c.push(C, I, k);
      }
    }
    for (let w = 0; w < e; w++)
      for (let b = 0; b < t.length - 1; b++) {
        const T = b + w * t.length, M = T, A = T + t.length, C = T + t.length + 1, I = T + 1;
        s.push(M, A, I), s.push(C, I, A);
      }
    this.setIndex(s), this.setAttribute("position", new Wt(a, 3)), this.setAttribute("uv", new Wt(o, 2)), this.setAttribute("normal", new Wt(c, 3));
  }
  static fromJSON(t) {
    return new Uh(t.points, t.segments, t.phiStart, t.phiLength);
  }
}
class Kd extends Uh {
  constructor(t = 1, e = 1, n = 4, r = 8) {
    const s = new Jd();
    s.absarc(0, -e / 2, t, 1.5 * Math.PI, 0), s.absarc(0, e / 2, t, 0, 0.5 * Math.PI), super(s.getPoints(n), r), this.type = "CapsuleGeometry", this.parameters = { radius: t, height: e, capSegments: n, radialSegments: r };
  }
  static fromJSON(t) {
    return new Kd(t.radius, t.length, t.capSegments, t.radialSegments);
  }
}
class $d extends _e {
  constructor(t = 1, e = 32, n = 0, r = 2 * Math.PI) {
    super(), this.type = "CircleGeometry", this.parameters = { radius: t, segments: e, thetaStart: n, thetaLength: r }, e = Math.max(3, e);
    const s = [], a = [], o = [], l = [], c = new D(), u = new wt();
    a.push(0, 0, 0), o.push(0, 0, 1), l.push(0.5, 0.5);
    for (let h = 0, p = 3; h <= e; h++, p += 3) {
      const f = n + h / e * r;
      c.x = t * Math.cos(f), c.y = t * Math.sin(f), a.push(c.x, c.y, c.z), o.push(0, 0, 1), u.x = (a[p] / t + 1) / 2, u.y = (a[p + 1] / t + 1) / 2, l.push(u.x, u.y);
    }
    for (let h = 1; h <= e; h++)
      s.push(h, h + 1, 0);
    this.setIndex(s), this.setAttribute("position", new Wt(a, 3)), this.setAttribute("normal", new Wt(o, 3)), this.setAttribute("uv", new Wt(l, 2));
  }
  static fromJSON(t) {
    return new $d(t.radius, t.segments, t.thetaStart, t.thetaLength);
  }
}
class nr extends _e {
  constructor(t = 1, e = 1, n = 1, r = 32, s = 1, a = !1, o = 0, l = 2 * Math.PI) {
    super(), this.type = "CylinderGeometry", this.parameters = { radiusTop: t, radiusBottom: e, height: n, radialSegments: r, heightSegments: s, openEnded: a, thetaStart: o, thetaLength: l };
    const c = this;
    r = Math.floor(r), s = Math.floor(s);
    const u = [], h = [], p = [], f = [];
    let v = 0;
    const m = [], y = n / 2;
    let _ = 0;
    function w(b) {
      const T = v, M = new wt(), A = new D();
      let C = 0;
      const I = b === !0 ? t : e, k = b === !0 ? 1 : -1;
      for (let L = 1; L <= r; L++)
        h.push(0, y * k, 0), p.push(0, k, 0), f.push(0.5, 0.5), v++;
      const R = v;
      for (let L = 0; L <= r; L++) {
        const E = L / r * l + o, q = Math.cos(E), it = Math.sin(E);
        A.x = I * it, A.y = y * k, A.z = I * q, h.push(A.x, A.y, A.z), p.push(0, k, 0), M.x = 0.5 * q + 0.5, M.y = 0.5 * it * k + 0.5, f.push(M.x, M.y), v++;
      }
      for (let L = 0; L < r; L++) {
        const E = T + L, q = R + L;
        b === !0 ? u.push(q, q + 1, E) : u.push(q + 1, q, E), C += 3;
      }
      c.addGroup(_, C, b === !0 ? 1 : 2), _ += C;
    }
    (function() {
      const b = new D(), T = new D();
      let M = 0;
      const A = (e - t) / n;
      for (let C = 0; C <= s; C++) {
        const I = [], k = C / s, R = k * (e - t) + t;
        for (let L = 0; L <= r; L++) {
          const E = L / r, q = E * l + o, it = Math.sin(q), rt = Math.cos(q);
          T.x = R * it, T.y = -k * n + y, T.z = R * rt, h.push(T.x, T.y, T.z), b.set(it, A, rt).normalize(), p.push(b.x, b.y, b.z), f.push(E, 1 - k), I.push(v++);
        }
        m.push(I);
      }
      for (let C = 0; C < r; C++)
        for (let I = 0; I < s; I++) {
          const k = m[I][C], R = m[I + 1][C], L = m[I + 1][C + 1], E = m[I][C + 1];
          u.push(k, R, E), u.push(R, L, E), M += 6;
        }
      c.addGroup(_, M, 0), _ += M;
    })(), a === !1 && (t > 0 && w(!0), e > 0 && w(!1)), this.setIndex(u), this.setAttribute("position", new Wt(h, 3)), this.setAttribute("normal", new Wt(p, 3)), this.setAttribute("uv", new Wt(f, 2));
  }
  static fromJSON(t) {
    return new nr(t.radiusTop, t.radiusBottom, t.height, t.radialSegments, t.heightSegments, t.openEnded, t.thetaStart, t.thetaLength);
  }
}
class Qd extends nr {
  constructor(t = 1, e = 1, n = 32, r = 1, s = !1, a = 0, o = 2 * Math.PI) {
    super(0, t, e, n, r, s, a, o), this.type = "ConeGeometry", this.parameters = { radius: t, height: e, radialSegments: n, heightSegments: r, openEnded: s, thetaStart: a, thetaLength: o };
  }
  static fromJSON(t) {
    return new Qd(t.radius, t.height, t.radialSegments, t.heightSegments, t.openEnded, t.thetaStart, t.thetaLength);
  }
}
class Za extends _e {
  constructor(t = [], e = [], n = 1, r = 0) {
    super(), this.type = "PolyhedronGeometry", this.parameters = { vertices: t, indices: e, radius: n, detail: r };
    const s = [], a = [];
    function o(p, f, v, m) {
      const y = m + 1, _ = [];
      for (let w = 0; w <= y; w++) {
        _[w] = [];
        const b = p.clone().lerp(v, w / y), T = f.clone().lerp(v, w / y), M = y - w;
        for (let A = 0; A <= M; A++)
          _[w][A] = A === 0 && w === y ? b : b.clone().lerp(T, A / M);
      }
      for (let w = 0; w < y; w++)
        for (let b = 0; b < 2 * (y - w) - 1; b++) {
          const T = Math.floor(b / 2);
          b % 2 == 0 ? (l(_[w][T + 1]), l(_[w + 1][T]), l(_[w][T])) : (l(_[w][T + 1]), l(_[w + 1][T + 1]), l(_[w + 1][T]));
        }
    }
    function l(p) {
      s.push(p.x, p.y, p.z);
    }
    function c(p, f) {
      const v = 3 * p;
      f.x = t[v + 0], f.y = t[v + 1], f.z = t[v + 2];
    }
    function u(p, f, v, m) {
      m < 0 && p.x === 1 && (a[f] = p.x - 1), v.x === 0 && v.z === 0 && (a[f] = m / 2 / Math.PI + 0.5);
    }
    function h(p) {
      return Math.atan2(p.z, -p.x);
    }
    (function(p) {
      const f = new D(), v = new D(), m = new D();
      for (let y = 0; y < e.length; y += 3)
        c(e[y + 0], f), c(e[y + 1], v), c(e[y + 2], m), o(f, v, m, p);
    })(r), function(p) {
      const f = new D();
      for (let v = 0; v < s.length; v += 3)
        f.x = s[v + 0], f.y = s[v + 1], f.z = s[v + 2], f.normalize().multiplyScalar(p), s[v + 0] = f.x, s[v + 1] = f.y, s[v + 2] = f.z;
    }(n), function() {
      const p = new D();
      for (let v = 0; v < s.length; v += 3) {
        p.x = s[v + 0], p.y = s[v + 1], p.z = s[v + 2];
        const m = h(p) / 2 / Math.PI + 0.5, y = (f = p, Math.atan2(-f.y, Math.sqrt(f.x * f.x + f.z * f.z)) / Math.PI + 0.5);
        a.push(m, 1 - y);
      }
      var f;
      (function() {
        const v = new D(), m = new D(), y = new D(), _ = new D(), w = new wt(), b = new wt(), T = new wt();
        for (let M = 0, A = 0; M < s.length; M += 9, A += 6) {
          v.set(s[M + 0], s[M + 1], s[M + 2]), m.set(s[M + 3], s[M + 4], s[M + 5]), y.set(s[M + 6], s[M + 7], s[M + 8]), w.set(a[A + 0], a[A + 1]), b.set(a[A + 2], a[A + 3]), T.set(a[A + 4], a[A + 5]), _.copy(v).add(m).add(y).divideScalar(3);
          const C = h(_);
          u(w, A + 0, v, C), u(b, A + 2, m, C), u(T, A + 4, y, C);
        }
      })(), function() {
        for (let v = 0; v < a.length; v += 6) {
          const m = a[v + 0], y = a[v + 2], _ = a[v + 4], w = Math.max(m, y, _), b = Math.min(m, y, _);
          w > 0.9 && b < 0.1 && (m < 0.2 && (a[v + 0] += 1), y < 0.2 && (a[v + 2] += 1), _ < 0.2 && (a[v + 4] += 1));
        }
      }();
    }(), this.setAttribute("position", new Wt(s, 3)), this.setAttribute("normal", new Wt(s.slice(), 3)), this.setAttribute("uv", new Wt(a, 2)), r === 0 ? this.computeVertexNormals() : this.normalizeNormals();
  }
  static fromJSON(t) {
    return new Za(t.vertices, t.indices, t.radius, t.details);
  }
}
class tp extends Za {
  constructor(t = 1, e = 0) {
    const n = (1 + Math.sqrt(5)) / 2, r = 1 / n;
    super([-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -r, -n, 0, -r, n, 0, r, -n, 0, r, n, -r, -n, 0, -r, n, 0, r, -n, 0, r, n, 0, -n, 0, -r, n, 0, -r, -n, 0, r, n, 0, r], [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], t, e), this.type = "DodecahedronGeometry", this.parameters = { radius: t, detail: e };
  }
  static fromJSON(t) {
    return new tp(t.radius, t.detail);
  }
}
const mm = new D(), gm = new D(), x_ = new D(), vm = new Pr();
class FI extends _e {
  constructor(t = null, e = 1) {
    if (super(), this.type = "EdgesGeometry", this.parameters = { geometry: t, thresholdAngle: e }, t !== null) {
      const r = Math.pow(10, 4), s = Math.cos(Vl * e), a = t.getIndex(), o = t.getAttribute("position"), l = a ? a.count : o.count, c = [0, 0, 0], u = ["a", "b", "c"], h = new Array(3), p = {}, f = [];
      for (let v = 0; v < l; v += 3) {
        a ? (c[0] = a.getX(v), c[1] = a.getX(v + 1), c[2] = a.getX(v + 2)) : (c[0] = v, c[1] = v + 1, c[2] = v + 2);
        const { a: m, b: y, c: _ } = vm;
        if (m.fromBufferAttribute(o, c[0]), y.fromBufferAttribute(o, c[1]), _.fromBufferAttribute(o, c[2]), vm.getNormal(x_), h[0] = `${Math.round(m.x * r)},${Math.round(m.y * r)},${Math.round(m.z * r)}`, h[1] = `${Math.round(y.x * r)},${Math.round(y.y * r)},${Math.round(y.z * r)}`, h[2] = `${Math.round(_.x * r)},${Math.round(_.y * r)},${Math.round(_.z * r)}`, h[0] !== h[1] && h[1] !== h[2] && h[2] !== h[0])
          for (let w = 0; w < 3; w++) {
            const b = (w + 1) % 3, T = h[w], M = h[b], A = vm[u[w]], C = vm[u[b]], I = `${T}_${M}`, k = `${M}_${T}`;
            k in p && p[k] ? (x_.dot(p[k].normal) <= s && (f.push(A.x, A.y, A.z), f.push(C.x, C.y, C.z)), p[k] = null) : I in p || (p[I] = { index0: c[w], index1: c[b], normal: x_.clone() });
          }
      }
      for (const v in p)
        if (p[v]) {
          const { index0: m, index1: y } = p[v];
          mm.fromBufferAttribute(o, m), gm.fromBufferAttribute(o, y), f.push(mm.x, mm.y, mm.z), f.push(gm.x, gm.y, gm.z);
        }
      this.setAttribute("position", new Wt(f, 3));
    }
  }
}
class Rl extends Jd {
  constructor(t) {
    super(t), this.uuid = Vi(), this.type = "Shape", this.holes = [];
  }
  getPointsHoles(t) {
    const e = [];
    for (let n = 0, r = this.holes.length; n < r; n++)
      e[n] = this.holes[n].getPoints(t);
    return e;
  }
  extractPoints(t) {
    return { shape: this.getPoints(t), holes: this.getPointsHoles(t) };
  }
  copy(t) {
    super.copy(t), this.holes = [];
    for (let e = 0, n = t.holes.length; e < n; e++) {
      const r = t.holes[e];
      this.holes.push(r.clone());
    }
    return this;
  }
  toJSON() {
    const t = super.toJSON();
    t.uuid = this.uuid, t.holes = [];
    for (let e = 0, n = this.holes.length; e < n; e++) {
      const r = this.holes[e];
      t.holes.push(r.toJSON());
    }
    return t;
  }
  fromJSON(t) {
    super.fromJSON(t), this.uuid = t.uuid, this.holes = [];
    for (let e = 0, n = t.holes.length; e < n; e++) {
      const r = t.holes[e];
      this.holes.push(new Jd().fromJSON(r));
    }
    return this;
  }
}
const cU = function(i, t, e = 2) {
  const n = t && t.length, r = n ? t[0] * e : i.length;
  let s = xE(i, 0, r, e, !0);
  const a = [];
  if (!s || s.next === s.prev)
    return a;
  let o, l, c, u, h, p, f;
  if (n && (s = function(v, m, y, _) {
    const w = [];
    let b, T, M, A, C;
    for (b = 0, T = m.length; b < T; b++)
      M = m[b] * _, A = b < T - 1 ? m[b + 1] * _ : v.length, C = xE(v, M, A, _, !1), C === C.next && (C.steiner = !0), w.push(vU(C));
    for (w.sort(fU), b = 0; b < w.length; b++)
      y = mU(w[b], y);
    return y;
  }(i, t, s, e)), i.length > 80 * e) {
    o = c = i[0], l = u = i[1];
    for (let v = e; v < r; v += e)
      h = i[v], p = i[v + 1], h < o && (o = h), p < l && (l = p), h > c && (c = h), p > u && (u = p);
    f = Math.max(c - o, u - l), f = f !== 0 ? 32767 / f : 0;
  }
  return ep(s, a, e, o, l, f, 0), a;
};
function xE(i, t, e, n, r) {
  let s, a;
  if (r === function(o, l, c, u) {
    let h = 0;
    for (let p = l, f = c - u; p < c; p += u)
      h += (o[f] - o[p]) * (o[p + 1] + o[f + 1]), f = p;
    return h;
  }(i, t, e, n) > 0)
    for (s = t; s < e; s += n)
      a = bE(s, i[s], i[s + 1], a);
  else
    for (s = e - n; s >= t; s -= n)
      a = bE(s, i[s], i[s + 1], a);
  return a && a0(a, a.next) && (rp(a), a = a.next), a;
}
function Jl(i, t) {
  if (!i)
    return i;
  t || (t = i);
  let e, n = i;
  do
    if (e = !1, n.steiner || !a0(n, n.next) && jn(n.prev, n, n.next) !== 0)
      n = n.next;
    else {
      if (rp(n), n = t = n.prev, n === n.next)
        break;
      e = !0;
    }
  while (e || n !== t);
  return t;
}
function ep(i, t, e, n, r, s, a) {
  if (!i)
    return;
  !a && s && function(u, h, p, f) {
    let v = u;
    do
      v.z === 0 && (v.z = ax(v.x, v.y, h, p, f)), v.prevZ = v.prev, v.nextZ = v.next, v = v.next;
    while (v !== u);
    v.prevZ.nextZ = null, v.prevZ = null, function(m) {
      let y, _, w, b, T, M, A, C, I = 1;
      do {
        for (_ = m, m = null, T = null, M = 0; _; ) {
          for (M++, w = _, A = 0, y = 0; y < I && (A++, w = w.nextZ, w); y++)
            ;
          for (C = I; A > 0 || C > 0 && w; )
            A !== 0 && (C === 0 || !w || _.z <= w.z) ? (b = _, _ = _.nextZ, A--) : (b = w, w = w.nextZ, C--), T ? T.nextZ = b : m = b, b.prevZ = T, T = b;
          _ = w;
        }
        T.nextZ = null, I *= 2;
      } while (M > 1);
    }(v);
  }(i, n, r, s);
  let o, l, c = i;
  for (; i.prev !== i.next; )
    if (o = i.prev, l = i.next, s ? uU(i, n, r, s) : hU(i))
      t.push(o.i / e | 0), t.push(i.i / e | 0), t.push(l.i / e | 0), rp(i), i = l.next, c = l.next;
    else if ((i = l) === c) {
      a ? a === 1 ? ep(i = dU(Jl(i), t, e), t, e, n, r, s, 2) : a === 2 && pU(i, t, e, n, r, s) : ep(Jl(i), t, e, n, r, s, 1);
      break;
    }
}
function hU(i) {
  const t = i.prev, e = i, n = i.next;
  if (jn(t, e, n) >= 0)
    return !1;
  const r = t.x, s = e.x, a = n.x, o = t.y, l = e.y, c = n.y, u = r < s ? r < a ? r : a : s < a ? s : a, h = o < l ? o < c ? o : c : l < c ? l : c, p = r > s ? r > a ? r : a : s > a ? s : a, f = o > l ? o > c ? o : c : l > c ? l : c;
  let v = n.next;
  for (; v !== t; ) {
    if (v.x >= u && v.x <= p && v.y >= h && v.y <= f && wh(r, o, s, l, a, c, v.x, v.y) && jn(v.prev, v, v.next) >= 0)
      return !1;
    v = v.next;
  }
  return !0;
}
function uU(i, t, e, n) {
  const r = i.prev, s = i, a = i.next;
  if (jn(r, s, a) >= 0)
    return !1;
  const o = r.x, l = s.x, c = a.x, u = r.y, h = s.y, p = a.y, f = o < l ? o < c ? o : c : l < c ? l : c, v = u < h ? u < p ? u : p : h < p ? h : p, m = o > l ? o > c ? o : c : l > c ? l : c, y = u > h ? u > p ? u : p : h > p ? h : p, _ = ax(f, v, t, e, n), w = ax(m, y, t, e, n);
  let b = i.prevZ, T = i.nextZ;
  for (; b && b.z >= _ && T && T.z <= w; ) {
    if (b.x >= f && b.x <= m && b.y >= v && b.y <= y && b !== r && b !== a && wh(o, u, l, h, c, p, b.x, b.y) && jn(b.prev, b, b.next) >= 0 || (b = b.prevZ, T.x >= f && T.x <= m && T.y >= v && T.y <= y && T !== r && T !== a && wh(o, u, l, h, c, p, T.x, T.y) && jn(T.prev, T, T.next) >= 0))
      return !1;
    T = T.nextZ;
  }
  for (; b && b.z >= _; ) {
    if (b.x >= f && b.x <= m && b.y >= v && b.y <= y && b !== r && b !== a && wh(o, u, l, h, c, p, b.x, b.y) && jn(b.prev, b, b.next) >= 0)
      return !1;
    b = b.prevZ;
  }
  for (; T && T.z <= w; ) {
    if (T.x >= f && T.x <= m && T.y >= v && T.y <= y && T !== r && T !== a && wh(o, u, l, h, c, p, T.x, T.y) && jn(T.prev, T, T.next) >= 0)
      return !1;
    T = T.nextZ;
  }
  return !0;
}
function dU(i, t, e) {
  let n = i;
  do {
    const r = n.prev, s = n.next.next;
    !a0(r, s) && UI(r, n, n.next, s) && np(r, s) && np(s, r) && (t.push(r.i / e | 0), t.push(n.i / e | 0), t.push(s.i / e | 0), rp(n), rp(n.next), n = i = s), n = n.next;
  } while (n !== i);
  return Jl(n);
}
function pU(i, t, e, n, r, s) {
  let a = i;
  do {
    let o = a.next.next;
    for (; o !== a.prev; ) {
      if (a.i !== o.i && yU(a, o)) {
        let l = VI(a, o);
        return a = Jl(a, a.next), l = Jl(l, l.next), ep(a, t, e, n, r, s, 0), void ep(l, t, e, n, r, s, 0);
      }
      o = o.next;
    }
    a = a.next;
  } while (a !== i);
}
function fU(i, t) {
  return i.x - t.x;
}
function mU(i, t) {
  const e = function(r, s) {
    let a, o = s, l = -1 / 0;
    const c = r.x, u = r.y;
    do {
      if (u <= o.y && u >= o.next.y && o.next.y !== o.y) {
        const y = o.x + (u - o.y) * (o.next.x - o.x) / (o.next.y - o.y);
        if (y <= c && y > l && (l = y, a = o.x < o.next.x ? o : o.next, y === c))
          return a;
      }
      o = o.next;
    } while (o !== s);
    if (!a)
      return null;
    const h = a, p = a.x, f = a.y;
    let v, m = 1 / 0;
    o = a;
    do
      c >= o.x && o.x >= p && c !== o.x && wh(u < f ? c : l, u, p, f, u < f ? l : c, u, o.x, o.y) && (v = Math.abs(u - o.y) / (c - o.x), np(o, r) && (v < m || v === m && (o.x > a.x || o.x === a.x && gU(a, o))) && (a = o, m = v)), o = o.next;
    while (o !== h);
    return a;
  }(i, t);
  if (!e)
    return t;
  const n = VI(e, i);
  return Jl(n, n.next), Jl(e, e.next);
}
function gU(i, t) {
  return jn(i.prev, i, t.prev) < 0 && jn(t.next, i, i.next) < 0;
}
function ax(i, t, e, n, r) {
  return (i = 1431655765 & ((i = 858993459 & ((i = 252645135 & ((i = 16711935 & ((i = (i - e) * r | 0) | i << 8)) | i << 4)) | i << 2)) | i << 1)) | (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = (t - n) * r | 0) | t << 8)) | t << 4)) | t << 2)) | t << 1)) << 1;
}
function vU(i) {
  let t = i, e = i;
  do
    (t.x < e.x || t.x === e.x && t.y < e.y) && (e = t), t = t.next;
  while (t !== i);
  return e;
}
function wh(i, t, e, n, r, s, a, o) {
  return (r - a) * (t - o) >= (i - a) * (s - o) && (i - a) * (n - o) >= (e - a) * (t - o) && (e - a) * (s - o) >= (r - a) * (n - o);
}
function yU(i, t) {
  return i.next.i !== t.i && i.prev.i !== t.i && !function(e, n) {
    let r = e;
    do {
      if (r.i !== e.i && r.next.i !== e.i && r.i !== n.i && r.next.i !== n.i && UI(r, r.next, e, n))
        return !0;
      r = r.next;
    } while (r !== e);
    return !1;
  }(i, t) && (np(i, t) && np(t, i) && function(e, n) {
    let r = e, s = !1;
    const a = (e.x + n.x) / 2, o = (e.y + n.y) / 2;
    do
      r.y > o != r.next.y > o && r.next.y !== r.y && a < (r.next.x - r.x) * (o - r.y) / (r.next.y - r.y) + r.x && (s = !s), r = r.next;
    while (r !== e);
    return s;
  }(i, t) && (jn(i.prev, i, t.prev) || jn(i, t.prev, t)) || a0(i, t) && jn(i.prev, i, i.next) > 0 && jn(t.prev, t, t.next) > 0);
}
function jn(i, t, e) {
  return (t.y - i.y) * (e.x - t.x) - (t.x - i.x) * (e.y - t.y);
}
function a0(i, t) {
  return i.x === t.x && i.y === t.y;
}
function UI(i, t, e, n) {
  const r = _m(jn(i, t, e)), s = _m(jn(i, t, n)), a = _m(jn(e, n, i)), o = _m(jn(e, n, t));
  return r !== s && a !== o || !(r !== 0 || !ym(i, e, t)) || !(s !== 0 || !ym(i, n, t)) || !(a !== 0 || !ym(e, i, n)) || !(o !== 0 || !ym(e, t, n));
}
function ym(i, t, e) {
  return t.x <= Math.max(i.x, e.x) && t.x >= Math.min(i.x, e.x) && t.y <= Math.max(i.y, e.y) && t.y >= Math.min(i.y, e.y);
}
function _m(i) {
  return i > 0 ? 1 : i < 0 ? -1 : 0;
}
function np(i, t) {
  return jn(i.prev, i, i.next) < 0 ? jn(i, t, i.next) >= 0 && jn(i, i.prev, t) >= 0 : jn(i, t, i.prev) < 0 || jn(i, i.next, t) < 0;
}
function VI(i, t) {
  const e = new ox(i.i, i.x, i.y), n = new ox(t.i, t.x, t.y), r = i.next, s = t.prev;
  return i.next = t, t.prev = i, e.next = r, r.prev = e, n.next = e, e.prev = n, s.next = n, n.prev = s, n;
}
function bE(i, t, e, n) {
  const r = new ox(i, t, e);
  return n ? (r.next = n.next, r.prev = n, n.next.prev = r, n.next = r) : (r.prev = r, r.next = r), r;
}
function rp(i) {
  i.next.prev = i.prev, i.prev.next = i.next, i.prevZ && (i.prevZ.nextZ = i.nextZ), i.nextZ && (i.nextZ.prevZ = i.prevZ);
}
function ox(i, t, e) {
  this.i = i, this.x = t, this.y = e, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1;
}
class na {
  static area(t) {
    const e = t.length;
    let n = 0;
    for (let r = e - 1, s = 0; s < e; r = s++)
      n += t[r].x * t[s].y - t[s].x * t[r].y;
    return 0.5 * n;
  }
  static isClockWise(t) {
    return na.area(t) < 0;
  }
  static triangulateShape(t, e) {
    const n = [], r = [], s = [];
    SE(t), ME(n, t);
    let a = t.length;
    e.forEach(SE);
    for (let l = 0; l < e.length; l++)
      r.push(a), a += e[l].length, ME(n, e[l]);
    const o = cU(n, r);
    for (let l = 0; l < o.length; l += 3)
      s.push(o.slice(l, l + 3));
    return s;
  }
}
function SE(i) {
  const t = i.length;
  t > 2 && i[t - 1].equals(i[0]) && i.pop();
}
function ME(i, t) {
  for (let e = 0; e < t.length; e++)
    i.push(t[e].x), i.push(t[e].y);
}
class ip extends _e {
  constructor(t = new Rl([new wt(0.5, 0.5), new wt(-0.5, 0.5), new wt(-0.5, -0.5), new wt(0.5, -0.5)]), e = {}) {
    super(), this.type = "ExtrudeGeometry", this.parameters = { shapes: t, options: e }, t = Array.isArray(t) ? t : [t];
    const n = this, r = [], s = [];
    for (let o = 0, l = t.length; o < l; o++)
      a(t[o]);
    function a(o) {
      const l = [], c = e.curveSegments !== void 0 ? e.curveSegments : 12, u = e.steps !== void 0 ? e.steps : 1, h = e.depth !== void 0 ? e.depth : 1;
      let p = e.bevelEnabled === void 0 || e.bevelEnabled, f = e.bevelThickness !== void 0 ? e.bevelThickness : 0.2, v = e.bevelSize !== void 0 ? e.bevelSize : f - 0.1, m = e.bevelOffset !== void 0 ? e.bevelOffset : 0, y = e.bevelSegments !== void 0 ? e.bevelSegments : 3;
      const _ = e.extrudePath, w = e.UVGenerator !== void 0 ? e.UVGenerator : _U;
      let b, T, M, A, C, I = !1;
      _ && (b = _.getSpacedPoints(u), I = !0, p = !1, T = _.computeFrenetFrames(u, !1), M = new D(), A = new D(), C = new D()), p || (y = 0, f = 0, v = 0, m = 0);
      const k = o.extractPoints(c);
      let R = k.shape;
      const L = k.holes;
      if (!na.isClockWise(R)) {
        R = R.reverse();
        for (let et = 0, J = L.length; et < J; et++) {
          const K = L[et];
          na.isClockWise(K) && (L[et] = K.reverse());
        }
      }
      const E = na.triangulateShape(R, L), q = R;
      for (let et = 0, J = L.length; et < J; et++) {
        const K = L[et];
        R = R.concat(K);
      }
      function it(et, J, K) {
        return J || console.error("THREE.ExtrudeGeometry: vec does not exist"), J.clone().multiplyScalar(K).add(et);
      }
      const rt = R.length, ft = E.length;
      function nt(et, J, K) {
        let S, Z, G;
        const F = et.x - J.x, z = et.y - J.y, Y = K.x - et.x, pt = K.y - et.y, ht = F * F + z * z, lt = F * pt - z * Y;
        if (Math.abs(lt) > Number.EPSILON) {
          const yt = Math.sqrt(ht), O = Math.sqrt(Y * Y + pt * pt), V = J.x - z / yt, tt = J.y + F / yt, gt = ((K.x - pt / O - V) * pt - (K.y + Y / O - tt) * Y) / (F * pt - z * Y);
          S = V + F * gt - et.x, Z = tt + z * gt - et.y;
          const Tt = S * S + Z * Z;
          if (Tt <= 2)
            return new wt(S, Z);
          G = Math.sqrt(Tt / 2);
        } else {
          let yt = !1;
          F > Number.EPSILON ? Y > Number.EPSILON && (yt = !0) : F < -Number.EPSILON ? Y < -Number.EPSILON && (yt = !0) : Math.sign(z) === Math.sign(pt) && (yt = !0), yt ? (S = -z, Z = F, G = Math.sqrt(ht)) : (S = F, Z = z, G = Math.sqrt(ht / 2));
        }
        return new wt(S / G, Z / G);
      }
      const vt = [];
      for (let et = 0, J = q.length, K = J - 1, S = et + 1; et < J; et++, K++, S++)
        K === J && (K = 0), S === J && (S = 0), vt[et] = nt(q[et], q[K], q[S]);
      const $ = [];
      let W, ct = vt.concat();
      for (let et = 0, J = L.length; et < J; et++) {
        const K = L[et];
        W = [];
        for (let S = 0, Z = K.length, G = Z - 1, F = S + 1; S < Z; S++, G++, F++)
          G === Z && (G = 0), F === Z && (F = 0), W[S] = nt(K[S], K[G], K[F]);
        $.push(W), ct = ct.concat(W);
      }
      for (let et = 0; et < y; et++) {
        const J = et / y, K = f * Math.cos(J * Math.PI / 2), S = v * Math.sin(J * Math.PI / 2) + m;
        for (let Z = 0, G = q.length; Z < G; Z++) {
          const F = it(q[Z], vt[Z], S);
          Mt(F.x, F.y, -K);
        }
        for (let Z = 0, G = L.length; Z < G; Z++) {
          const F = L[Z];
          W = $[Z];
          for (let z = 0, Y = F.length; z < Y; z++) {
            const pt = it(F[z], W[z], S);
            Mt(pt.x, pt.y, -K);
          }
        }
      }
      const mt = v + m;
      for (let et = 0; et < rt; et++) {
        const J = p ? it(R[et], ct[et], mt) : R[et];
        I ? (A.copy(T.normals[0]).multiplyScalar(J.x), M.copy(T.binormals[0]).multiplyScalar(J.y), C.copy(b[0]).add(A).add(M), Mt(C.x, C.y, C.z)) : Mt(J.x, J.y, 0);
      }
      for (let et = 1; et <= u; et++)
        for (let J = 0; J < rt; J++) {
          const K = p ? it(R[J], ct[J], mt) : R[J];
          I ? (A.copy(T.normals[et]).multiplyScalar(K.x), M.copy(T.binormals[et]).multiplyScalar(K.y), C.copy(b[et]).add(A).add(M), Mt(C.x, C.y, C.z)) : Mt(K.x, K.y, h / u * et);
        }
      for (let et = y - 1; et >= 0; et--) {
        const J = et / y, K = f * Math.cos(J * Math.PI / 2), S = v * Math.sin(J * Math.PI / 2) + m;
        for (let Z = 0, G = q.length; Z < G; Z++) {
          const F = it(q[Z], vt[Z], S);
          Mt(F.x, F.y, h + K);
        }
        for (let Z = 0, G = L.length; Z < G; Z++) {
          const F = L[Z];
          W = $[Z];
          for (let z = 0, Y = F.length; z < Y; z++) {
            const pt = it(F[z], W[z], S);
            I ? Mt(pt.x, pt.y + b[u - 1].y, b[u - 1].x + K) : Mt(pt.x, pt.y, h + K);
          }
        }
      }
      function dt(et, J) {
        let K = et.length;
        for (; --K >= 0; ) {
          const S = K;
          let Z = K - 1;
          Z < 0 && (Z = et.length - 1);
          for (let G = 0, F = u + 2 * y; G < F; G++) {
            const z = rt * G, Y = rt * (G + 1);
            H(J + S + z, J + Z + z, J + Z + Y, J + S + Y);
          }
        }
      }
      function Mt(et, J, K) {
        l.push(et), l.push(J), l.push(K);
      }
      function At(et, J, K) {
        N(et), N(J), N(K);
        const S = r.length / 3, Z = w.generateTopUV(n, r, S - 3, S - 2, S - 1);
        st(Z[0]), st(Z[1]), st(Z[2]);
      }
      function H(et, J, K, S) {
        N(et), N(J), N(S), N(J), N(K), N(S);
        const Z = r.length / 3, G = w.generateSideWallUV(n, r, Z - 6, Z - 3, Z - 2, Z - 1);
        st(G[0]), st(G[1]), st(G[3]), st(G[1]), st(G[2]), st(G[3]);
      }
      function N(et) {
        r.push(l[3 * et + 0]), r.push(l[3 * et + 1]), r.push(l[3 * et + 2]);
      }
      function st(et) {
        s.push(et.x), s.push(et.y);
      }
      (function() {
        const et = r.length / 3;
        if (p) {
          let J = 0, K = rt * J;
          for (let S = 0; S < ft; S++) {
            const Z = E[S];
            At(Z[2] + K, Z[1] + K, Z[0] + K);
          }
          J = u + 2 * y, K = rt * J;
          for (let S = 0; S < ft; S++) {
            const Z = E[S];
            At(Z[0] + K, Z[1] + K, Z[2] + K);
          }
        } else {
          for (let J = 0; J < ft; J++) {
            const K = E[J];
            At(K[2], K[1], K[0]);
          }
          for (let J = 0; J < ft; J++) {
            const K = E[J];
            At(K[0] + rt * u, K[1] + rt * u, K[2] + rt * u);
          }
        }
        n.addGroup(et, r.length / 3 - et, 0);
      })(), function() {
        const et = r.length / 3;
        let J = 0;
        dt(q, J), J += q.length;
        for (let K = 0, S = L.length; K < S; K++) {
          const Z = L[K];
          dt(Z, J), J += Z.length;
        }
        n.addGroup(et, r.length / 3 - et, 1);
      }();
    }
    this.setAttribute("position", new Wt(r, 3)), this.setAttribute("uv", new Wt(s, 2)), this.computeVertexNormals();
  }
  toJSON() {
    const t = super.toJSON();
    return function(e, n, r) {
      if (r.shapes = [], Array.isArray(e))
        for (let s = 0, a = e.length; s < a; s++) {
          const o = e[s];
          r.shapes.push(o.uuid);
        }
      else
        r.shapes.push(e.uuid);
      return r.options = Object.assign({}, n), n.extrudePath !== void 0 && (r.options.extrudePath = n.extrudePath.toJSON()), r;
    }(this.parameters.shapes, this.parameters.options, t);
  }
  static fromJSON(t, e) {
    const n = [];
    for (let s = 0, a = t.shapes.length; s < a; s++) {
      const o = e[t.shapes[s]];
      n.push(o);
    }
    const r = t.options.extrudePath;
    return r !== void 0 && (t.options.extrudePath = new qb[r.type]().fromJSON(r)), new ip(n, t.options);
  }
}
const _U = { generateTopUV: function(i, t, e, n, r) {
  const s = t[3 * e], a = t[3 * e + 1], o = t[3 * n], l = t[3 * n + 1], c = t[3 * r], u = t[3 * r + 1];
  return [new wt(s, a), new wt(o, l), new wt(c, u)];
}, generateSideWallUV: function(i, t, e, n, r, s) {
  const a = t[3 * e], o = t[3 * e + 1], l = t[3 * e + 2], c = t[3 * n], u = t[3 * n + 1], h = t[3 * n + 2], p = t[3 * r], f = t[3 * r + 1], v = t[3 * r + 2], m = t[3 * s], y = t[3 * s + 1], _ = t[3 * s + 2];
  return Math.abs(o - u) < Math.abs(a - c) ? [new wt(a, 1 - l), new wt(c, 1 - h), new wt(p, 1 - v), new wt(m, 1 - _)] : [new wt(o, 1 - l), new wt(u, 1 - h), new wt(f, 1 - v), new wt(y, 1 - _)];
} };
class sp extends Za {
  constructor(t = 1, e = 0) {
    const n = (1 + Math.sqrt(5)) / 2;
    super([-1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, 0, 0, -1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, n, 0, -1, n, 0, 1, -n, 0, -1, -n, 0, 1], [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], t, e), this.type = "IcosahedronGeometry", this.parameters = { radius: t, detail: e };
  }
  static fromJSON(t) {
    return new sp(t.radius, t.detail);
  }
}
class ea extends Za {
  constructor(t = 1, e = 0) {
    super([1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], t, e), this.type = "OctahedronGeometry", this.parameters = { radius: t, detail: e };
  }
  static fromJSON(t) {
    return new ea(t.radius, t.detail);
  }
}
class ap extends _e {
  constructor(t = 0.5, e = 1, n = 32, r = 1, s = 0, a = 2 * Math.PI) {
    super(), this.type = "RingGeometry", this.parameters = { innerRadius: t, outerRadius: e, thetaSegments: n, phiSegments: r, thetaStart: s, thetaLength: a }, n = Math.max(3, n);
    const o = [], l = [], c = [], u = [];
    let h = t;
    const p = (e - t) / (r = Math.max(1, r)), f = new D(), v = new wt();
    for (let m = 0; m <= r; m++) {
      for (let y = 0; y <= n; y++) {
        const _ = s + y / n * a;
        f.x = h * Math.cos(_), f.y = h * Math.sin(_), l.push(f.x, f.y, f.z), c.push(0, 0, 1), v.x = (f.x / e + 1) / 2, v.y = (f.y / e + 1) / 2, u.push(v.x, v.y);
      }
      h += p;
    }
    for (let m = 0; m < r; m++) {
      const y = m * (n + 1);
      for (let _ = 0; _ < n; _++) {
        const w = _ + y, b = w, T = w + n + 1, M = w + n + 2, A = w + 1;
        o.push(b, T, A), o.push(T, M, A);
      }
    }
    this.setIndex(o), this.setAttribute("position", new Wt(l, 3)), this.setAttribute("normal", new Wt(c, 3)), this.setAttribute("uv", new Wt(u, 2));
  }
  static fromJSON(t) {
    return new ap(t.innerRadius, t.outerRadius, t.thetaSegments, t.phiSegments, t.thetaStart, t.thetaLength);
  }
}
class op extends _e {
  constructor(t = new Rl([new wt(0, 0.5), new wt(-0.5, -0.5), new wt(0.5, -0.5)]), e = 12) {
    super(), this.type = "ShapeGeometry", this.parameters = { shapes: t, curveSegments: e };
    const n = [], r = [], s = [], a = [];
    let o = 0, l = 0;
    if (Array.isArray(t) === !1)
      c(t);
    else
      for (let u = 0; u < t.length; u++)
        c(t[u]), this.addGroup(o, l, u), o += l, l = 0;
    function c(u) {
      const h = r.length / 3, p = u.extractPoints(e);
      let f = p.shape;
      const v = p.holes;
      na.isClockWise(f) === !1 && (f = f.reverse());
      for (let y = 0, _ = v.length; y < _; y++) {
        const w = v[y];
        na.isClockWise(w) === !0 && (v[y] = w.reverse());
      }
      const m = na.triangulateShape(f, v);
      for (let y = 0, _ = v.length; y < _; y++) {
        const w = v[y];
        f = f.concat(w);
      }
      for (let y = 0, _ = f.length; y < _; y++) {
        const w = f[y];
        r.push(w.x, w.y, 0), s.push(0, 0, 1), a.push(w.x, w.y);
      }
      for (let y = 0, _ = m.length; y < _; y++) {
        const w = m[y], b = w[0] + h, T = w[1] + h, M = w[2] + h;
        n.push(b, T, M), l += 3;
      }
    }
    this.setIndex(n), this.setAttribute("position", new Wt(r, 3)), this.setAttribute("normal", new Wt(s, 3)), this.setAttribute("uv", new Wt(a, 2));
  }
  toJSON() {
    const t = super.toJSON();
    return function(e, n) {
      if (n.shapes = [], Array.isArray(e))
        for (let r = 0, s = e.length; r < s; r++) {
          const a = e[r];
          n.shapes.push(a.uuid);
        }
      else
        n.shapes.push(e.uuid);
      return n;
    }(this.parameters.shapes, t);
  }
  static fromJSON(t, e) {
    const n = [];
    for (let r = 0, s = t.shapes.length; r < s; r++) {
      const a = e[t.shapes[r]];
      n.push(a);
    }
    return new op(n, t.curveSegments);
  }
}
class Va extends _e {
  constructor(t = 1, e = 32, n = 16, r = 0, s = 2 * Math.PI, a = 0, o = Math.PI) {
    super(), this.type = "SphereGeometry", this.parameters = { radius: t, widthSegments: e, heightSegments: n, phiStart: r, phiLength: s, thetaStart: a, thetaLength: o }, e = Math.max(3, Math.floor(e)), n = Math.max(2, Math.floor(n));
    const l = Math.min(a + o, Math.PI);
    let c = 0;
    const u = [], h = new D(), p = new D(), f = [], v = [], m = [], y = [];
    for (let _ = 0; _ <= n; _++) {
      const w = [], b = _ / n;
      let T = 0;
      _ == 0 && a == 0 ? T = 0.5 / e : _ == n && l == Math.PI && (T = -0.5 / e);
      for (let M = 0; M <= e; M++) {
        const A = M / e;
        h.x = -t * Math.cos(r + A * s) * Math.sin(a + b * o), h.y = t * Math.cos(a + b * o), h.z = t * Math.sin(r + A * s) * Math.sin(a + b * o), v.push(h.x, h.y, h.z), p.copy(h).normalize(), m.push(p.x, p.y, p.z), y.push(A + T, 1 - b), w.push(c++);
      }
      u.push(w);
    }
    for (let _ = 0; _ < n; _++)
      for (let w = 0; w < e; w++) {
        const b = u[_][w + 1], T = u[_][w], M = u[_ + 1][w], A = u[_ + 1][w + 1];
        (_ !== 0 || a > 0) && f.push(b, T, A), (_ !== n - 1 || l < Math.PI) && f.push(T, M, A);
      }
    this.setIndex(f), this.setAttribute("position", new Wt(v, 3)), this.setAttribute("normal", new Wt(m, 3)), this.setAttribute("uv", new Wt(y, 2));
  }
  static fromJSON(t) {
    return new Va(t.radius, t.widthSegments, t.heightSegments, t.phiStart, t.phiLength, t.thetaStart, t.thetaLength);
  }
}
class lp extends Za {
  constructor(t = 1, e = 0) {
    super([1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], t, e), this.type = "TetrahedronGeometry", this.parameters = { radius: t, detail: e };
  }
  static fromJSON(t) {
    return new lp(t.radius, t.detail);
  }
}
class $s extends _e {
  constructor(t = 1, e = 0.4, n = 12, r = 48, s = 2 * Math.PI) {
    super(), this.type = "TorusGeometry", this.parameters = { radius: t, tube: e, radialSegments: n, tubularSegments: r, arc: s }, n = Math.floor(n), r = Math.floor(r);
    const a = [], o = [], l = [], c = [], u = new D(), h = new D(), p = new D();
    for (let f = 0; f <= n; f++)
      for (let v = 0; v <= r; v++) {
        const m = v / r * s, y = f / n * Math.PI * 2;
        h.x = (t + e * Math.cos(y)) * Math.cos(m), h.y = (t + e * Math.cos(y)) * Math.sin(m), h.z = e * Math.sin(y), o.push(h.x, h.y, h.z), u.x = t * Math.cos(m), u.y = t * Math.sin(m), p.subVectors(h, u).normalize(), l.push(p.x, p.y, p.z), c.push(v / r), c.push(f / n);
      }
    for (let f = 1; f <= n; f++)
      for (let v = 1; v <= r; v++) {
        const m = (r + 1) * f + v - 1, y = (r + 1) * (f - 1) + v - 1, _ = (r + 1) * (f - 1) + v, w = (r + 1) * f + v;
        a.push(m, y, w), a.push(y, _, w);
      }
    this.setIndex(a), this.setAttribute("position", new Wt(o, 3)), this.setAttribute("normal", new Wt(l, 3)), this.setAttribute("uv", new Wt(c, 2));
  }
  static fromJSON(t) {
    return new $s(t.radius, t.tube, t.radialSegments, t.tubularSegments, t.arc);
  }
}
class cp extends _e {
  constructor(t = 1, e = 0.4, n = 64, r = 8, s = 2, a = 3) {
    super(), this.type = "TorusKnotGeometry", this.parameters = { radius: t, tube: e, tubularSegments: n, radialSegments: r, p: s, q: a }, n = Math.floor(n), r = Math.floor(r);
    const o = [], l = [], c = [], u = [], h = new D(), p = new D(), f = new D(), v = new D(), m = new D(), y = new D(), _ = new D();
    for (let b = 0; b <= n; ++b) {
      const T = b / n * s * Math.PI * 2;
      w(T, s, a, t, f), w(T + 0.01, s, a, t, v), y.subVectors(v, f), _.addVectors(v, f), m.crossVectors(y, _), _.crossVectors(m, y), m.normalize(), _.normalize();
      for (let M = 0; M <= r; ++M) {
        const A = M / r * Math.PI * 2, C = -e * Math.cos(A), I = e * Math.sin(A);
        h.x = f.x + (C * _.x + I * m.x), h.y = f.y + (C * _.y + I * m.y), h.z = f.z + (C * _.z + I * m.z), l.push(h.x, h.y, h.z), p.subVectors(h, f).normalize(), c.push(p.x, p.y, p.z), u.push(b / n), u.push(M / r);
      }
    }
    for (let b = 1; b <= n; b++)
      for (let T = 1; T <= r; T++) {
        const M = (r + 1) * (b - 1) + (T - 1), A = (r + 1) * b + (T - 1), C = (r + 1) * b + T, I = (r + 1) * (b - 1) + T;
        o.push(M, A, I), o.push(A, C, I);
      }
    function w(b, T, M, A, C) {
      const I = Math.cos(b), k = Math.sin(b), R = M / T * b, L = Math.cos(R);
      C.x = A * (2 + L) * 0.5 * I, C.y = A * (2 + L) * k * 0.5, C.z = A * Math.sin(R) * 0.5;
    }
    this.setIndex(o), this.setAttribute("position", new Wt(l, 3)), this.setAttribute("normal", new Wt(c, 3)), this.setAttribute("uv", new Wt(u, 2));
  }
  static fromJSON(t) {
    return new cp(t.radius, t.tube, t.tubularSegments, t.radialSegments, t.p, t.q);
  }
}
class hp extends _e {
  constructor(t = new Wb(new D(-1, -1, 0), new D(-1, 1, 0), new D(1, 1, 0)), e = 64, n = 1, r = 8, s = !1) {
    super(), this.type = "TubeGeometry", this.parameters = { path: t, tubularSegments: e, radius: n, radialSegments: r, closed: s };
    const a = t.computeFrenetFrames(e, s);
    this.tangents = a.tangents, this.normals = a.normals, this.binormals = a.binormals;
    const o = new D(), l = new D(), c = new wt();
    let u = new D();
    const h = [], p = [], f = [], v = [];
    function m(y) {
      u = t.getPointAt(y / e, u);
      const _ = a.normals[y], w = a.binormals[y];
      for (let b = 0; b <= r; b++) {
        const T = b / r * Math.PI * 2, M = Math.sin(T), A = -Math.cos(T);
        l.x = A * _.x + M * w.x, l.y = A * _.y + M * w.y, l.z = A * _.z + M * w.z, l.normalize(), p.push(l.x, l.y, l.z), o.x = u.x + n * l.x, o.y = u.y + n * l.y, o.z = u.z + n * l.z, h.push(o.x, o.y, o.z);
      }
    }
    (function() {
      for (let y = 0; y < e; y++)
        m(y);
      m(s === !1 ? e : 0), function() {
        for (let y = 0; y <= e; y++)
          for (let _ = 0; _ <= r; _++)
            c.x = y / e, c.y = _ / r, f.push(c.x, c.y);
      }(), function() {
        for (let y = 1; y <= e; y++)
          for (let _ = 1; _ <= r; _++) {
            const w = (r + 1) * (y - 1) + (_ - 1), b = (r + 1) * y + (_ - 1), T = (r + 1) * y + _, M = (r + 1) * (y - 1) + _;
            v.push(w, b, M), v.push(b, T, M);
          }
      }();
    })(), this.setIndex(v), this.setAttribute("position", new Wt(h, 3)), this.setAttribute("normal", new Wt(p, 3)), this.setAttribute("uv", new Wt(f, 2));
  }
  toJSON() {
    const t = super.toJSON();
    return t.path = this.parameters.path.toJSON(), t;
  }
  static fromJSON(t) {
    return new hp(new qb[t.path.type]().fromJSON(t.path), t.tubularSegments, t.radius, t.radialSegments, t.closed);
  }
}
class Xb extends _e {
  constructor(t = null) {
    if (super(), this.type = "WireframeGeometry", this.parameters = { geometry: t }, t !== null) {
      const e = [], n = /* @__PURE__ */ new Set(), r = new D(), s = new D();
      if (t.index !== null) {
        const a = t.attributes.position, o = t.index;
        let l = t.groups;
        l.length === 0 && (l = [{ start: 0, count: o.count, materialIndex: 0 }]);
        for (let c = 0, u = l.length; c < u; ++c) {
          const h = l[c], p = h.start;
          for (let f = p, v = p + h.count; f < v; f += 3)
            for (let m = 0; m < 3; m++) {
              const y = o.getX(f + m), _ = o.getX(f + (m + 1) % 3);
              r.fromBufferAttribute(a, y), s.fromBufferAttribute(a, _), TE(r, s, n) === !0 && (e.push(r.x, r.y, r.z), e.push(s.x, s.y, s.z));
            }
        }
      } else {
        const a = t.attributes.position;
        for (let o = 0, l = a.count / 3; o < l; o++)
          for (let c = 0; c < 3; c++) {
            const u = 3 * o + c, h = 3 * o + (c + 1) % 3;
            r.fromBufferAttribute(a, u), s.fromBufferAttribute(a, h), TE(r, s, n) === !0 && (e.push(r.x, r.y, r.z), e.push(s.x, s.y, s.z));
          }
      }
      this.setAttribute("position", new Wt(e, 3));
    }
  }
}
function TE(i, t, e) {
  const n = `${i.x},${i.y},${i.z}-${t.x},${t.y},${t.z}`, r = `${t.x},${t.y},${t.z}-${i.x},${i.y},${i.z}`;
  return e.has(n) !== !0 && e.has(r) !== !0 && (e.add(n), e.add(r), !0);
}
var EE = Object.freeze({ __proto__: null, BoxGeometry: zn, CapsuleGeometry: Kd, CircleGeometry: $d, ConeGeometry: Qd, CylinderGeometry: nr, DodecahedronGeometry: tp, EdgesGeometry: FI, ExtrudeGeometry: ip, IcosahedronGeometry: sp, LatheGeometry: Uh, OctahedronGeometry: ea, PlaneGeometry: Wa, PolyhedronGeometry: Za, RingGeometry: ap, ShapeGeometry: op, SphereGeometry: Va, TetrahedronGeometry: lp, TorusGeometry: $s, TorusKnotGeometry: cp, TubeGeometry: hp, WireframeGeometry: Xb });
class HI extends Kr {
  constructor(t) {
    super(), this.isShadowMaterial = !0, this.type = "ShadowMaterial", this.color = new Ht(0), this.transparent = !0, this.fog = !0, this.setValues(t);
  }
  copy(t) {
    return super.copy(t), this.color.copy(t.color), this.fog = t.fog, this;
  }
}
class jI extends Gn {
  constructor(t) {
    super(t), this.isRawShaderMaterial = !0, this.type = "RawShaderMaterial";
  }
}
class Ds extends Kr {
  constructor(t) {
    super(), this.isMeshStandardMaterial = !0, this.defines = { STANDARD: "" }, this.type = "MeshStandardMaterial", this.color = new Ht(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Ht(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new wt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(t);
  }
  copy(t) {
    return super.copy(t), this.defines = { STANDARD: "" }, this.color.copy(t.color), this.roughness = t.roughness, this.metalness = t.metalness, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.roughnessMap = t.roughnessMap, this.metalnessMap = t.metalnessMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapIntensity = t.envMapIntensity, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.flatShading = t.flatShading, this.fog = t.fog, this;
  }
}
class GI extends Ds {
  constructor(t) {
    super(), this.isMeshPhysicalMaterial = !0, this.defines = { STANDARD: "", PHYSICAL: "" }, this.type = "MeshPhysicalMaterial", this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new wt(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", { get: function() {
      return rr(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
    }, set: function(e) {
      this.ior = (1 + 0.4 * e) / (1 - 0.4 * e);
    } }), this.iridescenceMap = null, this.iridescenceIOR = 1.3, this.iridescenceThicknessRange = [100, 400], this.iridescenceThicknessMap = null, this.sheenColor = new Ht(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 1 / 0, this.attenuationColor = new Ht(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new Ht(1, 1, 1), this.specularColorMap = null, this._sheen = 0, this._clearcoat = 0, this._iridescence = 0, this._transmission = 0, this.setValues(t);
  }
  get sheen() {
    return this._sheen;
  }
  set sheen(t) {
    this._sheen > 0 != t > 0 && this.version++, this._sheen = t;
  }
  get clearcoat() {
    return this._clearcoat;
  }
  set clearcoat(t) {
    this._clearcoat > 0 != t > 0 && this.version++, this._clearcoat = t;
  }
  get iridescence() {
    return this._iridescence;
  }
  set iridescence(t) {
    this._iridescence > 0 != t > 0 && this.version++, this._iridescence = t;
  }
  get transmission() {
    return this._transmission;
  }
  set transmission(t) {
    this._transmission > 0 != t > 0 && this.version++, this._transmission = t;
  }
  copy(t) {
    return super.copy(t), this.defines = { STANDARD: "", PHYSICAL: "" }, this.clearcoat = t.clearcoat, this.clearcoatMap = t.clearcoatMap, this.clearcoatRoughness = t.clearcoatRoughness, this.clearcoatRoughnessMap = t.clearcoatRoughnessMap, this.clearcoatNormalMap = t.clearcoatNormalMap, this.clearcoatNormalScale.copy(t.clearcoatNormalScale), this.ior = t.ior, this.iridescence = t.iridescence, this.iridescenceMap = t.iridescenceMap, this.iridescenceIOR = t.iridescenceIOR, this.iridescenceThicknessRange = [...t.iridescenceThicknessRange], this.iridescenceThicknessMap = t.iridescenceThicknessMap, this.sheen = t.sheen, this.sheenColor.copy(t.sheenColor), this.sheenColorMap = t.sheenColorMap, this.sheenRoughness = t.sheenRoughness, this.sheenRoughnessMap = t.sheenRoughnessMap, this.transmission = t.transmission, this.transmissionMap = t.transmissionMap, this.thickness = t.thickness, this.thicknessMap = t.thicknessMap, this.attenuationDistance = t.attenuationDistance, this.attenuationColor.copy(t.attenuationColor), this.specularIntensity = t.specularIntensity, this.specularIntensityMap = t.specularIntensityMap, this.specularColor.copy(t.specularColor), this.specularColorMap = t.specularColorMap, this;
  }
}
class WI extends Kr {
  constructor(t) {
    super(), this.isMeshPhongMaterial = !0, this.type = "MeshPhongMaterial", this.color = new Ht(16777215), this.specular = new Ht(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Ht(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new wt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(t);
  }
  copy(t) {
    return super.copy(t), this.color.copy(t.color), this.specular.copy(t.specular), this.shininess = t.shininess, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.flatShading = t.flatShading, this.fog = t.fog, this;
  }
}
class ZI extends Kr {
  constructor(t) {
    super(), this.isMeshToonMaterial = !0, this.defines = { TOON: "" }, this.type = "MeshToonMaterial", this.color = new Ht(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Ht(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new wt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(t);
  }
  copy(t) {
    return super.copy(t), this.color.copy(t.color), this.map = t.map, this.gradientMap = t.gradientMap, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.alphaMap = t.alphaMap, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.fog = t.fog, this;
  }
}
class Yb extends Kr {
  constructor(t) {
    super(), this.isMeshNormalMaterial = !0, this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new wt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.flatShading = !1, this.setValues(t);
  }
  copy(t) {
    return super.copy(t), this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.flatShading = t.flatShading, this;
  }
}
class qI extends Kr {
  constructor(t) {
    super(), this.isMeshLambertMaterial = !0, this.type = "MeshLambertMaterial", this.color = new Ht(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Ht(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new wt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(t);
  }
  copy(t) {
    return super.copy(t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.flatShading = t.flatShading, this.fog = t.fog, this;
  }
}
class XI extends Kr {
  constructor(t) {
    super(), this.isMeshMatcapMaterial = !0, this.defines = { MATCAP: "" }, this.type = "MeshMatcapMaterial", this.color = new Ht(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new wt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.flatShading = !1, this.fog = !0, this.setValues(t);
  }
  copy(t) {
    return super.copy(t), this.defines = { MATCAP: "" }, this.color.copy(t.color), this.matcap = t.matcap, this.map = t.map, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.alphaMap = t.alphaMap, this.flatShading = t.flatShading, this.fog = t.fog, this;
  }
}
class Jb extends Ar {
  constructor(t) {
    super(), this.isLineDashedMaterial = !0, this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(t);
  }
  copy(t) {
    return super.copy(t), this.scale = t.scale, this.dashSize = t.dashSize, this.gapSize = t.gapSize, this;
  }
}
function is(i, t, e) {
  return Kb(i) ? new i.constructor(i.subarray(t, e !== void 0 ? e : i.length)) : i.slice(t, e);
}
function zl(i, t, e) {
  return !i || !e && i.constructor === t ? i : typeof t.BYTES_PER_ELEMENT == "number" ? new t(i) : Array.prototype.slice.call(i);
}
function Kb(i) {
  return ArrayBuffer.isView(i) && !(i instanceof DataView);
}
function YI(i) {
  const t = i.length, e = new Array(t);
  for (let n = 0; n !== t; ++n)
    e[n] = n;
  return e.sort(function(n, r) {
    return i[n] - i[r];
  }), e;
}
function lx(i, t, e) {
  const n = i.length, r = new i.constructor(n);
  for (let s = 0, a = 0; a !== n; ++s) {
    const o = e[s] * t;
    for (let l = 0; l !== t; ++l)
      r[a++] = i[o + l];
  }
  return r;
}
function $b(i, t, e, n) {
  let r = 1, s = i[0];
  for (; s !== void 0 && s[n] === void 0; )
    s = i[r++];
  if (s === void 0)
    return;
  let a = s[n];
  if (a !== void 0)
    if (Array.isArray(a))
      do
        a = s[n], a !== void 0 && (t.push(s.time), e.push.apply(e, a)), s = i[r++];
      while (s !== void 0);
    else if (a.toArray !== void 0)
      do
        a = s[n], a !== void 0 && (t.push(s.time), a.toArray(e, e.length)), s = i[r++];
      while (s !== void 0);
    else
      do
        a = s[n], a !== void 0 && (t.push(s.time), e.push(a)), s = i[r++];
      while (s !== void 0);
}
var wU = Object.freeze({ __proto__: null, arraySlice: is, convertArray: zl, flattenJSON: $b, getKeyframeOrder: YI, isTypedArray: Kb, makeClipAdditive: function(i, t = 0, e = i, n = 30) {
  n <= 0 && (n = 30);
  const r = e.tracks.length, s = t / n;
  for (let a = 0; a < r; ++a) {
    const o = e.tracks[a], l = o.ValueTypeName;
    if (l === "bool" || l === "string")
      continue;
    const c = i.tracks.find(function(_) {
      return _.name === o.name && _.ValueTypeName === l;
    });
    if (c === void 0)
      continue;
    let u = 0;
    const h = o.getValueSize();
    o.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (u = h / 3);
    let p = 0;
    const f = c.getValueSize();
    c.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (p = f / 3);
    const v = o.times.length - 1;
    let m;
    if (s <= o.times[0]) {
      const _ = u, w = h - u;
      m = is(o.values, _, w);
    } else if (s >= o.times[v]) {
      const _ = v * h + u, w = _ + h - u;
      m = is(o.values, _, w);
    } else {
      const _ = o.createInterpolant(), w = u, b = h - u;
      _.evaluate(s), m = is(_.resultBuffer, w, b);
    }
    l === "quaternion" && new kn().fromArray(m).normalize().conjugate().toArray(m);
    const y = c.times.length;
    for (let _ = 0; _ < y; ++_) {
      const w = _ * f + p;
      if (l === "quaternion")
        kn.multiplyQuaternionsFlat(c.values, w, m, 0, c.values, w);
      else {
        const b = f - 2 * p;
        for (let T = 0; T < b; ++T)
          c.values[w + T] -= m[T];
      }
    }
  }
  return i.blendMode = 2501, i;
}, sortedArray: lx, subclip: function(i, t, e, n, r = 30) {
  const s = i.clone();
  s.name = t;
  const a = [];
  for (let l = 0; l < s.tracks.length; ++l) {
    const c = s.tracks[l], u = c.getValueSize(), h = [], p = [];
    for (let f = 0; f < c.times.length; ++f) {
      const v = c.times[f] * r;
      if (!(v < e || v >= n)) {
        h.push(c.times[f]);
        for (let m = 0; m < u; ++m)
          p.push(c.values[f * u + m]);
      }
    }
    h.length !== 0 && (c.times = zl(h, c.times.constructor), c.values = zl(p, c.values.constructor), a.push(c));
  }
  s.tracks = a;
  let o = 1 / 0;
  for (let l = 0; l < s.tracks.length; ++l)
    o > s.tracks[l].times[0] && (o = s.tracks[l].times[0]);
  for (let l = 0; l < s.tracks.length; ++l)
    s.tracks[l].shift(-1 * o);
  return s.resetDuration(), s;
} });
class Sp {
  constructor(t, e, n, r) {
    this.parameterPositions = t, this._cachedIndex = 0, this.resultBuffer = r !== void 0 ? r : new e.constructor(n), this.sampleValues = e, this.valueSize = n, this.settings = null, this.DefaultSettings_ = {};
  }
  evaluate(t) {
    const e = this.parameterPositions;
    let n = this._cachedIndex, r = e[n], s = e[n - 1];
    t: {
      e: {
        let a;
        n: {
          r:
            if (!(t < r)) {
              for (let o = n + 2; ; ) {
                if (r === void 0) {
                  if (t < s)
                    break r;
                  return n = e.length, this._cachedIndex = n, this.copySampleValue_(n - 1);
                }
                if (n === o)
                  break;
                if (s = r, r = e[++n], t < r)
                  break e;
              }
              a = e.length;
              break n;
            }
          if (t >= s)
            break t;
          {
            const o = e[1];
            t < o && (n = 2, s = o);
            for (let l = n - 2; ; ) {
              if (s === void 0)
                return this._cachedIndex = 0, this.copySampleValue_(0);
              if (n === l)
                break;
              if (r = s, s = e[--n - 1], t >= s)
                break e;
            }
            a = n, n = 0;
          }
        }
        for (; n < a; ) {
          const o = n + a >>> 1;
          t < e[o] ? a = o : n = o + 1;
        }
        if (r = e[n], s = e[n - 1], s === void 0)
          return this._cachedIndex = 0, this.copySampleValue_(0);
        if (r === void 0)
          return n = e.length, this._cachedIndex = n, this.copySampleValue_(n - 1);
      }
      this._cachedIndex = n, this.intervalChanged_(n, s, r);
    }
    return this.interpolate_(n, s, t, r);
  }
  getSettings_() {
    return this.settings || this.DefaultSettings_;
  }
  copySampleValue_(t) {
    const e = this.resultBuffer, n = this.sampleValues, r = this.valueSize, s = t * r;
    for (let a = 0; a !== r; ++a)
      e[a] = n[s + a];
    return e;
  }
  interpolate_() {
    throw new Error("call to abstract method");
  }
  intervalChanged_() {
  }
}
class JI extends Sp {
  constructor(t, e, n, r) {
    super(t, e, n, r), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = { endingStart: 2400, endingEnd: 2400 };
  }
  intervalChanged_(t, e, n) {
    const r = this.parameterPositions;
    let s = t - 2, a = t + 1, o = r[s], l = r[a];
    if (o === void 0)
      switch (this.getSettings_().endingStart) {
        case 2401:
          s = t, o = 2 * e - n;
          break;
        case 2402:
          s = r.length - 2, o = e + r[s] - r[s + 1];
          break;
        default:
          s = t, o = n;
      }
    if (l === void 0)
      switch (this.getSettings_().endingEnd) {
        case 2401:
          a = t, l = 2 * n - e;
          break;
        case 2402:
          a = 1, l = n + r[1] - r[0];
          break;
        default:
          a = t - 1, l = e;
      }
    const c = 0.5 * (n - e), u = this.valueSize;
    this._weightPrev = c / (e - o), this._weightNext = c / (l - n), this._offsetPrev = s * u, this._offsetNext = a * u;
  }
  interpolate_(t, e, n, r) {
    const s = this.resultBuffer, a = this.sampleValues, o = this.valueSize, l = t * o, c = l - o, u = this._offsetPrev, h = this._offsetNext, p = this._weightPrev, f = this._weightNext, v = (n - e) / (r - e), m = v * v, y = m * v, _ = -p * y + 2 * p * m - p * v, w = (1 + p) * y + (-1.5 - 2 * p) * m + (-0.5 + p) * v + 1, b = (-1 - f) * y + (1.5 + f) * m + 0.5 * v, T = f * y - f * m;
    for (let M = 0; M !== o; ++M)
      s[M] = _ * a[u + M] + w * a[c + M] + b * a[l + M] + T * a[h + M];
    return s;
  }
}
class Qb extends Sp {
  constructor(t, e, n, r) {
    super(t, e, n, r);
  }
  interpolate_(t, e, n, r) {
    const s = this.resultBuffer, a = this.sampleValues, o = this.valueSize, l = t * o, c = l - o, u = (n - e) / (r - e), h = 1 - u;
    for (let p = 0; p !== o; ++p)
      s[p] = a[c + p] * h + a[l + p] * u;
    return s;
  }
}
class KI extends Sp {
  constructor(t, e, n, r) {
    super(t, e, n, r);
  }
  interpolate_(t) {
    return this.copySampleValue_(t - 1);
  }
}
class Rs {
  constructor(t, e, n, r) {
    if (t === void 0)
      throw new Error("THREE.KeyframeTrack: track name is undefined");
    if (e === void 0 || e.length === 0)
      throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t);
    this.name = t, this.times = zl(e, this.TimeBufferType), this.values = zl(n, this.ValueBufferType), this.setInterpolation(r || this.DefaultInterpolation);
  }
  static toJSON(t) {
    const e = t.constructor;
    let n;
    if (e.toJSON !== this.toJSON)
      n = e.toJSON(t);
    else {
      n = { name: t.name, times: zl(t.times, Array), values: zl(t.values, Array) };
      const r = t.getInterpolation();
      r !== t.DefaultInterpolation && (n.interpolation = r);
    }
    return n.type = t.ValueTypeName, n;
  }
  InterpolantFactoryMethodDiscrete(t) {
    return new KI(this.times, this.values, this.getValueSize(), t);
  }
  InterpolantFactoryMethodLinear(t) {
    return new Qb(this.times, this.values, this.getValueSize(), t);
  }
  InterpolantFactoryMethodSmooth(t) {
    return new JI(this.times, this.values, this.getValueSize(), t);
  }
  setInterpolation(t) {
    let e;
    switch (t) {
      case 2300:
        e = this.InterpolantFactoryMethodDiscrete;
        break;
      case 2301:
        e = this.InterpolantFactoryMethodLinear;
        break;
      case 2302:
        e = this.InterpolantFactoryMethodSmooth;
    }
    if (e === void 0) {
      const n = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
      if (this.createInterpolant === void 0) {
        if (t === this.DefaultInterpolation)
          throw new Error(n);
        this.setInterpolation(this.DefaultInterpolation);
      }
      return console.warn("THREE.KeyframeTrack:", n), this;
    }
    return this.createInterpolant = e, this;
  }
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return 2300;
      case this.InterpolantFactoryMethodLinear:
        return 2301;
      case this.InterpolantFactoryMethodSmooth:
        return 2302;
    }
  }
  getValueSize() {
    return this.values.length / this.times.length;
  }
  shift(t) {
    if (t !== 0) {
      const e = this.times;
      for (let n = 0, r = e.length; n !== r; ++n)
        e[n] += t;
    }
    return this;
  }
  scale(t) {
    if (t !== 1) {
      const e = this.times;
      for (let n = 0, r = e.length; n !== r; ++n)
        e[n] *= t;
    }
    return this;
  }
  trim(t, e) {
    const n = this.times, r = n.length;
    let s = 0, a = r - 1;
    for (; s !== r && n[s] < t; )
      ++s;
    for (; a !== -1 && n[a] > e; )
      --a;
    if (++a, s !== 0 || a !== r) {
      s >= a && (a = Math.max(a, 1), s = a - 1);
      const o = this.getValueSize();
      this.times = is(n, s, a), this.values = is(this.values, s * o, a * o);
    }
    return this;
  }
  validate() {
    let t = !0;
    const e = this.getValueSize();
    e - Math.floor(e) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), t = !1);
    const n = this.times, r = this.values, s = n.length;
    s === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this), t = !1);
    let a = null;
    for (let o = 0; o !== s; o++) {
      const l = n[o];
      if (typeof l == "number" && isNaN(l)) {
        console.error("THREE.KeyframeTrack: Time is not a valid number.", this, o, l), t = !1;
        break;
      }
      if (a !== null && a > l) {
        console.error("THREE.KeyframeTrack: Out of order keys.", this, o, l, a), t = !1;
        break;
      }
      a = l;
    }
    if (r !== void 0 && Kb(r))
      for (let o = 0, l = r.length; o !== l; ++o) {
        const c = r[o];
        if (isNaN(c)) {
          console.error("THREE.KeyframeTrack: Value is not a valid number.", this, o, c), t = !1;
          break;
        }
      }
    return t;
  }
  optimize() {
    const t = is(this.times), e = is(this.values), n = this.getValueSize(), r = this.getInterpolation() === 2302, s = t.length - 1;
    let a = 1;
    for (let o = 1; o < s; ++o) {
      let l = !1;
      const c = t[o];
      if (c !== t[o + 1] && (o !== 1 || c !== t[0]))
        if (r)
          l = !0;
        else {
          const u = o * n, h = u - n, p = u + n;
          for (let f = 0; f !== n; ++f) {
            const v = e[u + f];
            if (v !== e[h + f] || v !== e[p + f]) {
              l = !0;
              break;
            }
          }
        }
      if (l) {
        if (o !== a) {
          t[a] = t[o];
          const u = o * n, h = a * n;
          for (let p = 0; p !== n; ++p)
            e[h + p] = e[u + p];
        }
        ++a;
      }
    }
    if (s > 0) {
      t[a] = t[s];
      for (let o = s * n, l = a * n, c = 0; c !== n; ++c)
        e[l + c] = e[o + c];
      ++a;
    }
    return a !== t.length ? (this.times = is(t, 0, a), this.values = is(e, 0, a * n)) : (this.times = t, this.values = e), this;
  }
  clone() {
    const t = is(this.times, 0), e = is(this.values, 0), n = new this.constructor(this.name, t, e);
    return n.createInterpolant = this.createInterpolant, n;
  }
}
Rs.prototype.TimeBufferType = Float32Array, Rs.prototype.ValueBufferType = Float32Array, Rs.prototype.DefaultInterpolation = 2301;
class Il extends Rs {
}
Il.prototype.ValueTypeName = "bool", Il.prototype.ValueBufferType = Array, Il.prototype.DefaultInterpolation = 2300, Il.prototype.InterpolantFactoryMethodLinear = void 0, Il.prototype.InterpolantFactoryMethodSmooth = void 0;
class tS extends Rs {
}
tS.prototype.ValueTypeName = "color";
class up extends Rs {
}
up.prototype.ValueTypeName = "number";
class $I extends Sp {
  constructor(t, e, n, r) {
    super(t, e, n, r);
  }
  interpolate_(t, e, n, r) {
    const s = this.resultBuffer, a = this.sampleValues, o = this.valueSize, l = (n - e) / (r - e);
    let c = t * o;
    for (let u = c + o; c !== u; c += 4)
      kn.slerpFlat(s, 0, a, c - o, a, c, l);
    return s;
  }
}
class Rh extends Rs {
  InterpolantFactoryMethodLinear(t) {
    return new $I(this.times, this.values, this.getValueSize(), t);
  }
}
Rh.prototype.ValueTypeName = "quaternion", Rh.prototype.DefaultInterpolation = 2301, Rh.prototype.InterpolantFactoryMethodSmooth = void 0;
class Ol extends Rs {
}
Ol.prototype.ValueTypeName = "string", Ol.prototype.ValueBufferType = Array, Ol.prototype.DefaultInterpolation = 2300, Ol.prototype.InterpolantFactoryMethodLinear = void 0, Ol.prototype.InterpolantFactoryMethodSmooth = void 0;
class dp extends Rs {
}
dp.prototype.ValueTypeName = "vector";
class Ih {
  constructor(t, e = -1, n, r = 2500) {
    this.name = t, this.tracks = n, this.duration = e, this.blendMode = r, this.uuid = Vi(), this.duration < 0 && this.resetDuration();
  }
  static parse(t) {
    const e = [], n = t.tracks, r = 1 / (t.fps || 1);
    for (let a = 0, o = n.length; a !== o; ++a)
      e.push(xU(n[a]).scale(r));
    const s = new this(t.name, t.duration, e, t.blendMode);
    return s.uuid = t.uuid, s;
  }
  static toJSON(t) {
    const e = [], n = t.tracks, r = { name: t.name, duration: t.duration, tracks: e, uuid: t.uuid, blendMode: t.blendMode };
    for (let s = 0, a = n.length; s !== a; ++s)
      e.push(Rs.toJSON(n[s]));
    return r;
  }
  static CreateFromMorphTargetSequence(t, e, n, r) {
    const s = e.length, a = [];
    for (let o = 0; o < s; o++) {
      let l = [], c = [];
      l.push((o + s - 1) % s, o, (o + 1) % s), c.push(0, 1, 0);
      const u = YI(l);
      l = lx(l, 1, u), c = lx(c, 1, u), r || l[0] !== 0 || (l.push(s), c.push(c[0])), a.push(new up(".morphTargetInfluences[" + e[o].name + "]", l, c).scale(1 / n));
    }
    return new this(t, -1, a);
  }
  static findByName(t, e) {
    let n = t;
    if (!Array.isArray(t)) {
      const r = t;
      n = r.geometry && r.geometry.animations || r.animations;
    }
    for (let r = 0; r < n.length; r++)
      if (n[r].name === e)
        return n[r];
    return null;
  }
  static CreateClipsFromMorphTargetSequences(t, e, n) {
    const r = {}, s = /^([\w-]*?)([\d]+)$/;
    for (let o = 0, l = t.length; o < l; o++) {
      const c = t[o], u = c.name.match(s);
      if (u && u.length > 1) {
        const h = u[1];
        let p = r[h];
        p || (r[h] = p = []), p.push(c);
      }
    }
    const a = [];
    for (const o in r)
      a.push(this.CreateFromMorphTargetSequence(o, r[o], e, n));
    return a;
  }
  static parseAnimation(t, e) {
    if (!t)
      return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
    const n = function(u, h, p, f, v) {
      if (p.length !== 0) {
        const m = [], y = [];
        $b(p, m, y, f), m.length !== 0 && v.push(new u(h, m, y));
      }
    }, r = [], s = t.name || "default", a = t.fps || 30, o = t.blendMode;
    let l = t.length || -1;
    const c = t.hierarchy || [];
    for (let u = 0; u < c.length; u++) {
      const h = c[u].keys;
      if (h && h.length !== 0)
        if (h[0].morphTargets) {
          const p = {};
          let f;
          for (f = 0; f < h.length; f++)
            if (h[f].morphTargets)
              for (let v = 0; v < h[f].morphTargets.length; v++)
                p[h[f].morphTargets[v]] = -1;
          for (const v in p) {
            const m = [], y = [];
            for (let _ = 0; _ !== h[f].morphTargets.length; ++_) {
              const w = h[f];
              m.push(w.time), y.push(w.morphTarget === v ? 1 : 0);
            }
            r.push(new up(".morphTargetInfluence[" + v + "]", m, y));
          }
          l = p.length * a;
        } else {
          const p = ".bones[" + e[u].name + "]";
          n(dp, p + ".position", h, "pos", r), n(Rh, p + ".quaternion", h, "rot", r), n(dp, p + ".scale", h, "scl", r);
        }
    }
    return r.length === 0 ? null : new this(s, l, r, o);
  }
  resetDuration() {
    let t = 0;
    for (let e = 0, n = this.tracks.length; e !== n; ++e) {
      const r = this.tracks[e];
      t = Math.max(t, r.times[r.times.length - 1]);
    }
    return this.duration = t, this;
  }
  trim() {
    for (let t = 0; t < this.tracks.length; t++)
      this.tracks[t].trim(0, this.duration);
    return this;
  }
  validate() {
    let t = !0;
    for (let e = 0; e < this.tracks.length; e++)
      t = t && this.tracks[e].validate();
    return t;
  }
  optimize() {
    for (let t = 0; t < this.tracks.length; t++)
      this.tracks[t].optimize();
    return this;
  }
  clone() {
    const t = [];
    for (let e = 0; e < this.tracks.length; e++)
      t.push(this.tracks[e].clone());
    return new this.constructor(this.name, this.duration, t, this.blendMode);
  }
  toJSON() {
    return this.constructor.toJSON(this);
  }
}
function xU(i) {
  if (i.type === void 0)
    throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
  const t = function(e) {
    switch (e.toLowerCase()) {
      case "scalar":
      case "double":
      case "float":
      case "number":
      case "integer":
        return up;
      case "vector":
      case "vector2":
      case "vector3":
      case "vector4":
        return dp;
      case "color":
        return tS;
      case "quaternion":
        return Rh;
      case "bool":
      case "boolean":
        return Il;
      case "string":
        return Ol;
    }
    throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + e);
  }(i.type);
  if (i.times === void 0) {
    const e = [], n = [];
    $b(i.keys, e, n, "value"), i.times = e, i.values = n;
  }
  return t.parse !== void 0 ? t.parse(i) : new t(i.name, i.times, i.values, i.interpolation);
}
const Zl = { enabled: !1, files: {}, add: function(i, t) {
  this.enabled !== !1 && (this.files[i] = t);
}, get: function(i) {
  if (this.enabled !== !1)
    return this.files[i];
}, remove: function(i) {
  delete this.files[i];
}, clear: function() {
  this.files = {};
} };
class cx {
  constructor(t, e, n) {
    const r = this;
    let s, a = !1, o = 0, l = 0;
    const c = [];
    this.onStart = void 0, this.onLoad = t, this.onProgress = e, this.onError = n, this.itemStart = function(u) {
      l++, a === !1 && r.onStart !== void 0 && r.onStart(u, o, l), a = !0;
    }, this.itemEnd = function(u) {
      o++, r.onProgress !== void 0 && r.onProgress(u, o, l), o === l && (a = !1, r.onLoad !== void 0 && r.onLoad());
    }, this.itemError = function(u) {
      r.onError !== void 0 && r.onError(u);
    }, this.resolveURL = function(u) {
      return s ? s(u) : u;
    }, this.setURLModifier = function(u) {
      return s = u, this;
    }, this.addHandler = function(u, h) {
      return c.push(u, h), this;
    }, this.removeHandler = function(u) {
      const h = c.indexOf(u);
      return h !== -1 && c.splice(h, 2), this;
    }, this.getHandler = function(u) {
      for (let h = 0, p = c.length; h < p; h += 2) {
        const f = c[h], v = c[h + 1];
        if (f.global && (f.lastIndex = 0), f.test(u))
          return v;
      }
      return null;
    };
  }
}
const QI = new cx();
class Fi {
  constructor(t) {
    this.manager = t !== void 0 ? t : QI, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {};
  }
  load() {
  }
  loadAsync(t, e) {
    const n = this;
    return new Promise(function(r, s) {
      n.load(t, r, e, s);
    });
  }
  parse() {
  }
  setCrossOrigin(t) {
    return this.crossOrigin = t, this;
  }
  setWithCredentials(t) {
    return this.withCredentials = t, this;
  }
  setPath(t) {
    return this.path = t, this;
  }
  setResourcePath(t) {
    return this.resourcePath = t, this;
  }
  setRequestHeader(t) {
    return this.requestHeader = t, this;
  }
}
const wa = {};
class bU extends Error {
  constructor(t, e) {
    super(t), this.response = e;
  }
}
class La extends Fi {
  constructor(t) {
    super(t);
  }
  load(t, e, n, r) {
    t === void 0 && (t = ""), this.path !== void 0 && (t = this.path + t), t = this.manager.resolveURL(t);
    const s = Zl.get(t);
    if (s !== void 0)
      return this.manager.itemStart(t), setTimeout(() => {
        e && e(s), this.manager.itemEnd(t);
      }, 0), s;
    if (wa[t] !== void 0)
      return void wa[t].push({ onLoad: e, onProgress: n, onError: r });
    wa[t] = [], wa[t].push({ onLoad: e, onProgress: n, onError: r });
    const a = new Request(t, { headers: new Headers(this.requestHeader), credentials: this.withCredentials ? "include" : "same-origin" }), o = this.mimeType, l = this.responseType;
    fetch(a).then((c) => {
      if (c.status === 200 || c.status === 0) {
        if (c.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."), typeof ReadableStream > "u" || c.body === void 0 || c.body.getReader === void 0)
          return c;
        const u = wa[t], h = c.body.getReader(), p = c.headers.get("Content-Length") || c.headers.get("X-File-Size"), f = p ? parseInt(p) : 0, v = f !== 0;
        let m = 0;
        const y = new ReadableStream({ start(_) {
          (function w() {
            h.read().then(({ done: b, value: T }) => {
              if (b)
                _.close();
              else {
                m += T.byteLength;
                const M = new ProgressEvent("progress", { lengthComputable: v, loaded: m, total: f });
                for (let A = 0, C = u.length; A < C; A++) {
                  const I = u[A];
                  I.onProgress && I.onProgress(M);
                }
                _.enqueue(T), w();
              }
            });
          })();
        } });
        return new Response(y);
      }
      throw new bU(`fetch for "${c.url}" responded with ${c.status}: ${c.statusText}`, c);
    }).then((c) => {
      switch (l) {
        case "arraybuffer":
          return c.arrayBuffer();
        case "blob":
          return c.blob();
        case "document":
          return c.text().then((u) => new DOMParser().parseFromString(u, o));
        case "json":
          return c.json();
        default:
          if (o === void 0)
            return c.text();
          {
            const u = /charset="?([^;"\s]*)"?/i.exec(o), h = u && u[1] ? u[1].toLowerCase() : void 0, p = new TextDecoder(h);
            return c.arrayBuffer().then((f) => p.decode(f));
          }
      }
    }).then((c) => {
      Zl.add(t, c);
      const u = wa[t];
      delete wa[t];
      for (let h = 0, p = u.length; h < p; h++) {
        const f = u[h];
        f.onLoad && f.onLoad(c);
      }
    }).catch((c) => {
      const u = wa[t];
      if (u === void 0)
        throw this.manager.itemError(t), c;
      delete wa[t];
      for (let h = 0, p = u.length; h < p; h++) {
        const f = u[h];
        f.onError && f.onError(c);
      }
      this.manager.itemError(t);
    }).finally(() => {
      this.manager.itemEnd(t);
    }), this.manager.itemStart(t);
  }
  setResponseType(t) {
    return this.responseType = t, this;
  }
  setMimeType(t) {
    return this.mimeType = t, this;
  }
}
class _d extends Fi {
  constructor(t) {
    super(t);
  }
  load(t, e, n, r) {
    this.path !== void 0 && (t = this.path + t), t = this.manager.resolveURL(t);
    const s = this, a = Zl.get(t);
    if (a !== void 0)
      return s.manager.itemStart(t), setTimeout(function() {
        e && e(a), s.manager.itemEnd(t);
      }, 0), a;
    const o = Xd("img");
    function l() {
      u(), Zl.add(t, this), e && e(this), s.manager.itemEnd(t);
    }
    function c(h) {
      u(), r && r(h), s.manager.itemError(t), s.manager.itemEnd(t);
    }
    function u() {
      o.removeEventListener("load", l, !1), o.removeEventListener("error", c, !1);
    }
    return o.addEventListener("load", l, !1), o.addEventListener("error", c, !1), t.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (o.crossOrigin = this.crossOrigin), s.manager.itemStart(t), o.src = t, o;
  }
}
class eS extends Fi {
  constructor(t) {
    super(t);
  }
  load(t, e, n, r) {
    const s = this, a = new Ro(), o = new La(this.manager);
    return o.setResponseType("arraybuffer"), o.setRequestHeader(this.requestHeader), o.setPath(this.path), o.setWithCredentials(s.withCredentials), o.load(t, function(l) {
      const c = s.parse(l);
      c && (c.image !== void 0 ? a.image = c.image : c.data !== void 0 && (a.image.width = c.width, a.image.height = c.height, a.image.data = c.data), a.wrapS = c.wrapS !== void 0 ? c.wrapS : 1001, a.wrapT = c.wrapT !== void 0 ? c.wrapT : 1001, a.magFilter = c.magFilter !== void 0 ? c.magFilter : 1006, a.minFilter = c.minFilter !== void 0 ? c.minFilter : 1006, a.anisotropy = c.anisotropy !== void 0 ? c.anisotropy : 1, c.encoding !== void 0 && (a.encoding = c.encoding), c.flipY !== void 0 && (a.flipY = c.flipY), c.format !== void 0 && (a.format = c.format), c.type !== void 0 && (a.type = c.type), c.mipmaps !== void 0 && (a.mipmaps = c.mipmaps, a.minFilter = 1008), c.mipmapCount === 1 && (a.minFilter = 1006), c.generateMipmaps !== void 0 && (a.generateMipmaps = c.generateMipmaps), a.needsUpdate = !0, e && e(a, c));
    }, n, r), a;
  }
}
class o0 extends Fi {
  constructor(t) {
    super(t);
  }
  load(t, e, n, r) {
    const s = new Yn(), a = new _d(this.manager);
    return a.setCrossOrigin(this.crossOrigin), a.setPath(this.path), a.load(t, function(o) {
      s.image = o, s.needsUpdate = !0, e !== void 0 && e(s);
    }, n, r), s;
  }
}
class Vo extends Ue {
  constructor(t, e = 1) {
    super(), this.isLight = !0, this.type = "Light", this.color = new Ht(t), this.intensity = e;
  }
  dispose() {
  }
  copy(t, e) {
    return super.copy(t, e), this.color.copy(t.color), this.intensity = t.intensity, this;
  }
  toJSON(t) {
    const e = super.toJSON(t);
    return e.object.color = this.color.getHex(), e.object.intensity = this.intensity, this.groundColor !== void 0 && (e.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (e.object.distance = this.distance), this.angle !== void 0 && (e.object.angle = this.angle), this.decay !== void 0 && (e.object.decay = this.decay), this.penumbra !== void 0 && (e.object.penumbra = this.penumbra), this.shadow !== void 0 && (e.object.shadow = this.shadow.toJSON()), e;
  }
}
class AE extends Vo {
  constructor(t, e, n) {
    super(t, n), this.isHemisphereLight = !0, this.type = "HemisphereLight", this.position.copy(Ue.DEFAULT_UP), this.updateMatrix(), this.groundColor = new Ht(e);
  }
  copy(t, e) {
    return super.copy(t, e), this.groundColor.copy(t.groundColor), this;
  }
}
const b_ = new Vt(), CE = new D(), PE = new D();
class nS {
  constructor(t) {
    this.camera = t, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new wt(512, 512), this.map = null, this.mapPass = null, this.matrix = new Vt(), this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new t0(), this._frameExtents = new wt(1, 1), this._viewportCount = 1, this._viewports = [new ze(0, 0, 1, 1)];
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(t) {
    const e = this.camera, n = this.matrix;
    CE.setFromMatrixPosition(t.matrixWorld), e.position.copy(CE), PE.setFromMatrixPosition(t.target.matrixWorld), e.lookAt(PE), e.updateMatrixWorld(), b_.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), this._frustum.setFromProjectionMatrix(b_), n.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1), n.multiply(b_);
  }
  getViewport(t) {
    return this._viewports[t];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
  }
  copy(t) {
    return this.camera = t.camera.clone(), this.bias = t.bias, this.radius = t.radius, this.mapSize.copy(t.mapSize), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const t = {};
    return this.bias !== 0 && (t.bias = this.bias), this.normalBias !== 0 && (t.normalBias = this.normalBias), this.radius !== 1 && (t.radius = this.radius), this.mapSize.x === 512 && this.mapSize.y === 512 || (t.mapSize = this.mapSize.toArray()), t.camera = this.camera.toJSON(!1).object, delete t.camera.matrix, t;
  }
}
class SU extends nS {
  constructor() {
    super(new Cr(50, 1, 0.5, 500)), this.isSpotLightShadow = !0, this.focus = 1;
  }
  updateMatrices(t) {
    const e = this.camera, n = 2 * qd * t.angle * this.focus, r = this.mapSize.width / this.mapSize.height, s = t.distance || e.far;
    n === e.fov && r === e.aspect && s === e.far || (e.fov = n, e.aspect = r, e.far = s, e.updateProjectionMatrix()), super.updateMatrices(t);
  }
  copy(t) {
    return super.copy(t), this.focus = t.focus, this;
  }
}
class DE extends Vo {
  constructor(t, e, n = 0, r = Math.PI / 3, s = 0, a = 2) {
    super(t, e), this.isSpotLight = !0, this.type = "SpotLight", this.position.copy(Ue.DEFAULT_UP), this.updateMatrix(), this.target = new Ue(), this.distance = n, this.angle = r, this.penumbra = s, this.decay = a, this.map = null, this.shadow = new SU();
  }
  get power() {
    return this.intensity * Math.PI;
  }
  set power(t) {
    this.intensity = t / Math.PI;
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(t, e) {
    return super.copy(t, e), this.distance = t.distance, this.angle = t.angle, this.penumbra = t.penumbra, this.decay = t.decay, this.target = t.target.clone(), this.shadow = t.shadow.clone(), this;
  }
}
const RE = new Vt(), qu = new D(), S_ = new D();
class MU extends nS {
  constructor() {
    super(new Cr(90, 1, 0.5, 500)), this.isPointLightShadow = !0, this._frameExtents = new wt(4, 2), this._viewportCount = 6, this._viewports = [new ze(2, 1, 1, 1), new ze(0, 1, 1, 1), new ze(3, 1, 1, 1), new ze(1, 1, 1, 1), new ze(3, 0, 1, 1), new ze(1, 0, 1, 1)], this._cubeDirections = [new D(1, 0, 0), new D(-1, 0, 0), new D(0, 0, 1), new D(0, 0, -1), new D(0, 1, 0), new D(0, -1, 0)], this._cubeUps = [new D(0, 1, 0), new D(0, 1, 0), new D(0, 1, 0), new D(0, 1, 0), new D(0, 0, 1), new D(0, 0, -1)];
  }
  updateMatrices(t, e = 0) {
    const n = this.camera, r = this.matrix, s = t.distance || n.far;
    s !== n.far && (n.far = s, n.updateProjectionMatrix()), qu.setFromMatrixPosition(t.matrixWorld), n.position.copy(qu), S_.copy(n.position), S_.add(this._cubeDirections[e]), n.up.copy(this._cubeUps[e]), n.lookAt(S_), n.updateMatrixWorld(), r.makeTranslation(-qu.x, -qu.y, -qu.z), RE.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(RE);
  }
}
class hx extends Vo {
  constructor(t, e, n = 0, r = 2) {
    super(t, e), this.isPointLight = !0, this.type = "PointLight", this.distance = n, this.decay = r, this.shadow = new MU();
  }
  get power() {
    return 4 * this.intensity * Math.PI;
  }
  set power(t) {
    this.intensity = t / (4 * Math.PI);
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(t, e) {
    return super.copy(t, e), this.distance = t.distance, this.decay = t.decay, this.shadow = t.shadow.clone(), this;
  }
}
class TU extends nS {
  constructor() {
    super(new Yl(-5, 5, 5, -5, 0.5, 500)), this.isDirectionalLightShadow = !0;
  }
}
class ux extends Vo {
  constructor(t, e) {
    super(t, e), this.isDirectionalLight = !0, this.type = "DirectionalLight", this.position.copy(Ue.DEFAULT_UP), this.updateMatrix(), this.target = new Ue(), this.shadow = new TU();
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(t) {
    return super.copy(t), this.target = t.target.clone(), this.shadow = t.shadow.clone(), this;
  }
}
class dx extends Vo {
  constructor(t, e) {
    super(t, e), this.isAmbientLight = !0, this.type = "AmbientLight";
  }
}
class IE extends Vo {
  constructor(t, e, n = 10, r = 10) {
    super(t, e), this.isRectAreaLight = !0, this.type = "RectAreaLight", this.width = n, this.height = r;
  }
  get power() {
    return this.intensity * this.width * this.height * Math.PI;
  }
  set power(t) {
    this.intensity = t / (this.width * this.height * Math.PI);
  }
  copy(t) {
    return super.copy(t), this.width = t.width, this.height = t.height, this;
  }
  toJSON(t) {
    const e = super.toJSON(t);
    return e.object.width = this.width, e.object.height = this.height, e;
  }
}
class tO {
  constructor() {
    this.isSphericalHarmonics3 = !0, this.coefficients = [];
    for (let t = 0; t < 9; t++)
      this.coefficients.push(new D());
  }
  set(t) {
    for (let e = 0; e < 9; e++)
      this.coefficients[e].copy(t[e]);
    return this;
  }
  zero() {
    for (let t = 0; t < 9; t++)
      this.coefficients[t].set(0, 0, 0);
    return this;
  }
  getAt(t, e) {
    const n = t.x, r = t.y, s = t.z, a = this.coefficients;
    return e.copy(a[0]).multiplyScalar(0.282095), e.addScaledVector(a[1], 0.488603 * r), e.addScaledVector(a[2], 0.488603 * s), e.addScaledVector(a[3], 0.488603 * n), e.addScaledVector(a[4], n * r * 1.092548), e.addScaledVector(a[5], r * s * 1.092548), e.addScaledVector(a[6], 0.315392 * (3 * s * s - 1)), e.addScaledVector(a[7], n * s * 1.092548), e.addScaledVector(a[8], 0.546274 * (n * n - r * r)), e;
  }
  getIrradianceAt(t, e) {
    const n = t.x, r = t.y, s = t.z, a = this.coefficients;
    return e.copy(a[0]).multiplyScalar(0.886227), e.addScaledVector(a[1], 1.023328 * r), e.addScaledVector(a[2], 1.023328 * s), e.addScaledVector(a[3], 1.023328 * n), e.addScaledVector(a[4], 0.858086 * n * r), e.addScaledVector(a[5], 0.858086 * r * s), e.addScaledVector(a[6], 0.743125 * s * s - 0.247708), e.addScaledVector(a[7], 0.858086 * n * s), e.addScaledVector(a[8], 0.429043 * (n * n - r * r)), e;
  }
  add(t) {
    for (let e = 0; e < 9; e++)
      this.coefficients[e].add(t.coefficients[e]);
    return this;
  }
  addScaledSH(t, e) {
    for (let n = 0; n < 9; n++)
      this.coefficients[n].addScaledVector(t.coefficients[n], e);
    return this;
  }
  scale(t) {
    for (let e = 0; e < 9; e++)
      this.coefficients[e].multiplyScalar(t);
    return this;
  }
  lerp(t, e) {
    for (let n = 0; n < 9; n++)
      this.coefficients[n].lerp(t.coefficients[n], e);
    return this;
  }
  equals(t) {
    for (let e = 0; e < 9; e++)
      if (!this.coefficients[e].equals(t.coefficients[e]))
        return !1;
    return !0;
  }
  copy(t) {
    return this.set(t.coefficients);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  fromArray(t, e = 0) {
    const n = this.coefficients;
    for (let r = 0; r < 9; r++)
      n[r].fromArray(t, e + 3 * r);
    return this;
  }
  toArray(t = [], e = 0) {
    const n = this.coefficients;
    for (let r = 0; r < 9; r++)
      n[r].toArray(t, e + 3 * r);
    return t;
  }
  static getBasisAt(t, e) {
    const n = t.x, r = t.y, s = t.z;
    e[0] = 0.282095, e[1] = 0.488603 * r, e[2] = 0.488603 * s, e[3] = 0.488603 * n, e[4] = 1.092548 * n * r, e[5] = 1.092548 * r * s, e[6] = 0.315392 * (3 * s * s - 1), e[7] = 1.092548 * n * s, e[8] = 0.546274 * (n * n - r * r);
  }
}
class wm extends Vo {
  constructor(t = new tO(), e = 1) {
    super(void 0, e), this.isLightProbe = !0, this.sh = t;
  }
  copy(t) {
    return super.copy(t), this.sh.copy(t.sh), this;
  }
  fromJSON(t) {
    return this.intensity = t.intensity, this.sh.fromArray(t.sh), this;
  }
  toJSON(t) {
    const e = super.toJSON(t);
    return e.object.sh = this.sh.toArray(), e;
  }
}
class Av extends Fi {
  constructor(t) {
    super(t), this.textures = {};
  }
  load(t, e, n, r) {
    const s = this, a = new La(s.manager);
    a.setPath(s.path), a.setRequestHeader(s.requestHeader), a.setWithCredentials(s.withCredentials), a.load(t, function(o) {
      try {
        e(s.parse(JSON.parse(o)));
      } catch (l) {
        r ? r(l) : console.error(l), s.manager.itemError(t);
      }
    }, n, r);
  }
  parse(t) {
    const e = this.textures;
    function n(s) {
      return e[s] === void 0 && console.warn("THREE.MaterialLoader: Undefined texture", s), e[s];
    }
    const r = Av.createMaterialFromType(t.type);
    if (t.uuid !== void 0 && (r.uuid = t.uuid), t.name !== void 0 && (r.name = t.name), t.color !== void 0 && r.color !== void 0 && r.color.setHex(t.color), t.roughness !== void 0 && (r.roughness = t.roughness), t.metalness !== void 0 && (r.metalness = t.metalness), t.sheen !== void 0 && (r.sheen = t.sheen), t.sheenColor !== void 0 && (r.sheenColor = new Ht().setHex(t.sheenColor)), t.sheenRoughness !== void 0 && (r.sheenRoughness = t.sheenRoughness), t.emissive !== void 0 && r.emissive !== void 0 && r.emissive.setHex(t.emissive), t.specular !== void 0 && r.specular !== void 0 && r.specular.setHex(t.specular), t.specularIntensity !== void 0 && (r.specularIntensity = t.specularIntensity), t.specularColor !== void 0 && r.specularColor !== void 0 && r.specularColor.setHex(t.specularColor), t.shininess !== void 0 && (r.shininess = t.shininess), t.clearcoat !== void 0 && (r.clearcoat = t.clearcoat), t.clearcoatRoughness !== void 0 && (r.clearcoatRoughness = t.clearcoatRoughness), t.iridescence !== void 0 && (r.iridescence = t.iridescence), t.iridescenceIOR !== void 0 && (r.iridescenceIOR = t.iridescenceIOR), t.iridescenceThicknessRange !== void 0 && (r.iridescenceThicknessRange = t.iridescenceThicknessRange), t.transmission !== void 0 && (r.transmission = t.transmission), t.thickness !== void 0 && (r.thickness = t.thickness), t.attenuationDistance !== void 0 && (r.attenuationDistance = t.attenuationDistance), t.attenuationColor !== void 0 && r.attenuationColor !== void 0 && r.attenuationColor.setHex(t.attenuationColor), t.fog !== void 0 && (r.fog = t.fog), t.flatShading !== void 0 && (r.flatShading = t.flatShading), t.blending !== void 0 && (r.blending = t.blending), t.combine !== void 0 && (r.combine = t.combine), t.side !== void 0 && (r.side = t.side), t.shadowSide !== void 0 && (r.shadowSide = t.shadowSide), t.opacity !== void 0 && (r.opacity = t.opacity), t.transparent !== void 0 && (r.transparent = t.transparent), t.alphaTest !== void 0 && (r.alphaTest = t.alphaTest), t.depthTest !== void 0 && (r.depthTest = t.depthTest), t.depthWrite !== void 0 && (r.depthWrite = t.depthWrite), t.colorWrite !== void 0 && (r.colorWrite = t.colorWrite), t.stencilWrite !== void 0 && (r.stencilWrite = t.stencilWrite), t.stencilWriteMask !== void 0 && (r.stencilWriteMask = t.stencilWriteMask), t.stencilFunc !== void 0 && (r.stencilFunc = t.stencilFunc), t.stencilRef !== void 0 && (r.stencilRef = t.stencilRef), t.stencilFuncMask !== void 0 && (r.stencilFuncMask = t.stencilFuncMask), t.stencilFail !== void 0 && (r.stencilFail = t.stencilFail), t.stencilZFail !== void 0 && (r.stencilZFail = t.stencilZFail), t.stencilZPass !== void 0 && (r.stencilZPass = t.stencilZPass), t.wireframe !== void 0 && (r.wireframe = t.wireframe), t.wireframeLinewidth !== void 0 && (r.wireframeLinewidth = t.wireframeLinewidth), t.wireframeLinecap !== void 0 && (r.wireframeLinecap = t.wireframeLinecap), t.wireframeLinejoin !== void 0 && (r.wireframeLinejoin = t.wireframeLinejoin), t.rotation !== void 0 && (r.rotation = t.rotation), t.linewidth !== 1 && (r.linewidth = t.linewidth), t.dashSize !== void 0 && (r.dashSize = t.dashSize), t.gapSize !== void 0 && (r.gapSize = t.gapSize), t.scale !== void 0 && (r.scale = t.scale), t.polygonOffset !== void 0 && (r.polygonOffset = t.polygonOffset), t.polygonOffsetFactor !== void 0 && (r.polygonOffsetFactor = t.polygonOffsetFactor), t.polygonOffsetUnits !== void 0 && (r.polygonOffsetUnits = t.polygonOffsetUnits), t.dithering !== void 0 && (r.dithering = t.dithering), t.alphaToCoverage !== void 0 && (r.alphaToCoverage = t.alphaToCoverage), t.premultipliedAlpha !== void 0 && (r.premultipliedAlpha = t.premultipliedAlpha), t.forceSinglePass !== void 0 && (r.forceSinglePass = t.forceSinglePass), t.visible !== void 0 && (r.visible = t.visible), t.toneMapped !== void 0 && (r.toneMapped = t.toneMapped), t.userData !== void 0 && (r.userData = t.userData), t.vertexColors !== void 0 && (typeof t.vertexColors == "number" ? r.vertexColors = t.vertexColors > 0 : r.vertexColors = t.vertexColors), t.uniforms !== void 0)
      for (const s in t.uniforms) {
        const a = t.uniforms[s];
        switch (r.uniforms[s] = {}, a.type) {
          case "t":
            r.uniforms[s].value = n(a.value);
            break;
          case "c":
            r.uniforms[s].value = new Ht().setHex(a.value);
            break;
          case "v2":
            r.uniforms[s].value = new wt().fromArray(a.value);
            break;
          case "v3":
            r.uniforms[s].value = new D().fromArray(a.value);
            break;
          case "v4":
            r.uniforms[s].value = new ze().fromArray(a.value);
            break;
          case "m3":
            r.uniforms[s].value = new hi().fromArray(a.value);
            break;
          case "m4":
            r.uniforms[s].value = new Vt().fromArray(a.value);
            break;
          default:
            r.uniforms[s].value = a.value;
        }
      }
    if (t.defines !== void 0 && (r.defines = t.defines), t.vertexShader !== void 0 && (r.vertexShader = t.vertexShader), t.fragmentShader !== void 0 && (r.fragmentShader = t.fragmentShader), t.glslVersion !== void 0 && (r.glslVersion = t.glslVersion), t.extensions !== void 0)
      for (const s in t.extensions)
        r.extensions[s] = t.extensions[s];
    if (t.size !== void 0 && (r.size = t.size), t.sizeAttenuation !== void 0 && (r.sizeAttenuation = t.sizeAttenuation), t.map !== void 0 && (r.map = n(t.map)), t.matcap !== void 0 && (r.matcap = n(t.matcap)), t.alphaMap !== void 0 && (r.alphaMap = n(t.alphaMap)), t.bumpMap !== void 0 && (r.bumpMap = n(t.bumpMap)), t.bumpScale !== void 0 && (r.bumpScale = t.bumpScale), t.normalMap !== void 0 && (r.normalMap = n(t.normalMap)), t.normalMapType !== void 0 && (r.normalMapType = t.normalMapType), t.normalScale !== void 0) {
      let s = t.normalScale;
      Array.isArray(s) === !1 && (s = [s, s]), r.normalScale = new wt().fromArray(s);
    }
    return t.displacementMap !== void 0 && (r.displacementMap = n(t.displacementMap)), t.displacementScale !== void 0 && (r.displacementScale = t.displacementScale), t.displacementBias !== void 0 && (r.displacementBias = t.displacementBias), t.roughnessMap !== void 0 && (r.roughnessMap = n(t.roughnessMap)), t.metalnessMap !== void 0 && (r.metalnessMap = n(t.metalnessMap)), t.emissiveMap !== void 0 && (r.emissiveMap = n(t.emissiveMap)), t.emissiveIntensity !== void 0 && (r.emissiveIntensity = t.emissiveIntensity), t.specularMap !== void 0 && (r.specularMap = n(t.specularMap)), t.specularIntensityMap !== void 0 && (r.specularIntensityMap = n(t.specularIntensityMap)), t.specularColorMap !== void 0 && (r.specularColorMap = n(t.specularColorMap)), t.envMap !== void 0 && (r.envMap = n(t.envMap)), t.envMapIntensity !== void 0 && (r.envMapIntensity = t.envMapIntensity), t.reflectivity !== void 0 && (r.reflectivity = t.reflectivity), t.refractionRatio !== void 0 && (r.refractionRatio = t.refractionRatio), t.lightMap !== void 0 && (r.lightMap = n(t.lightMap)), t.lightMapIntensity !== void 0 && (r.lightMapIntensity = t.lightMapIntensity), t.aoMap !== void 0 && (r.aoMap = n(t.aoMap)), t.aoMapIntensity !== void 0 && (r.aoMapIntensity = t.aoMapIntensity), t.gradientMap !== void 0 && (r.gradientMap = n(t.gradientMap)), t.clearcoatMap !== void 0 && (r.clearcoatMap = n(t.clearcoatMap)), t.clearcoatRoughnessMap !== void 0 && (r.clearcoatRoughnessMap = n(t.clearcoatRoughnessMap)), t.clearcoatNormalMap !== void 0 && (r.clearcoatNormalMap = n(t.clearcoatNormalMap)), t.clearcoatNormalScale !== void 0 && (r.clearcoatNormalScale = new wt().fromArray(t.clearcoatNormalScale)), t.iridescenceMap !== void 0 && (r.iridescenceMap = n(t.iridescenceMap)), t.iridescenceThicknessMap !== void 0 && (r.iridescenceThicknessMap = n(t.iridescenceThicknessMap)), t.transmissionMap !== void 0 && (r.transmissionMap = n(t.transmissionMap)), t.thicknessMap !== void 0 && (r.thicknessMap = n(t.thicknessMap)), t.sheenColorMap !== void 0 && (r.sheenColorMap = n(t.sheenColorMap)), t.sheenRoughnessMap !== void 0 && (r.sheenRoughnessMap = n(t.sheenRoughnessMap)), r;
  }
  setTextures(t) {
    return this.textures = t, this;
  }
  static createMaterialFromType(t) {
    return new { ShadowMaterial: HI, SpriteMaterial: Vb, RawShaderMaterial: jI, ShaderMaterial: Gn, PointsMaterial: i0, MeshPhysicalMaterial: GI, MeshStandardMaterial: Ds, MeshPhongMaterial: WI, MeshToonMaterial: ZI, MeshNormalMaterial: Yb, MeshLambertMaterial: qI, MeshDepthMaterial: n0, MeshDistanceMaterial: Fb, MeshBasicMaterial: ci, MeshMatcapMaterial: XI, LineDashedMaterial: Jb, LineBasicMaterial: Ar, Material: Kr }[t]();
  }
}
class M_ {
  static decodeText(t) {
    if (typeof TextDecoder < "u")
      return new TextDecoder().decode(t);
    let e = "";
    for (let n = 0, r = t.length; n < r; n++)
      e += String.fromCharCode(t[n]);
    try {
      return decodeURIComponent(escape(e));
    } catch {
      return e;
    }
  }
  static extractUrlBase(t) {
    const e = t.lastIndexOf("/");
    return e === -1 ? "./" : t.slice(0, e + 1);
  }
  static resolveURL(t, e) {
    return typeof t != "string" || t === "" ? "" : (/^https?:\/\//i.test(e) && /^\//.test(t) && (e = e.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(t) || /^data:.*,.*$/i.test(t) || /^blob:.*$/i.test(t) ? t : e + t);
  }
}
class rS extends _e {
  constructor() {
    super(), this.isInstancedBufferGeometry = !0, this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0;
  }
  copy(t) {
    return super.copy(t), this.instanceCount = t.instanceCount, this;
  }
  toJSON() {
    const t = super.toJSON();
    return t.instanceCount = this.instanceCount, t.isInstancedBufferGeometry = !0, t;
  }
}
class OE extends Fi {
  constructor(t) {
    super(t);
  }
  load(t, e, n, r) {
    const s = this, a = new La(s.manager);
    a.setPath(s.path), a.setRequestHeader(s.requestHeader), a.setWithCredentials(s.withCredentials), a.load(t, function(o) {
      try {
        e(s.parse(JSON.parse(o)));
      } catch (l) {
        r ? r(l) : console.error(l), s.manager.itemError(t);
      }
    }, n, r);
  }
  parse(t) {
    const e = {}, n = {};
    function r(h, p) {
      if (e[p] !== void 0)
        return e[p];
      const f = h.interleavedBuffers[p], v = function(_, w) {
        if (n[w] !== void 0)
          return n[w];
        const b = _.arrayBuffers, T = b[w], M = new Uint32Array(T).buffer;
        return n[w] = M, M;
      }(h, f.buffer), m = _h(f.type, v), y = new r0(m, f.stride);
      return y.uuid = f.uuid, e[p] = y, y;
    }
    const s = t.isInstancedBufferGeometry ? new rS() : new _e(), a = t.data.index;
    if (a !== void 0) {
      const h = _h(a.type, a.array);
      s.setIndex(new Ze(h, 1));
    }
    const o = t.data.attributes;
    for (const h in o) {
      const p = o[h];
      let f;
      if (p.isInterleavedBufferAttribute) {
        const v = r(t.data, p.data);
        f = new Lr(v, p.itemSize, p.offset, p.normalized);
      } else {
        const v = _h(p.type, p.array);
        f = new (p.isInstancedBufferAttribute ? Dh : Ze)(v, p.itemSize, p.normalized);
      }
      p.name !== void 0 && (f.name = p.name), p.usage !== void 0 && f.setUsage(p.usage), p.updateRange !== void 0 && (f.updateRange.offset = p.updateRange.offset, f.updateRange.count = p.updateRange.count), s.setAttribute(h, f);
    }
    const l = t.data.morphAttributes;
    if (l)
      for (const h in l) {
        const p = l[h], f = [];
        for (let v = 0, m = p.length; v < m; v++) {
          const y = p[v];
          let _;
          if (y.isInterleavedBufferAttribute) {
            const w = r(t.data, y.data);
            _ = new Lr(w, y.itemSize, y.offset, y.normalized);
          } else {
            const w = _h(y.type, y.array);
            _ = new Ze(w, y.itemSize, y.normalized);
          }
          y.name !== void 0 && (_.name = y.name), f.push(_);
        }
        s.morphAttributes[h] = f;
      }
    t.data.morphTargetsRelative && (s.morphTargetsRelative = !0);
    const c = t.data.groups || t.data.drawcalls || t.data.offsets;
    if (c !== void 0)
      for (let h = 0, p = c.length; h !== p; ++h) {
        const f = c[h];
        s.addGroup(f.start, f.count, f.materialIndex);
      }
    const u = t.data.boundingSphere;
    if (u !== void 0) {
      const h = new D();
      u.center !== void 0 && h.fromArray(u.center), s.boundingSphere = new Mi(h, u.radius);
    }
    return t.name && (s.name = t.name), t.userData && (s.userData = t.userData), s;
  }
}
const EU = { UVMapping: 300, CubeReflectionMapping: 301, CubeRefractionMapping: 302, EquirectangularReflectionMapping: 303, EquirectangularRefractionMapping: 304, CubeUVReflectionMapping: 306 }, LE = { RepeatWrapping: 1e3, ClampToEdgeWrapping: 1001, MirroredRepeatWrapping: 1002 }, BE = { NearestFilter: 1003, NearestMipmapNearestFilter: 1004, NearestMipmapLinearFilter: 1005, LinearFilter: 1006, LinearMipmapNearestFilter: 1007, LinearMipmapLinearFilter: 1008 };
let xm;
class T_ {
  static getContext() {
    return xm === void 0 && (xm = new (window.AudioContext || window.webkitAudioContext)()), xm;
  }
  static setContext(t) {
    xm = t;
  }
}
const zE = new Vt(), kE = new Vt(), ol = new Vt();
class Cv {
  constructor(t = !0) {
    this.autoStart = t, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1;
  }
  start() {
    this.startTime = NE(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0;
  }
  stop() {
    this.getElapsedTime(), this.running = !1, this.autoStart = !1;
  }
  getElapsedTime() {
    return this.getDelta(), this.elapsedTime;
  }
  getDelta() {
    let t = 0;
    if (this.autoStart && !this.running)
      return this.start(), 0;
    if (this.running) {
      const e = NE();
      t = (e - this.oldTime) / 1e3, this.oldTime = e, this.elapsedTime += t;
    }
    return t;
  }
}
function NE() {
  return (typeof performance > "u" ? Date : performance).now();
}
const ll = new D(), FE = new kn(), AU = new D(), cl = new D();
class UE extends Ue {
  constructor(t) {
    super(), this.type = "Audio", this.listener = t, this.context = t.context, this.gain = this.context.createGain(), this.gain.connect(t.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = !1, this.filters = [];
  }
  getOutput() {
    return this.gain;
  }
  setNodeSource(t) {
    return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = t, this.connect(), this;
  }
  setMediaElementSource(t) {
    return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(t), this.connect(), this;
  }
  setMediaStreamSource(t) {
    return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(t), this.connect(), this;
  }
  setBuffer(t) {
    return this.buffer = t, this.sourceType = "buffer", this.autoplay && this.play(), this;
  }
  play(t = 0) {
    if (this.isPlaying === !0)
      return void console.warn("THREE.Audio: Audio is already playing.");
    if (this.hasPlaybackControl === !1)
      return void console.warn("THREE.Audio: this Audio has no playback control.");
    this._startedAt = this.context.currentTime + t;
    const e = this.context.createBufferSource();
    return e.buffer = this.buffer, e.loop = this.loop, e.loopStart = this.loopStart, e.loopEnd = this.loopEnd, e.onended = this.onEnded.bind(this), e.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = e, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect();
  }
  pause() {
    if (this.hasPlaybackControl !== !1)
      return this.isPlaying === !0 && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, this.loop === !0 && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this;
    console.warn("THREE.Audio: this Audio has no playback control.");
  }
  stop() {
    if (this.hasPlaybackControl !== !1)
      return this._progress = 0, this.source.stop(), this.source.onended = null, this.isPlaying = !1, this;
    console.warn("THREE.Audio: this Audio has no playback control.");
  }
  connect() {
    if (this.filters.length > 0) {
      this.source.connect(this.filters[0]);
      for (let t = 1, e = this.filters.length; t < e; t++)
        this.filters[t - 1].connect(this.filters[t]);
      this.filters[this.filters.length - 1].connect(this.getOutput());
    } else
      this.source.connect(this.getOutput());
    return this._connected = !0, this;
  }
  disconnect() {
    if (this.filters.length > 0) {
      this.source.disconnect(this.filters[0]);
      for (let t = 1, e = this.filters.length; t < e; t++)
        this.filters[t - 1].disconnect(this.filters[t]);
      this.filters[this.filters.length - 1].disconnect(this.getOutput());
    } else
      this.source.disconnect(this.getOutput());
    return this._connected = !1, this;
  }
  getFilters() {
    return this.filters;
  }
  setFilters(t) {
    return t || (t = []), this._connected === !0 ? (this.disconnect(), this.filters = t.slice(), this.connect()) : this.filters = t.slice(), this;
  }
  setDetune(t) {
    if (this.detune = t, this.source.detune !== void 0)
      return this.isPlaying === !0 && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01), this;
  }
  getDetune() {
    return this.detune;
  }
  getFilter() {
    return this.getFilters()[0];
  }
  setFilter(t) {
    return this.setFilters(t ? [t] : []);
  }
  setPlaybackRate(t) {
    if (this.hasPlaybackControl !== !1)
      return this.playbackRate = t, this.isPlaying === !0 && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01), this;
    console.warn("THREE.Audio: this Audio has no playback control.");
  }
  getPlaybackRate() {
    return this.playbackRate;
  }
  onEnded() {
    this.isPlaying = !1;
  }
  getLoop() {
    return this.hasPlaybackControl === !1 ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop;
  }
  setLoop(t) {
    if (this.hasPlaybackControl !== !1)
      return this.loop = t, this.isPlaying === !0 && (this.source.loop = this.loop), this;
    console.warn("THREE.Audio: this Audio has no playback control.");
  }
  setLoopStart(t) {
    return this.loopStart = t, this;
  }
  setLoopEnd(t) {
    return this.loopEnd = t, this;
  }
  getVolume() {
    return this.gain.gain.value;
  }
  setVolume(t) {
    return this.gain.gain.setTargetAtTime(t, this.context.currentTime, 0.01), this;
  }
}
const hl = new D(), VE = new kn(), CU = new D(), ul = new D();
class eO {
  constructor(t, e, n) {
    let r, s, a;
    switch (this.binding = t, this.valueSize = n, e) {
      case "quaternion":
        r = this._slerp, s = this._slerpAdditive, a = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(6 * n), this._workIndex = 5;
        break;
      case "string":
      case "bool":
        r = this._select, s = this._select, a = this._setAdditiveIdentityOther, this.buffer = new Array(5 * n);
        break;
      default:
        r = this._lerp, s = this._lerpAdditive, a = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(5 * n);
    }
    this._mixBufferRegion = r, this._mixBufferRegionAdditive = s, this._setIdentity = a, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0;
  }
  accumulate(t, e) {
    const n = this.buffer, r = this.valueSize, s = t * r + r;
    let a = this.cumulativeWeight;
    if (a === 0) {
      for (let o = 0; o !== r; ++o)
        n[s + o] = n[o];
      a = e;
    } else {
      a += e;
      const o = e / a;
      this._mixBufferRegion(n, s, 0, o, r);
    }
    this.cumulativeWeight = a;
  }
  accumulateAdditive(t) {
    const e = this.buffer, n = this.valueSize, r = n * this._addIndex;
    this.cumulativeWeightAdditive === 0 && this._setIdentity(), this._mixBufferRegionAdditive(e, r, 0, t, n), this.cumulativeWeightAdditive += t;
  }
  apply(t) {
    const e = this.valueSize, n = this.buffer, r = t * e + e, s = this.cumulativeWeight, a = this.cumulativeWeightAdditive, o = this.binding;
    if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, s < 1) {
      const l = e * this._origIndex;
      this._mixBufferRegion(n, r, l, 1 - s, e);
    }
    a > 0 && this._mixBufferRegionAdditive(n, r, this._addIndex * e, 1, e);
    for (let l = e, c = e + e; l !== c; ++l)
      if (n[l] !== n[l + e]) {
        o.setValue(n, r);
        break;
      }
  }
  saveOriginalState() {
    const t = this.binding, e = this.buffer, n = this.valueSize, r = n * this._origIndex;
    t.getValue(e, r);
    for (let s = n, a = r; s !== a; ++s)
      e[s] = e[r + s % n];
    this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0;
  }
  restoreOriginalState() {
    const t = 3 * this.valueSize;
    this.binding.setValue(this.buffer, t);
  }
  _setAdditiveIdentityNumeric() {
    const t = this._addIndex * this.valueSize, e = t + this.valueSize;
    for (let n = t; n < e; n++)
      this.buffer[n] = 0;
  }
  _setAdditiveIdentityQuaternion() {
    this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1;
  }
  _setAdditiveIdentityOther() {
    const t = this._origIndex * this.valueSize, e = this._addIndex * this.valueSize;
    for (let n = 0; n < this.valueSize; n++)
      this.buffer[e + n] = this.buffer[t + n];
  }
  _select(t, e, n, r, s) {
    if (r >= 0.5)
      for (let a = 0; a !== s; ++a)
        t[e + a] = t[n + a];
  }
  _slerp(t, e, n, r) {
    kn.slerpFlat(t, e, t, e, t, n, r);
  }
  _slerpAdditive(t, e, n, r, s) {
    const a = this._workIndex * s;
    kn.multiplyQuaternionsFlat(t, a, t, e, t, n), kn.slerpFlat(t, e, t, e, t, a, r);
  }
  _lerp(t, e, n, r, s) {
    const a = 1 - r;
    for (let o = 0; o !== s; ++o) {
      const l = e + o;
      t[l] = t[l] * a + t[n + o] * r;
    }
  }
  _lerpAdditive(t, e, n, r, s) {
    for (let a = 0; a !== s; ++a) {
      const o = e + a;
      t[o] = t[o] + t[n + a] * r;
    }
  }
}
const iS = "\\[\\]\\.:\\/", PU = new RegExp("[" + iS + "]", "g"), E_ = "[^" + iS + "]", DU = "[^" + iS.replace("\\.", "") + "]", RU = new RegExp("^" + /((?:WC+[\/:])*)/.source.replace("WC", E_) + /(WCOD+)?/.source.replace("WCOD", DU) + /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", E_) + /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", E_) + "$"), IU = ["material", "materials", "bones", "map"];
class Ye {
  constructor(t, e, n) {
    this.path = e, this.parsedPath = n || Ye.parseTrackName(e), this.node = Ye.findNode(t, this.parsedPath.nodeName) || t, this.rootNode = t, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
  }
  static create(t, e, n) {
    return t && t.isAnimationObjectGroup ? new Ye.Composite(t, e, n) : new Ye(t, e, n);
  }
  static sanitizeNodeName(t) {
    return t.replace(/\s/g, "_").replace(PU, "");
  }
  static parseTrackName(t) {
    const e = RU.exec(t);
    if (e === null)
      throw new Error("PropertyBinding: Cannot parse trackName: " + t);
    const n = { nodeName: e[2], objectName: e[3], objectIndex: e[4], propertyName: e[5], propertyIndex: e[6] }, r = n.nodeName && n.nodeName.lastIndexOf(".");
    if (r !== void 0 && r !== -1) {
      const s = n.nodeName.substring(r + 1);
      IU.indexOf(s) !== -1 && (n.nodeName = n.nodeName.substring(0, r), n.objectName = s);
    }
    if (n.propertyName === null || n.propertyName.length === 0)
      throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t);
    return n;
  }
  static findNode(t, e) {
    if (e === void 0 || e === "" || e === "." || e === -1 || e === t.name || e === t.uuid)
      return t;
    if (t.skeleton) {
      const n = t.skeleton.getBoneByName(e);
      if (n !== void 0)
        return n;
    }
    if (t.children) {
      const n = function(s) {
        for (let a = 0; a < s.length; a++) {
          const o = s[a];
          if (o.name === e || o.uuid === e)
            return o;
          const l = n(o.children);
          if (l)
            return l;
        }
        return null;
      }, r = n(t.children);
      if (r)
        return r;
    }
    return null;
  }
  _getValue_unavailable() {
  }
  _setValue_unavailable() {
  }
  _getValue_direct(t, e) {
    t[e] = this.targetObject[this.propertyName];
  }
  _getValue_array(t, e) {
    const n = this.resolvedProperty;
    for (let r = 0, s = n.length; r !== s; ++r)
      t[e++] = n[r];
  }
  _getValue_arrayElement(t, e) {
    t[e] = this.resolvedProperty[this.propertyIndex];
  }
  _getValue_toArray(t, e) {
    this.resolvedProperty.toArray(t, e);
  }
  _setValue_direct(t, e) {
    this.targetObject[this.propertyName] = t[e];
  }
  _setValue_direct_setNeedsUpdate(t, e) {
    this.targetObject[this.propertyName] = t[e], this.targetObject.needsUpdate = !0;
  }
  _setValue_direct_setMatrixWorldNeedsUpdate(t, e) {
    this.targetObject[this.propertyName] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  _setValue_array(t, e) {
    const n = this.resolvedProperty;
    for (let r = 0, s = n.length; r !== s; ++r)
      n[r] = t[e++];
  }
  _setValue_array_setNeedsUpdate(t, e) {
    const n = this.resolvedProperty;
    for (let r = 0, s = n.length; r !== s; ++r)
      n[r] = t[e++];
    this.targetObject.needsUpdate = !0;
  }
  _setValue_array_setMatrixWorldNeedsUpdate(t, e) {
    const n = this.resolvedProperty;
    for (let r = 0, s = n.length; r !== s; ++r)
      n[r] = t[e++];
    this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  _setValue_arrayElement(t, e) {
    this.resolvedProperty[this.propertyIndex] = t[e];
  }
  _setValue_arrayElement_setNeedsUpdate(t, e) {
    this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.needsUpdate = !0;
  }
  _setValue_arrayElement_setMatrixWorldNeedsUpdate(t, e) {
    this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  _setValue_fromArray(t, e) {
    this.resolvedProperty.fromArray(t, e);
  }
  _setValue_fromArray_setNeedsUpdate(t, e) {
    this.resolvedProperty.fromArray(t, e), this.targetObject.needsUpdate = !0;
  }
  _setValue_fromArray_setMatrixWorldNeedsUpdate(t, e) {
    this.resolvedProperty.fromArray(t, e), this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  _getValue_unbound(t, e) {
    this.bind(), this.getValue(t, e);
  }
  _setValue_unbound(t, e) {
    this.bind(), this.setValue(t, e);
  }
  bind() {
    let t = this.node;
    const e = this.parsedPath, n = e.objectName, r = e.propertyName;
    let s = e.propertyIndex;
    if (t || (t = Ye.findNode(this.rootNode, e.nodeName) || this.rootNode, this.node = t), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !t)
      return void console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
    if (n) {
      let c = e.objectIndex;
      switch (n) {
        case "materials":
          if (!t.material)
            return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
          if (!t.material.materials)
            return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
          t = t.material.materials;
          break;
        case "bones":
          if (!t.skeleton)
            return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
          t = t.skeleton.bones;
          for (let u = 0; u < t.length; u++)
            if (t[u].name === c) {
              c = u;
              break;
            }
          break;
        case "map":
          if ("map" in t) {
            t = t.map;
            break;
          }
          if (!t.material)
            return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
          if (!t.material.map)
            return void console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
          t = t.material.map;
          break;
        default:
          if (t[n] === void 0)
            return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
          t = t[n];
      }
      if (c !== void 0) {
        if (t[c] === void 0)
          return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, t);
        t = t[c];
      }
    }
    const a = t[r];
    if (a === void 0) {
      const c = e.nodeName;
      return void console.error("THREE.PropertyBinding: Trying to update property for track: " + c + "." + r + " but it wasn't found.", t);
    }
    let o = this.Versioning.None;
    this.targetObject = t, t.needsUpdate !== void 0 ? o = this.Versioning.NeedsUpdate : t.matrixWorldNeedsUpdate !== void 0 && (o = this.Versioning.MatrixWorldNeedsUpdate);
    let l = this.BindingType.Direct;
    if (s !== void 0) {
      if (r === "morphTargetInfluences") {
        if (!t.geometry)
          return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
        if (!t.geometry.morphAttributes)
          return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
        t.morphTargetDictionary[s] !== void 0 && (s = t.morphTargetDictionary[s]);
      }
      l = this.BindingType.ArrayElement, this.resolvedProperty = a, this.propertyIndex = s;
    } else
      a.fromArray !== void 0 && a.toArray !== void 0 ? (l = this.BindingType.HasFromToArray, this.resolvedProperty = a) : Array.isArray(a) ? (l = this.BindingType.EntireArray, this.resolvedProperty = a) : this.propertyName = r;
    this.getValue = this.GetterByBindingType[l], this.setValue = this.SetterByBindingTypeAndVersioning[l][o];
  }
  unbind() {
    this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
  }
}
Ye.Composite = class {
  constructor(i, t, e) {
    const n = e || Ye.parseTrackName(t);
    this._targetGroup = i, this._bindings = i.subscribe_(t, n);
  }
  getValue(i, t) {
    this.bind();
    const e = this._targetGroup.nCachedObjects_, n = this._bindings[e];
    n !== void 0 && n.getValue(i, t);
  }
  setValue(i, t) {
    const e = this._bindings;
    for (let n = this._targetGroup.nCachedObjects_, r = e.length; n !== r; ++n)
      e[n].setValue(i, t);
  }
  bind() {
    const i = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, e = i.length; t !== e; ++t)
      i[t].bind();
  }
  unbind() {
    const i = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, e = i.length; t !== e; ++t)
      i[t].unbind();
  }
}, Ye.prototype.BindingType = { Direct: 0, EntireArray: 1, ArrayElement: 2, HasFromToArray: 3 }, Ye.prototype.Versioning = { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 }, Ye.prototype.GetterByBindingType = [Ye.prototype._getValue_direct, Ye.prototype._getValue_array, Ye.prototype._getValue_arrayElement, Ye.prototype._getValue_toArray], Ye.prototype.SetterByBindingTypeAndVersioning = [[Ye.prototype._setValue_direct, Ye.prototype._setValue_direct_setNeedsUpdate, Ye.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [Ye.prototype._setValue_array, Ye.prototype._setValue_array_setNeedsUpdate, Ye.prototype._setValue_array_setMatrixWorldNeedsUpdate], [Ye.prototype._setValue_arrayElement, Ye.prototype._setValue_arrayElement_setNeedsUpdate, Ye.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [Ye.prototype._setValue_fromArray, Ye.prototype._setValue_fromArray_setNeedsUpdate, Ye.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];
class OU {
  constructor(t, e, n = null, r = e.blendMode) {
    this._mixer = t, this._clip = e, this._localRoot = n, this.blendMode = r;
    const s = e.tracks, a = s.length, o = new Array(a), l = { endingStart: 2400, endingEnd: 2400 };
    for (let c = 0; c !== a; ++c) {
      const u = s[c].createInterpolant(null);
      o[c] = u, u.settings = l;
    }
    this._interpolantSettings = l, this._interpolants = o, this._propertyBindings = new Array(a), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = 2201, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0;
  }
  play() {
    return this._mixer._activateAction(this), this;
  }
  stop() {
    return this._mixer._deactivateAction(this), this.reset();
  }
  reset() {
    return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping();
  }
  isRunning() {
    return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
  }
  isScheduled() {
    return this._mixer._isActiveAction(this);
  }
  startAt(t) {
    return this._startTime = t, this;
  }
  setLoop(t, e) {
    return this.loop = t, this.repetitions = e, this;
  }
  setEffectiveWeight(t) {
    return this.weight = t, this._effectiveWeight = this.enabled ? t : 0, this.stopFading();
  }
  getEffectiveWeight() {
    return this._effectiveWeight;
  }
  fadeIn(t) {
    return this._scheduleFading(t, 0, 1);
  }
  fadeOut(t) {
    return this._scheduleFading(t, 1, 0);
  }
  crossFadeFrom(t, e, n) {
    if (t.fadeOut(e), this.fadeIn(e), n) {
      const r = this._clip.duration, s = t._clip.duration, a = s / r, o = r / s;
      t.warp(1, a, e), this.warp(o, 1, e);
    }
    return this;
  }
  crossFadeTo(t, e, n) {
    return t.crossFadeFrom(this, e, n);
  }
  stopFading() {
    const t = this._weightInterpolant;
    return t !== null && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this;
  }
  setEffectiveTimeScale(t) {
    return this.timeScale = t, this._effectiveTimeScale = this.paused ? 0 : t, this.stopWarping();
  }
  getEffectiveTimeScale() {
    return this._effectiveTimeScale;
  }
  setDuration(t) {
    return this.timeScale = this._clip.duration / t, this.stopWarping();
  }
  syncWith(t) {
    return this.time = t.time, this.timeScale = t.timeScale, this.stopWarping();
  }
  halt(t) {
    return this.warp(this._effectiveTimeScale, 0, t);
  }
  warp(t, e, n) {
    const r = this._mixer, s = r.time, a = this.timeScale;
    let o = this._timeScaleInterpolant;
    o === null && (o = r._lendControlInterpolant(), this._timeScaleInterpolant = o);
    const l = o.parameterPositions, c = o.sampleValues;
    return l[0] = s, l[1] = s + n, c[0] = t / a, c[1] = e / a, this;
  }
  stopWarping() {
    const t = this._timeScaleInterpolant;
    return t !== null && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this;
  }
  getMixer() {
    return this._mixer;
  }
  getClip() {
    return this._clip;
  }
  getRoot() {
    return this._localRoot || this._mixer._root;
  }
  _update(t, e, n, r) {
    if (!this.enabled)
      return void this._updateWeight(t);
    const s = this._startTime;
    if (s !== null) {
      const l = (t - s) * n;
      l < 0 || n === 0 ? e = 0 : (this._startTime = null, e = n * l);
    }
    e *= this._updateTimeScale(t);
    const a = this._updateTime(e), o = this._updateWeight(t);
    if (o > 0) {
      const l = this._interpolants, c = this._propertyBindings;
      if (this.blendMode === 2501)
        for (let u = 0, h = l.length; u !== h; ++u)
          l[u].evaluate(a), c[u].accumulateAdditive(o);
      else
        for (let u = 0, h = l.length; u !== h; ++u)
          l[u].evaluate(a), c[u].accumulate(r, o);
    }
  }
  _updateWeight(t) {
    let e = 0;
    if (this.enabled) {
      e = this.weight;
      const n = this._weightInterpolant;
      if (n !== null) {
        const r = n.evaluate(t)[0];
        e *= r, t > n.parameterPositions[1] && (this.stopFading(), r === 0 && (this.enabled = !1));
      }
    }
    return this._effectiveWeight = e, e;
  }
  _updateTimeScale(t) {
    let e = 0;
    if (!this.paused) {
      e = this.timeScale;
      const n = this._timeScaleInterpolant;
      n !== null && (e *= n.evaluate(t)[0], t > n.parameterPositions[1] && (this.stopWarping(), e === 0 ? this.paused = !0 : this.timeScale = e));
    }
    return this._effectiveTimeScale = e, e;
  }
  _updateTime(t) {
    const e = this._clip.duration, n = this.loop;
    let r = this.time + t, s = this._loopCount;
    const a = n === 2202;
    if (t === 0)
      return s === -1 ? r : a && (1 & s) == 1 ? e - r : r;
    if (n === 2200) {
      s === -1 && (this._loopCount = 0, this._setEndings(!0, !0, !1));
      t: {
        if (r >= e)
          r = e;
        else {
          if (!(r < 0)) {
            this.time = r;
            break t;
          }
          r = 0;
        }
        this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this.time = r, this._mixer.dispatchEvent({ type: "finished", action: this, direction: t < 0 ? -1 : 1 });
      }
    } else {
      if (s === -1 && (t >= 0 ? (s = 0, this._setEndings(!0, this.repetitions === 0, a)) : this._setEndings(this.repetitions === 0, !0, a)), r >= e || r < 0) {
        const o = Math.floor(r / e);
        r -= e * o, s += Math.abs(o);
        const l = this.repetitions - s;
        if (l <= 0)
          this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, r = t > 0 ? e : 0, this.time = r, this._mixer.dispatchEvent({ type: "finished", action: this, direction: t > 0 ? 1 : -1 });
        else {
          if (l === 1) {
            const c = t < 0;
            this._setEndings(c, !c, a);
          } else
            this._setEndings(!1, !1, a);
          this._loopCount = s, this.time = r, this._mixer.dispatchEvent({ type: "loop", action: this, loopDelta: o });
        }
      } else
        this.time = r;
      if (a && (1 & s) == 1)
        return e - r;
    }
    return r;
  }
  _setEndings(t, e, n) {
    const r = this._interpolantSettings;
    n ? (r.endingStart = 2401, r.endingEnd = 2401) : (r.endingStart = t ? this.zeroSlopeAtStart ? 2401 : 2400 : 2402, r.endingEnd = e ? this.zeroSlopeAtEnd ? 2401 : 2400 : 2402);
  }
  _scheduleFading(t, e, n) {
    const r = this._mixer, s = r.time;
    let a = this._weightInterpolant;
    a === null && (a = r._lendControlInterpolant(), this._weightInterpolant = a);
    const o = a.parameterPositions, l = a.sampleValues;
    return o[0] = s, l[0] = e, o[1] = s + t, l[1] = n, this;
  }
}
const LU = new Float32Array(1);
class nO extends Ga {
  constructor(t) {
    super(), this._root = t, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1;
  }
  _bindAction(t, e) {
    const n = t._localRoot || this._root, r = t._clip.tracks, s = r.length, a = t._propertyBindings, o = t._interpolants, l = n.uuid, c = this._bindingsByRootAndName;
    let u = c[l];
    u === void 0 && (u = {}, c[l] = u);
    for (let h = 0; h !== s; ++h) {
      const p = r[h], f = p.name;
      let v = u[f];
      if (v !== void 0)
        ++v.referenceCount, a[h] = v;
      else {
        if (v = a[h], v !== void 0) {
          v._cacheIndex === null && (++v.referenceCount, this._addInactiveBinding(v, l, f));
          continue;
        }
        const m = e && e._propertyBindings[h].binding.parsedPath;
        v = new eO(Ye.create(n, f, m), p.ValueTypeName, p.getValueSize()), ++v.referenceCount, this._addInactiveBinding(v, l, f), a[h] = v;
      }
      o[h].resultBuffer = v.buffer;
    }
  }
  _activateAction(t) {
    if (!this._isActiveAction(t)) {
      if (t._cacheIndex === null) {
        const n = (t._localRoot || this._root).uuid, r = t._clip.uuid, s = this._actionsByClip[r];
        this._bindAction(t, s && s.knownActions[0]), this._addInactiveAction(t, r, n);
      }
      const e = t._propertyBindings;
      for (let n = 0, r = e.length; n !== r; ++n) {
        const s = e[n];
        s.useCount++ == 0 && (this._lendBinding(s), s.saveOriginalState());
      }
      this._lendAction(t);
    }
  }
  _deactivateAction(t) {
    if (this._isActiveAction(t)) {
      const e = t._propertyBindings;
      for (let n = 0, r = e.length; n !== r; ++n) {
        const s = e[n];
        --s.useCount == 0 && (s.restoreOriginalState(), this._takeBackBinding(s));
      }
      this._takeBackAction(t);
    }
  }
  _initMemoryManager() {
    this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
    const t = this;
    this.stats = { actions: { get total() {
      return t._actions.length;
    }, get inUse() {
      return t._nActiveActions;
    } }, bindings: { get total() {
      return t._bindings.length;
    }, get inUse() {
      return t._nActiveBindings;
    } }, controlInterpolants: { get total() {
      return t._controlInterpolants.length;
    }, get inUse() {
      return t._nActiveControlInterpolants;
    } } };
  }
  _isActiveAction(t) {
    const e = t._cacheIndex;
    return e !== null && e < this._nActiveActions;
  }
  _addInactiveAction(t, e, n) {
    const r = this._actions, s = this._actionsByClip;
    let a = s[e];
    if (a === void 0)
      a = { knownActions: [t], actionByRoot: {} }, t._byClipCacheIndex = 0, s[e] = a;
    else {
      const o = a.knownActions;
      t._byClipCacheIndex = o.length, o.push(t);
    }
    t._cacheIndex = r.length, r.push(t), a.actionByRoot[n] = t;
  }
  _removeInactiveAction(t) {
    const e = this._actions, n = e[e.length - 1], r = t._cacheIndex;
    n._cacheIndex = r, e[r] = n, e.pop(), t._cacheIndex = null;
    const s = t._clip.uuid, a = this._actionsByClip, o = a[s], l = o.knownActions, c = l[l.length - 1], u = t._byClipCacheIndex;
    c._byClipCacheIndex = u, l[u] = c, l.pop(), t._byClipCacheIndex = null, delete o.actionByRoot[(t._localRoot || this._root).uuid], l.length === 0 && delete a[s], this._removeInactiveBindingsForAction(t);
  }
  _removeInactiveBindingsForAction(t) {
    const e = t._propertyBindings;
    for (let n = 0, r = e.length; n !== r; ++n) {
      const s = e[n];
      --s.referenceCount == 0 && this._removeInactiveBinding(s);
    }
  }
  _lendAction(t) {
    const e = this._actions, n = t._cacheIndex, r = this._nActiveActions++, s = e[r];
    t._cacheIndex = r, e[r] = t, s._cacheIndex = n, e[n] = s;
  }
  _takeBackAction(t) {
    const e = this._actions, n = t._cacheIndex, r = --this._nActiveActions, s = e[r];
    t._cacheIndex = r, e[r] = t, s._cacheIndex = n, e[n] = s;
  }
  _addInactiveBinding(t, e, n) {
    const r = this._bindingsByRootAndName, s = this._bindings;
    let a = r[e];
    a === void 0 && (a = {}, r[e] = a), a[n] = t, t._cacheIndex = s.length, s.push(t);
  }
  _removeInactiveBinding(t) {
    const e = this._bindings, n = t.binding, r = n.rootNode.uuid, s = n.path, a = this._bindingsByRootAndName, o = a[r], l = e[e.length - 1], c = t._cacheIndex;
    l._cacheIndex = c, e[c] = l, e.pop(), delete o[s], Object.keys(o).length === 0 && delete a[r];
  }
  _lendBinding(t) {
    const e = this._bindings, n = t._cacheIndex, r = this._nActiveBindings++, s = e[r];
    t._cacheIndex = r, e[r] = t, s._cacheIndex = n, e[n] = s;
  }
  _takeBackBinding(t) {
    const e = this._bindings, n = t._cacheIndex, r = --this._nActiveBindings, s = e[r];
    t._cacheIndex = r, e[r] = t, s._cacheIndex = n, e[n] = s;
  }
  _lendControlInterpolant() {
    const t = this._controlInterpolants, e = this._nActiveControlInterpolants++;
    let n = t[e];
    return n === void 0 && (n = new Qb(new Float32Array(2), new Float32Array(2), 1, LU), n.__cacheIndex = e, t[e] = n), n;
  }
  _takeBackControlInterpolant(t) {
    const e = this._controlInterpolants, n = t.__cacheIndex, r = --this._nActiveControlInterpolants, s = e[r];
    t.__cacheIndex = r, e[r] = t, s.__cacheIndex = n, e[n] = s;
  }
  clipAction(t, e, n) {
    const r = e || this._root, s = r.uuid;
    let a = typeof t == "string" ? Ih.findByName(r, t) : t;
    const o = a !== null ? a.uuid : t, l = this._actionsByClip[o];
    let c = null;
    if (n === void 0 && (n = a !== null ? a.blendMode : 2500), l !== void 0) {
      const h = l.actionByRoot[s];
      if (h !== void 0 && h.blendMode === n)
        return h;
      c = l.knownActions[0], a === null && (a = c._clip);
    }
    if (a === null)
      return null;
    const u = new OU(this, a, e, n);
    return this._bindAction(u, c), this._addInactiveAction(u, o, s), u;
  }
  existingAction(t, e) {
    const n = e || this._root, r = n.uuid, s = typeof t == "string" ? Ih.findByName(n, t) : t, a = s ? s.uuid : t, o = this._actionsByClip[a];
    return o !== void 0 && o.actionByRoot[r] || null;
  }
  stopAllAction() {
    const t = this._actions;
    for (let e = this._nActiveActions - 1; e >= 0; --e)
      t[e].stop();
    return this;
  }
  update(t) {
    t *= this.timeScale;
    const e = this._actions, n = this._nActiveActions, r = this.time += t, s = Math.sign(t), a = this._accuIndex ^= 1;
    for (let c = 0; c !== n; ++c)
      e[c]._update(r, t, s, a);
    const o = this._bindings, l = this._nActiveBindings;
    for (let c = 0; c !== l; ++c)
      o[c].apply(a);
    return this;
  }
  setTime(t) {
    this.time = 0;
    for (let e = 0; e < this._actions.length; e++)
      this._actions[e].time = 0;
    return this.update(t);
  }
  getRoot() {
    return this._root;
  }
  uncacheClip(t) {
    const e = this._actions, n = t.uuid, r = this._actionsByClip, s = r[n];
    if (s !== void 0) {
      const a = s.knownActions;
      for (let o = 0, l = a.length; o !== l; ++o) {
        const c = a[o];
        this._deactivateAction(c);
        const u = c._cacheIndex, h = e[e.length - 1];
        c._cacheIndex = null, c._byClipCacheIndex = null, h._cacheIndex = u, e[u] = h, e.pop(), this._removeInactiveBindingsForAction(c);
      }
      delete r[n];
    }
  }
  uncacheRoot(t) {
    const e = t.uuid, n = this._actionsByClip;
    for (const s in n) {
      const a = n[s].actionByRoot[e];
      a !== void 0 && (this._deactivateAction(a), this._removeInactiveAction(a));
    }
    const r = this._bindingsByRootAndName[e];
    if (r !== void 0)
      for (const s in r) {
        const a = r[s];
        a.restoreOriginalState(), this._removeInactiveBinding(a);
      }
  }
  uncacheAction(t, e) {
    const n = this.existingAction(t, e);
    n !== null && (this._deactivateAction(n), this._removeInactiveAction(n));
  }
}
class sS {
  constructor(t) {
    this.value = t;
  }
  clone() {
    return new sS(this.value.clone === void 0 ? this.value : this.value.clone());
  }
}
let BU = 0;
class Vh extends r0 {
  constructor(t, e, n = 1) {
    super(t, e), this.isInstancedInterleavedBuffer = !0, this.meshPerAttribute = n;
  }
  copy(t) {
    return super.copy(t), this.meshPerAttribute = t.meshPerAttribute, this;
  }
  clone(t) {
    const e = super.clone(t);
    return e.meshPerAttribute = this.meshPerAttribute, e;
  }
  toJSON(t) {
    const e = super.toJSON(t);
    return e.isInstancedInterleavedBuffer = !0, e.meshPerAttribute = this.meshPerAttribute, e;
  }
}
class iu {
  constructor(t, e, n = 0, r = 1 / 0) {
    this.ray = new Uo(t, e), this.near = n, this.far = r, this.camera = null, this.layers = new $v(), this.params = { Mesh: {}, Line: { threshold: 1 }, LOD: {}, Points: { threshold: 1 }, Sprite: {} };
  }
  set(t, e) {
    this.ray.set(t, e);
  }
  setFromCamera(t, e) {
    e.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(t.x, t.y, 0.5).unproject(e).sub(this.ray.origin).normalize(), this.camera = e) : e.isOrthographicCamera ? (this.ray.origin.set(t.x, t.y, (e.near + e.far) / (e.near - e.far)).unproject(e), this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld), this.camera = e) : console.error("THREE.Raycaster: Unsupported camera type: " + e.type);
  }
  intersectObject(t, e = !0, n = []) {
    return px(t, this, n, e), n.sort(HE), n;
  }
  intersectObjects(t, e = !0, n = []) {
    for (let r = 0, s = t.length; r < s; r++)
      px(t[r], this, n, e);
    return n.sort(HE), n;
  }
}
function HE(i, t) {
  return i.distance - t.distance;
}
function px(i, t, e, n) {
  if (i.layers.test(t.layers) && i.raycast(t, e), n === !0) {
    const r = i.children;
    for (let s = 0, a = r.length; s < a; s++)
      px(r[s], t, e, !0);
  }
}
class rO {
  constructor(t = 1, e = 0, n = 0) {
    return this.radius = t, this.phi = e, this.theta = n, this;
  }
  set(t, e, n) {
    return this.radius = t, this.phi = e, this.theta = n, this;
  }
  copy(t) {
    return this.radius = t.radius, this.phi = t.phi, this.theta = t.theta, this;
  }
  makeSafe() {
    return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this;
  }
  setFromVector3(t) {
    return this.setFromCartesianCoords(t.x, t.y, t.z);
  }
  setFromCartesianCoords(t, e, n) {
    return this.radius = Math.sqrt(t * t + e * e + n * n), this.radius === 0 ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(t, n), this.phi = Math.acos(rr(e / this.radius, -1, 1))), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const jE = new wt(), GE = new D(), bm = new D();
class ss {
  constructor(t = new D(), e = new D()) {
    this.start = t, this.end = e;
  }
  set(t, e) {
    return this.start.copy(t), this.end.copy(e), this;
  }
  copy(t) {
    return this.start.copy(t.start), this.end.copy(t.end), this;
  }
  getCenter(t) {
    return t.addVectors(this.start, this.end).multiplyScalar(0.5);
  }
  delta(t) {
    return t.subVectors(this.end, this.start);
  }
  distanceSq() {
    return this.start.distanceToSquared(this.end);
  }
  distance() {
    return this.start.distanceTo(this.end);
  }
  at(t, e) {
    return this.delta(e).multiplyScalar(t).add(this.start);
  }
  closestPointToPointParameter(t, e) {
    GE.subVectors(t, this.start), bm.subVectors(this.end, this.start);
    const n = bm.dot(bm);
    let r = bm.dot(GE) / n;
    return e && (r = rr(r, 0, 1)), r;
  }
  closestPointToPoint(t, e, n) {
    const r = this.closestPointToPointParameter(t, e);
    return this.delta(n).multiplyScalar(r).add(this.start);
  }
  applyMatrix4(t) {
    return this.start.applyMatrix4(t), this.end.applyMatrix4(t), this;
  }
  equals(t) {
    return t.start.equals(this.start) && t.end.equals(this.end);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const WE = new D(), mo = new D(), Sm = new Vt(), A_ = new Vt();
function iO(i) {
  const t = [];
  i.isBone === !0 && t.push(i);
  for (let e = 0; e < i.children.length; e++)
    t.push.apply(t, iO(i.children[e]));
  return t;
}
const zU = new D(), ZE = new Ht(), qE = new Ht(), XE = new D(), Mm = new D(), YE = new D();
class sO extends Ue {
  constructor(t, e, n) {
    super(), this.light = t, this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = n, this.type = "DirectionalLightHelper", e === void 0 && (e = 1);
    let r = new _e();
    r.setAttribute("position", new Wt([-e, e, 0, e, e, 0, e, -e, 0, -e, -e, 0, -e, e, 0], 3));
    const s = new Ar({ fog: !1, toneMapped: !1 });
    this.lightPlane = new Yr(r, s), this.add(this.lightPlane), r = new _e(), r.setAttribute("position", new Wt([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new Yr(r, s), this.add(this.targetLine), this.update();
  }
  dispose() {
    this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1), this.light.target.updateWorldMatrix(!0, !1), XE.setFromMatrixPosition(this.light.matrixWorld), Mm.setFromMatrixPosition(this.light.target.matrixWorld), YE.subVectors(Mm, XE), this.lightPlane.lookAt(Mm), this.color !== void 0 ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(Mm), this.targetLine.scale.z = YE.length();
  }
}
const Tm = new D(), Xn = new Qv();
class aS extends Ts {
  constructor(t) {
    const e = new _e(), n = new Ar({ color: 16777215, vertexColors: !0, toneMapped: !1 }), r = [], s = [], a = {};
    function o(v, m) {
      l(v), l(m);
    }
    function l(v) {
      r.push(0, 0, 0), s.push(0, 0, 0), a[v] === void 0 && (a[v] = []), a[v].push(r.length / 3 - 1);
    }
    o("n1", "n2"), o("n2", "n4"), o("n4", "n3"), o("n3", "n1"), o("f1", "f2"), o("f2", "f4"), o("f4", "f3"), o("f3", "f1"), o("n1", "f1"), o("n2", "f2"), o("n3", "f3"), o("n4", "f4"), o("p", "n1"), o("p", "n2"), o("p", "n3"), o("p", "n4"), o("u1", "u2"), o("u2", "u3"), o("u3", "u1"), o("c", "t"), o("p", "c"), o("cn1", "cn2"), o("cn3", "cn4"), o("cf1", "cf2"), o("cf3", "cf4"), e.setAttribute("position", new Wt(r, 3)), e.setAttribute("color", new Wt(s, 3)), super(e, n), this.type = "CameraHelper", this.camera = t, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = a, this.update();
    const c = new Ht(16755200), u = new Ht(16711680), h = new Ht(43775), p = new Ht(16777215), f = new Ht(3355443);
    this.setColors(c, u, h, p, f);
  }
  setColors(t, e, n, r, s) {
    const a = this.geometry.getAttribute("color");
    a.setXYZ(0, t.r, t.g, t.b), a.setXYZ(1, t.r, t.g, t.b), a.setXYZ(2, t.r, t.g, t.b), a.setXYZ(3, t.r, t.g, t.b), a.setXYZ(4, t.r, t.g, t.b), a.setXYZ(5, t.r, t.g, t.b), a.setXYZ(6, t.r, t.g, t.b), a.setXYZ(7, t.r, t.g, t.b), a.setXYZ(8, t.r, t.g, t.b), a.setXYZ(9, t.r, t.g, t.b), a.setXYZ(10, t.r, t.g, t.b), a.setXYZ(11, t.r, t.g, t.b), a.setXYZ(12, t.r, t.g, t.b), a.setXYZ(13, t.r, t.g, t.b), a.setXYZ(14, t.r, t.g, t.b), a.setXYZ(15, t.r, t.g, t.b), a.setXYZ(16, t.r, t.g, t.b), a.setXYZ(17, t.r, t.g, t.b), a.setXYZ(18, t.r, t.g, t.b), a.setXYZ(19, t.r, t.g, t.b), a.setXYZ(20, t.r, t.g, t.b), a.setXYZ(21, t.r, t.g, t.b), a.setXYZ(22, t.r, t.g, t.b), a.setXYZ(23, t.r, t.g, t.b), a.setXYZ(24, e.r, e.g, e.b), a.setXYZ(25, e.r, e.g, e.b), a.setXYZ(26, e.r, e.g, e.b), a.setXYZ(27, e.r, e.g, e.b), a.setXYZ(28, e.r, e.g, e.b), a.setXYZ(29, e.r, e.g, e.b), a.setXYZ(30, e.r, e.g, e.b), a.setXYZ(31, e.r, e.g, e.b), a.setXYZ(32, n.r, n.g, n.b), a.setXYZ(33, n.r, n.g, n.b), a.setXYZ(34, n.r, n.g, n.b), a.setXYZ(35, n.r, n.g, n.b), a.setXYZ(36, n.r, n.g, n.b), a.setXYZ(37, n.r, n.g, n.b), a.setXYZ(38, r.r, r.g, r.b), a.setXYZ(39, r.r, r.g, r.b), a.setXYZ(40, s.r, s.g, s.b), a.setXYZ(41, s.r, s.g, s.b), a.setXYZ(42, s.r, s.g, s.b), a.setXYZ(43, s.r, s.g, s.b), a.setXYZ(44, s.r, s.g, s.b), a.setXYZ(45, s.r, s.g, s.b), a.setXYZ(46, s.r, s.g, s.b), a.setXYZ(47, s.r, s.g, s.b), a.setXYZ(48, s.r, s.g, s.b), a.setXYZ(49, s.r, s.g, s.b), a.needsUpdate = !0;
  }
  update() {
    const t = this.geometry, e = this.pointMap;
    Xn.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), er("c", e, t, Xn, 0, 0, -1), er("t", e, t, Xn, 0, 0, 1), er("n1", e, t, Xn, -1, -1, -1), er("n2", e, t, Xn, 1, -1, -1), er("n3", e, t, Xn, -1, 1, -1), er("n4", e, t, Xn, 1, 1, -1), er("f1", e, t, Xn, -1, -1, 1), er("f2", e, t, Xn, 1, -1, 1), er("f3", e, t, Xn, -1, 1, 1), er("f4", e, t, Xn, 1, 1, 1), er("u1", e, t, Xn, 0.7, 1.1, -1), er("u2", e, t, Xn, -0.7, 1.1, -1), er("u3", e, t, Xn, 0, 2, -1), er("cf1", e, t, Xn, -1, 0, 1), er("cf2", e, t, Xn, 1, 0, 1), er("cf3", e, t, Xn, 0, -1, 1), er("cf4", e, t, Xn, 0, 1, 1), er("cn1", e, t, Xn, -1, 0, -1), er("cn2", e, t, Xn, 1, 0, -1), er("cn3", e, t, Xn, 0, -1, -1), er("cn4", e, t, Xn, 0, 1, -1), t.getAttribute("position").needsUpdate = !0;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
function er(i, t, e, n, r, s, a) {
  Tm.set(r, s, a).unproject(n);
  const o = t[i];
  if (o !== void 0) {
    const l = e.getAttribute("position");
    for (let c = 0, u = o.length; c < u; c++)
      l.setXYZ(o[c], Tm.x, Tm.y, Tm.z);
  }
}
const Em = new ke();
class aO extends Ts {
  constructor(t, e = 16776960) {
    const n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), r = new Float32Array(24), s = new _e();
    s.setIndex(new Ze(n, 1)), s.setAttribute("position", new Ze(r, 3)), super(s, new Ar({ color: e, toneMapped: !1 })), this.object = t, this.type = "BoxHelper", this.matrixAutoUpdate = !1, this.update();
  }
  update(t) {
    if (t !== void 0 && console.warn("THREE.BoxHelper: .update() has no longer arguments."), this.object !== void 0 && Em.setFromObject(this.object), Em.isEmpty())
      return;
    const e = Em.min, n = Em.max, r = this.geometry.attributes.position, s = r.array;
    s[0] = n.x, s[1] = n.y, s[2] = n.z, s[3] = e.x, s[4] = n.y, s[5] = n.z, s[6] = e.x, s[7] = e.y, s[8] = n.z, s[9] = n.x, s[10] = e.y, s[11] = n.z, s[12] = n.x, s[13] = n.y, s[14] = e.z, s[15] = e.x, s[16] = n.y, s[17] = e.z, s[18] = e.x, s[19] = e.y, s[20] = e.z, s[21] = n.x, s[22] = e.y, s[23] = e.z, r.needsUpdate = !0, this.geometry.computeBoundingSphere();
  }
  setFromObject(t) {
    return this.object = t, this.update(), this;
  }
  copy(t, e) {
    return super.copy(t, e), this.object = t.object, this;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class oO extends Ts {
  constructor(t, e = 16776960) {
    const n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), r = new _e();
    r.setIndex(new Ze(n, 1)), r.setAttribute("position", new Wt([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], 3)), super(r, new Ar({ color: e, toneMapped: !1 })), this.box = t, this.type = "Box3Helper", this.geometry.computeBoundingSphere();
  }
  updateMatrixWorld(t) {
    const e = this.box;
    e.isEmpty() || (e.getCenter(this.position), e.getSize(this.scale), this.scale.multiplyScalar(0.5), super.updateMatrixWorld(t));
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
const JE = new D();
let Am, C_;
const xa = kU();
function kU() {
  const i = new ArrayBuffer(4), t = new Float32Array(i), e = new Uint32Array(i), n = new Uint32Array(512), r = new Uint32Array(512);
  for (let l = 0; l < 256; ++l) {
    const c = l - 127;
    c < -27 ? (n[l] = 0, n[256 | l] = 32768, r[l] = 24, r[256 | l] = 24) : c < -14 ? (n[l] = 1024 >> -c - 14, n[256 | l] = 1024 >> -c - 14 | 32768, r[l] = -c - 1, r[256 | l] = -c - 1) : c <= 15 ? (n[l] = c + 15 << 10, n[256 | l] = c + 15 << 10 | 32768, r[l] = 13, r[256 | l] = 13) : c < 128 ? (n[l] = 31744, n[256 | l] = 64512, r[l] = 24, r[256 | l] = 24) : (n[l] = 31744, n[256 | l] = 64512, r[l] = 13, r[256 | l] = 13);
  }
  const s = new Uint32Array(2048), a = new Uint32Array(64), o = new Uint32Array(64);
  for (let l = 1; l < 1024; ++l) {
    let c = l << 13, u = 0;
    for (; !(8388608 & c); )
      c <<= 1, u -= 8388608;
    c &= -8388609, u += 947912704, s[l] = c | u;
  }
  for (let l = 1024; l < 2048; ++l)
    s[l] = 939524096 + (l - 1024 << 13);
  for (let l = 1; l < 31; ++l)
    a[l] = l << 23;
  a[31] = 1199570944, a[32] = 2147483648;
  for (let l = 33; l < 63; ++l)
    a[l] = 2147483648 + (l - 32 << 23);
  a[63] = 3347054592;
  for (let l = 1; l < 64; ++l)
    l !== 32 && (o[l] = 1024);
  return { floatView: t, uint32View: e, baseTable: n, shiftTable: r, mantissaTable: s, exponentTable: a, offsetTable: o };
}
var kl = Object.freeze({ __proto__: null, fromHalfFloat: function(i) {
  const t = i >> 10;
  return xa.uint32View[0] = xa.mantissaTable[xa.offsetTable[t] + (1023 & i)] + xa.exponentTable[t], xa.floatView[0];
}, toHalfFloat: function(i) {
  Math.abs(i) > 65504 && console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."), i = rr(i, -65504, 65504), xa.floatView[0] = i;
  const t = xa.uint32View[0], e = t >> 23 & 511;
  return xa.baseTable[e] + ((8388607 & t) >> xa.shiftTable[e]);
} });
class lO extends zn {
  constructor(t, e, n, r, s, a) {
    console.warn("THREE.BoxBufferGeometry has been renamed to THREE.BoxGeometry."), super(t, e, n, r, s, a);
  }
}
typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: { revision: wv } })), typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = wv);
const NU = Object.freeze(Object.defineProperty({ __proto__: null, ACESFilmicToneMapping: 4, AddEquation: 100, AddOperation: 2, AdditiveAnimationBlendMode: 2501, AdditiveBlending: 2, AlphaFormat: 1021, AlwaysDepth: 1, AlwaysStencilFunc: 519, AmbientLight: dx, AmbientLightProbe: class extends wm {
  constructor(i, t = 1) {
    super(void 0, t), this.isAmbientLightProbe = !0;
    const e = new Ht().set(i);
    this.sh.coefficients[0].set(e.r, e.g, e.b).multiplyScalar(2 * Math.sqrt(Math.PI));
  }
}, AnimationClip: Ih, AnimationLoader: class extends Fi {
  constructor(i) {
    super(i);
  }
  load(i, t, e, n) {
    const r = this, s = new La(this.manager);
    s.setPath(this.path), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials), s.load(i, function(a) {
      try {
        t(r.parse(JSON.parse(a)));
      } catch (o) {
        n ? n(o) : console.error(o), r.manager.itemError(i);
      }
    }, e, n);
  }
  parse(i) {
    const t = [];
    for (let e = 0; e < i.length; e++) {
      const n = Ih.parse(i[e]);
      t.push(n);
    }
    return t;
  }
}, AnimationMixer: nO, AnimationObjectGroup: class {
  constructor() {
    this.isAnimationObjectGroup = !0, this.uuid = Vi(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
    const i = {};
    this._indicesByUUID = i;
    for (let e = 0, n = arguments.length; e !== n; ++e)
      i[arguments[e].uuid] = e;
    this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
    const t = this;
    this.stats = { objects: { get total() {
      return t._objects.length;
    }, get inUse() {
      return this.total - t.nCachedObjects_;
    } }, get bindingsPerObject() {
      return t._bindings.length;
    } };
  }
  add() {
    const i = this._objects, t = this._indicesByUUID, e = this._paths, n = this._parsedPaths, r = this._bindings, s = r.length;
    let a, o = i.length, l = this.nCachedObjects_;
    for (let c = 0, u = arguments.length; c !== u; ++c) {
      const h = arguments[c], p = h.uuid;
      let f = t[p];
      if (f === void 0) {
        f = o++, t[p] = f, i.push(h);
        for (let v = 0, m = s; v !== m; ++v)
          r[v].push(new Ye(h, e[v], n[v]));
      } else if (f < l) {
        a = i[f];
        const v = --l, m = i[v];
        t[m.uuid] = f, i[f] = m, t[p] = v, i[v] = h;
        for (let y = 0, _ = s; y !== _; ++y) {
          const w = r[y], b = w[v];
          let T = w[f];
          w[f] = b, T === void 0 && (T = new Ye(h, e[y], n[y])), w[v] = T;
        }
      } else
        i[f] !== a && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.");
    }
    this.nCachedObjects_ = l;
  }
  remove() {
    const i = this._objects, t = this._indicesByUUID, e = this._bindings, n = e.length;
    let r = this.nCachedObjects_;
    for (let s = 0, a = arguments.length; s !== a; ++s) {
      const o = arguments[s], l = o.uuid, c = t[l];
      if (c !== void 0 && c >= r) {
        const u = r++, h = i[u];
        t[h.uuid] = c, i[c] = h, t[l] = u, i[u] = o;
        for (let p = 0, f = n; p !== f; ++p) {
          const v = e[p], m = v[u], y = v[c];
          v[c] = m, v[u] = y;
        }
      }
    }
    this.nCachedObjects_ = r;
  }
  uncache() {
    const i = this._objects, t = this._indicesByUUID, e = this._bindings, n = e.length;
    let r = this.nCachedObjects_, s = i.length;
    for (let a = 0, o = arguments.length; a !== o; ++a) {
      const l = arguments[a].uuid, c = t[l];
      if (c !== void 0)
        if (delete t[l], c < r) {
          const u = --r, h = i[u], p = --s, f = i[p];
          t[h.uuid] = c, i[c] = h, t[f.uuid] = u, i[u] = f, i.pop();
          for (let v = 0, m = n; v !== m; ++v) {
            const y = e[v], _ = y[u], w = y[p];
            y[c] = _, y[u] = w, y.pop();
          }
        } else {
          const u = --s, h = i[u];
          u > 0 && (t[h.uuid] = c), i[c] = h, i.pop();
          for (let p = 0, f = n; p !== f; ++p) {
            const v = e[p];
            v[c] = v[u], v.pop();
          }
        }
    }
    this.nCachedObjects_ = r;
  }
  subscribe_(i, t) {
    const e = this._bindingsIndicesByPath;
    let n = e[i];
    const r = this._bindings;
    if (n !== void 0)
      return r[n];
    const s = this._paths, a = this._parsedPaths, o = this._objects, l = o.length, c = this.nCachedObjects_, u = new Array(l);
    n = r.length, e[i] = n, s.push(i), a.push(t), r.push(u);
    for (let h = c, p = o.length; h !== p; ++h) {
      const f = o[h];
      u[h] = new Ye(f, i, t);
    }
    return u;
  }
  unsubscribe_(i) {
    const t = this._bindingsIndicesByPath, e = t[i];
    if (e !== void 0) {
      const n = this._paths, r = this._parsedPaths, s = this._bindings, a = s.length - 1, o = s[a];
      t[i[a]] = e, s[e] = o, s.pop(), r[e] = r[a], r.pop(), n[e] = n[a], n.pop();
    }
  }
}, AnimationUtils: wU, ArcCurve: LI, ArrayCamera: DI, ArrowHelper: class extends Ue {
  constructor(i = new D(0, 0, 1), t = new D(0, 0, 0), e = 1, n = 16776960, r = 0.2 * e, s = 0.2 * r) {
    super(), this.type = "ArrowHelper", Am === void 0 && (Am = new _e(), Am.setAttribute("position", new Wt([0, 0, 0, 0, 1, 0], 3)), C_ = new nr(0, 0.5, 1, 5, 1), C_.translate(0, -0.5, 0)), this.position.copy(t), this.line = new Yr(Am, new Ar({ color: n, toneMapped: !1 })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new Nt(C_, new ci({ color: n, toneMapped: !1 })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(i), this.setLength(e, r, s);
  }
  setDirection(i) {
    if (i.y > 0.99999)
      this.quaternion.set(0, 0, 0, 1);
    else if (i.y < -0.99999)
      this.quaternion.set(1, 0, 0, 0);
    else {
      JE.set(i.z, 0, -i.x).normalize();
      const t = Math.acos(i.y);
      this.quaternion.setFromAxisAngle(JE, t);
    }
  }
  setLength(i, t = 0.2 * i, e = 0.2 * t) {
    this.line.scale.set(1, Math.max(1e-4, i - t), 1), this.line.updateMatrix(), this.cone.scale.set(e, t, e), this.cone.position.y = i, this.cone.updateMatrix();
  }
  setColor(i) {
    this.line.material.color.set(i), this.cone.material.color.set(i);
  }
  copy(i) {
    return super.copy(i, !1), this.line.copy(i.line), this.cone.copy(i.cone), this;
  }
  dispose() {
    this.line.geometry.dispose(), this.line.material.dispose(), this.cone.geometry.dispose(), this.cone.material.dispose();
  }
}, Audio: UE, AudioAnalyser: class {
  constructor(i, t = 2048) {
    this.analyser = i.context.createAnalyser(), this.analyser.fftSize = t, this.data = new Uint8Array(this.analyser.frequencyBinCount), i.getOutput().connect(this.analyser);
  }
  getFrequencyData() {
    return this.analyser.getByteFrequencyData(this.data), this.data;
  }
  getAverageFrequency() {
    let i = 0;
    const t = this.getFrequencyData();
    for (let e = 0; e < t.length; e++)
      i += t[e];
    return i / t.length;
  }
}, AudioContext: T_, AudioListener: class extends Ue {
  constructor() {
    super(), this.type = "AudioListener", this.context = T_.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new Cv();
  }
  getInput() {
    return this.gain;
  }
  removeFilter() {
    return this.filter !== null && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this;
  }
  getFilter() {
    return this.filter;
  }
  setFilter(i) {
    return this.filter !== null ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = i, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this;
  }
  getMasterVolume() {
    return this.gain.gain.value;
  }
  setMasterVolume(i) {
    return this.gain.gain.setTargetAtTime(i, this.context.currentTime, 0.01), this;
  }
  updateMatrixWorld(i) {
    super.updateMatrixWorld(i);
    const t = this.context.listener, e = this.up;
    if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(ll, FE, AU), cl.set(0, 0, -1).applyQuaternion(FE), t.positionX) {
      const n = this.context.currentTime + this.timeDelta;
      t.positionX.linearRampToValueAtTime(ll.x, n), t.positionY.linearRampToValueAtTime(ll.y, n), t.positionZ.linearRampToValueAtTime(ll.z, n), t.forwardX.linearRampToValueAtTime(cl.x, n), t.forwardY.linearRampToValueAtTime(cl.y, n), t.forwardZ.linearRampToValueAtTime(cl.z, n), t.upX.linearRampToValueAtTime(e.x, n), t.upY.linearRampToValueAtTime(e.y, n), t.upZ.linearRampToValueAtTime(e.z, n);
    } else
      t.setPosition(ll.x, ll.y, ll.z), t.setOrientation(cl.x, cl.y, cl.z, e.x, e.y, e.z);
  }
}, AudioLoader: class extends Fi {
  constructor(i) {
    super(i);
  }
  load(i, t, e, n) {
    const r = this, s = new La(this.manager);
    s.setResponseType("arraybuffer"), s.setPath(this.path), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials), s.load(i, function(a) {
      try {
        const o = a.slice(0);
        T_.getContext().decodeAudioData(o, function(l) {
          t(l);
        });
      } catch (o) {
        n ? n(o) : console.error(o), r.manager.itemError(i);
      }
    }, e, n);
  }
}, AxesHelper: class extends Ts {
  constructor(i = 1) {
    const t = [0, 0, 0, i, 0, 0, 0, 0, 0, 0, i, 0, 0, 0, 0, 0, 0, i], e = new _e();
    e.setAttribute("position", new Wt(t, 3)), e.setAttribute("color", new Wt([1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1], 3)), super(e, new Ar({ vertexColors: !0, toneMapped: !1 })), this.type = "AxesHelper";
  }
  setColors(i, t, e) {
    const n = new Ht(), r = this.geometry.attributes.color.array;
    return n.set(i), n.toArray(r, 0), n.toArray(r, 3), n.set(t), n.toArray(r, 6), n.toArray(r, 9), n.set(e), n.toArray(r, 12), n.toArray(r, 15), this.geometry.attributes.color.needsUpdate = !0, this;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}, BackSide: 1, BasicDepthPacking: 3200, BasicShadowMap: 0, Bone: rx, BooleanKeyframeTrack: Il, Box2: class {
  constructor(i = new wt(1 / 0, 1 / 0), t = new wt(-1 / 0, -1 / 0)) {
    this.isBox2 = !0, this.min = i, this.max = t;
  }
  set(i, t) {
    return this.min.copy(i), this.max.copy(t), this;
  }
  setFromPoints(i) {
    this.makeEmpty();
    for (let t = 0, e = i.length; t < e; t++)
      this.expandByPoint(i[t]);
    return this;
  }
  setFromCenterAndSize(i, t) {
    const e = jE.copy(t).multiplyScalar(0.5);
    return this.min.copy(i).sub(e), this.max.copy(i).add(e), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(i) {
    return this.min.copy(i.min), this.max.copy(i.max), this;
  }
  makeEmpty() {
    return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y;
  }
  getCenter(i) {
    return this.isEmpty() ? i.set(0, 0) : i.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(i) {
    return this.isEmpty() ? i.set(0, 0) : i.subVectors(this.max, this.min);
  }
  expandByPoint(i) {
    return this.min.min(i), this.max.max(i), this;
  }
  expandByVector(i) {
    return this.min.sub(i), this.max.add(i), this;
  }
  expandByScalar(i) {
    return this.min.addScalar(-i), this.max.addScalar(i), this;
  }
  containsPoint(i) {
    return !(i.x < this.min.x || i.x > this.max.x || i.y < this.min.y || i.y > this.max.y);
  }
  containsBox(i) {
    return this.min.x <= i.min.x && i.max.x <= this.max.x && this.min.y <= i.min.y && i.max.y <= this.max.y;
  }
  getParameter(i, t) {
    return t.set((i.x - this.min.x) / (this.max.x - this.min.x), (i.y - this.min.y) / (this.max.y - this.min.y));
  }
  intersectsBox(i) {
    return !(i.max.x < this.min.x || i.min.x > this.max.x || i.max.y < this.min.y || i.min.y > this.max.y);
  }
  clampPoint(i, t) {
    return t.copy(i).clamp(this.min, this.max);
  }
  distanceToPoint(i) {
    return jE.copy(i).clamp(this.min, this.max).sub(i).length();
  }
  intersect(i) {
    return this.min.max(i.min), this.max.min(i.max), this;
  }
  union(i) {
    return this.min.min(i.min), this.max.max(i.max), this;
  }
  translate(i) {
    return this.min.add(i), this.max.add(i), this;
  }
  equals(i) {
    return i.min.equals(this.min) && i.max.equals(this.max);
  }
}, Box3: ke, Box3Helper: oO, BoxBufferGeometry: lO, BoxGeometry: zn, BoxHelper: aO, BufferAttribute: Ze, BufferGeometry: _e, BufferGeometryLoader: OE, ByteType: 1010, Cache: Zl, Camera: Qv, CameraHelper: aS, CanvasTexture: class extends Yn {
  constructor(i, t, e, n, r, s, a, o, l) {
    super(i, t, e, n, r, s, a, o, l), this.isCanvasTexture = !0, this.needsUpdate = !0;
  }
}, CapsuleBufferGeometry: class extends Kd {
  constructor(i, t, e, n) {
    console.warn("THREE.CapsuleBufferGeometry has been renamed to THREE.CapsuleGeometry."), super(i, t, e, n);
  }
}, CapsuleGeometry: Kd, CatmullRomCurve3: BI, CineonToneMapping: 3, CircleBufferGeometry: class extends $d {
  constructor(i, t, e, n) {
    console.warn("THREE.CircleBufferGeometry has been renamed to THREE.CircleGeometry."), super(i, t, e, n);
  }
}, CircleGeometry: $d, ClampToEdgeWrapping: 1001, Clock: Cv, Color: Ht, ColorKeyframeTrack: tS, ColorManagement: qr, CompressedArrayTexture: class extends v_ {
  constructor(i, t, e, n, r, s) {
    super(i, t, e, r, s), this.isCompressedArrayTexture = !0, this.image.depth = n, this.wrapR = 1001;
  }
}, CompressedTexture: v_, CompressedTextureLoader: class extends Fi {
  constructor(i) {
    super(i);
  }
  load(i, t, e, n) {
    const r = this, s = [], a = new v_(), o = new La(this.manager);
    o.setPath(this.path), o.setResponseType("arraybuffer"), o.setRequestHeader(this.requestHeader), o.setWithCredentials(r.withCredentials);
    let l = 0;
    function c(u) {
      o.load(i[u], function(h) {
        const p = r.parse(h, !0);
        s[u] = { width: p.width, height: p.height, format: p.format, mipmaps: p.mipmaps }, l += 1, l === 6 && (p.mipmapCount === 1 && (a.minFilter = 1006), a.image = s, a.format = p.format, a.needsUpdate = !0, t && t(a));
      }, e, n);
    }
    if (Array.isArray(i))
      for (let u = 0, h = i.length; u < h; ++u)
        c(u);
    else
      o.load(i, function(u) {
        const h = r.parse(u, !0);
        if (h.isCubemap) {
          const p = h.mipmaps.length / h.mipmapCount;
          for (let f = 0; f < p; f++) {
            s[f] = { mipmaps: [] };
            for (let v = 0; v < h.mipmapCount; v++)
              s[f].mipmaps.push(h.mipmaps[f * h.mipmapCount + v]), s[f].format = h.format, s[f].width = h.width, s[f].height = h.height;
          }
          a.image = s;
        } else
          a.image.width = h.width, a.image.height = h.height, a.mipmaps = h.mipmaps;
        h.mipmapCount === 1 && (a.minFilter = 1006), a.format = h.format, a.needsUpdate = !0, t && t(a);
      }, e, n);
    return a;
  }
}, ConeBufferGeometry: class extends Qd {
  constructor(i, t, e, n, r, s, a) {
    console.warn("THREE.ConeBufferGeometry has been renamed to THREE.ConeGeometry."), super(i, t, e, n, r, s, a);
  }
}, ConeGeometry: Qd, CubeCamera: bI, CubeReflectionMapping: 301, CubeRefractionMapping: 302, CubeTexture: Dd, CubeTextureLoader: class extends Fi {
  constructor(i) {
    super(i);
  }
  load(i, t, e, n) {
    const r = new Dd(), s = new _d(this.manager);
    s.setCrossOrigin(this.crossOrigin), s.setPath(this.path);
    let a = 0;
    function o(l) {
      s.load(i[l], function(c) {
        r.images[l] = c, a++, a === 6 && (r.needsUpdate = !0, t && t(r));
      }, void 0, n);
    }
    for (let l = 0; l < i.length; ++l)
      o(l);
    return r;
  }
}, CubeUVReflectionMapping: 306, CubicBezierCurve: jb, CubicBezierCurve3: zI, CubicInterpolant: JI, CullFaceBack: 1, CullFaceFront: 2, CullFaceFrontBack: 3, CullFaceNone: 0, Curve: Is, CurvePath: NI, CustomBlending: 5, CustomToneMapping: 5, CylinderBufferGeometry: class extends nr {
  constructor(i, t, e, n, r, s, a, o) {
    console.warn("THREE.CylinderBufferGeometry has been renamed to THREE.CylinderGeometry."), super(i, t, e, n, r, s, a, o);
  }
}, CylinderGeometry: nr, Cylindrical: class {
  constructor(i = 1, t = 0, e = 0) {
    return this.radius = i, this.theta = t, this.y = e, this;
  }
  set(i, t, e) {
    return this.radius = i, this.theta = t, this.y = e, this;
  }
  copy(i) {
    return this.radius = i.radius, this.theta = i.theta, this.y = i.y, this;
  }
  setFromVector3(i) {
    return this.setFromCartesianCoords(i.x, i.y, i.z);
  }
  setFromCartesianCoords(i, t, e) {
    return this.radius = Math.sqrt(i * i + e * e), this.theta = Math.atan2(i, e), this.y = t, this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}, Data3DTexture: ex, DataArrayTexture: bv, DataTexture: Ro, DataTextureLoader: eS, DataUtils: kl, DecrementStencilOp: 7683, DecrementWrapStencilOp: 34056, DefaultLoadingManager: QI, DepthFormat: 1026, DepthStencilFormat: 1027, DepthTexture: RI, DirectionalLight: ux, DirectionalLightHelper: sO, DiscreteInterpolant: KI, DodecahedronBufferGeometry: class extends tp {
  constructor(i, t) {
    console.warn("THREE.DodecahedronBufferGeometry has been renamed to THREE.DodecahedronGeometry."), super(i, t);
  }
}, DodecahedronGeometry: tp, DoubleSide: 2, DstAlphaFactor: 206, DstColorFactor: 208, DynamicCopyUsage: 35050, DynamicDrawUsage: 35048, DynamicReadUsage: 35049, EdgesGeometry: FI, EllipseCurve: bp, EqualDepth: 4, EqualStencilFunc: 514, EquirectangularReflectionMapping: 303, EquirectangularRefractionMapping: 304, Euler: nu, EventDispatcher: Ga, ExtrudeBufferGeometry: class extends ip {
  constructor(i, t) {
    console.warn("THREE.ExtrudeBufferGeometry has been renamed to THREE.ExtrudeGeometry."), super(i, t);
  }
}, ExtrudeGeometry: ip, FileLoader: La, Float16BufferAttribute: class extends Ze {
  constructor(i, t, e) {
    super(new Uint16Array(i), t, e), this.isFloat16BufferAttribute = !0;
  }
}, Float32BufferAttribute: Wt, Float64BufferAttribute: class extends Ze {
  constructor(i, t, e) {
    super(new Float64Array(i), t, e);
  }
}, FloatType: 1015, Fog: Mv, FogExp2: Sv, FramebufferTexture: class extends Yn {
  constructor(i, t, e) {
    super({ width: i, height: t }), this.isFramebufferTexture = !0, this.format = e, this.magFilter = 1003, this.minFilter = 1003, this.generateMipmaps = !1, this.needsUpdate = !0;
  }
}, FrontSide: 0, Frustum: t0, GLBufferAttribute: class {
  constructor(i, t, e, n, r) {
    this.isGLBufferAttribute = !0, this.name = "", this.buffer = i, this.type = t, this.itemSize = e, this.elementSize = n, this.count = r, this.version = 0;
  }
  set needsUpdate(i) {
    i === !0 && this.version++;
  }
  setBuffer(i) {
    return this.buffer = i, this;
  }
  setType(i, t) {
    return this.type = i, this.elementSize = t, this;
  }
  setItemSize(i) {
    return this.itemSize = i, this;
  }
  setCount(i) {
    return this.count = i, this;
  }
}, GLSL1: "100", GLSL3: $w, GreaterDepth: 6, GreaterEqualDepth: 5, GreaterEqualStencilFunc: 518, GreaterStencilFunc: 516, GridHelper: class extends Ts {
  constructor(i = 10, t = 10, e = 4473924, n = 8947848) {
    e = new Ht(e), n = new Ht(n);
    const r = t / 2, s = i / t, a = i / 2, o = [], l = [];
    for (let u = 0, h = 0, p = -a; u <= t; u++, p += s) {
      o.push(-a, 0, p, a, 0, p), o.push(p, 0, -a, p, 0, a);
      const f = u === r ? e : n;
      f.toArray(l, h), h += 3, f.toArray(l, h), h += 3, f.toArray(l, h), h += 3, f.toArray(l, h), h += 3;
    }
    const c = new _e();
    c.setAttribute("position", new Wt(o, 3)), c.setAttribute("color", new Wt(l, 3)), super(c, new Ar({ vertexColors: !0, toneMapped: !1 })), this.type = "GridHelper";
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}, Group: bi, HalfFloatType: 1016, HemisphereLight: AE, HemisphereLightHelper: class extends Ue {
  constructor(i, t, e) {
    super(), this.light = i, this.matrix = i.matrixWorld, this.matrixAutoUpdate = !1, this.color = e, this.type = "HemisphereLightHelper";
    const n = new ea(t);
    n.rotateY(0.5 * Math.PI), this.material = new ci({ wireframe: !0, fog: !1, toneMapped: !1 }), this.color === void 0 && (this.material.vertexColors = !0);
    const r = n.getAttribute("position"), s = new Float32Array(3 * r.count);
    n.setAttribute("color", new Ze(s, 3)), this.add(new Nt(n, this.material)), this.update();
  }
  dispose() {
    this.children[0].geometry.dispose(), this.children[0].material.dispose();
  }
  update() {
    const i = this.children[0];
    if (this.color !== void 0)
      this.material.color.set(this.color);
    else {
      const t = i.geometry.getAttribute("color");
      ZE.copy(this.light.color), qE.copy(this.light.groundColor);
      for (let e = 0, n = t.count; e < n; e++) {
        const r = e < n / 2 ? ZE : qE;
        t.setXYZ(e, r.r, r.g, r.b);
      }
      t.needsUpdate = !0;
    }
    this.light.updateWorldMatrix(!0, !1), i.lookAt(zU.setFromMatrixPosition(this.light.matrixWorld).negate());
  }
}, HemisphereLightProbe: class extends wm {
  constructor(i, t, e = 1) {
    super(void 0, e), this.isHemisphereLightProbe = !0;
    const n = new Ht().set(i), r = new Ht().set(t), s = new D(n.r, n.g, n.b), a = new D(r.r, r.g, r.b), o = Math.sqrt(Math.PI), l = o * Math.sqrt(0.75);
    this.sh.coefficients[0].copy(s).add(a).multiplyScalar(o), this.sh.coefficients[1].copy(s).sub(a).multiplyScalar(l);
  }
}, IcosahedronBufferGeometry: class extends sp {
  constructor(i, t) {
    console.warn("THREE.IcosahedronBufferGeometry has been renamed to THREE.IcosahedronGeometry."), super(i, t);
  }
}, IcosahedronGeometry: sp, ImageBitmapLoader: class extends Fi {
  constructor(i) {
    super(i), this.isImageBitmapLoader = !0, typeof createImageBitmap > "u" && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), typeof fetch > "u" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = { premultiplyAlpha: "none" };
  }
  setOptions(i) {
    return this.options = i, this;
  }
  load(i, t, e, n) {
    i === void 0 && (i = ""), this.path !== void 0 && (i = this.path + i), i = this.manager.resolveURL(i);
    const r = this, s = Zl.get(i);
    if (s !== void 0)
      return r.manager.itemStart(i), setTimeout(function() {
        t && t(s), r.manager.itemEnd(i);
      }, 0), s;
    const a = {};
    a.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include", a.headers = this.requestHeader, fetch(i, a).then(function(o) {
      return o.blob();
    }).then(function(o) {
      return createImageBitmap(o, Object.assign(r.options, { colorSpaceConversion: "none" }));
    }).then(function(o) {
      Zl.add(i, o), t && t(o), r.manager.itemEnd(i);
    }).catch(function(o) {
      n && n(o), r.manager.itemError(i), r.manager.itemEnd(i);
    }), r.manager.itemStart(i);
  }
}, ImageLoader: _d, ImageUtils: kb, IncrementStencilOp: 7682, IncrementWrapStencilOp: 34055, InstancedBufferAttribute: Dh, InstancedBufferGeometry: rS, InstancedInterleavedBuffer: Vh, InstancedMesh: uE, Int16BufferAttribute: class extends Ze {
  constructor(i, t, e) {
    super(new Int16Array(i), t, e);
  }
}, Int32BufferAttribute: class extends Ze {
  constructor(i, t, e) {
    super(new Int32Array(i), t, e);
  }
}, Int8BufferAttribute: class extends Ze {
  constructor(i, t, e) {
    super(new Int8Array(i), t, e);
  }
}, IntType: 1013, InterleavedBuffer: r0, InterleavedBufferAttribute: Lr, Interpolant: Sp, InterpolateDiscrete: 2300, InterpolateLinear: 2301, InterpolateSmooth: 2302, InvertStencilOp: 5386, KeepStencilOp: 7680, KeyframeTrack: Rs, LOD: nE, LatheBufferGeometry: class extends Uh {
  constructor(i, t, e, n) {
    console.warn("THREE.LatheBufferGeometry has been renamed to THREE.LatheGeometry."), super(i, t, e, n);
  }
}, LatheGeometry: Uh, Layers: $v, LessDepth: 2, LessEqualDepth: 3, LessEqualStencilFunc: 515, LessStencilFunc: 513, Light: Vo, LightProbe: wm, Line: Yr, Line3: ss, LineBasicMaterial: Ar, LineCurve: s0, LineCurve3: kI, LineDashedMaterial: Jb, LineLoop: vE, LineSegments: Ts, LinearEncoding: 3e3, LinearFilter: 1006, LinearInterpolant: Qb, LinearMipMapLinearFilter: 1008, LinearMipMapNearestFilter: 1007, LinearMipmapLinearFilter: 1008, LinearMipmapNearestFilter: 1007, LinearSRGBColorSpace: Zd, LinearToneMapping: 1, Loader: Fi, LoaderUtils: M_, LoadingManager: cx, LoopOnce: 2200, LoopPingPong: 2202, LoopRepeat: 2201, LuminanceAlphaFormat: 1025, LuminanceFormat: 1024, MOUSE: { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 }, Material: Kr, MaterialLoader: Av, MathUtils: Hl, Matrix3: hi, Matrix4: Vt, MaxEquation: 104, Mesh: Nt, MeshBasicMaterial: ci, MeshDepthMaterial: n0, MeshDistanceMaterial: Fb, MeshLambertMaterial: qI, MeshMatcapMaterial: XI, MeshNormalMaterial: Yb, MeshPhongMaterial: WI, MeshPhysicalMaterial: GI, MeshStandardMaterial: Ds, MeshToonMaterial: ZI, MinEquation: 103, MirroredRepeatWrapping: 1002, MixOperation: 1, MultiplyBlending: 4, MultiplyOperation: 0, NearestFilter: 1003, NearestMipMapLinearFilter: 1005, NearestMipMapNearestFilter: 1004, NearestMipmapLinearFilter: 1005, NearestMipmapNearestFilter: 1004, NeverDepth: 0, NeverStencilFunc: 512, NoBlending: 0, NoColorSpace: "", NoToneMapping: 0, NormalAnimationBlendMode: 2500, NormalBlending: 1, NotEqualDepth: 7, NotEqualStencilFunc: 517, NumberKeyframeTrack: up, Object3D: Ue, ObjectLoader: class extends Fi {
  constructor(i) {
    super(i);
  }
  load(i, t, e, n) {
    const r = this, s = this.path === "" ? M_.extractUrlBase(i) : this.path;
    this.resourcePath = this.resourcePath || s;
    const a = new La(this.manager);
    a.setPath(this.path), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), a.load(i, function(o) {
      let l = null;
      try {
        l = JSON.parse(o);
      } catch (u) {
        return n !== void 0 && n(u), void console.error("THREE:ObjectLoader: Can't parse " + i + ".", u.message);
      }
      const c = l.metadata;
      if (c === void 0 || c.type === void 0 || c.type.toLowerCase() === "geometry")
        return n !== void 0 && n(new Error("THREE.ObjectLoader: Can't load " + i)), void console.error("THREE.ObjectLoader: Can't load " + i);
      r.parse(l, t);
    }, e, n);
  }
  async loadAsync(i, t) {
    const e = this.path === "" ? M_.extractUrlBase(i) : this.path;
    this.resourcePath = this.resourcePath || e;
    const n = new La(this.manager);
    n.setPath(this.path), n.setRequestHeader(this.requestHeader), n.setWithCredentials(this.withCredentials);
    const r = await n.loadAsync(i, t), s = JSON.parse(r), a = s.metadata;
    if (a === void 0 || a.type === void 0 || a.type.toLowerCase() === "geometry")
      throw new Error("THREE.ObjectLoader: Can't load " + i);
    return await this.parseAsync(s);
  }
  parse(i, t) {
    const e = this.parseAnimations(i.animations), n = this.parseShapes(i.shapes), r = this.parseGeometries(i.geometries, n), s = this.parseImages(i.images, function() {
      t !== void 0 && t(l);
    }), a = this.parseTextures(i.textures, s), o = this.parseMaterials(i.materials, a), l = this.parseObject(i.object, r, o, a, e), c = this.parseSkeletons(i.skeletons, l);
    if (this.bindSkeletons(l, c), t !== void 0) {
      let u = !1;
      for (const h in s)
        if (s[h].data instanceof HTMLImageElement) {
          u = !0;
          break;
        }
      u === !1 && t(l);
    }
    return l;
  }
  async parseAsync(i) {
    const t = this.parseAnimations(i.animations), e = this.parseShapes(i.shapes), n = this.parseGeometries(i.geometries, e), r = await this.parseImagesAsync(i.images), s = this.parseTextures(i.textures, r), a = this.parseMaterials(i.materials, s), o = this.parseObject(i.object, n, a, s, t), l = this.parseSkeletons(i.skeletons, o);
    return this.bindSkeletons(o, l), o;
  }
  parseShapes(i) {
    const t = {};
    if (i !== void 0)
      for (let e = 0, n = i.length; e < n; e++) {
        const r = new Rl().fromJSON(i[e]);
        t[r.uuid] = r;
      }
    return t;
  }
  parseSkeletons(i, t) {
    const e = {}, n = {};
    if (t.traverse(function(r) {
      r.isBone && (n[r.uuid] = r);
    }), i !== void 0)
      for (let r = 0, s = i.length; r < s; r++) {
        const a = new Ev().fromJSON(i[r], n);
        e[a.uuid] = a;
      }
    return e;
  }
  parseGeometries(i, t) {
    const e = {};
    if (i !== void 0) {
      const n = new OE();
      for (let r = 0, s = i.length; r < s; r++) {
        let a;
        const o = i[r];
        switch (o.type) {
          case "BufferGeometry":
          case "InstancedBufferGeometry":
            a = n.parse(o);
            break;
          default:
            o.type in EE ? a = EE[o.type].fromJSON(o, t) : console.warn(`THREE.ObjectLoader: Unsupported geometry type "${o.type}"`);
        }
        a.uuid = o.uuid, o.name !== void 0 && (a.name = o.name), a.isBufferGeometry === !0 && o.userData !== void 0 && (a.userData = o.userData), e[o.uuid] = a;
      }
    }
    return e;
  }
  parseMaterials(i, t) {
    const e = {}, n = {};
    if (i !== void 0) {
      const r = new Av();
      r.setTextures(t);
      for (let s = 0, a = i.length; s < a; s++) {
        const o = i[s];
        e[o.uuid] === void 0 && (e[o.uuid] = r.parse(o)), n[o.uuid] = e[o.uuid];
      }
    }
    return n;
  }
  parseAnimations(i) {
    const t = {};
    if (i !== void 0)
      for (let e = 0; e < i.length; e++) {
        const n = i[e], r = Ih.parse(n);
        t[r.uuid] = r;
      }
    return t;
  }
  parseImages(i, t) {
    const e = this, n = {};
    let r;
    function s(a) {
      if (typeof a == "string") {
        const o = a;
        return function(l) {
          return e.manager.itemStart(l), r.load(l, function() {
            e.manager.itemEnd(l);
          }, void 0, function() {
            e.manager.itemError(l), e.manager.itemEnd(l);
          });
        }(/^(\/\/)|([a-z]+:(\/\/)?)/i.test(o) ? o : e.resourcePath + o);
      }
      return a.data ? { data: _h(a.type, a.data), width: a.width, height: a.height } : null;
    }
    if (i !== void 0 && i.length > 0) {
      const a = new cx(t);
      r = new _d(a), r.setCrossOrigin(this.crossOrigin);
      for (let o = 0, l = i.length; o < l; o++) {
        const c = i[o], u = c.url;
        if (Array.isArray(u)) {
          const h = [];
          for (let p = 0, f = u.length; p < f; p++) {
            const v = s(u[p]);
            v !== null && (v instanceof HTMLImageElement ? h.push(v) : h.push(new Ro(v.data, v.width, v.height)));
          }
          n[c.uuid] = new Dl(h);
        } else {
          const h = s(c.url);
          n[c.uuid] = new Dl(h);
        }
      }
    }
    return n;
  }
  async parseImagesAsync(i) {
    const t = this, e = {};
    let n;
    async function r(s) {
      if (typeof s == "string") {
        const a = s, o = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(a) ? a : t.resourcePath + a;
        return await n.loadAsync(o);
      }
      return s.data ? { data: _h(s.type, s.data), width: s.width, height: s.height } : null;
    }
    if (i !== void 0 && i.length > 0) {
      n = new _d(this.manager), n.setCrossOrigin(this.crossOrigin);
      for (let s = 0, a = i.length; s < a; s++) {
        const o = i[s], l = o.url;
        if (Array.isArray(l)) {
          const c = [];
          for (let u = 0, h = l.length; u < h; u++) {
            const p = l[u], f = await r(p);
            f !== null && (f instanceof HTMLImageElement ? c.push(f) : c.push(new Ro(f.data, f.width, f.height)));
          }
          e[o.uuid] = new Dl(c);
        } else {
          const c = await r(o.url);
          e[o.uuid] = new Dl(c);
        }
      }
    }
    return e;
  }
  parseTextures(i, t) {
    function e(r, s) {
      return typeof r == "number" ? r : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", r), s[r]);
    }
    const n = {};
    if (i !== void 0)
      for (let r = 0, s = i.length; r < s; r++) {
        const a = i[r];
        a.image === void 0 && console.warn('THREE.ObjectLoader: No "image" specified for', a.uuid), t[a.image] === void 0 && console.warn("THREE.ObjectLoader: Undefined image", a.image);
        const o = t[a.image], l = o.data;
        let c;
        Array.isArray(l) ? (c = new Dd(), l.length === 6 && (c.needsUpdate = !0)) : (c = l && l.data ? new Ro() : new Yn(), l && (c.needsUpdate = !0)), c.source = o, c.uuid = a.uuid, a.name !== void 0 && (c.name = a.name), a.mapping !== void 0 && (c.mapping = e(a.mapping, EU)), a.offset !== void 0 && c.offset.fromArray(a.offset), a.repeat !== void 0 && c.repeat.fromArray(a.repeat), a.center !== void 0 && c.center.fromArray(a.center), a.rotation !== void 0 && (c.rotation = a.rotation), a.wrap !== void 0 && (c.wrapS = e(a.wrap[0], LE), c.wrapT = e(a.wrap[1], LE)), a.format !== void 0 && (c.format = a.format), a.type !== void 0 && (c.type = a.type), a.encoding !== void 0 && (c.encoding = a.encoding), a.minFilter !== void 0 && (c.minFilter = e(a.minFilter, BE)), a.magFilter !== void 0 && (c.magFilter = e(a.magFilter, BE)), a.anisotropy !== void 0 && (c.anisotropy = a.anisotropy), a.flipY !== void 0 && (c.flipY = a.flipY), a.generateMipmaps !== void 0 && (c.generateMipmaps = a.generateMipmaps), a.premultiplyAlpha !== void 0 && (c.premultiplyAlpha = a.premultiplyAlpha), a.unpackAlignment !== void 0 && (c.unpackAlignment = a.unpackAlignment), a.userData !== void 0 && (c.userData = a.userData), n[a.uuid] = c;
      }
    return n;
  }
  parseObject(i, t, e, n, r) {
    let s, a, o;
    function l(h) {
      return t[h] === void 0 && console.warn("THREE.ObjectLoader: Undefined geometry", h), t[h];
    }
    function c(h) {
      if (h !== void 0) {
        if (Array.isArray(h)) {
          const p = [];
          for (let f = 0, v = h.length; f < v; f++) {
            const m = h[f];
            e[m] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", m), p.push(e[m]);
          }
          return p;
        }
        return e[h] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", h), e[h];
      }
    }
    function u(h) {
      return n[h] === void 0 && console.warn("THREE.ObjectLoader: Undefined texture", h), n[h];
    }
    switch (i.type) {
      case "Scene":
        s = new Tv(), i.background !== void 0 && (Number.isInteger(i.background) ? s.background = new Ht(i.background) : s.background = u(i.background)), i.environment !== void 0 && (s.environment = u(i.environment)), i.fog !== void 0 && (i.fog.type === "Fog" ? s.fog = new Mv(i.fog.color, i.fog.near, i.fog.far) : i.fog.type === "FogExp2" && (s.fog = new Sv(i.fog.color, i.fog.density))), i.backgroundBlurriness !== void 0 && (s.backgroundBlurriness = i.backgroundBlurriness), i.backgroundIntensity !== void 0 && (s.backgroundIntensity = i.backgroundIntensity);
        break;
      case "PerspectiveCamera":
        s = new Cr(i.fov, i.aspect, i.near, i.far), i.focus !== void 0 && (s.focus = i.focus), i.zoom !== void 0 && (s.zoom = i.zoom), i.filmGauge !== void 0 && (s.filmGauge = i.filmGauge), i.filmOffset !== void 0 && (s.filmOffset = i.filmOffset), i.view !== void 0 && (s.view = Object.assign({}, i.view));
        break;
      case "OrthographicCamera":
        s = new Yl(i.left, i.right, i.top, i.bottom, i.near, i.far), i.zoom !== void 0 && (s.zoom = i.zoom), i.view !== void 0 && (s.view = Object.assign({}, i.view));
        break;
      case "AmbientLight":
        s = new dx(i.color, i.intensity);
        break;
      case "DirectionalLight":
        s = new ux(i.color, i.intensity);
        break;
      case "PointLight":
        s = new hx(i.color, i.intensity, i.distance, i.decay);
        break;
      case "RectAreaLight":
        s = new IE(i.color, i.intensity, i.width, i.height);
        break;
      case "SpotLight":
        s = new DE(i.color, i.intensity, i.distance, i.angle, i.penumbra, i.decay);
        break;
      case "HemisphereLight":
        s = new AE(i.color, i.groundColor, i.intensity);
        break;
      case "LightProbe":
        s = new wm().fromJSON(i);
        break;
      case "SkinnedMesh":
        a = l(i.geometry), o = c(i.material), s = new oE(a, o), i.bindMode !== void 0 && (s.bindMode = i.bindMode), i.bindMatrix !== void 0 && s.bindMatrix.fromArray(i.bindMatrix), i.skeleton !== void 0 && (s.skeleton = i.skeleton);
        break;
      case "Mesh":
        a = l(i.geometry), o = c(i.material), s = new Nt(a, o);
        break;
      case "InstancedMesh":
        a = l(i.geometry), o = c(i.material);
        const h = i.count, p = i.instanceMatrix, f = i.instanceColor;
        s = new uE(a, o, h), s.instanceMatrix = new Dh(new Float32Array(p.array), 16), f !== void 0 && (s.instanceColor = new Dh(new Float32Array(f.array), f.itemSize));
        break;
      case "LOD":
        s = new nE();
        break;
      case "Line":
        s = new Yr(l(i.geometry), c(i.material));
        break;
      case "LineLoop":
        s = new vE(l(i.geometry), c(i.material));
        break;
      case "LineSegments":
        s = new Ts(l(i.geometry), c(i.material));
        break;
      case "PointCloud":
      case "Points":
        s = new sx(l(i.geometry), c(i.material));
        break;
      case "Sprite":
        s = new tE(c(i.material));
        break;
      case "Group":
        s = new bi();
        break;
      case "Bone":
        s = new rx();
        break;
      default:
        s = new Ue();
    }
    if (s.uuid = i.uuid, i.name !== void 0 && (s.name = i.name), i.matrix !== void 0 ? (s.matrix.fromArray(i.matrix), i.matrixAutoUpdate !== void 0 && (s.matrixAutoUpdate = i.matrixAutoUpdate), s.matrixAutoUpdate && s.matrix.decompose(s.position, s.quaternion, s.scale)) : (i.position !== void 0 && s.position.fromArray(i.position), i.rotation !== void 0 && s.rotation.fromArray(i.rotation), i.quaternion !== void 0 && s.quaternion.fromArray(i.quaternion), i.scale !== void 0 && s.scale.fromArray(i.scale)), i.castShadow !== void 0 && (s.castShadow = i.castShadow), i.receiveShadow !== void 0 && (s.receiveShadow = i.receiveShadow), i.shadow && (i.shadow.bias !== void 0 && (s.shadow.bias = i.shadow.bias), i.shadow.normalBias !== void 0 && (s.shadow.normalBias = i.shadow.normalBias), i.shadow.radius !== void 0 && (s.shadow.radius = i.shadow.radius), i.shadow.mapSize !== void 0 && s.shadow.mapSize.fromArray(i.shadow.mapSize), i.shadow.camera !== void 0 && (s.shadow.camera = this.parseObject(i.shadow.camera))), i.visible !== void 0 && (s.visible = i.visible), i.frustumCulled !== void 0 && (s.frustumCulled = i.frustumCulled), i.renderOrder !== void 0 && (s.renderOrder = i.renderOrder), i.userData !== void 0 && (s.userData = i.userData), i.layers !== void 0 && (s.layers.mask = i.layers), i.children !== void 0) {
      const h = i.children;
      for (let p = 0; p < h.length; p++)
        s.add(this.parseObject(h[p], t, e, n, r));
    }
    if (i.animations !== void 0) {
      const h = i.animations;
      for (let p = 0; p < h.length; p++) {
        const f = h[p];
        s.animations.push(r[f]);
      }
    }
    if (i.type === "LOD") {
      i.autoUpdate !== void 0 && (s.autoUpdate = i.autoUpdate);
      const h = i.levels;
      for (let p = 0; p < h.length; p++) {
        const f = h[p], v = s.getObjectByProperty("uuid", f.object);
        v !== void 0 && s.addLevel(v, f.distance, f.hysteresis);
      }
    }
    return s;
  }
  bindSkeletons(i, t) {
    Object.keys(t).length !== 0 && i.traverse(function(e) {
      if (e.isSkinnedMesh === !0 && e.skeleton !== void 0) {
        const n = t[e.skeleton];
        n === void 0 ? console.warn("THREE.ObjectLoader: No skeleton found with UUID:", e.skeleton) : e.bind(n, e.bindMatrix);
      }
    });
  }
}, ObjectSpaceNormalMap: 1, OctahedronBufferGeometry: class extends ea {
  constructor(i, t) {
    console.warn("THREE.OctahedronBufferGeometry has been renamed to THREE.OctahedronGeometry."), super(i, t);
  }
}, OctahedronGeometry: ea, OneFactor: 201, OneMinusDstAlphaFactor: 207, OneMinusDstColorFactor: 209, OneMinusSrcAlphaFactor: 205, OneMinusSrcColorFactor: 203, OrthographicCamera: Yl, PCFShadowMap: 1, PCFSoftShadowMap: 2, PMREMGenerator: Yd, Path: Jd, PerspectiveCamera: Cr, Plane: Hn, PlaneBufferGeometry: class extends Wa {
  constructor(i, t, e, n) {
    console.warn("THREE.PlaneBufferGeometry has been renamed to THREE.PlaneGeometry."), super(i, t, e, n);
  }
}, PlaneGeometry: Wa, PlaneHelper: class extends Yr {
  constructor(i, t = 1, e = 16776960) {
    const n = e, r = new _e();
    r.setAttribute("position", new Wt([1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0], 3)), r.computeBoundingSphere(), super(r, new Ar({ color: n, toneMapped: !1 })), this.type = "PlaneHelper", this.plane = i, this.size = t;
    const s = new _e();
    s.setAttribute("position", new Wt([1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0], 3)), s.computeBoundingSphere(), this.add(new Nt(s, new ci({ color: n, opacity: 0.2, transparent: !0, depthWrite: !1, toneMapped: !1 })));
  }
  updateMatrixWorld(i) {
    this.position.set(0, 0, 0), this.scale.set(0.5 * this.size, 0.5 * this.size, 1), this.lookAt(this.plane.normal), this.translateZ(-this.plane.constant), super.updateMatrixWorld(i);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose(), this.children[0].geometry.dispose(), this.children[0].material.dispose();
  }
}, PointLight: hx, PointLightHelper: class extends Nt {
  constructor(i, t, e) {
    super(new Va(t, 4, 2), new ci({ wireframe: !0, fog: !1, toneMapped: !1 })), this.light = i, this.color = e, this.type = "PointLightHelper", this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update();
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1), this.color !== void 0 ? this.material.color.set(this.color) : this.material.color.copy(this.light.color);
  }
}, Points: sx, PointsMaterial: i0, PolarGridHelper: class extends Ts {
  constructor(i = 10, t = 16, e = 8, n = 64, r = 4473924, s = 8947848) {
    r = new Ht(r), s = new Ht(s);
    const a = [], o = [];
    if (t > 1)
      for (let c = 0; c < t; c++) {
        const u = c / t * (2 * Math.PI), h = Math.sin(u) * i, p = Math.cos(u) * i;
        a.push(0, 0, 0), a.push(h, 0, p);
        const f = 1 & c ? r : s;
        o.push(f.r, f.g, f.b), o.push(f.r, f.g, f.b);
      }
    for (let c = 0; c < e; c++) {
      const u = 1 & c ? r : s, h = i - i / e * c;
      for (let p = 0; p < n; p++) {
        let f = p / n * (2 * Math.PI), v = Math.sin(f) * h, m = Math.cos(f) * h;
        a.push(v, 0, m), o.push(u.r, u.g, u.b), f = (p + 1) / n * (2 * Math.PI), v = Math.sin(f) * h, m = Math.cos(f) * h, a.push(v, 0, m), o.push(u.r, u.g, u.b);
      }
    }
    const l = new _e();
    l.setAttribute("position", new Wt(a, 3)), l.setAttribute("color", new Wt(o, 3)), super(l, new Ar({ vertexColors: !0, toneMapped: !1 })), this.type = "PolarGridHelper";
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}, PolyhedronBufferGeometry: class extends Za {
  constructor(i, t, e, n) {
    console.warn("THREE.PolyhedronBufferGeometry has been renamed to THREE.PolyhedronGeometry."), super(i, t, e, n);
  }
}, PolyhedronGeometry: Za, PositionalAudio: class extends UE {
  constructor(i) {
    super(i), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain);
  }
  disconnect() {
    super.disconnect(), this.panner.disconnect(this.gain);
  }
  getOutput() {
    return this.panner;
  }
  getRefDistance() {
    return this.panner.refDistance;
  }
  setRefDistance(i) {
    return this.panner.refDistance = i, this;
  }
  getRolloffFactor() {
    return this.panner.rolloffFactor;
  }
  setRolloffFactor(i) {
    return this.panner.rolloffFactor = i, this;
  }
  getDistanceModel() {
    return this.panner.distanceModel;
  }
  setDistanceModel(i) {
    return this.panner.distanceModel = i, this;
  }
  getMaxDistance() {
    return this.panner.maxDistance;
  }
  setMaxDistance(i) {
    return this.panner.maxDistance = i, this;
  }
  setDirectionalCone(i, t, e) {
    return this.panner.coneInnerAngle = i, this.panner.coneOuterAngle = t, this.panner.coneOuterGain = e, this;
  }
  updateMatrixWorld(i) {
    if (super.updateMatrixWorld(i), this.hasPlaybackControl === !0 && this.isPlaying === !1)
      return;
    this.matrixWorld.decompose(hl, VE, CU), ul.set(0, 0, 1).applyQuaternion(VE);
    const t = this.panner;
    if (t.positionX) {
      const e = this.context.currentTime + this.listener.timeDelta;
      t.positionX.linearRampToValueAtTime(hl.x, e), t.positionY.linearRampToValueAtTime(hl.y, e), t.positionZ.linearRampToValueAtTime(hl.z, e), t.orientationX.linearRampToValueAtTime(ul.x, e), t.orientationY.linearRampToValueAtTime(ul.y, e), t.orientationZ.linearRampToValueAtTime(ul.z, e);
    } else
      t.setPosition(hl.x, hl.y, hl.z), t.setOrientation(ul.x, ul.y, ul.z);
  }
}, PropertyBinding: Ye, PropertyMixer: eO, QuadraticBezierCurve: Gb, QuadraticBezierCurve3: Wb, Quaternion: kn, QuaternionKeyframeTrack: Rh, QuaternionLinearInterpolant: $I, RED_GREEN_RGTC2_Format: 36285, RED_RGTC1_Format: 36283, REVISION: wv, RGBADepthPacking: 3201, RGBAFormat: 1023, RGBAIntegerFormat: 1033, RGBA_ASTC_10x10_Format: 37819, RGBA_ASTC_10x5_Format: 37816, RGBA_ASTC_10x6_Format: 37817, RGBA_ASTC_10x8_Format: 37818, RGBA_ASTC_12x10_Format: 37820, RGBA_ASTC_12x12_Format: 37821, RGBA_ASTC_4x4_Format: 37808, RGBA_ASTC_5x4_Format: 37809, RGBA_ASTC_5x5_Format: 37810, RGBA_ASTC_6x5_Format: 37811, RGBA_ASTC_6x6_Format: 37812, RGBA_ASTC_8x5_Format: 37813, RGBA_ASTC_8x6_Format: 37814, RGBA_ASTC_8x8_Format: 37815, RGBA_BPTC_Format: 36492, RGBA_ETC2_EAC_Format: 37496, RGBA_PVRTC_2BPPV1_Format: 35843, RGBA_PVRTC_4BPPV1_Format: 35842, RGBA_S3TC_DXT1_Format: 33777, RGBA_S3TC_DXT3_Format: 33778, RGBA_S3TC_DXT5_Format: 33779, RGB_ETC1_Format: 36196, RGB_ETC2_Format: 37492, RGB_PVRTC_2BPPV1_Format: 35841, RGB_PVRTC_4BPPV1_Format: 35840, RGB_S3TC_DXT1_Format: 33776, RGFormat: 1030, RGIntegerFormat: 1031, RawShaderMaterial: jI, Ray: Uo, Raycaster: iu, RectAreaLight: IE, RedFormat: 1028, RedIntegerFormat: 1029, ReinhardToneMapping: 2, RepeatWrapping: 1e3, ReplaceStencilOp: 7681, ReverseSubtractEquation: 102, RingBufferGeometry: class extends ap {
  constructor(i, t, e, n, r, s) {
    console.warn("THREE.RingBufferGeometry has been renamed to THREE.RingGeometry."), super(i, t, e, n, r, s);
  }
}, RingGeometry: ap, SIGNED_RED_GREEN_RGTC2_Format: 36286, SIGNED_RED_RGTC1_Format: 36284, SRGBColorSpace: Ms, Scene: Tv, ShaderChunk: Le, ShaderLib: Pn, ShaderMaterial: Gn, ShadowMaterial: HI, Shape: Rl, ShapeBufferGeometry: class extends op {
  constructor(i, t) {
    console.warn("THREE.ShapeBufferGeometry has been renamed to THREE.ShapeGeometry."), super(i, t);
  }
}, ShapeGeometry: op, ShapePath: class {
  constructor() {
    this.type = "ShapePath", this.color = new Ht(), this.subPaths = [], this.currentPath = null;
  }
  moveTo(i, t) {
    return this.currentPath = new Jd(), this.subPaths.push(this.currentPath), this.currentPath.moveTo(i, t), this;
  }
  lineTo(i, t) {
    return this.currentPath.lineTo(i, t), this;
  }
  quadraticCurveTo(i, t, e, n) {
    return this.currentPath.quadraticCurveTo(i, t, e, n), this;
  }
  bezierCurveTo(i, t, e, n, r, s) {
    return this.currentPath.bezierCurveTo(i, t, e, n, r, s), this;
  }
  splineThru(i) {
    return this.currentPath.splineThru(i), this;
  }
  toShapes(i) {
    function t(m, y) {
      const _ = y.length;
      let w = !1;
      for (let b = _ - 1, T = 0; T < _; b = T++) {
        let M = y[b], A = y[T], C = A.x - M.x, I = A.y - M.y;
        if (Math.abs(I) > Number.EPSILON) {
          if (I < 0 && (M = y[T], C = -C, A = y[b], I = -I), m.y < M.y || m.y > A.y)
            continue;
          if (m.y === M.y) {
            if (m.x === M.x)
              return !0;
          } else {
            const k = I * (m.x - M.x) - C * (m.y - M.y);
            if (k === 0)
              return !0;
            if (k < 0)
              continue;
            w = !w;
          }
        } else {
          if (m.y !== M.y)
            continue;
          if (A.x <= m.x && m.x <= M.x || M.x <= m.x && m.x <= A.x)
            return !0;
        }
      }
      return w;
    }
    const e = na.isClockWise, n = this.subPaths;
    if (n.length === 0)
      return [];
    let r, s, a;
    const o = [];
    if (n.length === 1)
      return s = n[0], a = new Rl(), a.curves = s.curves, o.push(a), o;
    let l = !e(n[0].getPoints());
    l = i ? !l : l;
    const c = [], u = [];
    let h, p, f = [], v = 0;
    u[v] = void 0, f[v] = [];
    for (let m = 0, y = n.length; m < y; m++)
      s = n[m], h = s.getPoints(), r = e(h), r = i ? !r : r, r ? (!l && u[v] && v++, u[v] = { s: new Rl(), p: h }, u[v].s.curves = s.curves, l && v++, f[v] = []) : f[v].push({ h: s, p: h[0] });
    if (!u[0])
      return function(m) {
        const y = [];
        for (let _ = 0, w = m.length; _ < w; _++) {
          const b = m[_], T = new Rl();
          T.curves = b.curves, y.push(T);
        }
        return y;
      }(n);
    if (u.length > 1) {
      let m = !1, y = 0;
      for (let _ = 0, w = u.length; _ < w; _++)
        c[_] = [];
      for (let _ = 0, w = u.length; _ < w; _++) {
        const b = f[_];
        for (let T = 0; T < b.length; T++) {
          const M = b[T];
          let A = !0;
          for (let C = 0; C < u.length; C++)
            t(M.p, u[C].p) && (_ !== C && y++, A ? (A = !1, c[C].push(M)) : m = !0);
          A && c[_].push(M);
        }
      }
      y > 0 && m === !1 && (f = c);
    }
    for (let m = 0, y = u.length; m < y; m++) {
      a = u[m].s, o.push(a), p = f[m];
      for (let _ = 0, w = p.length; _ < w; _++)
        a.holes.push(p[_].h);
    }
    return o;
  }
}, ShapeUtils: na, ShortType: 1011, Skeleton: Ev, SkeletonHelper: class extends Ts {
  constructor(i) {
    const t = iO(i), e = new _e(), n = [], r = [], s = new Ht(0, 0, 1), a = new Ht(0, 1, 0);
    for (let o = 0; o < t.length; o++) {
      const l = t[o];
      l.parent && l.parent.isBone && (n.push(0, 0, 0), n.push(0, 0, 0), r.push(s.r, s.g, s.b), r.push(a.r, a.g, a.b));
    }
    e.setAttribute("position", new Wt(n, 3)), e.setAttribute("color", new Wt(r, 3)), super(e, new Ar({ vertexColors: !0, depthTest: !1, depthWrite: !1, toneMapped: !1, transparent: !0 })), this.isSkeletonHelper = !0, this.type = "SkeletonHelper", this.root = i, this.bones = t, this.matrix = i.matrixWorld, this.matrixAutoUpdate = !1;
  }
  updateMatrixWorld(i) {
    const t = this.bones, e = this.geometry, n = e.getAttribute("position");
    A_.copy(this.root.matrixWorld).invert();
    for (let r = 0, s = 0; r < t.length; r++) {
      const a = t[r];
      a.parent && a.parent.isBone && (Sm.multiplyMatrices(A_, a.matrixWorld), mo.setFromMatrixPosition(Sm), n.setXYZ(s, mo.x, mo.y, mo.z), Sm.multiplyMatrices(A_, a.parent.matrixWorld), mo.setFromMatrixPosition(Sm), n.setXYZ(s + 1, mo.x, mo.y, mo.z), s += 2);
    }
    e.getAttribute("position").needsUpdate = !0, super.updateMatrixWorld(i);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}, SkinnedMesh: oE, Source: Dl, Sphere: Mi, SphereBufferGeometry: class extends Va {
  constructor(i, t, e, n, r, s, a) {
    console.warn("THREE.SphereBufferGeometry has been renamed to THREE.SphereGeometry."), super(i, t, e, n, r, s, a);
  }
}, SphereGeometry: Va, Spherical: rO, SphericalHarmonics3: tO, SplineCurve: Zb, SpotLight: DE, SpotLightHelper: class extends Ue {
  constructor(i, t) {
    super(), this.light = i, this.matrix = i.matrixWorld, this.matrixAutoUpdate = !1, this.color = t, this.type = "SpotLightHelper";
    const e = new _e(), n = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];
    for (let s = 0, a = 1, o = 32; s < o; s++, a++) {
      const l = s / o * Math.PI * 2, c = a / o * Math.PI * 2;
      n.push(Math.cos(l), Math.sin(l), 1, Math.cos(c), Math.sin(c), 1);
    }
    e.setAttribute("position", new Wt(n, 3));
    const r = new Ar({ fog: !1, toneMapped: !1 });
    this.cone = new Ts(e, r), this.add(this.cone), this.update();
  }
  dispose() {
    this.cone.geometry.dispose(), this.cone.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1), this.light.target.updateWorldMatrix(!0, !1);
    const i = this.light.distance ? this.light.distance : 1e3, t = i * Math.tan(this.light.angle);
    this.cone.scale.set(t, t, i), WE.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(WE), this.color !== void 0 ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color);
  }
}, Sprite: tE, SpriteMaterial: Vb, SrcAlphaFactor: 204, SrcAlphaSaturateFactor: 210, SrcColorFactor: 202, StaticCopyUsage: 35046, StaticDrawUsage: 35044, StaticReadUsage: 35045, StereoCamera: class {
  constructor() {
    this.type = "StereoCamera", this.aspect = 1, this.eyeSep = 0.064, this.cameraL = new Cr(), this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new Cr(), this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1, this._cache = { focus: null, fov: null, aspect: null, near: null, far: null, zoom: null, eyeSep: null };
  }
  update(i) {
    const t = this._cache;
    if (t.focus !== i.focus || t.fov !== i.fov || t.aspect !== i.aspect * this.aspect || t.near !== i.near || t.far !== i.far || t.zoom !== i.zoom || t.eyeSep !== this.eyeSep) {
      t.focus = i.focus, t.fov = i.fov, t.aspect = i.aspect * this.aspect, t.near = i.near, t.far = i.far, t.zoom = i.zoom, t.eyeSep = this.eyeSep, ol.copy(i.projectionMatrix);
      const e = t.eyeSep / 2, n = e * t.near / t.focus, r = t.near * Math.tan(Vl * t.fov * 0.5) / t.zoom;
      let s, a;
      kE.elements[12] = -e, zE.elements[12] = e, s = -r * t.aspect + n, a = r * t.aspect + n, ol.elements[0] = 2 * t.near / (a - s), ol.elements[8] = (a + s) / (a - s), this.cameraL.projectionMatrix.copy(ol), s = -r * t.aspect - n, a = r * t.aspect - n, ol.elements[0] = 2 * t.near / (a - s), ol.elements[8] = (a + s) / (a - s), this.cameraR.projectionMatrix.copy(ol);
    }
    this.cameraL.matrixWorld.copy(i.matrixWorld).multiply(kE), this.cameraR.matrixWorld.copy(i.matrixWorld).multiply(zE);
  }
}, StreamCopyUsage: 35042, StreamDrawUsage: 35040, StreamReadUsage: 35041, StringKeyframeTrack: Ol, SubtractEquation: 101, SubtractiveBlending: 3, TOUCH: { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 }, TangentSpaceNormalMap: 0, TetrahedronBufferGeometry: class extends lp {
  constructor(i, t) {
    console.warn("THREE.TetrahedronBufferGeometry has been renamed to THREE.TetrahedronGeometry."), super(i, t);
  }
}, TetrahedronGeometry: lp, Texture: Yn, TextureLoader: o0, TorusBufferGeometry: class extends $s {
  constructor(i, t, e, n, r) {
    console.warn("THREE.TorusBufferGeometry has been renamed to THREE.TorusGeometry."), super(i, t, e, n, r);
  }
}, TorusGeometry: $s, TorusKnotBufferGeometry: class extends cp {
  constructor(i, t, e, n, r, s) {
    console.warn("THREE.TorusKnotBufferGeometry has been renamed to THREE.TorusKnotGeometry."), super(i, t, e, n, r, s);
  }
}, TorusKnotGeometry: cp, Triangle: Pr, TriangleFanDrawMode: 2, TriangleStripDrawMode: 1, TrianglesDrawMode: 0, TubeBufferGeometry: class extends hp {
  constructor(i, t, e, n, r) {
    console.warn("THREE.TubeBufferGeometry has been renamed to THREE.TubeGeometry."), super(i, t, e, n, r);
  }
}, TubeGeometry: hp, TwoPassDoubleSide: 2, UVMapping: 300, Uint16BufferAttribute: Gl, Uint32BufferAttribute: Wl, Uint8BufferAttribute: class extends Ze {
  constructor(i, t, e) {
    super(new Uint8Array(i), t, e);
  }
}, Uint8ClampedBufferAttribute: class extends Ze {
  constructor(i, t, e) {
    super(new Uint8ClampedArray(i), t, e);
  }
}, Uniform: sS, UniformsGroup: class extends Ga {
  constructor() {
    super(), this.isUniformsGroup = !0, Object.defineProperty(this, "id", { value: BU++ }), this.name = "", this.usage = 35044, this.uniforms = [];
  }
  add(i) {
    return this.uniforms.push(i), this;
  }
  remove(i) {
    const t = this.uniforms.indexOf(i);
    return t !== -1 && this.uniforms.splice(t, 1), this;
  }
  setName(i) {
    return this.name = i, this;
  }
  setUsage(i) {
    return this.usage = i, this;
  }
  dispose() {
    return this.dispatchEvent({ type: "dispose" }), this;
  }
  copy(i) {
    this.name = i.name, this.usage = i.usage;
    const t = i.uniforms;
    this.uniforms.length = 0;
    for (let e = 0, n = t.length; e < n; e++)
      this.uniforms.push(t[e].clone());
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}, UniformsLib: Xt, UniformsUtils: Jn, UnsignedByteType: 1009, UnsignedInt248Type: 1020, UnsignedIntType: 1014, UnsignedShort4444Type: 1017, UnsignedShort5551Type: 1018, UnsignedShortType: 1012, VSMShadowMap: 3, Vector2: wt, Vector3: D, Vector4: ze, VectorKeyframeTrack: dp, VideoTexture: class extends Yn {
  constructor(i, t, e, n, r, s, a, o, l) {
    super(i, t, e, n, r, s, a, o, l), this.isVideoTexture = !0, this.minFilter = s !== void 0 ? s : 1006, this.magFilter = r !== void 0 ? r : 1006, this.generateMipmaps = !1;
    const c = this;
    "requestVideoFrameCallback" in i && i.requestVideoFrameCallback(function u() {
      c.needsUpdate = !0, i.requestVideoFrameCallback(u);
    });
  }
  clone() {
    return new this.constructor(this.image).copy(this);
  }
  update() {
    const i = this.image;
    !("requestVideoFrameCallback" in i) && i.readyState >= i.HAVE_CURRENT_DATA && (this.needsUpdate = !0);
  }
}, WebGL1Renderer: II, WebGL3DRenderTarget: class extends ir {
  constructor(i = 1, t = 1, e = 1) {
    super(i, t), this.isWebGL3DRenderTarget = !0, this.depth = e, this.texture = new ex(null, i, t, e), this.texture.isRenderTargetTexture = !0;
  }
}, WebGLArrayRenderTarget: class extends ir {
  constructor(i = 1, t = 1, e = 1) {
    super(i, t), this.isWebGLArrayRenderTarget = !0, this.depth = e, this.texture = new bv(null, i, t, e), this.texture.isRenderTargetTexture = !0;
  }
}, WebGLCubeRenderTarget: SI, WebGLMultipleRenderTargets: class extends ir {
  constructor(i = 1, t = 1, e = 1, n = {}) {
    super(i, t, n), this.isWebGLMultipleRenderTargets = !0;
    const r = this.texture;
    this.texture = [];
    for (let s = 0; s < e; s++)
      this.texture[s] = r.clone(), this.texture[s].isRenderTargetTexture = !0;
  }
  setSize(i, t, e = 1) {
    if (this.width !== i || this.height !== t || this.depth !== e) {
      this.width = i, this.height = t, this.depth = e;
      for (let n = 0, r = this.texture.length; n < r; n++)
        this.texture[n].image.width = i, this.texture[n].image.height = t, this.texture[n].image.depth = e;
      this.dispose();
    }
    return this.viewport.set(0, 0, i, t), this.scissor.set(0, 0, i, t), this;
  }
  copy(i) {
    this.dispose(), this.width = i.width, this.height = i.height, this.depth = i.depth, this.viewport.set(0, 0, this.width, this.height), this.scissor.set(0, 0, this.width, this.height), this.depthBuffer = i.depthBuffer, this.stencilBuffer = i.stencilBuffer, i.depthTexture !== null && (this.depthTexture = i.depthTexture.clone()), this.texture.length = 0;
    for (let t = 0, e = i.texture.length; t < e; t++)
      this.texture[t] = i.texture[t].clone(), this.texture[t].isRenderTargetTexture = !0;
    return this;
  }
}, WebGLRenderTarget: ir, WebGLRenderer: Ub, WebGLUtils: PI, WireframeGeometry: Xb, WrapAroundEnding: 2402, ZeroCurvatureEnding: 2400, ZeroFactor: 200, ZeroSlopeEnding: 2401, ZeroStencilOp: 0, _SRGBAFormat: 1035, sRGBEncoding: 3001 }, Symbol.toStringTag, { value: "Module" }));
var Od = function() {
  var i = 0, t = document.createElement("div");
  function e(u) {
    return t.appendChild(u.dom), u;
  }
  function n(u) {
    for (var h = 0; h < t.children.length; h++)
      t.children[h].style.display = h === u ? "block" : "none";
    i = u;
  }
  t.style.cssText = "position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000", t.addEventListener("click", function(u) {
    u.preventDefault(), n(++i % t.children.length);
  }, !1);
  var r = (performance || Date).now(), s = r, a = 0, o = e(new Od.Panel("FPS", "#0ff", "#002")), l = e(new Od.Panel("MS", "#0f0", "#020"));
  if (self.performance && self.performance.memory)
    var c = e(new Od.Panel("MB", "#f08", "#201"));
  return n(0), { REVISION: 16, dom: t, addPanel: e, showPanel: n, begin: function() {
    r = (performance || Date).now();
  }, end: function() {
    a++;
    var u = (performance || Date).now();
    if (l.update(u - r, 200), u >= s + 1e3 && (o.update(1e3 * a / (u - s), 100), s = u, a = 0, c)) {
      var h = performance.memory;
      c.update(h.usedJSHeapSize / 1048576, h.jsHeapSizeLimit / 1048576);
    }
    return u;
  }, update: function() {
    r = this.end();
  }, domElement: t, setMode: n };
};
Od.Panel = function(i, t, e) {
  var n = 1 / 0, r = 0, s = Math.round, a = s(window.devicePixelRatio || 1), o = 80 * a, l = 48 * a, c = 3 * a, u = 2 * a, h = 3 * a, p = 15 * a, f = 74 * a, v = 30 * a, m = document.createElement("canvas");
  m.width = o, m.height = l, m.style.cssText = "width:80px;height:48px";
  var y = m.getContext("2d");
  return y.font = "bold " + 9 * a + "px Helvetica,Arial,sans-serif", y.textBaseline = "top", y.fillStyle = e, y.fillRect(0, 0, o, l), y.fillStyle = t, y.fillText(i, c, u), y.fillRect(h, p, f, v), y.fillStyle = e, y.globalAlpha = 0.9, y.fillRect(h, p, f, v), { dom: m, update: function(_, w) {
    n = Math.min(n, _), r = Math.max(r, _), y.fillStyle = e, y.globalAlpha = 1, y.fillRect(0, 0, o, p), y.fillStyle = t, y.fillText(s(_) + " " + i + " (" + s(n) + "-" + s(r) + ")", c, u), y.drawImage(m, h + a, p, f - a, v, h, p, f - a, v), y.fillRect(h + f - a, p, a, v), y.fillStyle = e, y.globalAlpha = 0.9, y.fillRect(h + f - a, p, a, s((1 - _ / w) * v));
  } };
};
const FU = Od;
class UU extends Tv {
  constructor() {
    super();
    const t = new zn();
    t.deleteAttribute("uv");
    const e = new Ds({ side: 1 }), n = new Ds(), r = new hx(16777215, 5, 28, 2);
    r.position.set(0.418, 16.199, 0.3), this.add(r);
    const s = new Nt(t, e);
    s.position.set(-0.757, 13.219, 0.717), s.scale.set(31.713, 28.305, 28.591), this.add(s);
    const a = new Nt(t, n);
    a.position.set(-10.906, 2.009, 1.846), a.rotation.set(0, -0.195, 0), a.scale.set(2.328, 7.905, 4.651), this.add(a);
    const o = new Nt(t, n);
    o.position.set(-5.607, -0.754, -0.758), o.rotation.set(0, 0.994, 0), o.scale.set(1.97, 1.534, 3.955), this.add(o);
    const l = new Nt(t, n);
    l.position.set(6.167, 0.857, 7.803), l.rotation.set(0, 0.561, 0), l.scale.set(3.927, 6.285, 3.687), this.add(l);
    const c = new Nt(t, n);
    c.position.set(-2.017, 0.018, 6.124), c.rotation.set(0, 0.333, 0), c.scale.set(2.002, 4.566, 2.064), this.add(c);
    const u = new Nt(t, n);
    u.position.set(2.291, -0.756, -2.621), u.rotation.set(0, -0.286, 0), u.scale.set(1.546, 1.552, 1.496), this.add(u);
    const h = new Nt(t, n);
    h.position.set(-2.193, -0.369, -5.547), h.rotation.set(0, 0.516, 0), h.scale.set(3.875, 3.487, 2.986), this.add(h);
    const p = new Nt(t, jc(50));
    p.position.set(-16.116, 14.37, 8.208), p.scale.set(0.1, 2.428, 2.739), this.add(p);
    const f = new Nt(t, jc(50));
    f.position.set(-16.109, 18.021, -8.207), f.scale.set(0.1, 2.425, 2.751), this.add(f);
    const v = new Nt(t, jc(17));
    v.position.set(14.904, 12.198, -1.832), v.scale.set(0.15, 4.265, 6.331), this.add(v);
    const m = new Nt(t, jc(43));
    m.position.set(-0.462, 8.89, 14.52), m.scale.set(4.38, 5.441, 0.088), this.add(m);
    const y = new Nt(t, jc(20));
    y.position.set(3.235, 11.486, -12.541), y.scale.set(2.5, 2, 0.1), this.add(y);
    const _ = new Nt(t, jc(100));
    _.position.set(0, 20, 0), _.scale.set(1, 0.1, 1), this.add(_);
  }
  dispose() {
    const t = /* @__PURE__ */ new Set();
    this.traverse((e) => {
      e.isMesh && (t.add(e.geometry), t.add(e.material));
    });
    for (const e of t)
      e.dispose();
  }
}
function jc(i) {
  const t = new ci();
  return t.color.setScalar(i), t;
}
var bn = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Mp(i) {
  return i && i.__esModule && Object.prototype.hasOwnProperty.call(i, "default") ? i.default : i;
}
var Xu = function(i) {
  return i && i.Math === Math && i;
}, Oe = Xu(typeof globalThis == "object" && globalThis) || Xu(typeof window == "object" && window) || Xu(typeof self == "object" && self) || Xu(typeof bn == "object" && bn) || Xu(typeof bn == "object" && bn) || function() {
  return this;
}() || Function("return this")(), Tp = {}, je = function(i) {
  try {
    return !!i();
  } catch {
    return !0;
  }
}, Mn = !je(function() {
  return Object.defineProperty({}, 1, { get: function() {
    return 7;
  } })[1] !== 7;
}), l0 = !je(function() {
  var i = (function() {
  }).bind();
  return typeof i != "function" || i.hasOwnProperty("prototype");
}), VU = l0, Cm = Function.prototype.call, Ne = VU ? Cm.bind(Cm) : function() {
  return Cm.apply(Cm, arguments);
}, oS = {}, cO = {}.propertyIsEnumerable, hO = Object.getOwnPropertyDescriptor, HU = hO && !cO.call({ 1: 2 }, 1);
oS.f = HU ? function(i) {
  var t = hO(this, i);
  return !!t && t.enumerable;
} : cO;
var go, ev, Ho = function(i, t) {
  return { enumerable: !(1 & i), configurable: !(2 & i), writable: !(4 & i), value: t };
}, uO = l0, dO = Function.prototype, fx = dO.call, jU = uO && dO.bind.bind(fx, fx), Ae = uO ? jU : function(i) {
  return function() {
    return fx.apply(i, arguments);
  };
}, pO = Ae, GU = pO({}.toString), WU = pO("".slice), qa = function(i) {
  return WU(GU(i), 8, -1);
}, ZU = je, qU = qa, P_ = Object, XU = Ae("".split), c0 = ZU(function() {
  return !P_("z").propertyIsEnumerable(0);
}) ? function(i) {
  return qU(i) === "String" ? XU(i, "") : P_(i);
} : P_, Hi = function(i) {
  return i == null;
}, YU = Hi, JU = TypeError, Xa = function(i) {
  if (YU(i))
    throw new JU("Can't call method on " + i);
  return i;
}, KU = c0, $U = Xa, su = function(i) {
  return KU($U(i));
}, D_ = typeof document == "object" && document.all, Ke = D_ === void 0 && D_ !== void 0 ? function(i) {
  return typeof i == "function" || i === D_;
} : function(i) {
  return typeof i == "function";
}, QU = Ke, Rn = function(i) {
  return typeof i == "object" ? i !== null : QU(i);
}, R_ = Oe, t6 = Ke, $r = function(i, t) {
  return arguments.length < 2 ? (e = R_[i], t6(e) ? e : void 0) : R_[i] && R_[i][t];
  var e;
}, Ya = Ae({}.isPrototypeOf), jo = typeof navigator < "u" && String(navigator.userAgent) || "", fO = Oe, I_ = jo, KE = fO.process, $E = fO.Deno, QE = KE && KE.versions || $E && $E.version, t3 = QE && QE.v8;
t3 && (ev = (go = t3.split("."))[0] > 0 && go[0] < 4 ? 1 : +(go[0] + go[1])), !ev && I_ && (!(go = I_.match(/Edge\/(\d+)/)) || go[1] >= 74) && (go = I_.match(/Chrome\/(\d+)/)) && (ev = +go[1]);
var No = ev, e3 = No, e6 = je, n6 = Oe.String, mO = !!Object.getOwnPropertySymbols && !e6(function() {
  var i = Symbol("symbol detection");
  return !n6(i) || !(Object(i) instanceof Symbol) || !Symbol.sham && e3 && e3 < 41;
}), gO = mO && !Symbol.sham && typeof Symbol.iterator == "symbol", r6 = $r, i6 = Ke, s6 = Ya, a6 = Object, lS = gO ? function(i) {
  return typeof i == "symbol";
} : function(i) {
  var t = r6("Symbol");
  return i6(t) && s6(t.prototype, a6(i));
}, o6 = String, au = function(i) {
  try {
    return o6(i);
  } catch {
    return "Object";
  }
}, l6 = Ke, c6 = au, h6 = TypeError, Wn = function(i) {
  if (l6(i))
    return i;
  throw new h6(c6(i) + " is not a function");
}, u6 = Wn, d6 = Hi, Go = function(i, t) {
  var e = i[t];
  return d6(e) ? void 0 : u6(e);
}, O_ = Ne, L_ = Ke, B_ = Rn, p6 = TypeError, vO = { exports: {} }, n3 = Oe, f6 = Object.defineProperty, cS = function(i, t) {
  try {
    f6(n3, i, { value: t, configurable: !0, writable: !0 });
  } catch {
    n3[i] = t;
  }
  return t;
}, m6 = Oe, g6 = cS, r3 = "__core-js_shared__", i3 = vO.exports = m6[r3] || g6(r3, {});
(i3.versions || (i3.versions = [])).push({ version: "3.36.0", mode: "global", copyright: "© 2014-2024 Denis Pushkarev (zloirock.ru)", license: "https://github.com/zloirock/core-js/blob/v3.36.0/LICENSE", source: "https://github.com/zloirock/core-js" });
var hS = vO.exports, s3 = hS, h0 = function(i, t) {
  return s3[i] || (s3[i] = t || {});
}, v6 = Xa, y6 = Object, Br = function(i) {
  return y6(v6(i));
}, _6 = Br, w6 = Ae({}.hasOwnProperty), sr = Object.hasOwn || function(i, t) {
  return w6(_6(i), t);
}, x6 = Ae, b6 = 0, S6 = Math.random(), M6 = x6(1 .toString), u0 = function(i) {
  return "Symbol(" + (i === void 0 ? "" : i) + ")_" + M6(++b6 + S6, 36);
}, T6 = h0, a3 = sr, E6 = u0, A6 = mO, C6 = gO, xh = Oe.Symbol, z_ = T6("wks"), P6 = C6 ? xh.for || xh : xh && xh.withoutSetter || E6, ln = function(i) {
  return a3(z_, i) || (z_[i] = A6 && a3(xh, i) ? xh[i] : P6("Symbol." + i)), z_[i];
}, D6 = Ne, o3 = Rn, l3 = lS, R6 = Go, I6 = function(i, t) {
  var e, n;
  if (t === "string" && L_(e = i.toString) && !B_(n = O_(e, i)) || L_(e = i.valueOf) && !B_(n = O_(e, i)) || t !== "string" && L_(e = i.toString) && !B_(n = O_(e, i)))
    return n;
  throw new p6("Can't convert object to primitive value");
}, O6 = TypeError, L6 = ln("toPrimitive"), yO = function(i, t) {
  if (!o3(i) || l3(i))
    return i;
  var e, n = R6(i, L6);
  if (n) {
    if (t === void 0 && (t = "default"), e = D6(n, i, t), !o3(e) || l3(e))
      return e;
    throw new O6("Can't convert object to primitive value");
  }
  return t === void 0 && (t = "number"), I6(i, t);
}, B6 = yO, z6 = lS, uS = function(i) {
  var t = B6(i, "string");
  return z6(t) ? t : t + "";
}, c3 = Rn, mx = Oe.document, k6 = c3(mx) && c3(mx.createElement), d0 = function(i) {
  return k6 ? mx.createElement(i) : {};
}, N6 = d0, _O = !Mn && !je(function() {
  return Object.defineProperty(N6("div"), "a", { get: function() {
    return 7;
  } }).a !== 7;
}), F6 = Mn, U6 = Ne, V6 = oS, H6 = Ho, j6 = su, G6 = uS, W6 = sr, Z6 = _O, h3 = Object.getOwnPropertyDescriptor;
Tp.f = F6 ? h3 : function(i, t) {
  if (i = j6(i), t = G6(t), Z6)
    try {
      return h3(i, t);
    } catch {
    }
  if (W6(i, t))
    return H6(!U6(V6.f, i, t), i[t]);
};
var di = {}, wO = Mn && je(function() {
  return Object.defineProperty(function() {
  }, "prototype", { value: 42, writable: !1 }).prototype !== 42;
}), q6 = Rn, X6 = String, Y6 = TypeError, $e = function(i) {
  if (q6(i))
    return i;
  throw new Y6(X6(i) + " is not an object");
}, J6 = Mn, K6 = _O, $6 = wO, Pm = $e, u3 = uS, Q6 = TypeError, k_ = Object.defineProperty, tV = Object.getOwnPropertyDescriptor, N_ = "enumerable", F_ = "configurable", U_ = "writable";
di.f = J6 ? $6 ? function(i, t, e) {
  if (Pm(i), t = u3(t), Pm(e), typeof i == "function" && t === "prototype" && "value" in e && U_ in e && !e[U_]) {
    var n = tV(i, t);
    n && n[U_] && (i[t] = e.value, e = { configurable: F_ in e ? e[F_] : n[F_], enumerable: N_ in e ? e[N_] : n[N_], writable: !1 });
  }
  return k_(i, t, e);
} : k_ : function(i, t, e) {
  if (Pm(i), t = u3(t), Pm(e), K6)
    try {
      return k_(i, t, e);
    } catch {
    }
  if ("get" in e || "set" in e)
    throw new Q6("Accessors not supported");
  return "value" in e && (i[t] = e.value), i;
};
var eV = di, nV = Ho, os = Mn ? function(i, t, e) {
  return eV.f(i, t, nV(1, e));
} : function(i, t, e) {
  return i[t] = e, i;
}, xO = { exports: {} }, gx = Mn, rV = sr, bO = Function.prototype, iV = gx && Object.getOwnPropertyDescriptor, V_ = rV(bO, "name"), Ep = { EXISTS: V_, PROPER: V_ && (function() {
}).name === "something", CONFIGURABLE: V_ && (!gx || gx && iV(bO, "name").configurable) }, sV = Ke, vx = hS, aV = Ae(Function.toString);
sV(vx.inspectSource) || (vx.inspectSource = function(i) {
  return aV(i);
});
var Pv, Ld, Dv, dS = vx.inspectSource, oV = Ke, d3 = Oe.WeakMap, SO = oV(d3) && /native code/.test(String(d3)), lV = u0, p3 = h0("keys"), pS = function(i) {
  return p3[i] || (p3[i] = lV(i));
}, p0 = {}, cV = SO, MO = Oe, hV = Rn, uV = os, H_ = sr, j_ = hS, dV = pS, pV = p0, f3 = "Object already initialized", yx = MO.TypeError, fV = MO.WeakMap;
if (cV || j_.state) {
  var Fs = j_.state || (j_.state = new fV());
  Fs.get = Fs.get, Fs.has = Fs.has, Fs.set = Fs.set, Pv = function(i, t) {
    if (Fs.has(i))
      throw new yx(f3);
    return t.facade = i, Fs.set(i, t), t;
  }, Ld = function(i) {
    return Fs.get(i) || {};
  }, Dv = function(i) {
    return Fs.has(i);
  };
} else {
  var Gc = dV("state");
  pV[Gc] = !0, Pv = function(i, t) {
    if (H_(i, Gc))
      throw new yx(f3);
    return t.facade = i, uV(i, Gc, t), t;
  }, Ld = function(i) {
    return H_(i, Gc) ? i[Gc] : {};
  }, Dv = function(i) {
    return H_(i, Gc);
  };
}
var Fn = { set: Pv, get: Ld, has: Dv, enforce: function(i) {
  return Dv(i) ? Ld(i) : Pv(i, {});
}, getterFor: function(i) {
  return function(t) {
    var e;
    if (!hV(t) || (e = Ld(t)).type !== i)
      throw new yx("Incompatible receiver, " + i + " required");
    return e;
  };
} }, fS = Ae, mV = je, gV = Ke, Dm = sr, _x = Mn, vV = Ep.CONFIGURABLE, yV = dS, _V = Fn.enforce, wV = Fn.get, m3 = String, nv = Object.defineProperty, xV = fS("".slice), bV = fS("".replace), SV = fS([].join), MV = _x && !mV(function() {
  return nv(function() {
  }, "length", { value: 8 }).length !== 8;
}), TV = String(String).split("String"), EV = xO.exports = function(i, t, e) {
  xV(m3(t), 0, 7) === "Symbol(" && (t = "[" + bV(m3(t), /^Symbol\(([^)]*)\).*$/, "$1") + "]"), e && e.getter && (t = "get " + t), e && e.setter && (t = "set " + t), (!Dm(i, "name") || vV && i.name !== t) && (_x ? nv(i, "name", { value: t, configurable: !0 }) : i.name = t), MV && e && Dm(e, "arity") && i.length !== e.arity && nv(i, "length", { value: e.arity });
  try {
    e && Dm(e, "constructor") && e.constructor ? _x && nv(i, "prototype", { writable: !1 }) : i.prototype && (i.prototype = void 0);
  } catch {
  }
  var n = _V(i);
  return Dm(n, "source") || (n.source = SV(TV, typeof t == "string" ? t : "")), i;
};
Function.prototype.toString = EV(function() {
  return gV(this) && wV(this).source || yV(this);
}, "toString");
var TO = xO.exports, AV = Ke, CV = di, PV = TO, DV = cS, pi = function(i, t, e, n) {
  n || (n = {});
  var r = n.enumerable, s = n.name !== void 0 ? n.name : t;
  if (AV(e) && PV(e, s, n), n.global)
    r ? i[t] = e : DV(t, e);
  else {
    try {
      n.unsafe ? i[t] && (r = !0) : delete i[t];
    } catch {
    }
    r ? i[t] = e : CV.f(i, t, { value: e, enumerable: !1, configurable: !n.nonConfigurable, writable: !n.nonWritable });
  }
  return i;
}, ou = {}, RV = Math.ceil, IV = Math.floor, OV = Math.trunc || function(i) {
  var t = +i;
  return (t > 0 ? IV : RV)(t);
}, LV = OV, Os = function(i) {
  var t = +i;
  return t != t || t === 0 ? 0 : LV(t);
}, BV = Os, zV = Math.max, kV = Math.min, EO = function(i, t) {
  var e = BV(i);
  return e < 0 ? zV(e + t, 0) : kV(e, t);
}, NV = Os, FV = Math.min, lu = function(i) {
  var t = NV(i);
  return t > 0 ? FV(t, 9007199254740991) : 0;
}, UV = lu, Qr = function(i) {
  return UV(i.length);
}, VV = su, HV = EO, jV = Qr, g3 = function(i) {
  return function(t, e, n) {
    var r = VV(t), s = jV(r);
    if (s === 0)
      return !i && -1;
    var a, o = HV(n, s);
    if (i && e != e) {
      for (; s > o; )
        if ((a = r[o++]) != a)
          return !0;
    } else
      for (; s > o; o++)
        if ((i || o in r) && r[o] === e)
          return i || o || 0;
    return !i && -1;
  };
}, AO = { includes: g3(!0), indexOf: g3(!1) }, G_ = sr, GV = su, WV = AO.indexOf, ZV = p0, v3 = Ae([].push), CO = function(i, t) {
  var e, n = GV(i), r = 0, s = [];
  for (e in n)
    !G_(ZV, e) && G_(n, e) && v3(s, e);
  for (; t.length > r; )
    G_(n, e = t[r++]) && (~WV(s, e) || v3(s, e));
  return s;
}, mS = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"], qV = CO, XV = mS.concat("length", "prototype");
ou.f = Object.getOwnPropertyNames || function(i) {
  return qV(i, XV);
};
var gS = {};
gS.f = Object.getOwnPropertySymbols;
var YV = $r, JV = ou, KV = gS, $V = $e, QV = Ae([].concat), t8 = YV("Reflect", "ownKeys") || function(i) {
  var t = JV.f($V(i)), e = KV.f;
  return e ? QV(t, e(i)) : t;
}, y3 = sr, e8 = t8, n8 = Tp, r8 = di, f0 = function(i, t, e) {
  for (var n = e8(t), r = r8.f, s = n8.f, a = 0; a < n.length; a++) {
    var o = n[a];
    y3(i, o) || e && y3(e, o) || r(i, o, s(t, o));
  }
}, i8 = je, s8 = Ke, a8 = /#|\.prototype\./, Ap = function(i, t) {
  var e = l8[o8(i)];
  return e === h8 || e !== c8 && (s8(t) ? i8(t) : !!t);
}, o8 = Ap.normalize = function(i) {
  return String(i).replace(a8, ".").toLowerCase();
}, l8 = Ap.data = {}, c8 = Ap.NATIVE = "N", h8 = Ap.POLYFILL = "P", m0 = Ap, Rm = Oe, u8 = Tp.f, d8 = os, p8 = pi, f8 = cS, m8 = f0, g8 = m0, zt = function(i, t) {
  var e, n, r, s, a, o = i.target, l = i.global, c = i.stat;
  if (e = l ? Rm : c ? Rm[o] || f8(o, {}) : Rm[o] && Rm[o].prototype)
    for (n in t) {
      if (s = t[n], r = i.dontCallGetSet ? (a = u8(e, n)) && a.value : e[n], !g8(l ? n : o + (c ? "." : "#") + n, i.forced) && r !== void 0) {
        if (typeof s == typeof r)
          continue;
        m8(s, r);
      }
      (i.sham || r && r.sham) && d8(s, "sham", !0), p8(e, n, s, i);
    }
}, PO = {};
PO[ln("toStringTag")] = "z";
var v8 = String(PO) === "[object z]", y8 = Ke, rv = qa, _8 = ln("toStringTag"), w8 = Object, x8 = rv(function() {
  return arguments;
}()) === "Arguments", Wo = v8 ? rv : function(i) {
  var t, e, n;
  return i === void 0 ? "Undefined" : i === null ? "Null" : typeof (e = function(r, s) {
    try {
      return r[s];
    } catch {
    }
  }(t = w8(i), _8)) == "string" ? e : x8 ? rv(t) : (n = rv(t)) === "Object" && y8(t.callee) ? "Arguments" : n;
}, b8 = Wo, S8 = String, fi = function(i) {
  if (b8(i) === "Symbol")
    throw new TypeError("Cannot convert a Symbol value to a string");
  return S8(i);
}, _3 = TO, M8 = di, ls = function(i, t, e) {
  return e.get && _3(e.get, t, { getter: !0 }), e.set && _3(e.set, t, { setter: !0 }), M8.f(i, t, e);
}, T8 = zt, E8 = Mn, Im = Ae, A8 = sr, C8 = Ke, P8 = Ya, D8 = fi, R8 = ls, I8 = f0, Ra = Oe.Symbol, dl = Ra && Ra.prototype;
if (E8 && C8(Ra) && (!("description" in dl) || Ra().description !== void 0)) {
  var w3 = {}, Om = function() {
    var i = arguments.length < 1 || arguments[0] === void 0 ? void 0 : D8(arguments[0]), t = P8(dl, this) ? new Ra(i) : i === void 0 ? Ra() : Ra(i);
    return i === "" && (w3[t] = !0), t;
  };
  I8(Om, Ra), Om.prototype = dl, dl.constructor = Om;
  var O8 = String(Ra("description detection")) === "Symbol(description detection)", L8 = Im(dl.valueOf), B8 = Im(dl.toString), z8 = /^Symbol\((.*)\)[^)]+$/, k8 = Im("".replace), N8 = Im("".slice);
  R8(dl, "description", { configurable: !0, get: function() {
    var i = L8(this);
    if (A8(w3, i))
      return "";
    var t = B8(i), e = O8 ? N8(t, 7, -1) : k8(t, z8, "$1");
    return e === "" ? void 0 : e;
  } }), T8({ global: !0, constructor: !0, forced: !0 }, { Symbol: Om });
}
var F8 = qa, DO = Array.isArray || function(i) {
  return F8(i) === "Array";
}, U8 = TypeError, V8 = qa, H8 = Ae, Rv = function(i) {
  if (V8(i) === "Function")
    return H8(i);
}, j8 = Wn, G8 = l0, W8 = Rv(Rv.bind), Zn = function(i, t) {
  return j8(i), t === void 0 ? i : G8 ? W8(i, t) : function() {
    return i.apply(t, arguments);
  };
}, Z8 = DO, q8 = Qr, X8 = function(i) {
  if (i > 9007199254740991)
    throw U8("Maximum allowed index exceeded");
  return i;
}, Y8 = Zn, RO = function(i, t, e, n, r, s, a, o) {
  for (var l, c, u = r, h = 0, p = !!a && Y8(a, o); h < n; )
    h in e && (l = p ? p(e[h], h, t) : e[h], s > 0 && Z8(l) ? (c = q8(l), u = RO(i, t, l, c, u, s - 1) - 1) : (X8(u + 1), i[u] = l), u++), h++;
  return u;
}, IO = RO, J8 = Ae, K8 = je, OO = Ke, $8 = Wo, Q8 = dS, LO = function() {
}, BO = $r("Reflect", "construct"), vS = /^\s*(?:class|function)\b/, tH = J8(vS.exec), eH = !vS.test(LO), Yu = function(i) {
  if (!OO(i))
    return !1;
  try {
    return BO(LO, [], i), !0;
  } catch {
    return !1;
  }
}, zO = function(i) {
  if (!OO(i))
    return !1;
  switch ($8(i)) {
    case "AsyncFunction":
    case "GeneratorFunction":
    case "AsyncGeneratorFunction":
      return !1;
  }
  try {
    return eH || !!tH(vS, Q8(i));
  } catch {
    return !0;
  }
};
zO.sham = !0;
var Cp = !BO || K8(function() {
  var i;
  return Yu(Yu.call) || !Yu(Object) || !Yu(function() {
    i = !0;
  }) || i;
}) ? zO : Yu, x3 = DO, nH = Cp, rH = Rn, iH = ln("species"), b3 = Array, sH = function(i) {
  var t;
  return x3(i) && (t = i.constructor, (nH(t) && (t === b3 || x3(t.prototype)) || rH(t) && (t = t[iH]) === null) && (t = void 0)), t === void 0 ? b3 : t;
}, yS = function(i, t) {
  return new (sH(i))(t === 0 ? 0 : t);
}, aH = IO, oH = Br, lH = Qr, cH = Os, hH = yS;
zt({ target: "Array", proto: !0 }, { flat: function() {
  var i = arguments.length ? arguments[0] : void 0, t = oH(this), e = lH(t), n = hH(t, 0);
  return n.length = aH(n, t, t, e, 0, i === void 0 ? 1 : cH(i)), n;
} });
var uH = IO, dH = Wn, pH = Br, fH = Qr, mH = yS;
zt({ target: "Array", proto: !0 }, { flatMap: function(i) {
  var t, e = pH(this), n = fH(e);
  return dH(i), (t = mH(e, 0)).length = uH(t, e, e, n, 0, 1, i, arguments.length > 1 ? arguments[1] : void 0), t;
} });
var kO = {}, gH = CO, vH = mS, NO = Object.keys || function(i) {
  return gH(i, vH);
}, yH = Mn, _H = wO, wH = di, xH = $e, bH = su, SH = NO;
kO.f = yH && !_H ? Object.defineProperties : function(i, t) {
  xH(i);
  for (var e, n = bH(t), r = SH(t), s = r.length, a = 0; s > a; )
    wH.f(i, e = r[a++], n[e]);
  return i;
};
var Lm, FO = $r("document", "documentElement"), MH = $e, TH = kO, S3 = mS, EH = p0, AH = FO, CH = d0, wx = "prototype", xx = "script", UO = pS("IE_PROTO"), W_ = function() {
}, VO = function(i) {
  return "<" + xx + ">" + i + "</" + xx + ">";
}, M3 = function(i) {
  i.write(VO("")), i.close();
  var t = i.parentWindow.Object;
  return i = null, t;
}, iv = function() {
  try {
    Lm = new ActiveXObject("htmlfile");
  } catch {
  }
  var i, t, e;
  iv = typeof document < "u" ? document.domain && Lm ? M3(Lm) : (t = CH("iframe"), e = "java" + xx + ":", t.style.display = "none", AH.appendChild(t), t.src = String(e), (i = t.contentWindow.document).open(), i.write(VO("document.F=Object")), i.close(), i.F) : M3(Lm);
  for (var n = S3.length; n--; )
    delete iv[wx][S3[n]];
  return iv();
};
EH[UO] = !0;
var sa = Object.create || function(i, t) {
  var e;
  return i !== null ? (W_[wx] = MH(i), e = new W_(), W_[wx] = null, e[UO] = i) : e = iv(), t === void 0 ? e : TH.f(e, t);
}, PH = ln, DH = sa, RH = di.f, bx = PH("unscopables"), Sx = Array.prototype;
Sx[bx] === void 0 && RH(Sx, bx, { configurable: !0, value: DH(null) });
var Hh = function(i) {
  Sx[bx][i] = !0;
}, IH = AO.includes, OH = Hh;
zt({ target: "Array", proto: !0, forced: je(function() {
  return !Array(1).includes();
}) }, { includes: function(i) {
  return IH(this, i, arguments.length > 1 ? arguments[1] : void 0);
} }), OH("includes");
var LH = Wn, BH = Br, zH = c0, kH = Qr, T3 = TypeError, E3 = "Reduce of empty array with no initial value", A3 = function(i) {
  return function(t, e, n, r) {
    var s = BH(t), a = zH(s), o = kH(s);
    if (LH(e), o === 0 && n < 2)
      throw new T3(E3);
    var l = i ? o - 1 : 0, c = i ? -1 : 1;
    if (n < 2)
      for (; ; ) {
        if (l in a) {
          r = a[l], l += c;
          break;
        }
        if (l += c, i ? l < 0 : o <= l)
          throw new T3(E3);
      }
    for (; i ? l >= 0 : o > l; l += c)
      l in a && (r = e(r, a[l], l, s));
    return r;
  };
}, HO = { left: A3(!1), right: A3(!0) }, NH = je, _S = function(i, t) {
  var e = [][i];
  return !!e && NH(function() {
    e.call(null, t || function() {
      return 1;
    }, 1);
  });
}, cu = qa(Oe.process) === "process", FH = HO.left;
zt({ target: "Array", proto: !0, forced: !cu && No > 79 && No < 83 || !_S("reduce") }, { reduce: function(i) {
  var t = arguments.length;
  return FH(this, i, t, t > 1 ? arguments[1] : void 0);
} });
var UH = HO.right;
zt({ target: "Array", proto: !0, forced: !cu && No > 79 && No < 83 || !_S("reduceRight") }, { reduceRight: function(i) {
  return UH(this, i, arguments.length, arguments.length > 1 ? arguments[1] : void 0);
} });
var C3 = au, VH = TypeError, hu = Ae([].slice), P3 = hu, HH = Math.floor, Mx = function(i, t) {
  var e = i.length;
  if (e < 8)
    for (var n, r, s = 1; s < e; ) {
      for (r = s, n = i[s]; r && t(i[r - 1], n) > 0; )
        i[r] = i[--r];
      r !== s++ && (i[r] = n);
    }
  else
    for (var a = HH(e / 2), o = Mx(P3(i, 0, a), t), l = Mx(P3(i, a), t), c = o.length, u = l.length, h = 0, p = 0; h < c || p < u; )
      i[h + p] = h < c && p < u ? t(o[h], l[p]) <= 0 ? o[h++] : l[p++] : h < c ? o[h++] : l[p++];
  return i;
}, wS = Mx, D3 = jo.match(/firefox\/(\d+)/i), jO = !!D3 && +D3[1], GO = /MSIE|Trident/.test(jo), R3 = jo.match(/AppleWebKit\/(\d+)\./), WO = !!R3 && +R3[1], jH = zt, ZO = Ae, GH = Wn, WH = Br, I3 = Qr, ZH = function(i, t) {
  if (!delete i[t])
    throw new VH("Cannot delete property " + C3(t) + " of " + C3(i));
}, O3 = fi, xS = je, qH = wS, XH = _S, L3 = jO, YH = GO, B3 = No, z3 = WO, Io = [], k3 = ZO(Io.sort), JH = ZO(Io.push), KH = xS(function() {
  Io.sort(void 0);
}), $H = xS(function() {
  Io.sort(null);
}), QH = XH("sort"), N3 = !xS(function() {
  if (B3)
    return B3 < 70;
  if (!(L3 && L3 > 3)) {
    if (YH)
      return !0;
    if (z3)
      return z3 < 603;
    var i, t, e, n, r = "";
    for (i = 65; i < 76; i++) {
      switch (t = String.fromCharCode(i), i) {
        case 66:
        case 69:
        case 70:
        case 72:
          e = 3;
          break;
        case 68:
        case 71:
          e = 4;
          break;
        default:
          e = 2;
      }
      for (n = 0; n < 47; n++)
        Io.push({ k: t + n, v: e });
    }
    for (Io.sort(function(s, a) {
      return a.v - s.v;
    }), n = 0; n < Io.length; n++)
      t = Io[n].k.charAt(0), r.charAt(r.length - 1) !== t && (r += t);
    return r !== "DGBEFHACIJK";
  }
});
jH({ target: "Array", proto: !0, forced: KH || !$H || !QH || !N3 }, { sort: function(i) {
  i !== void 0 && GH(i);
  var t = WH(this);
  if (N3)
    return i === void 0 ? k3(t) : k3(t, i);
  var e, n, r = [], s = I3(t);
  for (n = 0; n < s; n++)
    n in t && JH(r, t[n]);
  for (qH(r, function(a) {
    return function(o, l) {
      return l === void 0 ? -1 : o === void 0 ? 1 : a !== void 0 ? +a(o, l) || 0 : O3(o) > O3(l) ? 1 : -1;
    };
  }(i)), e = I3(r), n = 0; n < e; )
    t[n] = r[n++];
  for (; n < s; )
    ZH(t, n++);
  return t;
} }), Hh("flat"), Hh("flatMap");
var tj = zt, F3 = Math.hypot, ej = Math.abs, nj = Math.sqrt;
tj({ target: "Math", stat: !0, arity: 2, forced: !!F3 && F3(1 / 0, NaN) !== 1 / 0 }, { hypot: function(i, t) {
  for (var e, n, r = 0, s = 0, a = arguments.length, o = 0; s < a; )
    o < (e = ej(arguments[s++])) ? (r = r * (n = o / e) * n + 1, o = e) : r += e > 0 ? (n = e / o) * n : e;
  return o === 1 / 0 ? 1 / 0 : o * nj(r);
} });
var uu = {}, rj = uu, ij = ln("iterator"), sj = Array.prototype, bS = function(i) {
  return i !== void 0 && (rj.Array === i || sj[ij] === i);
}, aj = Wo, U3 = Go, oj = Hi, lj = uu, cj = ln("iterator"), Pp = function(i) {
  if (!oj(i))
    return U3(i, cj) || U3(i, "@@iterator") || lj[aj(i)];
}, hj = Ne, uj = Wn, dj = $e, pj = au, fj = Pp, mj = TypeError, Dp = function(i, t) {
  var e = arguments.length < 2 ? fj(i) : t;
  if (uj(e))
    return dj(hj(e, i));
  throw new mj(pj(i) + " is not iterable");
}, gj = Ne, V3 = $e, vj = Go, g0 = function(i, t, e) {
  var n, r;
  V3(i);
  try {
    if (!(n = vj(i, "return"))) {
      if (t === "throw")
        throw e;
      return e;
    }
    n = gj(n, i);
  } catch (s) {
    r = !0, n = s;
  }
  if (t === "throw")
    throw e;
  if (r)
    throw n;
  return V3(n), e;
}, yj = Zn, _j = Ne, wj = $e, xj = au, bj = bS, Sj = Qr, H3 = Ya, Mj = Dp, Tj = Pp, j3 = g0, Ej = TypeError, sv = function(i, t) {
  this.stopped = i, this.result = t;
}, G3 = sv.prototype, Ti = function(i, t, e) {
  var n, r, s, a, o, l, c, u = e && e.that, h = !(!e || !e.AS_ENTRIES), p = !(!e || !e.IS_RECORD), f = !(!e || !e.IS_ITERATOR), v = !(!e || !e.INTERRUPTED), m = yj(t, u), y = function(w) {
    return n && j3(n, "normal", w), new sv(!0, w);
  }, _ = function(w) {
    return h ? (wj(w), v ? m(w[0], w[1], y) : m(w[0], w[1])) : v ? m(w, y) : m(w);
  };
  if (p)
    n = i.iterator;
  else if (f)
    n = i;
  else {
    if (!(r = Tj(i)))
      throw new Ej(xj(i) + " is not iterable");
    if (bj(r)) {
      for (s = 0, a = Sj(i); a > s; s++)
        if ((o = _(i[s])) && H3(G3, o))
          return o;
      return new sv(!1);
    }
    n = Mj(i, r);
  }
  for (l = p ? i.next : n.next; !(c = _j(l, n)).done; ) {
    try {
      o = _(c.value);
    } catch (w) {
      j3(n, "throw", w);
    }
    if (typeof o == "object" && o && H3(G3, o))
      return o;
  }
  return new sv(!1);
}, Aj = Mn, Cj = di, Pj = Ho, qO = function(i, t, e) {
  Aj ? Cj.f(i, t, Pj(0, e)) : i[t] = e;
}, Dj = Ti, Rj = qO;
zt({ target: "Object", stat: !0 }, { fromEntries: function(i) {
  var t = {};
  return Dj(i, function(e, n) {
    Rj(t, e, n);
  }, { AS_ENTRIES: !0 }), t;
} });
var pp, Wc, W3, Z_, Ij = Ae, Oj = Wn, XO = function(i, t, e) {
  try {
    return Ij(Oj(Object.getOwnPropertyDescriptor(i, t)[e]));
  } catch {
  }
}, Lj = Rn, Bj = function(i) {
  return Lj(i) || i === null;
}, zj = String, kj = TypeError, Nj = XO, Fj = $e, Uj = function(i) {
  if (Bj(i))
    return i;
  throw new kj("Can't set " + zj(i) + " as a prototype");
}, Ql = Object.setPrototypeOf || ("__proto__" in {} ? function() {
  var i, t = !1, e = {};
  try {
    (i = Nj(Object.prototype, "__proto__", "set"))(e, []), t = e instanceof Array;
  } catch {
  }
  return function(n, r) {
    return Fj(n), Uj(r), t ? i(n, r) : n.__proto__ = r, n;
  };
}() : void 0), Vj = di.f, Hj = sr, Z3 = ln("toStringTag"), Zo = function(i, t, e) {
  i && !e && (i = i.prototype), i && !Hj(i, Z3) && Vj(i, Z3, { configurable: !0, value: t });
}, jj = $r, Gj = ls, Wj = Mn, q3 = ln("species"), Rp = function(i) {
  var t = jj(i);
  Wj && t && !t[q3] && Gj(t, q3, { configurable: !0, get: function() {
    return this;
  } });
}, Zj = Ya, qj = TypeError, Ja = function(i, t) {
  if (Zj(t, i))
    return i;
  throw new qj("Incorrect invocation");
}, Xj = Cp, Yj = au, Jj = TypeError, YO = function(i) {
  if (Xj(i))
    return i;
  throw new Jj(Yj(i) + " is not a constructor");
}, X3 = $e, Kj = YO, $j = Hi, Qj = ln("species"), SS = function(i, t) {
  var e, n = X3(i).constructor;
  return n === void 0 || $j(e = X3(n)[Qj]) ? t : Kj(e);
}, tG = l0, JO = Function.prototype, Y3 = JO.apply, J3 = JO.call, Ip = typeof Reflect == "object" && Reflect.apply || (tG ? J3.bind(Y3) : function() {
  return J3.apply(Y3, arguments);
}), eG = TypeError, Op = function(i, t) {
  if (i < t)
    throw new eG("Not enough arguments");
  return i;
}, KO = /(?:ipad|iphone|ipod).*applewebkit/i.test(jo), Ui = Oe, nG = Ip, rG = Zn, K3 = Ke, iG = sr, $O = je, $3 = FO, sG = hu, Q3 = d0, aG = Op, oG = KO, lG = cu, Tx = Ui.setImmediate, Ex = Ui.clearImmediate, cG = Ui.process, q_ = Ui.Dispatch, hG = Ui.Function, tA = Ui.MessageChannel, uG = Ui.String, X_ = 0, Bd = {}, eA = "onreadystatechange";
$O(function() {
  pp = Ui.location;
});
var MS = function(i) {
  if (iG(Bd, i)) {
    var t = Bd[i];
    delete Bd[i], t();
  }
}, Y_ = function(i) {
  return function() {
    MS(i);
  };
}, nA = function(i) {
  MS(i.data);
}, rA = function(i) {
  Ui.postMessage(uG(i), pp.protocol + "//" + pp.host);
};
Tx && Ex || (Tx = function(i) {
  aG(arguments.length, 1);
  var t = K3(i) ? i : hG(i), e = sG(arguments, 1);
  return Bd[++X_] = function() {
    nG(t, void 0, e);
  }, Wc(X_), X_;
}, Ex = function(i) {
  delete Bd[i];
}, lG ? Wc = function(i) {
  cG.nextTick(Y_(i));
} : q_ && q_.now ? Wc = function(i) {
  q_.now(Y_(i));
} : tA && !oG ? (Z_ = (W3 = new tA()).port2, W3.port1.onmessage = nA, Wc = rG(Z_.postMessage, Z_)) : Ui.addEventListener && K3(Ui.postMessage) && !Ui.importScripts && pp && pp.protocol !== "file:" && !$O(rA) ? (Wc = rA, Ui.addEventListener("message", nA, !1)) : Wc = eA in Q3("script") ? function(i) {
  $3.appendChild(Q3("script"))[eA] = function() {
    $3.removeChild(this), MS(i);
  };
} : function(i) {
  setTimeout(Y_(i), 0);
});
var v0 = { set: Tx, clear: Ex }, iA = Oe, dG = Mn, pG = Object.getOwnPropertyDescriptor, QO = function(i) {
  if (!dG)
    return iA[i];
  var t = pG(iA, i);
  return t && t.value;
}, tL = function() {
  this.head = null, this.tail = null;
};
tL.prototype = { add: function(i) {
  var t = { item: i, next: null }, e = this.tail;
  e ? e.next = t : this.head = t, this.tail = t;
}, get: function() {
  var i = this.head;
  if (i)
    return (this.head = i.next) === null && (this.tail = null), i.item;
} };
var Zc, J_, K_, $_, sA, eL = tL, fG = /ipad|iphone|ipod/i.test(jo) && typeof Pebble < "u", mG = /web0s(?!.*chrome)/i.test(jo), jh = Oe, gG = QO, aA = Zn, Q_ = v0.set, vG = eL, yG = KO, _G = fG, wG = mG, t1 = cu, oA = jh.MutationObserver || jh.WebKitMutationObserver, lA = jh.document, cA = jh.process, Bm = jh.Promise, Ax = gG("queueMicrotask");
if (!Ax) {
  var zm = new vG(), km = function() {
    var i, t;
    for (t1 && (i = cA.domain) && i.exit(); t = zm.get(); )
      try {
        t();
      } catch (e) {
        throw zm.head && Zc(), e;
      }
    i && i.enter();
  };
  yG || t1 || wG || !oA || !lA ? !_G && Bm && Bm.resolve ? (($_ = Bm.resolve(void 0)).constructor = Bm, sA = aA($_.then, $_), Zc = function() {
    sA(km);
  }) : t1 ? Zc = function() {
    cA.nextTick(km);
  } : (Q_ = aA(Q_, jh), Zc = function() {
    Q_(km);
  }) : (J_ = !0, K_ = lA.createTextNode(""), new oA(km).observe(K_, { characterData: !0 }), Zc = function() {
    K_.data = J_ = !J_;
  }), Ax = function(i) {
    zm.head || Zc(), zm.add(i);
  };
}
var nL = Ax, rL = function(i, t) {
  try {
    arguments.length === 1 ? console.error(i) : console.error(i, t);
  } catch {
  }
}, du = function(i) {
  try {
    return { error: !1, value: i() };
  } catch (t) {
    return { error: !0, value: t };
  }
}, Lp = Oe.Promise, iL = typeof Deno == "object" && Deno && typeof Deno.version == "object", xG = !iL && !cu && typeof window == "object" && typeof document == "object", bG = Oe, zd = Lp, SG = Ke, MG = m0, TG = dS, EG = ln, AG = xG, CG = iL, e1 = No;
zd && zd.prototype;
var PG = EG("species"), sL = !1, aL = SG(bG.PromiseRejectionEvent), DG = MG("Promise", function() {
  var i = TG(zd), t = i !== String(zd);
  if (!t && e1 === 66)
    return !0;
  if (!e1 || e1 < 51 || !/native code/.test(i)) {
    var e = new zd(function(r) {
      r(1);
    }), n = function(r) {
      r(function() {
      }, function() {
      });
    };
    if ((e.constructor = {})[PG] = n, !(sL = e.then(function() {
    }) instanceof n))
      return !0;
  }
  return !t && (AG || CG) && !aL;
}), tc = { CONSTRUCTOR: DG, REJECTION_EVENT: aL, SUBCLASSING: sL }, Ka = {}, hA = Wn, RG = TypeError, IG = function(i) {
  var t, e;
  this.promise = new i(function(n, r) {
    if (t !== void 0 || e !== void 0)
      throw new RG("Bad Promise constructor");
    t = n, e = r;
  }), this.resolve = hA(t), this.reject = hA(e);
};
Ka.f = function(i) {
  return new IG(i);
};
var n1, uA, dA, OG = zt, Iv = cu, Fo = Oe, Gh = Ne, pA = pi, fA = Ql, LG = Zo, BG = Rp, zG = Wn, av = Ke, kG = Rn, NG = Ja, FG = SS, oL = v0.set, TS = nL, UG = rL, VG = du, HG = eL, lL = Fn, Ov = Lp, cL = Ka, Lv = "Promise", hL = tc.CONSTRUCTOR, jG = tc.REJECTION_EVENT, GG = tc.SUBCLASSING, r1 = lL.getterFor(Lv), WG = lL.set, uh = Ov && Ov.prototype, bh = Ov, Nm = uh, uL = Fo.TypeError, Cx = Fo.document, ES = Fo.process, Px = cL.f, ZG = Px, qG = !!(Cx && Cx.createEvent && Fo.dispatchEvent), dL = "unhandledrejection", pL = function(i) {
  var t;
  return !(!kG(i) || !av(t = i.then)) && t;
}, fL = function(i, t) {
  var e, n, r, s = t.value, a = t.state === 1, o = a ? i.ok : i.fail, l = i.resolve, c = i.reject, u = i.domain;
  try {
    o ? (a || (t.rejection === 2 && YG(t), t.rejection = 1), o === !0 ? e = s : (u && u.enter(), e = o(s), u && (u.exit(), r = !0)), e === i.promise ? c(new uL("Promise-chain cycle")) : (n = pL(e)) ? Gh(n, e, l, c) : l(e)) : c(s);
  } catch (h) {
    u && !r && u.exit(), c(h);
  }
}, mL = function(i, t) {
  i.notified || (i.notified = !0, TS(function() {
    for (var e, n = i.reactions; e = n.get(); )
      fL(e, i);
    i.notified = !1, t && !i.rejection && XG(i);
  }));
}, gL = function(i, t, e) {
  var n, r;
  qG ? ((n = Cx.createEvent("Event")).promise = t, n.reason = e, n.initEvent(i, !1, !0), Fo.dispatchEvent(n)) : n = { promise: t, reason: e }, !jG && (r = Fo["on" + i]) ? r(n) : i === dL && UG("Unhandled promise rejection", e);
}, XG = function(i) {
  Gh(oL, Fo, function() {
    var t, e = i.facade, n = i.value;
    if (mA(i) && (t = VG(function() {
      Iv ? ES.emit("unhandledRejection", n, e) : gL(dL, e, n);
    }), i.rejection = Iv || mA(i) ? 2 : 1, t.error))
      throw t.value;
  });
}, mA = function(i) {
  return i.rejection !== 1 && !i.parent;
}, YG = function(i) {
  Gh(oL, Fo, function() {
    var t = i.facade;
    Iv ? ES.emit("rejectionHandled", t) : gL("rejectionhandled", t, i.value);
  });
}, Sh = function(i, t, e) {
  return function(n) {
    i(t, n, e);
  };
}, Oh = function(i, t, e) {
  i.done || (i.done = !0, e && (i = e), i.value = t, i.state = 2, mL(i, !0));
}, Dx = function(i, t, e) {
  if (!i.done) {
    i.done = !0, e && (i = e);
    try {
      if (i.facade === t)
        throw new uL("Promise can't be resolved itself");
      var n = pL(t);
      n ? TS(function() {
        var r = { done: !1 };
        try {
          Gh(n, t, Sh(Dx, r, i), Sh(Oh, r, i));
        } catch (s) {
          Oh(r, s, i);
        }
      }) : (i.value = t, i.state = 1, mL(i, !1));
    } catch (r) {
      Oh({ done: !1 }, r, i);
    }
  }
};
if (hL && (Nm = (bh = function(i) {
  NG(this, Nm), zG(i), Gh(n1, this);
  var t = r1(this);
  try {
    i(Sh(Dx, t), Sh(Oh, t));
  } catch (e) {
    Oh(t, e);
  }
}).prototype, (n1 = function(i) {
  WG(this, { type: Lv, done: !1, notified: !1, parent: !1, reactions: new HG(), rejection: !1, state: 0, value: void 0 });
}).prototype = pA(Nm, "then", function(i, t) {
  var e = r1(this), n = Px(FG(this, bh));
  return e.parent = !0, n.ok = !av(i) || i, n.fail = av(t) && t, n.domain = Iv ? ES.domain : void 0, e.state === 0 ? e.reactions.add(n) : TS(function() {
    fL(n, e);
  }), n.promise;
}), uA = function() {
  var i = new n1(), t = r1(i);
  this.promise = i, this.resolve = Sh(Dx, t), this.reject = Sh(Oh, t);
}, cL.f = Px = function(i) {
  return i === bh || i === void 0 ? new uA(i) : ZG(i);
}, av(Ov) && uh !== Object.prototype)) {
  dA = uh.then, GG || pA(uh, "then", function(i, t) {
    var e = this;
    return new bh(function(n, r) {
      Gh(dA, e, n, r);
    }).then(i, t);
  }, { unsafe: !0 });
  try {
    delete uh.constructor;
  } catch {
  }
  fA && fA(uh, Nm);
}
OG({ global: !0, constructor: !0, wrap: !0, forced: hL }, { Promise: bh }), LG(bh, Lv, !1), BG(Lv);
var vL = ln("iterator"), yL = !1;
try {
  var JG = 0, gA = { next: function() {
    return { done: !!JG++ };
  }, return: function() {
    yL = !0;
  } };
  gA[vL] = function() {
    return this;
  }, Array.from(gA, function() {
    throw 2;
  });
} catch {
}
var AS = function(i, t) {
  try {
    if (!t && !yL)
      return !1;
  } catch {
    return !1;
  }
  var e = !1;
  try {
    var n = {};
    n[vL] = function() {
      return { next: function() {
        return { done: e = !0 };
      } };
    }, i(n);
  } catch {
  }
  return e;
}, KG = Lp, y0 = tc.CONSTRUCTOR || !AS(function(i) {
  KG.all(i).then(void 0, function() {
  });
}), $G = Ne, QG = Wn, t7 = Ka, e7 = du, n7 = Ti;
zt({ target: "Promise", stat: !0, forced: y0 }, { all: function(i) {
  var t = this, e = t7.f(t), n = e.resolve, r = e.reject, s = e7(function() {
    var a = QG(t.resolve), o = [], l = 0, c = 1;
    n7(i, function(u) {
      var h = l++, p = !1;
      c++, $G(a, t, u).then(function(f) {
        p || (p = !0, o[h] = f, --c || n(o));
      }, r);
    }), --c || n(o);
  });
  return s.error && r(s.value), e.promise;
} });
var r7 = zt, i7 = tc.CONSTRUCTOR, Rx = Lp, s7 = $r, a7 = Ke, o7 = pi, vA = Rx && Rx.prototype;
if (r7({ target: "Promise", proto: !0, forced: i7, real: !0 }, { catch: function(i) {
  return this.then(void 0, i);
} }), a7(Rx)) {
  var yA = s7("Promise").prototype.catch;
  vA.catch !== yA && o7(vA, "catch", yA, { unsafe: !0 });
}
var l7 = Ne, c7 = Wn, h7 = Ka, u7 = du, d7 = Ti;
zt({ target: "Promise", stat: !0, forced: y0 }, { race: function(i) {
  var t = this, e = h7.f(t), n = e.reject, r = u7(function() {
    var s = c7(t.resolve);
    d7(i, function(a) {
      l7(s, t, a).then(e.resolve, n);
    });
  });
  return r.error && n(r.value), e.promise;
} });
var p7 = Ka;
zt({ target: "Promise", stat: !0, forced: tc.CONSTRUCTOR }, { reject: function(i) {
  var t = p7.f(this);
  return (0, t.reject)(i), t.promise;
} });
var f7 = $e, m7 = Rn, g7 = Ka, _L = function(i, t) {
  if (f7(i), m7(t) && t.constructor === i)
    return t;
  var e = g7.f(i);
  return (0, e.resolve)(t), e.promise;
}, v7 = zt, y7 = tc.CONSTRUCTOR, _7 = _L;
$r("Promise"), v7({ target: "Promise", stat: !0, forced: y7 }, { resolve: function(i) {
  return _7(this, i);
} });
var w7 = zt, Bv = Lp, x7 = je, _A = $r, wA = Ke, b7 = SS, xA = _L, S7 = pi, i1 = Bv && Bv.prototype;
if (w7({ target: "Promise", proto: !0, real: !0, forced: !!Bv && x7(function() {
  i1.finally.call({ then: function() {
  } }, function() {
  });
}) }, { finally: function(i) {
  var t = b7(this, _A("Promise")), e = wA(i);
  return this.then(e ? function(n) {
    return xA(t, i()).then(function() {
      return n;
    });
  } : i, e ? function(n) {
    return xA(t, i()).then(function() {
      throw n;
    });
  } : i);
} }), wA(Bv)) {
  var bA = _A("Promise").prototype.finally;
  i1.finally !== bA && S7(i1, "finally", bA, { unsafe: !0 });
}
var M7 = Ke, T7 = Rn, SA = Ql, _0 = function(i, t, e) {
  var n, r;
  return SA && M7(n = t.constructor) && n !== e && T7(r = n.prototype) && r !== e.prototype && SA(i, r), i;
}, E7 = Rn, A7 = qa, C7 = ln("match"), CS = function(i) {
  var t;
  return E7(i) && ((t = i[C7]) !== void 0 ? !!t : A7(i) === "RegExp");
}, P7 = $e, PS = function() {
  var i = P7(this), t = "";
  return i.hasIndices && (t += "d"), i.global && (t += "g"), i.ignoreCase && (t += "i"), i.multiline && (t += "m"), i.dotAll && (t += "s"), i.unicode && (t += "u"), i.unicodeSets && (t += "v"), i.sticky && (t += "y"), t;
}, D7 = Ne, R7 = sr, I7 = Ya, O7 = PS, MA = RegExp.prototype, DS = function(i) {
  var t = i.flags;
  return t !== void 0 || "flags" in MA || R7(i, "flags") || !I7(MA, i) ? t : D7(O7, i);
}, RS = je, IS = Oe.RegExp, Ix = RS(function() {
  var i = IS("a", "y");
  return i.lastIndex = 2, i.exec("abcd") !== null;
}), L7 = Ix || RS(function() {
  return !IS("a", "y").sticky;
}), wL = { BROKEN_CARET: Ix || RS(function() {
  var i = IS("^r", "gy");
  return i.lastIndex = 2, i.exec("str") !== null;
}), MISSED_STICKY: L7, UNSUPPORTED_Y: Ix }, B7 = di.f, z7 = je, k7 = Oe.RegExp, xL = z7(function() {
  var i = k7(".", "s");
  return !(i.dotAll && i.test(`
`) && i.flags === "s");
}), N7 = je, F7 = Oe.RegExp, bL = N7(function() {
  var i = F7("(?<a>b)", "g");
  return i.exec("b").groups.a !== "b" || "b".replace(i, "$<a>c") !== "bc";
}), U7 = Mn, OS = Oe, Bp = Ae, V7 = m0, H7 = _0, j7 = os, G7 = sa, W7 = ou.f, TA = Ya, Z7 = CS, EA = fi, q7 = DS, SL = wL, X7 = function(i, t, e) {
  e in i || B7(i, e, { configurable: !0, get: function() {
    return t[e];
  }, set: function(n) {
    t[e] = n;
  } });
}, Y7 = pi, J7 = je, K7 = sr, $7 = Fn.enforce, Q7 = Rp, ML = xL, TL = bL, tW = ln("match"), Bo = OS.RegExp, dh = Bo.prototype, eW = OS.SyntaxError, nW = Bp(dh.exec), Fm = Bp("".charAt), AA = Bp("".replace), CA = Bp("".indexOf), rW = Bp("".slice), iW = /^\?<[^\s\d!#%&*+<=>@^][^\s!#%&*+<=>@^]*>/, ql = /a/g, s1 = /a/g, sW = new Bo(ql) !== ql, EL = SL.MISSED_STICKY, aW = SL.UNSUPPORTED_Y, oW = U7 && (!sW || EL || ML || TL || J7(function() {
  return s1[tW] = !1, Bo(ql) !== ql || Bo(s1) === s1 || String(Bo(ql, "i")) !== "/a/i";
}));
if (V7("RegExp", oW)) {
  for (var pl = function(i, t) {
    var e, n, r, s, a, o, l = TA(dh, this), c = Z7(i), u = t === void 0, h = [], p = i;
    if (!l && c && u && i.constructor === pl)
      return i;
    if ((c || TA(dh, i)) && (i = i.source, u && (t = q7(p))), i = i === void 0 ? "" : EA(i), t = t === void 0 ? "" : EA(t), p = i, ML && "dotAll" in ql && (n = !!t && CA(t, "s") > -1) && (t = AA(t, /s/g, "")), e = t, EL && "sticky" in ql && (r = !!t && CA(t, "y") > -1) && aW && (t = AA(t, /y/g, "")), TL && (s = function(f) {
      for (var v, m = f.length, y = 0, _ = "", w = [], b = G7(null), T = !1, M = !1, A = 0, C = ""; y <= m; y++) {
        if ((v = Fm(f, y)) === "\\")
          v += Fm(f, ++y);
        else if (v === "]")
          T = !1;
        else if (!T)
          switch (!0) {
            case v === "[":
              T = !0;
              break;
            case v === "(":
              nW(iW, rW(f, y + 1)) && (y += 2, M = !0), _ += v, A++;
              continue;
            case (v === ">" && M):
              if (C === "" || K7(b, C))
                throw new eW("Invalid capture group name");
              b[C] = !0, w[w.length] = [C, A], M = !1, C = "";
              continue;
          }
        M ? C += v : _ += v;
      }
      return [_, w];
    }(i), i = s[0], h = s[1]), a = H7(Bo(i, t), l ? this : dh, pl), (n || r || h.length) && (o = $7(a), n && (o.dotAll = !0, o.raw = pl(function(f) {
      for (var v, m = f.length, y = 0, _ = "", w = !1; y <= m; y++)
        (v = Fm(f, y)) !== "\\" ? w || v !== "." ? (v === "[" ? w = !0 : v === "]" && (w = !1), _ += v) : _ += "[\\s\\S]" : _ += v + Fm(f, ++y);
      return _;
    }(i), e)), r && (o.sticky = !0), h.length && (o.groups = h)), i !== p)
      try {
        j7(a, "source", p === "" ? "(?:)" : p);
      } catch {
      }
    return a;
  }, PA = W7(Bo), DA = 0; PA.length > DA; )
    X7(pl, Bo, PA[DA++]);
  dh.constructor = pl, pl.prototype = dh, Y7(OS, "RegExp", pl, { constructor: !0 });
}
Q7("RegExp");
var Mh = Ne, w0 = Ae, lW = fi, cW = PS, hW = wL, uW = sa, dW = Fn.get, pW = xL, fW = bL, mW = h0("native-string-replace", String.prototype.replace), zv = RegExp.prototype.exec, Ox = zv, gW = w0("".charAt), vW = w0("".indexOf), yW = w0("".replace), a1 = w0("".slice), o1 = function() {
  var i = /a/, t = /b*/g;
  return Mh(zv, i, "a"), Mh(zv, t, "a"), i.lastIndex !== 0 || t.lastIndex !== 0;
}(), RA = hW.BROKEN_CARET, l1 = /()??/.exec("")[1] !== void 0;
(o1 || l1 || RA || pW || fW) && (Ox = function(i) {
  var t, e, n, r, s, a, o, l = this, c = dW(l), u = lW(i), h = c.raw;
  if (h)
    return h.lastIndex = l.lastIndex, t = Mh(Ox, h, u), l.lastIndex = h.lastIndex, t;
  var p = c.groups, f = RA && l.sticky, v = Mh(cW, l), m = l.source, y = 0, _ = u;
  if (f && (v = yW(v, "y", ""), vW(v, "g") === -1 && (v += "g"), _ = a1(u, l.lastIndex), l.lastIndex > 0 && (!l.multiline || l.multiline && gW(u, l.lastIndex - 1) !== `
`) && (m = "(?: " + m + ")", _ = " " + _, y++), e = new RegExp("^(?:" + m + ")", v)), l1 && (e = new RegExp("^" + m + "$(?!\\s)", v)), o1 && (n = l.lastIndex), r = Mh(zv, f ? e : l, _), f ? r ? (r.input = a1(r.input, y), r[0] = a1(r[0], y), r.index = l.lastIndex, l.lastIndex += r[0].length) : l.lastIndex = 0 : o1 && r && (l.lastIndex = l.global ? r.index + r[0].length : n), l1 && r && r.length > 1 && Mh(mW, r[0], e, function() {
    for (s = 1; s < arguments.length - 2; s++)
      arguments[s] === void 0 && (r[s] = void 0);
  }), r && p)
    for (r.groups = a = uW(null), s = 0; s < p.length; s++)
      a[(o = p[s])[0]] = r[o[1]];
  return r;
});
var kv = Ox;
zt({ target: "RegExp", proto: !0, forced: /./.exec !== kv }, { exec: kv });
var _W = Mn, wW = ls, xW = PS, bW = je, AL = Oe.RegExp, CL = AL.prototype, SW = _W && bW(function() {
  var i = !0;
  try {
    AL(".", "d");
  } catch {
    i = !1;
  }
  var t = {}, e = "", n = i ? "dgimsy" : "gimsy", r = function(o, l) {
    Object.defineProperty(t, o, { get: function() {
      return e += l, !0;
    } });
  }, s = { dotAll: "s", global: "g", ignoreCase: "i", multiline: "m", sticky: "y" };
  for (var a in i && (s.hasIndices = "d"), s)
    r(a, s[a]);
  return Object.getOwnPropertyDescriptor(CL, "flags").get.call(t) !== n || e !== n;
});
SW && wW(CL, "flags", { configurable: !0, get: xW });
var IA = Ne, OA = pi, MW = kv, LA = je, PL = ln, TW = os, EW = PL("species"), c1 = RegExp.prototype, LS = Ae, AW = Os, CW = fi, PW = Xa, DW = LS("".charAt), BA = LS("".charCodeAt), RW = LS("".slice), zA = function(i) {
  return function(t, e) {
    var n, r, s = CW(PW(t)), a = AW(e), o = s.length;
    return a < 0 || a >= o ? i ? "" : void 0 : (n = BA(s, a)) < 55296 || n > 56319 || a + 1 === o || (r = BA(s, a + 1)) < 56320 || r > 57343 ? i ? DW(s, a) : n : i ? RW(s, a, a + 2) : r - 56320 + (n - 55296 << 10) + 65536;
  };
}, pu = { codeAt: zA(!1), charAt: zA(!0) }, IW = pu.charAt, DL = function(i, t, e) {
  return t + (e ? IW(i, t).length : 1);
}, BS = Ae, OW = Br, LW = Math.floor, h1 = BS("".charAt), BW = BS("".replace), u1 = BS("".slice), zW = /\$([$&'`]|\d{1,2}|<[^>]*>)/g, kW = /\$([$&'`]|\d{1,2})/g, RL = function(i, t, e, n, r, s) {
  var a = e + i.length, o = n.length, l = kW;
  return r !== void 0 && (r = OW(r), l = zW), BW(s, l, function(c, u) {
    var h;
    switch (h1(u, 0)) {
      case "$":
        return "$";
      case "&":
        return i;
      case "`":
        return u1(t, 0, e);
      case "'":
        return u1(t, a);
      case "<":
        h = r[u1(u, 1, -1)];
        break;
      default:
        var p = +u;
        if (p === 0)
          return c;
        if (p > o) {
          var f = LW(p / 10);
          return f === 0 ? c : f <= o ? n[f - 1] === void 0 ? h1(u, 1) : n[f - 1] + h1(u, 1) : c;
        }
        h = n[p - 1];
    }
    return h === void 0 ? "" : h;
  });
}, kA = Ne, NW = $e, FW = Ke, UW = qa, VW = kv, HW = TypeError, IL = function(i, t) {
  var e = i.exec;
  if (FW(e)) {
    var n = kA(e, i, t);
    return n !== null && NW(n), n;
  }
  if (UW(i) === "RegExp")
    return kA(VW, i, t);
  throw new HW("RegExp#exec called on incompatible receiver");
}, jW = Ip, NA = Ne, x0 = Ae, GW = function(i, t, e, n) {
  var r = PL(i), s = !LA(function() {
    var c = {};
    return c[r] = function() {
      return 7;
    }, ""[i](c) !== 7;
  }), a = s && !LA(function() {
    var c = !1, u = /a/;
    return i === "split" && ((u = {}).constructor = {}, u.constructor[EW] = function() {
      return u;
    }, u.flags = "", u[r] = /./[r]), u.exec = function() {
      return c = !0, null;
    }, u[r](""), !c;
  });
  if (!s || !a || e) {
    var o = /./[r], l = t(r, ""[i], function(c, u, h, p, f) {
      var v = u.exec;
      return v === MW || v === c1.exec ? s && !f ? { done: !0, value: IA(o, u, h, p) } : { done: !0, value: IA(c, h, u, p) } : { done: !1 };
    });
    OA(String.prototype, i, l[0]), OA(c1, r, l[1]);
  }
  n && TW(c1[r], "sham", !0);
}, WW = je, ZW = $e, qW = Ke, XW = Hi, YW = Os, JW = lu, qc = fi, KW = Xa, $W = DL, QW = Go, t9 = RL, e9 = IL, Lx = ln("replace"), n9 = Math.max, r9 = Math.min, i9 = x0([].concat), d1 = x0([].push), FA = x0("".indexOf), UA = x0("".slice), s9 = "a".replace(/./, "$0") === "$0", VA = !!/./[Lx] && /./[Lx]("a", "$0") === "";
GW("replace", function(i, t, e) {
  var n = VA ? "$" : "$0";
  return [function(r, s) {
    var a = KW(this), o = XW(r) ? void 0 : QW(r, Lx);
    return o ? NA(o, r, a, s) : NA(t, qc(a), r, s);
  }, function(r, s) {
    var a = ZW(this), o = qc(r);
    if (typeof s == "string" && FA(s, n) === -1 && FA(s, "$<") === -1) {
      var l = e(t, a, o, s);
      if (l.done)
        return l.value;
    }
    var c = qW(s);
    c || (s = qc(s));
    var u, h = a.global;
    h && (u = a.unicode, a.lastIndex = 0);
    for (var p, f = []; (p = e9(a, o)) !== null && (d1(f, p), h); )
      qc(p[0]) === "" && (a.lastIndex = $W(o, JW(a.lastIndex), u));
    for (var v, m = "", y = 0, _ = 0; _ < f.length; _++) {
      for (var w, b = qc((p = f[_])[0]), T = n9(r9(YW(p.index), o.length), 0), M = [], A = 1; A < p.length; A++)
        d1(M, (v = p[A]) === void 0 ? v : String(v));
      var C = p.groups;
      if (c) {
        var I = i9([b], M, T, o);
        C !== void 0 && d1(I, C), w = qc(jW(s, void 0, I));
      } else
        w = t9(b, o, T, M, C, s);
      T >= y && (m += UA(o, y, T) + w, y = T + b.length);
    }
    return m + UA(o, y);
  }];
}, !!WW(function() {
  var i = /./;
  return i.exec = function() {
    var t = [];
    return t.groups = { a: "7" }, t;
  }, "".replace(i, "$<a>") !== "7";
}) || !s9 || VA);
var Si, Lh, Nv, Bx = { exports: {} }, OL = typeof ArrayBuffer < "u" && typeof DataView < "u", a9 = !je(function() {
  function i() {
  }
  return i.prototype.constructor = null, Object.getPrototypeOf(new i()) !== i.prototype;
}), o9 = sr, l9 = Ke, c9 = Br, h9 = a9, HA = pS("IE_PROTO"), zx = Object, u9 = zx.prototype, qo = h9 ? zx.getPrototypeOf : function(i) {
  var t = c9(i);
  if (o9(t, HA))
    return t[HA];
  var e = t.constructor;
  return l9(e) && t instanceof e ? e.prototype : t instanceof zx ? u9 : null;
}, d9 = OL, kx = Mn, ui = Oe, LL = Ke, b0 = Rn, Oo = sr, zS = Wo, p9 = au, f9 = os, p1 = pi, m9 = ls, g9 = Ya, S0 = qo, Wh = Ql, v9 = ln, y9 = u0, BL = Fn.enforce, _9 = Fn.get, Fv = ui.Int8Array, Nx = Fv && Fv.prototype, jA = ui.Uint8ClampedArray, GA = jA && jA.prototype, Qs = Fv && S0(Fv), Ps = Nx && S0(Nx), w9 = Object.prototype, Fx = ui.TypeError, WA = v9("toStringTag"), Ux = y9("TYPED_ARRAY_TAG"), Uv = "TypedArrayConstructor", Ha = d9 && !!Wh && zS(ui.opera) !== "Opera", zL = !1, Fa = { Int8Array: 1, Uint8Array: 1, Uint8ClampedArray: 1, Int16Array: 2, Uint16Array: 2, Int32Array: 4, Uint32Array: 4, Float32Array: 4, Float64Array: 8 }, kS = { BigInt64Array: 8, BigUint64Array: 8 }, kL = function(i) {
  var t = S0(i);
  if (b0(t)) {
    var e = _9(t);
    return e && Oo(e, Uv) ? e[Uv] : kL(t);
  }
}, ZA = function(i) {
  if (!b0(i))
    return !1;
  var t = zS(i);
  return Oo(Fa, t) || Oo(kS, t);
};
for (Si in Fa)
  (Nv = (Lh = ui[Si]) && Lh.prototype) ? BL(Nv)[Uv] = Lh : Ha = !1;
for (Si in kS)
  (Nv = (Lh = ui[Si]) && Lh.prototype) && (BL(Nv)[Uv] = Lh);
if ((!Ha || !LL(Qs) || Qs === Function.prototype) && (Qs = function() {
  throw new Fx("Incorrect invocation");
}, Ha))
  for (Si in Fa)
    ui[Si] && Wh(ui[Si], Qs);
if ((!Ha || !Ps || Ps === w9) && (Ps = Qs.prototype, Ha))
  for (Si in Fa)
    ui[Si] && Wh(ui[Si].prototype, Ps);
if (Ha && S0(GA) !== Ps && Wh(GA, Ps), kx && !Oo(Ps, WA))
  for (Si in zL = !0, m9(Ps, WA, { configurable: !0, get: function() {
    return b0(this) ? this[Ux] : void 0;
  } }), Fa)
    ui[Si] && f9(ui[Si], Ux, Si);
var $a = { NATIVE_ARRAY_BUFFER_VIEWS: Ha, TYPED_ARRAY_TAG: zL && Ux, aTypedArray: function(i) {
  if (ZA(i))
    return i;
  throw new Fx("Target is not a typed array");
}, aTypedArrayConstructor: function(i) {
  if (LL(i) && (!Wh || g9(Qs, i)))
    return i;
  throw new Fx(p9(i) + " is not a typed array constructor");
}, exportTypedArrayMethod: function(i, t, e, n) {
  if (kx) {
    if (e)
      for (var r in Fa) {
        var s = ui[r];
        if (s && Oo(s.prototype, i))
          try {
            delete s.prototype[i];
          } catch {
            try {
              s.prototype[i] = t;
            } catch {
            }
          }
      }
    Ps[i] && !e || p1(Ps, i, e ? t : Ha && Nx[i] || t, n);
  }
}, exportTypedArrayStaticMethod: function(i, t, e) {
  var n, r;
  if (kx) {
    if (Wh) {
      if (e) {
        for (n in Fa)
          if ((r = ui[n]) && Oo(r, i))
            try {
              delete r[i];
            } catch {
            }
      }
      if (Qs[i] && !e)
        return;
      try {
        return p1(Qs, i, e ? t : Ha && Qs[i] || t);
      } catch {
      }
    }
    for (n in Fa)
      !(r = ui[n]) || r[i] && !e || p1(r, i, t);
  }
}, getTypedArrayConstructor: kL, isView: function(i) {
  if (!b0(i))
    return !1;
  var t = zS(i);
  return t === "DataView" || Oo(Fa, t) || Oo(kS, t);
}, isTypedArray: ZA, TypedArray: Qs, TypedArrayPrototype: Ps }, NL = Oe, f1 = je, x9 = AS, b9 = $a.NATIVE_ARRAY_BUFFER_VIEWS, S9 = NL.ArrayBuffer, fl = NL.Int8Array, NS = !b9 || !f1(function() {
  fl(1);
}) || !f1(function() {
  new fl(-1);
}) || !x9(function(i) {
  new fl(), new fl(null), new fl(1.5), new fl(i);
}, !0) || f1(function() {
  return new fl(new S9(2), 1, void 0).length !== 1;
}), M9 = pi, fu = function(i, t, e) {
  for (var n in t)
    M9(i, n, t[n], e);
  return i;
}, T9 = Os, E9 = lu, A9 = RangeError, FL = function(i) {
  if (i === void 0)
    return 0;
  var t = T9(i), e = E9(t);
  if (t !== e)
    throw new A9("Wrong length or index");
  return e;
}, C9 = Math.sign || function(i) {
  var t = +i;
  return t === 0 || t != t ? t : t < 0 ? -1 : 1;
}, P9 = C9, D9 = Math.abs, UL = 2220446049250313e-31, qA = 1 / UL, R9 = function(i, t, e, n) {
  var r = +i, s = D9(r), a = P9(r);
  if (s < n)
    return a * function(c) {
      return c + qA - qA;
    }(s / n / t) * n * t;
  var o = (1 + t / UL) * s, l = o - (o - s);
  return l > e || l != l ? a * (1 / 0) : a * l;
}, VL = Math.fround || function(i) {
  return R9(i, 11920928955078125e-23, 34028234663852886e22, 11754943508222875e-54);
}, I9 = Array, O9 = Math.abs, ba = Math.pow, L9 = Math.floor, B9 = Math.log, z9 = Math.LN2, k9 = { pack: function(i, t, e) {
  var n, r, s, a = I9(e), o = 8 * e - t - 1, l = (1 << o) - 1, c = l >> 1, u = t === 23 ? ba(2, -24) - ba(2, -77) : 0, h = i < 0 || i === 0 && 1 / i < 0 ? 1 : 0, p = 0;
  for ((i = O9(i)) != i || i === 1 / 0 ? (r = i != i ? 1 : 0, n = l) : (n = L9(B9(i) / z9), i * (s = ba(2, -n)) < 1 && (n--, s *= 2), (i += n + c >= 1 ? u / s : u * ba(2, 1 - c)) * s >= 2 && (n++, s /= 2), n + c >= l ? (r = 0, n = l) : n + c >= 1 ? (r = (i * s - 1) * ba(2, t), n += c) : (r = i * ba(2, c - 1) * ba(2, t), n = 0)); t >= 8; )
    a[p++] = 255 & r, r /= 256, t -= 8;
  for (n = n << t | r, o += t; o > 0; )
    a[p++] = 255 & n, n /= 256, o -= 8;
  return a[--p] |= 128 * h, a;
}, unpack: function(i, t) {
  var e, n = i.length, r = 8 * n - t - 1, s = (1 << r) - 1, a = s >> 1, o = r - 7, l = n - 1, c = i[l--], u = 127 & c;
  for (c >>= 7; o > 0; )
    u = 256 * u + i[l--], o -= 8;
  for (e = u & (1 << -o) - 1, u >>= -o, o += t; o > 0; )
    e = 256 * e + i[l--], o -= 8;
  if (u === 0)
    u = 1 - a;
  else {
    if (u === s)
      return e ? NaN : c ? -1 / 0 : 1 / 0;
    e += ba(2, t), u -= a;
  }
  return (c ? -1 : 1) * e * ba(2, u - t);
} }, N9 = Br, XA = EO, F9 = Qr, M0 = Oe, FS = Ae, m1 = Mn, U9 = OL, V9 = os, H9 = ls, YA = fu, g1 = je, Um = Ja, j9 = Os, G9 = lu, Vv = FL, W9 = VL, HL = k9, Z9 = qo, JA = Ql, q9 = function(i) {
  for (var t = N9(this), e = F9(t), n = arguments.length, r = XA(n > 1 ? arguments[1] : void 0, e), s = n > 2 ? arguments[2] : void 0, a = s === void 0 ? e : XA(s, e); a > r; )
    t[r++] = i;
  return t;
}, X9 = hu, Y9 = _0, J9 = f0, KA = Zo, US = Fn, K9 = Ep.PROPER, $A = Ep.CONFIGURABLE, Bh = "ArrayBuffer", T0 = "DataView", zh = "prototype", jL = "Wrong index", QA = US.getterFor(Bh), kd = US.getterFor(T0), tC = US.set, xs = M0[Bh], Es = xs, Xc = Es && Es[zh], Ba = M0[T0], ml = Ba && Ba[zh], eC = Object.prototype, $9 = M0.Array, Hv = M0.RangeError, Q9 = FS(q9), tZ = FS([].reverse), GL = HL.pack, nC = HL.unpack, rC = function(i) {
  return [255 & i];
}, iC = function(i) {
  return [255 & i, i >> 8 & 255];
}, sC = function(i) {
  return [255 & i, i >> 8 & 255, i >> 16 & 255, i >> 24 & 255];
}, aC = function(i) {
  return i[3] << 24 | i[2] << 16 | i[1] << 8 | i[0];
}, eZ = function(i) {
  return GL(W9(i), 23, 4);
}, nZ = function(i) {
  return GL(i, 52, 8);
}, Vm = function(i, t, e) {
  H9(i[zh], t, { configurable: !0, get: function() {
    return e(this)[t];
  } });
}, vo = function(i, t, e, n) {
  var r = kd(i), s = Vv(e), a = !!n;
  if (s + t > r.byteLength)
    throw new Hv(jL);
  var o = r.bytes, l = s + r.byteOffset, c = X9(o, l, l + t);
  return a ? c : tZ(c);
}, yo = function(i, t, e, n, r, s) {
  var a = kd(i), o = Vv(e), l = n(+r), c = !!s;
  if (o + t > a.byteLength)
    throw new Hv(jL);
  for (var u = a.bytes, h = o + a.byteOffset, p = 0; p < t; p++)
    u[h + p] = l[c ? p : t - p - 1];
};
if (U9) {
  var oC = K9 && xs.name !== Bh;
  g1(function() {
    xs(1);
  }) && g1(function() {
    new xs(-1);
  }) && !g1(function() {
    return new xs(), new xs(1.5), new xs(NaN), xs.length !== 1 || oC && !$A;
  }) ? oC && $A && V9(xs, "name", Bh) : ((Es = function(i) {
    return Um(this, Xc), Y9(new xs(Vv(i)), this, Es);
  })[zh] = Xc, Xc.constructor = Es, J9(Es, xs)), JA && Z9(ml) !== eC && JA(ml, eC);
  var Hm = new Ba(new Es(2)), lC = FS(ml.setInt8);
  Hm.setInt8(0, 2147483648), Hm.setInt8(1, 2147483649), !Hm.getInt8(0) && Hm.getInt8(1) || YA(ml, { setInt8: function(i, t) {
    lC(this, i, t << 24 >> 24);
  }, setUint8: function(i, t) {
    lC(this, i, t << 24 >> 24);
  } }, { unsafe: !0 });
} else
  Xc = (Es = function(i) {
    Um(this, Xc);
    var t = Vv(i);
    tC(this, { type: Bh, bytes: Q9($9(t), 0), byteLength: t }), m1 || (this.byteLength = t, this.detached = !1);
  })[zh], ml = (Ba = function(i, t, e) {
    Um(this, ml), Um(i, Xc);
    var n = QA(i), r = n.byteLength, s = j9(t);
    if (s < 0 || s > r)
      throw new Hv("Wrong offset");
    if (s + (e = e === void 0 ? r - s : G9(e)) > r)
      throw new Hv("Wrong length");
    tC(this, { type: T0, buffer: i, byteLength: e, byteOffset: s, bytes: n.bytes }), m1 || (this.buffer = i, this.byteLength = e, this.byteOffset = s);
  })[zh], m1 && (Vm(Es, "byteLength", QA), Vm(Ba, "buffer", kd), Vm(Ba, "byteLength", kd), Vm(Ba, "byteOffset", kd)), YA(ml, { getInt8: function(i) {
    return vo(this, 1, i)[0] << 24 >> 24;
  }, getUint8: function(i) {
    return vo(this, 1, i)[0];
  }, getInt16: function(i) {
    var t = vo(this, 2, i, arguments.length > 1 && arguments[1]);
    return (t[1] << 8 | t[0]) << 16 >> 16;
  }, getUint16: function(i) {
    var t = vo(this, 2, i, arguments.length > 1 && arguments[1]);
    return t[1] << 8 | t[0];
  }, getInt32: function(i) {
    return aC(vo(this, 4, i, arguments.length > 1 && arguments[1]));
  }, getUint32: function(i) {
    return aC(vo(this, 4, i, arguments.length > 1 && arguments[1])) >>> 0;
  }, getFloat32: function(i) {
    return nC(vo(this, 4, i, arguments.length > 1 && arguments[1]), 23);
  }, getFloat64: function(i) {
    return nC(vo(this, 8, i, arguments.length > 1 && arguments[1]), 52);
  }, setInt8: function(i, t) {
    yo(this, 1, i, rC, t);
  }, setUint8: function(i, t) {
    yo(this, 1, i, rC, t);
  }, setInt16: function(i, t) {
    yo(this, 2, i, iC, t, arguments.length > 2 && arguments[2]);
  }, setUint16: function(i, t) {
    yo(this, 2, i, iC, t, arguments.length > 2 && arguments[2]);
  }, setInt32: function(i, t) {
    yo(this, 4, i, sC, t, arguments.length > 2 && arguments[2]);
  }, setUint32: function(i, t) {
    yo(this, 4, i, sC, t, arguments.length > 2 && arguments[2]);
  }, setFloat32: function(i, t) {
    yo(this, 4, i, eZ, t, arguments.length > 2 && arguments[2]);
  }, setFloat64: function(i, t) {
    yo(this, 8, i, nZ, t, arguments.length > 2 && arguments[2]);
  } });
KA(Es, Bh), KA(Ba, T0);
var rZ = { ArrayBuffer: Es, DataView: Ba }, iZ = Rn, sZ = Math.floor, aZ = Number.isInteger || function(i) {
  return !iZ(i) && isFinite(i) && sZ(i) === i;
}, oZ = Os, lZ = RangeError, cZ = function(i) {
  var t = oZ(i);
  if (t < 0)
    throw new lZ("The argument can't be less than 0");
  return t;
}, hZ = RangeError, WL = function(i, t) {
  var e = cZ(i);
  if (e % t)
    throw new hZ("Wrong offset");
  return e;
}, uZ = Math.round, dZ = Wo, pZ = yO, fZ = TypeError, mZ = Zn, gZ = Ne, vZ = YO, yZ = Br, _Z = Qr, wZ = Dp, xZ = Pp, bZ = bS, SZ = function(i) {
  var t = dZ(i);
  return t === "BigInt64Array" || t === "BigUint64Array";
}, MZ = $a.aTypedArrayConstructor, TZ = function(i) {
  var t = pZ(i, "number");
  if (typeof t == "number")
    throw new fZ("Can't convert number to bigint");
  return BigInt(t);
}, ZL = function(i) {
  var t, e, n, r, s, a, o, l, c = vZ(this), u = yZ(i), h = arguments.length, p = h > 1 ? arguments[1] : void 0, f = p !== void 0, v = xZ(u);
  if (v && !bZ(v))
    for (l = (o = wZ(u, v)).next, u = []; !(a = gZ(l, o)).done; )
      u.push(a.value);
  for (f && h > 2 && (p = mZ(p, arguments[2])), e = _Z(u), n = new (MZ(c))(e), r = SZ(n), t = 0; e > t; t++)
    s = f ? p(u[t], t) : u[t], n[t] = r ? TZ(s) : +s;
  return n;
}, EZ = Zn, AZ = c0, CZ = Br, PZ = Qr, DZ = yS, cC = Ae([].push), _o = function(i) {
  var t = i === 1, e = i === 2, n = i === 3, r = i === 4, s = i === 6, a = i === 7, o = i === 5 || s;
  return function(l, c, u, h) {
    for (var p, f, v = CZ(l), m = AZ(v), y = PZ(m), _ = EZ(c, u), w = 0, b = h || DZ, T = t ? b(l, y) : e || a ? b(l, 0) : void 0; y > w; w++)
      if ((o || w in m) && (f = _(p = m[w], w, v), i))
        if (t)
          T[w] = f;
        else if (f)
          switch (i) {
            case 3:
              return !0;
            case 5:
              return p;
            case 6:
              return w;
            case 2:
              cC(T, p);
          }
        else
          switch (i) {
            case 4:
              return !1;
            case 7:
              cC(T, p);
          }
    return s ? -1 : n || r ? r : T;
  };
}, VS = { forEach: _o(0), map: _o(1), filter: _o(2), some: _o(3), every: _o(4), find: _o(5), findIndex: _o(6), filterReject: _o(7) }, RZ = Qr, hC = zt, qL = Oe, uC = Ne, IZ = Mn, OZ = NS, zp = $a, XL = rZ, dC = Ja, LZ = Ho, Ju = os, BZ = aZ, zZ = lu, pC = FL, v1 = WL, kZ = function(i) {
  var t = uZ(i);
  return t < 0 ? 0 : t > 255 ? 255 : 255 & t;
}, YL = uS, Ku = sr, NZ = Wo, Vx = Rn, FZ = lS, UZ = sa, VZ = Ya, jm = Ql, HZ = ou.f, fC = ZL, jZ = VS.forEach, GZ = Rp, WZ = ls, JL = di, KL = Tp, mC = function(i, t, e) {
  for (var n = 0, r = arguments.length > 2 ? e : RZ(t), s = new i(r); r > n; )
    s[n] = t[n++];
  return s;
}, ZZ = _0, Hx = Fn.get, qZ = Fn.set, XZ = Fn.enforce, $L = JL.f, YZ = KL.f, y1 = qL.RangeError, QL = XL.ArrayBuffer, JZ = QL.prototype, KZ = XL.DataView, Gm = zp.NATIVE_ARRAY_BUFFER_VIEWS, gC = zp.TYPED_ARRAY_TAG, vC = zp.TypedArray, $u = zp.TypedArrayPrototype, jx = zp.isTypedArray, Wm = "BYTES_PER_ELEMENT", _1 = "Wrong length", Zm = function(i, t) {
  WZ(i, t, { configurable: !0, get: function() {
    return Hx(this)[t];
  } });
}, yC = function(i) {
  var t;
  return VZ(JZ, i) || (t = NZ(i)) === "ArrayBuffer" || t === "SharedArrayBuffer";
}, t5 = function(i, t) {
  return jx(i) && !FZ(t) && t in i && BZ(+t) && t >= 0;
}, _C = function(i, t) {
  return t = YL(t), t5(i, t) ? LZ(2, i[t]) : YZ(i, t);
}, wC = function(i, t, e) {
  return t = YL(t), !(t5(i, t) && Vx(e) && Ku(e, "value")) || Ku(e, "get") || Ku(e, "set") || e.configurable || Ku(e, "writable") && !e.writable || Ku(e, "enumerable") && !e.enumerable ? $L(i, t, e) : (i[t] = e.value, i);
};
IZ ? (Gm || (KL.f = _C, JL.f = wC, Zm($u, "buffer"), Zm($u, "byteOffset"), Zm($u, "byteLength"), Zm($u, "length")), hC({ target: "Object", stat: !0, forced: !Gm }, { getOwnPropertyDescriptor: _C, defineProperty: wC }), Bx.exports = function(i, t, e) {
  var n = i.match(/\d+/)[0] / 8, r = i + (e ? "Clamped" : "") + "Array", s = "get" + i, a = "set" + i, o = qL[r], l = o, c = l && l.prototype, u = {}, h = function(f, v) {
    $L(f, v, { get: function() {
      return function(m, y) {
        var _ = Hx(m);
        return _.view[s](y * n + _.byteOffset, !0);
      }(this, v);
    }, set: function(m) {
      return function(y, _, w) {
        var b = Hx(y);
        b.view[a](_ * n + b.byteOffset, e ? kZ(w) : w, !0);
      }(this, v, m);
    }, enumerable: !0 });
  };
  Gm ? OZ && (l = t(function(f, v, m, y) {
    return dC(f, c), ZZ(Vx(v) ? yC(v) ? y !== void 0 ? new o(v, v1(m, n), y) : m !== void 0 ? new o(v, v1(m, n)) : new o(v) : jx(v) ? mC(l, v) : uC(fC, l, v) : new o(pC(v)), f, l);
  }), jm && jm(l, vC), jZ(HZ(o), function(f) {
    f in l || Ju(l, f, o[f]);
  }), l.prototype = c) : (l = t(function(f, v, m, y) {
    dC(f, c);
    var _, w, b, T = 0, M = 0;
    if (Vx(v)) {
      if (!yC(v))
        return jx(v) ? mC(l, v) : uC(fC, l, v);
      _ = v, M = v1(m, n);
      var A = v.byteLength;
      if (y === void 0) {
        if (A % n)
          throw new y1(_1);
        if ((w = A - M) < 0)
          throw new y1(_1);
      } else if ((w = zZ(y) * n) + M > A)
        throw new y1(_1);
      b = w / n;
    } else
      b = pC(v), _ = new QL(w = b * n);
    for (qZ(f, { buffer: _, byteOffset: M, byteLength: w, length: b, view: new KZ(_) }); T < b; )
      h(f, T++);
  }), jm && jm(l, vC), c = l.prototype = UZ($u)), c.constructor !== l && Ju(c, "constructor", l), XZ(c).TypedArrayConstructor = l, gC && Ju(c, gC, r);
  var p = l !== o;
  u[r] = l, hC({ global: !0, constructor: !0, forced: p, sham: !Gm }, u), Wm in l || Ju(l, Wm, n), Wm in c || Ju(c, Wm, n), GZ(r);
}) : Bx.exports = function() {
};
var Sa = Bx.exports;
Sa("Float32", function(i) {
  return function(t, e, n) {
    return i(this, t, e, n);
  };
}), Sa("Float64", function(i) {
  return function(t, e, n) {
    return i(this, t, e, n);
  };
}), Sa("Int8", function(i) {
  return function(t, e, n) {
    return i(this, t, e, n);
  };
}), Sa("Int16", function(i) {
  return function(t, e, n) {
    return i(this, t, e, n);
  };
}), Sa("Int32", function(i) {
  return function(t, e, n) {
    return i(this, t, e, n);
  };
}), Sa("Uint8", function(i) {
  return function(t, e, n) {
    return i(this, t, e, n);
  };
}), Sa("Uint8", function(i) {
  return function(t, e, n) {
    return i(this, t, e, n);
  };
}, !0), Sa("Uint16", function(i) {
  return function(t, e, n) {
    return i(this, t, e, n);
  };
}), Sa("Uint32", function(i) {
  return function(t, e, n) {
    return i(this, t, e, n);
  };
}), (0, $a.exportTypedArrayStaticMethod)("from", ZL, NS);
var $Z = $a.aTypedArrayConstructor;
(0, $a.exportTypedArrayStaticMethod)("of", function() {
  for (var i = 0, t = arguments.length, e = new ($Z(this))(t); t > i; )
    e[i] = arguments[i++];
  return e;
}, NS);
var e5 = Oe, n5 = Ne, HS = $a, QZ = Qr, tq = WL, eq = Br, r5 = je, nq = e5.RangeError, Gx = e5.Int8Array, xC = Gx && Gx.prototype, i5 = xC && xC.set, rq = HS.aTypedArray, iq = HS.exportTypedArrayMethod, Wx = !r5(function() {
  var i = new Uint8ClampedArray(2);
  return n5(i5, i, { length: 1, 0: 3 }, 1), i[1] !== 3;
}), sq = Wx && HS.NATIVE_ARRAY_BUFFER_VIEWS && r5(function() {
  var i = new Gx(2);
  return i.set(1), i.set("2", 1), i[0] !== 0 || i[1] !== 2;
});
iq("set", function(i) {
  rq(this);
  var t = tq(arguments.length > 1 ? arguments[1] : void 0, 1), e = eq(i);
  if (Wx)
    return n5(i5, this, e, t);
  var n = this.length, r = QZ(e), s = 0;
  if (r + t > n)
    throw new nq("Wrong length");
  for (; s < r; )
    this[t + s] = e[s++];
}, !Wx || sq);
var aq = Rv, Zx = je, oq = Wn, lq = wS, bC = jO, cq = GO, SC = No, MC = WO, hq = $a.aTypedArray, uq = $a.exportTypedArrayMethod, fp = Oe.Uint16Array, kh = fp && aq(fp.prototype.sort), dq = !(!kh || Zx(function() {
  kh(new fp(2), null);
}) && Zx(function() {
  kh(new fp(2), {});
})), TC = !!kh && !Zx(function() {
  if (SC)
    return SC < 74;
  if (bC)
    return bC < 67;
  if (cq)
    return !0;
  if (MC)
    return MC < 602;
  var i, t, e = new fp(516), n = Array(516);
  for (i = 0; i < 516; i++)
    t = i % 4, e[i] = 515 - i, n[i] = i - 2 * t + 3;
  for (kh(e, function(r, s) {
    return (r / 4 | 0) - (s / 4 | 0);
  }), i = 0; i < 516; i++)
    if (e[i] !== n[i])
      return !0;
});
uq("sort", function(i) {
  return i !== void 0 && oq(i), TC ? kh(this, i) : lq(hq(this), function(t) {
    return function(e, n) {
      return t !== void 0 ? +t(e, n) || 0 : n != n ? -1 : e != e ? 1 : e === 0 && n === 0 ? 1 / e > 0 && 1 / n < 0 ? 1 : -1 : e > n;
    };
  }(i));
}, !TC || dq);
var pq = Rn, fq = os, s5 = Error, mq = Ae("".replace), gq = String(new s5("zxcasd").stack), a5 = /\n\s*at [^:]*:[^\n]*/, vq = a5.test(gq), yq = Ho, _q = !je(function() {
  var i = new Error("a");
  return !("stack" in i) || (Object.defineProperty(i, "stack", yq(1, 7)), i.stack !== 7);
}), wq = os, xq = function(i, t) {
  if (vq && typeof i == "string" && !s5.prepareStackTrace)
    for (; t--; )
      i = mq(i, a5, "");
  return i;
}, bq = _q, EC = Error.captureStackTrace, Sq = fi, Mq = zt, Tq = Ya, Eq = qo, jv = Ql, Aq = f0, o5 = sa, w1 = os, x1 = Ho, Cq = function(i, t) {
  pq(t) && "cause" in t && fq(i, "cause", t.cause);
}, Pq = function(i, t, e, n) {
  bq && (EC ? EC(i, t) : wq(i, "stack", xq(e, n)));
}, Dq = Ti, Rq = function(i, t) {
  return i === void 0 ? arguments.length < 2 ? "" : t : Sq(i);
}, Iq = ln("toStringTag"), Gv = Error, Oq = [].push, Zh = function(i, t) {
  var e, n = Tq(b1, this);
  jv ? e = jv(new Gv(), n ? Eq(this) : b1) : (e = n ? this : o5(b1), w1(e, Iq, "Error")), t !== void 0 && w1(e, "message", Rq(t)), Pq(e, Zh, e.stack, 1), arguments.length > 2 && Cq(e, arguments[2]);
  var r = [];
  return Dq(i, Oq, { that: r }), w1(e, "errors", r), e;
};
jv ? jv(Zh, Gv) : Aq(Zh, Gv, { name: !0 });
var b1 = Zh.prototype = o5(Gv.prototype, { constructor: x1(1, Zh), message: x1(1, ""), name: x1(1, "AggregateError") });
Mq({ global: !0, constructor: !0, arity: 2 }, { AggregateError: Zh });
var Lq = Hh, Bq = Br, zq = Qr;
Mn && (ls(Array.prototype, "lastIndex", { configurable: !0, get: function() {
  var i = Bq(this), t = zq(i);
  return t === 0 ? 0 : t - 1;
} }), Lq("lastIndex"));
var kq = Hh, AC = Br, CC = Qr;
Mn && (ls(Array.prototype, "lastItem", { configurable: !0, get: function() {
  var i = AC(this), t = CC(i);
  return t === 0 ? void 0 : i[t - 1];
}, set: function(i) {
  var t = AC(this), e = CC(t);
  return t[e === 0 ? 0 : e - 1] = i;
} }), kq("lastItem"));
var l5 = { exports: {} }, c5 = {}, Nq = qa, Fq = su, PC = ou.f, Uq = hu, DC = typeof window == "object" && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
c5.f = function(i) {
  return DC && Nq(i) === "Window" ? function(t) {
    try {
      return PC(t);
    } catch {
      return Uq(DC);
    }
  }(i) : PC(Fq(i));
};
var Vq = je(function() {
  if (typeof ArrayBuffer == "function") {
    var i = new ArrayBuffer(8);
    Object.isExtensible(i) && Object.defineProperty(i, "a", { value: 8 });
  }
}), Hq = je, jq = Rn, Gq = qa, RC = Vq, qm = Object.isExtensible, Wq = Hq(function() {
  qm(1);
}) || RC ? function(i) {
  return !!jq(i) && (!RC || Gq(i) !== "ArrayBuffer") && (!qm || qm(i));
} : qm, h5 = !je(function() {
  return Object.isExtensible(Object.preventExtensions({}));
}), Zq = zt, qq = Ae, Xq = p0, Yq = Rn, S1 = sr, Jq = di.f, IC = ou, Kq = c5, M1 = Wq, $q = h5, OC = !1, Ia = u0("meta"), Qq = 0, T1 = function(i) {
  Jq(i, Ia, { value: { objectID: "O" + Qq++, weakData: {} } });
}, tX = l5.exports = { enable: function() {
  tX.enable = function() {
  }, OC = !0;
  var i = IC.f, t = qq([].splice), e = {};
  e[Ia] = 1, i(e).length && (IC.f = function(n) {
    for (var r = i(n), s = 0, a = r.length; s < a; s++)
      if (r[s] === Ia) {
        t(r, s, 1);
        break;
      }
    return r;
  }, Zq({ target: "Object", stat: !0, forced: !0 }, { getOwnPropertyNames: Kq.f }));
}, fastKey: function(i, t) {
  if (!Yq(i))
    return typeof i == "symbol" ? i : (typeof i == "string" ? "S" : "P") + i;
  if (!S1(i, Ia)) {
    if (!M1(i))
      return "F";
    if (!t)
      return "E";
    T1(i);
  }
  return i[Ia].objectID;
}, getWeakData: function(i, t) {
  if (!S1(i, Ia)) {
    if (!M1(i))
      return !0;
    if (!t)
      return !1;
    T1(i);
  }
  return i[Ia].weakData;
}, onFreeze: function(i) {
  return $q && OC && M1(i) && !S1(i, Ia) && T1(i), i;
} };
Xq[Ia] = !0;
var Xl, LC, BC, E0 = l5.exports, eX = zt, nX = Oe, rX = Ae, zC = m0, iX = pi, sX = E0, aX = Ti, oX = Ja, lX = Ke, cX = Hi, E1 = Rn, A1 = je, hX = AS, uX = Zo, dX = _0, u5 = function(i, t, e) {
  var n = i.indexOf("Map") !== -1, r = i.indexOf("Weak") !== -1, s = n ? "set" : "add", a = nX[i], o = a && a.prototype, l = a, c = {}, u = function(y) {
    var _ = rX(o[y]);
    iX(o, y, y === "add" ? function(w) {
      return _(this, w === 0 ? 0 : w), this;
    } : y === "delete" ? function(w) {
      return !(r && !E1(w)) && _(this, w === 0 ? 0 : w);
    } : y === "get" ? function(w) {
      return r && !E1(w) ? void 0 : _(this, w === 0 ? 0 : w);
    } : y === "has" ? function(w) {
      return !(r && !E1(w)) && _(this, w === 0 ? 0 : w);
    } : function(w, b) {
      return _(this, w === 0 ? 0 : w, b), this;
    });
  };
  if (zC(i, !lX(a) || !(r || o.forEach && !A1(function() {
    new a().entries().next();
  }))))
    l = e.getConstructor(t, i, n, s), sX.enable();
  else if (zC(i, !0)) {
    var h = new l(), p = h[s](r ? {} : -0, 1) !== h, f = A1(function() {
      h.has(1);
    }), v = hX(function(y) {
      new a(y);
    }), m = !r && A1(function() {
      for (var y = new a(), _ = 5; _--; )
        y[s](_, _);
      return !y.has(-0);
    });
    v || ((l = t(function(y, _) {
      oX(y, o);
      var w = dX(new a(), y, l);
      return cX(_) || aX(_, w[s], { that: w, AS_ENTRIES: n }), w;
    })).prototype = o, o.constructor = l), (f || m) && (u("delete"), u("has"), n && u("get")), (m || p) && u(s), r && o.clear && delete o.clear;
  }
  return c[i] = l, eX({ global: !0, constructor: !0, forced: l !== a }, c), uX(l, i), r || e.setStrong(l, i, n), l;
}, pX = je, fX = Ke, mX = Rn, kC = qo, gX = pi, qx = ln("iterator"), d5 = !1;
[].keys && ("next" in (BC = [].keys()) ? (LC = kC(kC(BC))) !== Object.prototype && (Xl = LC) : d5 = !0);
var vX = !mX(Xl) || pX(function() {
  var i = {};
  return Xl[qx].call(i) !== i;
});
vX && (Xl = {}), fX(Xl[qx]) || gX(Xl, qx, function() {
  return this;
});
var jS = { IteratorPrototype: Xl, BUGGY_SAFARI_ITERATORS: d5 }, yX = jS.IteratorPrototype, _X = sa, wX = Ho, xX = Zo, bX = uu, SX = function() {
  return this;
}, kp = function(i, t, e, n) {
  var r = t + " Iterator";
  return i.prototype = _X(yX, { next: wX(+!n, e) }), xX(i, r, !1), bX[r] = SX, i;
}, MX = zt, TX = Ne, EX = Ke, AX = kp, NC = qo, FC = Ql, CX = Zo, PX = os, C1 = pi, DX = uu, RX = Ep.PROPER, IX = Ep.CONFIGURABLE, UC = jS.IteratorPrototype, Xm = jS.BUGGY_SAFARI_ITERATORS, Qu = ln("iterator"), VC = "keys", td = "values", HC = "entries", OX = function() {
  return this;
}, GS = function(i, t, e, n, r, s, a) {
  AX(e, t, n);
  var o, l, c, u = function(_) {
    if (_ === r && m)
      return m;
    if (!Xm && _ && _ in f)
      return f[_];
    switch (_) {
      case VC:
      case td:
      case HC:
        return function() {
          return new e(this, _);
        };
    }
    return function() {
      return new e(this);
    };
  }, h = t + " Iterator", p = !1, f = i.prototype, v = f[Qu] || f["@@iterator"] || r && f[r], m = !Xm && v || u(r), y = t === "Array" && f.entries || v;
  if (y && (o = NC(y.call(new i()))) !== Object.prototype && o.next && (NC(o) !== UC && (FC ? FC(o, UC) : EX(o[Qu]) || C1(o, Qu, OX)), CX(o, h, !0)), RX && r === td && v && v.name !== td && (IX ? PX(f, "name", td) : (p = !0, m = function() {
    return TX(v, this);
  })), r)
    if (l = { values: u(td), keys: s ? m : u(VC), entries: u(HC) }, a)
      for (c in l)
        (Xm || p || !(c in f)) && C1(f, c, l[c]);
    else
      MX({ target: t, proto: !0, forced: Xm || p }, l);
  return f[Qu] !== m && C1(f, Qu, m, { name: r }), DX[t] = m, l;
}, ec = function(i, t) {
  return { value: i, done: t };
}, jC = sa, LX = ls, GC = fu, BX = Zn, zX = Ja, kX = Hi, NX = Ti, FX = GS, WC = ec, UX = Rp, ed = Mn, ZC = E0.fastKey, qC = Fn.set, P1 = Fn.getterFor, VX = { getConstructor: function(i, t, e, n) {
  var r = i(function(c, u) {
    zX(c, s), qC(c, { type: t, index: jC(null), first: void 0, last: void 0, size: 0 }), ed || (c.size = 0), kX(u) || NX(u, c[n], { that: c, AS_ENTRIES: e });
  }), s = r.prototype, a = P1(t), o = function(c, u, h) {
    var p, f, v = a(c), m = l(c, u);
    return m ? m.value = h : (v.last = m = { index: f = ZC(u, !0), key: u, value: h, previous: p = v.last, next: void 0, removed: !1 }, v.first || (v.first = m), p && (p.next = m), ed ? v.size++ : c.size++, f !== "F" && (v.index[f] = m)), c;
  }, l = function(c, u) {
    var h, p = a(c), f = ZC(u);
    if (f !== "F")
      return p.index[f];
    for (h = p.first; h; h = h.next)
      if (h.key === u)
        return h;
  };
  return GC(s, { clear: function() {
    for (var c = a(this), u = c.first; u; )
      u.removed = !0, u.previous && (u.previous = u.previous.next = void 0), u = u.next;
    c.first = c.last = void 0, c.index = jC(null), ed ? c.size = 0 : this.size = 0;
  }, delete: function(c) {
    var u = this, h = a(u), p = l(u, c);
    if (p) {
      var f = p.next, v = p.previous;
      delete h.index[p.index], p.removed = !0, v && (v.next = f), f && (f.previous = v), h.first === p && (h.first = f), h.last === p && (h.last = v), ed ? h.size-- : u.size--;
    }
    return !!p;
  }, forEach: function(c) {
    for (var u, h = a(this), p = BX(c, arguments.length > 1 ? arguments[1] : void 0); u = u ? u.next : h.first; )
      for (p(u.value, u.key, this); u && u.removed; )
        u = u.previous;
  }, has: function(c) {
    return !!l(this, c);
  } }), GC(s, e ? { get: function(c) {
    var u = l(this, c);
    return u && u.value;
  }, set: function(c, u) {
    return o(this, c === 0 ? 0 : c, u);
  } } : { add: function(c) {
    return o(this, c = c === 0 ? 0 : c, c);
  } }), ed && LX(s, "size", { configurable: !0, get: function() {
    return a(this).size;
  } }), r;
}, setStrong: function(i, t, e) {
  var n = t + " Iterator", r = P1(t), s = P1(n);
  FX(i, t, function(a, o) {
    qC(this, { type: n, target: a, state: r(a), kind: o, last: void 0 });
  }, function() {
    for (var a = s(this), o = a.kind, l = a.last; l && l.removed; )
      l = l.previous;
    return a.target && (a.last = l = l ? l.next : a.state.first) ? WC(o === "keys" ? l.key : o === "values" ? l.value : [l.key, l.value], !1) : (a.target = void 0, WC(void 0, !0));
  }, e ? "entries" : "values", !e, !0), UX(t);
} };
u5("Map", function(i) {
  return function() {
    return i(this, arguments.length ? arguments[0] : void 0);
  };
}, VX);
var HX = Ae, XC = fu, Ym = E0.getWeakData, jX = Ja, GX = $e, WX = Hi, D1 = Rn, ZX = Ti, YC = sr, qX = Fn.set, XX = Fn.getterFor, YX = VS.find, JX = VS.findIndex, KX = HX([].splice), $X = 0, Jm = function(i) {
  return i.frozen || (i.frozen = new p5());
}, p5 = function() {
  this.entries = [];
}, R1 = function(i, t) {
  return YX(i.entries, function(e) {
    return e[0] === t;
  });
};
p5.prototype = { get: function(i) {
  var t = R1(this, i);
  if (t)
    return t[1];
}, has: function(i) {
  return !!R1(this, i);
}, set: function(i, t) {
  var e = R1(this, i);
  e ? e[1] = t : this.entries.push([i, t]);
}, delete: function(i) {
  var t = JX(this.entries, function(e) {
    return e[0] === i;
  });
  return ~t && KX(this.entries, t, 1), !!~t;
} };
var nd, QX = { getConstructor: function(i, t, e, n) {
  var r = i(function(l, c) {
    jX(l, s), qX(l, { type: t, id: $X++, frozen: void 0 }), WX(c) || ZX(c, l[n], { that: l, AS_ENTRIES: e });
  }), s = r.prototype, a = XX(t), o = function(l, c, u) {
    var h = a(l), p = Ym(GX(c), !0);
    return p === !0 ? Jm(h).set(c, u) : p[h.id] = u, l;
  };
  return XC(s, { delete: function(l) {
    var c = a(this);
    if (!D1(l))
      return !1;
    var u = Ym(l);
    return u === !0 ? Jm(c).delete(l) : u && YC(u, c.id) && delete u[c.id];
  }, has: function(l) {
    var c = a(this);
    if (!D1(l))
      return !1;
    var u = Ym(l);
    return u === !0 ? Jm(c).has(l) : u && YC(u, c.id);
  } }), XC(s, e ? { get: function(l) {
    var c = a(this);
    if (D1(l)) {
      var u = Ym(l);
      return u === !0 ? Jm(c).get(l) : u ? u[c.id] : void 0;
    }
  }, set: function(l, c) {
    return o(this, l, c);
  } } : { add: function(l) {
    return o(this, l, !0);
  } }), r;
} }, tY = h5, JC = Oe, ov = Ae, KC = fu, eY = E0, nY = u5, f5 = QX, Km = Rn, $m = Fn.enforce, rY = je, iY = SO, Np = Object, sY = Array.isArray, Qm = Np.isExtensible, $C = Np.isFrozen, aY = Np.isSealed, QC = Np.freeze, oY = Np.seal, lY = !JC.ActiveXObject && "ActiveXObject" in JC, m5 = function(i) {
  return function() {
    return i(this, arguments.length ? arguments[0] : void 0);
  };
}, g5 = nY("WeakMap", m5, f5), ph = g5.prototype, tg = ov(ph.set);
if (iY)
  if (lY) {
    nd = f5.getConstructor(m5, "WeakMap", !0), eY.enable();
    var tP = ov(ph.delete), eg = ov(ph.has), eP = ov(ph.get);
    KC(ph, { delete: function(i) {
      if (Km(i) && !Qm(i)) {
        var t = $m(this);
        return t.frozen || (t.frozen = new nd()), tP(this, i) || t.frozen.delete(i);
      }
      return tP(this, i);
    }, has: function(i) {
      if (Km(i) && !Qm(i)) {
        var t = $m(this);
        return t.frozen || (t.frozen = new nd()), eg(this, i) || t.frozen.has(i);
      }
      return eg(this, i);
    }, get: function(i) {
      if (Km(i) && !Qm(i)) {
        var t = $m(this);
        return t.frozen || (t.frozen = new nd()), eg(this, i) ? eP(this, i) : t.frozen.get(i);
      }
      return eP(this, i);
    }, set: function(i, t) {
      if (Km(i) && !Qm(i)) {
        var e = $m(this);
        e.frozen || (e.frozen = new nd()), eg(this, i) ? tg(this, i, t) : e.frozen.set(i, t);
      } else
        tg(this, i, t);
      return this;
    } });
  } else
    tY && rY(function() {
      var i = QC([]);
      return tg(new g5(), i, 1), !$C(i);
    }) && KC(ph, { set: function(i, t) {
      var e;
      return sY(i) && ($C(i) ? e = QC : aY(i) && (e = oY)), tg(this, i, t), e && e(i), this;
    } });
var v5 = $r, cY = sa, nP = Rn, hY = Object, uY = TypeError, dY = v5("Map"), pY = v5("WeakMap"), lv = function() {
  this.object = null, this.symbol = null, this.primitives = null, this.objectsByIndex = cY(null);
};
lv.prototype.get = function(i, t) {
  return this[i] || (this[i] = t());
}, lv.prototype.next = function(i, t, e) {
  var n = e ? this.objectsByIndex[i] || (this.objectsByIndex[i] = new pY()) : this.primitives || (this.primitives = new dY()), r = n.get(t);
  return r || n.set(t, r = new lv()), r;
};
var rP = new lv(), y5 = function() {
  var i, t, e = rP, n = arguments.length;
  for (i = 0; i < n; i++)
    nP(t = arguments[i]) && (e = e.next(i, t, !0));
  if (this === hY && e === rP)
    throw new uY("Composite keys must contain a non-primitive component");
  for (i = 0; i < n; i++)
    nP(t = arguments[i]) || (e = e.next(i, t, !1));
  return e;
}, fY = Ip, mY = y5, gY = $r, iP = sa, vY = Object, yY = function() {
  var i = gY("Object", "freeze");
  return i ? i(iP(null)) : iP(null);
};
zt({ global: !0, forced: !0 }, { compositeKey: function() {
  return fY(mY, vY, arguments).get("object", yY);
} });
var _Y = y5, sP = $r, wY = Ip;
zt({ global: !0, forced: !0 }, { compositeSymbol: function() {
  return arguments.length === 1 && typeof arguments[0] == "string" ? sP("Symbol").for(arguments[0]) : wY(_Y, null, arguments).get("symbol", sP("Symbol"));
} });
var I1 = Oe;
zt({ global: !0, forced: I1.globalThis !== I1 }, { globalThis: I1 });
var ng = Ae, rd = Map.prototype, Sn = { Map, set: ng(rd.set), get: ng(rd.get), has: ng(rd.has), remove: ng(rd.delete), proto: rd }, xY = Sn.has, ji = function(i) {
  return xY(i), i;
}, bY = ji, SY = Sn.remove;
zt({ target: "Map", proto: !0, real: !0, forced: !0 }, { deleteAll: function() {
  for (var i, t = bY(this), e = !0, n = 0, r = arguments.length; n < r; n++)
    i = SY(t, arguments[n]), e = e && i;
  return !!e;
} });
var MY = Ne, Xo = function(i, t, e) {
  for (var n, r, s = e ? i : i.iterator, a = i.next; !(n = MY(a, s)).done; )
    if ((r = t(n.value)) !== void 0)
      return r;
}, _5 = Ae, TY = Xo, EY = Sn.Map, w5 = Sn.proto, AY = _5(w5.forEach), x5 = _5(w5.entries), CY = x5(new EY()).next, Ls = function(i, t, e) {
  return e ? TY({ iterator: x5(i), next: CY }, function(n) {
    return t(n[1], n[0]);
  }) : AY(i, t);
}, PY = Zn, DY = ji, RY = Ls;
zt({ target: "Map", proto: !0, real: !0, forced: !0 }, { every: function(i) {
  var t = DY(this), e = PY(i, arguments.length > 1 ? arguments[1] : void 0);
  return RY(t, function(n, r) {
    if (!e(n, r, t))
      return !1;
  }, !0) !== !1;
} });
var IY = Zn, OY = ji, LY = Ls, BY = Sn.Map, zY = Sn.set;
zt({ target: "Map", proto: !0, real: !0, forced: !0 }, { filter: function(i) {
  var t = OY(this), e = IY(i, arguments.length > 1 ? arguments[1] : void 0), n = new BY();
  return LY(t, function(r, s) {
    e(r, s, t) && zY(n, s, r);
  }), n;
} });
var kY = Zn, NY = ji, FY = Ls;
zt({ target: "Map", proto: !0, real: !0, forced: !0 }, { find: function(i) {
  var t = NY(this), e = kY(i, arguments.length > 1 ? arguments[1] : void 0), n = FY(t, function(r, s) {
    if (e(r, s, t))
      return { value: r };
  }, !0);
  return n && n.value;
} });
var UY = Zn, VY = ji, HY = Ls;
zt({ target: "Map", proto: !0, real: !0, forced: !0 }, { findKey: function(i) {
  var t = VY(this), e = UY(i, arguments.length > 1 ? arguments[1] : void 0), n = HY(t, function(r, s) {
    if (e(r, s, t))
      return { key: s };
  }, !0);
  return n && n.key;
} });
var jY = Zn, GY = $e, WY = Br, ZY = Ti, A0 = function(i, t, e) {
  return function(n) {
    var r = WY(n), s = arguments.length, a = s > 1 ? arguments[1] : void 0, o = a !== void 0, l = o ? jY(a, s > 2 ? arguments[2] : void 0) : void 0, c = new i(), u = 0;
    return ZY(r, function(h) {
      var p = o ? l(h, u++) : h;
      e ? t(c, GY(p)[0], p[1]) : t(c, p);
    }), c;
  };
};
zt({ target: "Map", stat: !0, forced: !0 }, { from: A0(Sn.Map, Sn.set, !0) });
var qY = zt, XY = Wn, YY = Xa, JY = Ti, KY = Sn.Map, $Y = Sn.has, QY = Sn.get, tJ = Sn.set, eJ = Ae([].push);
qY({ target: "Map", stat: !0, forced: !1 }, { groupBy: function(i, t) {
  YY(i), XY(t);
  var e = new KY(), n = 0;
  return JY(i, function(r) {
    var s = t(r, n++);
    $Y(e, s) ? eJ(QY(e, s), r) : tJ(e, s, [r]);
  }), e;
} });
var nJ = function(i, t) {
  return i === t || i != i && t != t;
}, rJ = ji, iJ = Ls;
zt({ target: "Map", proto: !0, real: !0, forced: !0 }, { includes: function(i) {
  return iJ(rJ(this), function(t) {
    if (nJ(t, i))
      return !0;
  }, !0) === !0;
} });
var sJ = Ne, aJ = Ti, oJ = Ke, aP = Wn, lJ = Sn.Map;
zt({ target: "Map", stat: !0, forced: !0 }, { keyBy: function(i, t) {
  var e = new (oJ(this) ? this : lJ)();
  aP(t);
  var n = aP(e.set);
  return aJ(i, function(r) {
    sJ(n, e, t(r), r);
  }), e;
} });
var cJ = ji, hJ = Ls;
zt({ target: "Map", proto: !0, real: !0, forced: !0 }, { keyOf: function(i) {
  var t = hJ(cJ(this), function(e, n) {
    if (e === i)
      return { key: n };
  }, !0);
  return t && t.key;
} });
var uJ = Zn, dJ = ji, pJ = Ls, fJ = Sn.Map, mJ = Sn.set;
zt({ target: "Map", proto: !0, real: !0, forced: !0 }, { mapKeys: function(i) {
  var t = dJ(this), e = uJ(i, arguments.length > 1 ? arguments[1] : void 0), n = new fJ();
  return pJ(t, function(r, s) {
    mJ(n, e(r, s, t), r);
  }), n;
} });
var gJ = Zn, vJ = ji, yJ = Ls, _J = Sn.Map, wJ = Sn.set;
zt({ target: "Map", proto: !0, real: !0, forced: !0 }, { mapValues: function(i) {
  var t = vJ(this), e = gJ(i, arguments.length > 1 ? arguments[1] : void 0), n = new _J();
  return yJ(t, function(r, s) {
    wJ(n, s, e(r, s, t));
  }), n;
} });
var xJ = ji, bJ = Ti, SJ = Sn.set;
zt({ target: "Map", proto: !0, real: !0, arity: 1, forced: !0 }, { merge: function(i) {
  for (var t = xJ(this), e = arguments.length, n = 0; n < e; )
    bJ(arguments[n++], function(r, s) {
      SJ(t, r, s);
    }, { AS_ENTRIES: !0 });
  return t;
} });
var MJ = $e, C0 = function(i, t, e) {
  return function() {
    for (var n = new i(), r = arguments.length, s = 0; s < r; s++) {
      var a = arguments[s];
      e ? t(n, MJ(a)[0], a[1]) : t(n, a);
    }
    return n;
  };
};
zt({ target: "Map", stat: !0, forced: !0 }, { of: C0(Sn.Map, Sn.set, !0) });
var TJ = Wn, EJ = ji, AJ = Ls, CJ = TypeError;
zt({ target: "Map", proto: !0, real: !0, forced: !0 }, { reduce: function(i) {
  var t = EJ(this), e = arguments.length < 2, n = e ? void 0 : arguments[1];
  if (TJ(i), AJ(t, function(r, s) {
    e ? (e = !1, n = r) : n = i(n, r, s, t);
  }), e)
    throw new CJ("Reduce of empty map with no initial value");
  return n;
} });
var PJ = Zn, DJ = ji, RJ = Ls;
zt({ target: "Map", proto: !0, real: !0, forced: !0 }, { some: function(i) {
  var t = DJ(this), e = PJ(i, arguments.length > 1 ? arguments[1] : void 0);
  return RJ(t, function(n, r) {
    if (e(n, r, t))
      return !0;
  }, !0) === !0;
} });
var oP = Wn, IJ = ji, OJ = TypeError, LJ = Sn.get, BJ = Sn.has, zJ = Sn.set;
zt({ target: "Map", proto: !0, real: !0, forced: !0 }, { update: function(i, t) {
  var e = IJ(this), n = arguments.length;
  oP(t);
  var r = BJ(e, i);
  if (!r && n < 3)
    throw new OJ("Updating absent value");
  var s = r ? LJ(e, i) : oP(n > 2 ? arguments[2] : void 0)(i, e);
  return zJ(e, i, t(s, i, e)), e;
} });
var kJ = zt, NJ = Math.min, FJ = Math.max;
kJ({ target: "Math", stat: !0, forced: !0 }, { clamp: function(i, t, e) {
  return NJ(e, FJ(t, i));
} }), zt({ target: "Math", stat: !0, nonConfigurable: !0, nonWritable: !0 }, { DEG_PER_RAD: Math.PI / 180 });
var UJ = zt, VJ = 180 / Math.PI;
UJ({ target: "Math", stat: !0, forced: !0 }, { degrees: function(i) {
  return i * VJ;
} });
var b5 = Math.scale || function(i, t, e, n, r) {
  var s = +i, a = +t, o = +e, l = +n, c = +r;
  return s != s || a != a || o != o || l != l || c != c ? NaN : s === 1 / 0 || s === -1 / 0 ? s : (s - a) * (c - l) / (o - a) + l;
}, HJ = b5, jJ = VL;
zt({ target: "Math", stat: !0, forced: !0 }, { fscale: function(i, t, e, n, r) {
  return jJ(HJ(i, t, e, n, r));
} }), zt({ target: "Math", stat: !0, forced: !0 }, { iaddh: function(i, t, e, n) {
  var r = i >>> 0, s = e >>> 0;
  return (t >>> 0) + (n >>> 0) + ((r & s | (r | s) & ~(r + s >>> 0)) >>> 31) | 0;
} }), zt({ target: "Math", stat: !0, forced: !0 }, { imulh: function(i, t) {
  var e = 65535, n = +i, r = +t, s = n & e, a = r & e, o = n >> 16, l = r >> 16, c = (o * a >>> 0) + (s * a >>> 16);
  return o * l + (c >> 16) + ((s * l >>> 0) + (c & e) >> 16);
} }), zt({ target: "Math", stat: !0, forced: !0 }, { isubh: function(i, t, e, n) {
  var r = i >>> 0, s = e >>> 0;
  return (t >>> 0) - (n >>> 0) - ((~r & s | ~(r ^ s) & r - s >>> 0) >>> 31) | 0;
} }), zt({ target: "Math", stat: !0, nonConfigurable: !0, nonWritable: !0 }, { RAD_PER_DEG: 180 / Math.PI });
var GJ = zt, WJ = Math.PI / 180;
GJ({ target: "Math", stat: !0, forced: !0 }, { radians: function(i) {
  return i * WJ;
} }), zt({ target: "Math", stat: !0, forced: !0 }, { scale: b5 });
var ZJ = Oe.isFinite, qJ = Number.isFinite || function(i) {
  return typeof i == "number" && ZJ(i);
}, XJ = zt, YJ = $e, JJ = qJ, KJ = kp, $J = ec, S5 = Fn, M5 = "Seeded Random", T5 = M5 + " Generator", QJ = S5.set, tK = S5.getterFor(T5), eK = TypeError, nK = KJ(function(i) {
  QJ(this, { type: T5, seed: i % 2147483647 });
}, M5, function() {
  var i = tK(this), t = i.seed = (1103515245 * i.seed + 12345) % 2147483647;
  return $J((1073741823 & t) / 1073741823, !1);
});
XJ({ target: "Math", stat: !0, forced: !0 }, { seededPRNG: function(i) {
  var t = YJ(i).seed;
  if (!JJ(t))
    throw new eK('Math.seededPRNG() argument should have a "seed" field with a finite value.');
  return new nK(t);
} }), zt({ target: "Math", stat: !0, forced: !0 }, { signbit: function(i) {
  var t = +i;
  return t == t && t === 0 ? 1 / t == -1 / 0 : t < 0;
} }), zt({ target: "Math", stat: !0, forced: !0 }, { umulh: function(i, t) {
  var e = 65535, n = +i, r = +t, s = n & e, a = r & e, o = n >>> 16, l = r >>> 16, c = (o * a >>> 0) + (s * a >>> 16);
  return o * l + (c >>> 16) + ((s * l >>> 0) + (c & e) >>> 16);
} });
var rK = zt, Fp = Ae, iK = Os, id = "Invalid number representation", sK = RangeError, rg = SyntaxError, aK = TypeError, lP = parseInt, oK = Math.pow, E5 = /^[\d.a-z]+$/, lK = Fp("".charAt), cK = Fp(E5.exec), hK = Fp(1 .toString), uK = Fp("".slice), dK = Fp("".split);
rK({ target: "Number", stat: !0, forced: !0 }, { fromString: function(i, t) {
  var e = 1;
  if (typeof i != "string")
    throw new aK(id);
  if (!i.length)
    throw new rg(id);
  if (lK(i, 0) === "-" && (e = -1, !(i = uK(i, 1)).length))
    throw new rg(id);
  var n = t === void 0 ? 10 : iK(t);
  if (n < 2 || n > 36)
    throw new sK("Invalid radix");
  if (!cK(E5, i))
    throw new rg(id);
  var r = dK(i, "."), s = lP(r[0], n);
  if (r.length > 1 && (s += lP(r[1], n) / oK(n, r[1].length)), n === 10 && hK(s, n) !== i)
    throw new rg(id);
  return e * s;
} });
var pK = zt, cv = Ne, Up = Mn, fK = Rp, A5 = Wn, mK = $e, gK = Ja, C5 = Ke, vK = Hi, yK = Rn, hv = Go, _K = pi, WS = fu, P5 = ls, Th = rL, D5 = Fn, wK = ln("observable"), ZS = "Observable", R5 = "Subscription", I5 = "SubscriptionObserver", qS = D5.getterFor, XS = D5.set, xK = qS(ZS), cP = qS(R5), ig = qS(I5), O5 = function(i) {
  this.observer = mK(i), this.cleanup = void 0, this.subscriptionObserver = void 0;
};
O5.prototype = { type: R5, clean: function() {
  var i = this.cleanup;
  if (i) {
    this.cleanup = void 0;
    try {
      i();
    } catch (t) {
      Th(t);
    }
  }
}, close: function() {
  if (!Up) {
    var i = this.facade, t = this.subscriptionObserver;
    i.closed = !0, t && (t.closed = !0);
  }
  this.observer = void 0;
}, isClosed: function() {
  return this.observer === void 0;
} };
var Xx = function(i, t) {
  var e, n = XS(this, new O5(i));
  Up || (this.closed = !1);
  try {
    (e = hv(i, "start")) && cv(e, i, this);
  } catch (o) {
    Th(o);
  }
  if (!n.isClosed()) {
    var r = n.subscriptionObserver = new Yx(n);
    try {
      var s = t(r), a = s;
      vK(s) || (n.cleanup = C5(s.unsubscribe) ? function() {
        a.unsubscribe();
      } : A5(s));
    } catch (o) {
      return void r.error(o);
    }
    n.isClosed() && n.clean();
  }
};
Xx.prototype = WS({}, { unsubscribe: function() {
  var i = cP(this);
  i.isClosed() || (i.close(), i.clean());
} }), Up && P5(Xx.prototype, "closed", { configurable: !0, get: function() {
  return cP(this).isClosed();
} });
var Yx = function(i) {
  XS(this, { type: I5, subscriptionState: i }), Up || (this.closed = !1);
};
Yx.prototype = WS({}, { next: function(i) {
  var t = ig(this).subscriptionState;
  if (!t.isClosed()) {
    var e = t.observer;
    try {
      var n = hv(e, "next");
      n && cv(n, e, i);
    } catch (r) {
      Th(r);
    }
  }
}, error: function(i) {
  var t = ig(this).subscriptionState;
  if (!t.isClosed()) {
    var e = t.observer;
    t.close();
    try {
      var n = hv(e, "error");
      n ? cv(n, e, i) : Th(i);
    } catch (r) {
      Th(r);
    }
    t.clean();
  }
}, complete: function() {
  var i = ig(this).subscriptionState;
  if (!i.isClosed()) {
    var t = i.observer;
    i.close();
    try {
      var e = hv(t, "complete");
      e && cv(e, t);
    } catch (n) {
      Th(n);
    }
    i.clean();
  }
} }), Up && P5(Yx.prototype, "closed", { configurable: !0, get: function() {
  return ig(this).subscriptionState.isClosed();
} });
var L5 = function(i) {
  gK(this, Jx), XS(this, { type: ZS, subscriber: A5(i) });
}, Jx = L5.prototype;
WS(Jx, { subscribe: function(i) {
  var t = arguments.length;
  return new Xx(C5(i) ? { next: i, error: t > 1 ? arguments[1] : void 0, complete: t > 2 ? arguments[2] : void 0 } : yK(i) ? i : {}, xK(this).subscriber);
} }), _K(Jx, wK, function() {
  return this;
}), pK({ global: !0, constructor: !0, forced: !0 }, { Observable: L5 }), fK(ZS);
var bK = zt, SK = $r, MK = Ne, hP = $e, TK = Cp, EK = Dp, AK = Go, CK = Ti, PK = ln("observable");
bK({ target: "Observable", stat: !0, forced: !0 }, { from: function(i) {
  var t = TK(this) ? this : SK("Observable"), e = AK(hP(i), PK);
  if (e) {
    var n = hP(MK(e, i));
    return n.constructor === t ? n : new t(function(s) {
      return n.subscribe(s);
    });
  }
  var r = EK(i);
  return new t(function(s) {
    CK(r, function(a, o) {
      if (s.next(a), s.closed)
        return o();
    }, { IS_ITERATOR: !0, INTERRUPTED: !0 }), s.complete();
  });
} });
var DK = zt, B5 = $r, RK = Cp, IK = B5("Array");
DK({ target: "Observable", stat: !0, forced: !0 }, { of: function() {
  for (var i = RK(this) ? this : B5("Observable"), t = arguments.length, e = IK(t), n = 0; n < t; )
    e[n] = arguments[n++];
  return new i(function(r) {
    for (var s = 0; s < t; s++)
      if (r.next(e[s]), r.closed)
        return;
    r.complete();
  });
} });
var OK = Ne, LK = Wn, BK = Ka, zK = du, kK = Ti;
zt({ target: "Promise", stat: !0, forced: y0 }, { allSettled: function(i) {
  var t = this, e = BK.f(t), n = e.resolve, r = e.reject, s = zK(function() {
    var a = LK(t.resolve), o = [], l = 0, c = 1;
    kK(i, function(u) {
      var h = l++, p = !1;
      c++, OK(a, t, u).then(function(f) {
        p || (p = !0, o[h] = { status: "fulfilled", value: f }, --c || n(o));
      }, function(f) {
        p || (p = !0, o[h] = { status: "rejected", reason: f }, --c || n(o));
      });
    }), --c || n(o);
  });
  return s.error && r(s.value), e.promise;
} });
var NK = Ne, FK = Wn, UK = $r, VK = Ka, HK = du, jK = Ti, uP = "No one promise resolved";
zt({ target: "Promise", stat: !0, forced: y0 }, { any: function(i) {
  var t = this, e = UK("AggregateError"), n = VK.f(t), r = n.resolve, s = n.reject, a = HK(function() {
    var o = FK(t.resolve), l = [], c = 0, u = 1, h = !1;
    jK(i, function(p) {
      var f = c++, v = !1;
      u++, NK(o, t, p).then(function(m) {
        v || h || (h = !0, r(m));
      }, function(m) {
        v || h || (v = !0, l[f] = m, --u || s(new e(l, uP)));
      });
    }), --u || s(new e(l, uP));
  });
  return a.error && s(a.value), n.promise;
} });
var GK = Ka, WK = du;
zt({ target: "Promise", stat: !0, forced: !0 }, { try: function(i) {
  var t = GK.f(this), e = WK(i);
  return (e.error ? t.reject : t.resolve)(e.value), t.promise;
} });
var z5 = $r, ZK = Ae, qK = h0, dP = z5("Map"), XK = z5("WeakMap"), YK = ZK([].push), pP = qK("metadata"), Kx = pP.store || (pP.store = new XK()), sd = function(i, t, e) {
  var n = Kx.get(i);
  if (!n) {
    if (!e)
      return;
    Kx.set(i, n = new dP());
  }
  var r = n.get(t);
  if (!r) {
    if (!e)
      return;
    n.set(t, r = new dP());
  }
  return r;
}, vr = { store: Kx, getMap: sd, has: function(i, t, e) {
  var n = sd(t, e, !1);
  return n !== void 0 && n.has(i);
}, get: function(i, t, e) {
  var n = sd(t, e, !1);
  return n === void 0 ? void 0 : n.get(i);
}, set: function(i, t, e, n) {
  sd(e, n, !0).set(i, t);
}, keys: function(i, t) {
  var e = sd(i, t, !1), n = [];
  return e && e.forEach(function(r, s) {
    YK(n, s);
  }), n;
}, toKey: function(i) {
  return i === void 0 || typeof i == "symbol" ? i : String(i);
} }, JK = $e, KK = vr.toKey, $K = vr.set;
zt({ target: "Reflect", stat: !0 }, { defineMetadata: function(i, t, e) {
  var n = arguments.length < 4 ? void 0 : KK(arguments[3]);
  $K(i, t, JK(e), n);
} });
var QK = $e, t$ = vr.toKey, e$ = vr.getMap, fP = vr.store;
zt({ target: "Reflect", stat: !0 }, { deleteMetadata: function(i, t) {
  var e = arguments.length < 3 ? void 0 : t$(arguments[2]), n = e$(QK(t), e, !1);
  if (n === void 0 || !n.delete(i))
    return !1;
  if (n.size)
    return !0;
  var r = fP.get(t);
  return r.delete(e), !!r.size || fP.delete(t);
} });
var n$ = $e, r$ = qo, i$ = vr.has, s$ = vr.get, a$ = vr.toKey, k5 = function(i, t, e) {
  if (i$(i, t, e))
    return s$(i, t, e);
  var n = r$(t);
  return n !== null ? k5(i, n, e) : void 0;
};
zt({ target: "Reflect", stat: !0 }, { getMetadata: function(i, t) {
  var e = arguments.length < 3 ? void 0 : a$(arguments[2]);
  return k5(i, n$(t), e);
} });
var o$ = Wn, l$ = Hi, c$ = Qr, h$ = Br, u$ = Ls, d$ = Sn.Map, p$ = Sn.has, f$ = Sn.set, m$ = Ae([].push), g$ = zt, N5 = Ae, F5 = vr, v$ = $e, y$ = qo, _$ = function(i) {
  var t, e, n, r = h$(this), s = c$(r), a = [], o = new d$(), l = l$(i) ? function(c) {
    return c;
  } : o$(i);
  for (t = 0; t < s; t++)
    n = l(e = r[t]), p$(o, n) || f$(o, n, e);
  return u$(o, function(c) {
    m$(a, c);
  }), a;
}, w$ = N5(_$), x$ = N5([].concat), b$ = F5.keys, S$ = F5.toKey, U5 = function(i, t) {
  var e = b$(i, t), n = y$(i);
  if (n === null)
    return e;
  var r = U5(n, t);
  return r.length ? e.length ? w$(x$(e, r)) : r : e;
};
g$({ target: "Reflect", stat: !0 }, { getMetadataKeys: function(i) {
  var t = arguments.length < 2 ? void 0 : S$(arguments[1]);
  return U5(v$(i), t);
} });
var M$ = $e, T$ = vr.get, E$ = vr.toKey;
zt({ target: "Reflect", stat: !0 }, { getOwnMetadata: function(i, t) {
  var e = arguments.length < 3 ? void 0 : E$(arguments[2]);
  return T$(i, M$(t), e);
} });
var A$ = $e, C$ = vr.keys, P$ = vr.toKey;
zt({ target: "Reflect", stat: !0 }, { getOwnMetadataKeys: function(i) {
  var t = arguments.length < 2 ? void 0 : P$(arguments[1]);
  return C$(A$(i), t);
} });
var D$ = $e, R$ = qo, I$ = vr.has, O$ = vr.toKey, V5 = function(i, t, e) {
  if (I$(i, t, e))
    return !0;
  var n = R$(t);
  return n !== null && V5(i, n, e);
};
zt({ target: "Reflect", stat: !0 }, { hasMetadata: function(i, t) {
  var e = arguments.length < 3 ? void 0 : O$(arguments[2]);
  return V5(i, D$(t), e);
} });
var L$ = $e, B$ = vr.has, z$ = vr.toKey;
zt({ target: "Reflect", stat: !0 }, { hasOwnMetadata: function(i, t) {
  var e = arguments.length < 3 ? void 0 : z$(arguments[2]);
  return B$(i, L$(t), e);
} });
var k$ = $e, N$ = vr.toKey, F$ = vr.set;
zt({ target: "Reflect", stat: !0 }, { metadata: function(i, t) {
  return function(e, n) {
    F$(i, t, k$(e), N$(n));
  };
} });
var O1 = Ae, sg = Set.prototype, yn = { Set, add: O1(sg.add), has: O1(sg.has), remove: O1(sg.delete), proto: sg }, U$ = yn.has, ti = function(i) {
  return U$(i), i;
}, V$ = ti, H$ = yn.add;
zt({ target: "Set", proto: !0, real: !0, forced: !0 }, { addAll: function() {
  for (var i = V$(this), t = 0, e = arguments.length; t < e; t++)
    H$(i, arguments[t]);
  return i;
} });
var j$ = ti, G$ = yn.remove;
zt({ target: "Set", proto: !0, real: !0, forced: !0 }, { deleteAll: function() {
  for (var i, t = j$(this), e = !0, n = 0, r = arguments.length; n < r; n++)
    i = G$(t, arguments[n]), e = e && i;
  return !!e;
} });
var W$ = Wo, Z$ = sr, q$ = Hi, X$ = uu, Y$ = ln("iterator"), J$ = Object, mP = Ke, K$ = function(i) {
  if (q$(i))
    return !1;
  var t = J$(i);
  return t[Y$] !== void 0 || "@@iterator" in t || Z$(X$, W$(t));
}, $$ = Rn, Q$ = $r("Set"), nc = function(i) {
  return function(t) {
    return $$(t) && typeof t.size == "number" && mP(t.has) && mP(t.keys);
  }(i) ? i : K$(i) ? new Q$(i) : i;
}, H5 = Ae, tQ = Xo, eQ = yn.Set, j5 = yn.proto, nQ = H5(j5.forEach), G5 = H5(j5.keys), rQ = G5(new eQ()).next, cs = function(i, t, e) {
  return e ? tQ({ iterator: G5(i), next: rQ }, t) : nQ(i, t);
}, iQ = cs, sQ = yn.Set, aQ = yn.add, YS = function(i) {
  var t = new sQ();
  return iQ(i, function(e) {
    aQ(t, e);
  }), t;
}, Vp = XO(yn.proto, "size", "get") || function(i) {
  return i.size;
}, gP = Wn, W5 = $e, vP = Ne, oQ = Os, lQ = function(i) {
  return { iterator: i, next: i.next, done: !1 };
}, yP = "Invalid size", cQ = RangeError, hQ = TypeError, uQ = Math.max, Z5 = function(i, t) {
  this.set = i, this.size = uQ(t, 0), this.has = gP(i.has), this.keys = gP(i.keys);
};
Z5.prototype = { getIterator: function() {
  return lQ(W5(vP(this.keys, this.set)));
}, includes: function(i) {
  return vP(this.has, this.set, i);
} };
var rc = function(i) {
  W5(i);
  var t = +i.size;
  if (t != t)
    throw new hQ(yP);
  var e = oQ(t);
  if (e < 0)
    throw new cQ(yP);
  return new Z5(i, e);
}, dQ = ti, pQ = YS, fQ = Vp, mQ = rc, gQ = cs, vQ = Xo, yQ = yn.has, _P = yn.remove, _Q = Ne, wQ = nc, xQ = function(i) {
  var t = dQ(this), e = mQ(i), n = pQ(t);
  return fQ(t) <= e.size ? gQ(t, function(r) {
    e.includes(r) && _P(n, r);
  }) : vQ(e.getIterator(), function(r) {
    yQ(t, r) && _P(n, r);
  }), n;
};
zt({ target: "Set", proto: !0, real: !0, forced: !0 }, { difference: function(i) {
  return _Q(xQ, this, wQ(i));
} });
var bQ = Zn, SQ = ti, MQ = cs;
zt({ target: "Set", proto: !0, real: !0, forced: !0 }, { every: function(i) {
  var t = SQ(this), e = bQ(i, arguments.length > 1 ? arguments[1] : void 0);
  return MQ(t, function(n) {
    if (!e(n, n, t))
      return !1;
  }, !0) !== !1;
} });
var TQ = Zn, EQ = ti, AQ = cs, CQ = yn.Set, PQ = yn.add;
zt({ target: "Set", proto: !0, real: !0, forced: !0 }, { filter: function(i) {
  var t = EQ(this), e = TQ(i, arguments.length > 1 ? arguments[1] : void 0), n = new CQ();
  return AQ(t, function(r) {
    e(r, r, t) && PQ(n, r);
  }), n;
} });
var DQ = Zn, RQ = ti, IQ = cs;
zt({ target: "Set", proto: !0, real: !0, forced: !0 }, { find: function(i) {
  var t = RQ(this), e = DQ(i, arguments.length > 1 ? arguments[1] : void 0), n = IQ(t, function(r) {
    if (e(r, r, t))
      return { value: r };
  }, !0);
  return n && n.value;
} });
zt({ target: "Set", stat: !0, forced: !0 }, { from: A0(yn.Set, yn.add, !1) });
var OQ = ti, LQ = Vp, BQ = rc, zQ = cs, kQ = Xo, NQ = yn.Set, wP = yn.add, FQ = yn.has, UQ = Ne, VQ = nc, HQ = function(i) {
  var t = OQ(this), e = BQ(i), n = new NQ();
  return LQ(t) > e.size ? kQ(e.getIterator(), function(r) {
    FQ(t, r) && wP(n, r);
  }) : zQ(t, function(r) {
    e.includes(r) && wP(n, r);
  }), n;
};
zt({ target: "Set", proto: !0, real: !0, forced: !0 }, { intersection: function(i) {
  return UQ(HQ, this, VQ(i));
} });
var jQ = ti, GQ = yn.has, WQ = Vp, ZQ = rc, qQ = cs, XQ = Xo, YQ = g0, JQ = Ne, KQ = nc, $Q = function(i) {
  var t = jQ(this), e = ZQ(i);
  if (WQ(t) <= e.size)
    return qQ(t, function(r) {
      if (e.includes(r))
        return !1;
    }, !0) !== !1;
  var n = e.getIterator();
  return XQ(n, function(r) {
    if (GQ(t, r))
      return YQ(n, "normal", !1);
  }) !== !1;
};
zt({ target: "Set", proto: !0, real: !0, forced: !0 }, { isDisjointFrom: function(i) {
  return JQ($Q, this, KQ(i));
} });
var QQ = ti, ttt = Vp, ett = cs, ntt = rc, rtt = Ne, itt = nc, stt = function(i) {
  var t = QQ(this), e = ntt(i);
  return !(ttt(t) > e.size) && ett(t, function(n) {
    if (!e.includes(n))
      return !1;
  }, !0) !== !1;
};
zt({ target: "Set", proto: !0, real: !0, forced: !0 }, { isSubsetOf: function(i) {
  return rtt(stt, this, itt(i));
} });
var att = ti, ott = yn.has, ltt = Vp, ctt = rc, htt = Xo, utt = g0, dtt = Ne, ptt = nc, ftt = function(i) {
  var t = att(this), e = ctt(i);
  if (ltt(t) < e.size)
    return !1;
  var n = e.getIterator();
  return htt(n, function(r) {
    if (!ott(t, r))
      return utt(n, "normal", !1);
  }) !== !1;
};
zt({ target: "Set", proto: !0, real: !0, forced: !0 }, { isSupersetOf: function(i) {
  return dtt(ftt, this, ptt(i));
} });
var mtt = zt, q5 = Ae, gtt = ti, vtt = cs, ytt = fi, _tt = q5([].join), wtt = q5([].push);
mtt({ target: "Set", proto: !0, real: !0, forced: !0 }, { join: function(i) {
  var t = gtt(this), e = i === void 0 ? "," : ytt(i), n = [];
  return vtt(t, function(r) {
    wtt(n, r);
  }), _tt(n, e);
} });
var xtt = Zn, btt = ti, Stt = cs, Mtt = yn.Set, Ttt = yn.add;
zt({ target: "Set", proto: !0, real: !0, forced: !0 }, { map: function(i) {
  var t = btt(this), e = xtt(i, arguments.length > 1 ? arguments[1] : void 0), n = new Mtt();
  return Stt(t, function(r) {
    Ttt(n, e(r, r, t));
  }), n;
} });
zt({ target: "Set", stat: !0, forced: !0 }, { of: C0(yn.Set, yn.add, !1) });
var Ett = Wn, Att = ti, Ctt = cs, Ptt = TypeError;
zt({ target: "Set", proto: !0, real: !0, forced: !0 }, { reduce: function(i) {
  var t = Att(this), e = arguments.length < 2, n = e ? void 0 : arguments[1];
  if (Ett(i), Ctt(t, function(r) {
    e ? (e = !1, n = r) : n = i(n, r, r, t);
  }), e)
    throw new Ptt("Reduce of empty set with no initial value");
  return n;
} });
var Dtt = Zn, Rtt = ti, Itt = cs;
zt({ target: "Set", proto: !0, real: !0, forced: !0 }, { some: function(i) {
  var t = Rtt(this), e = Dtt(i, arguments.length > 1 ? arguments[1] : void 0);
  return Itt(t, function(n) {
    if (e(n, n, t))
      return !0;
  }, !0) === !0;
} });
var Ott = ti, Ltt = YS, Btt = rc, ztt = Xo, ktt = yn.add, Ntt = yn.has, Ftt = yn.remove, Utt = Ne, Vtt = nc, Htt = function(i) {
  var t = Ott(this), e = Btt(i).getIterator(), n = Ltt(t);
  return ztt(e, function(r) {
    Ntt(t, r) ? Ftt(n, r) : ktt(n, r);
  }), n;
};
zt({ target: "Set", proto: !0, real: !0, forced: !0 }, { symmetricDifference: function(i) {
  return Utt(Htt, this, Vtt(i));
} });
var jtt = ti, Gtt = yn.add, Wtt = YS, Ztt = rc, qtt = Xo, Xtt = Ne, Ytt = nc, Jtt = function(i) {
  var t = jtt(this), e = Ztt(i).getIterator(), n = Wtt(t);
  return qtt(e, function(r) {
    Gtt(n, r);
  }), n;
};
zt({ target: "Set", proto: !0, real: !0, forced: !0 }, { union: function(i) {
  return Xtt(Jtt, this, Ytt(i));
} });
var Ktt = pu.charAt, $tt = Xa, Qtt = Os, tet = fi;
zt({ target: "String", proto: !0, forced: !0 }, { at: function(i) {
  var t = tet($tt(this)), e = t.length, n = Qtt(i), r = n >= 0 ? n : e + n;
  return r < 0 || r >= e ? void 0 : Ktt(t, r);
} });
var eet = zt, net = kp, xP = ec, ret = Xa, iet = fi, X5 = Fn, set = pu.codeAt, aet = pu.charAt, Y5 = "String Iterator", oet = X5.set, cet = X5.getterFor(Y5), het = net(function(i) {
  oet(this, { type: Y5, string: i, index: 0 });
}, "String", function() {
  var i, t = cet(this), e = t.string, n = t.index;
  return n >= e.length ? xP(void 0, !0) : (i = aet(e, n), t.index += i.length, xP({ codePoint: set(i, 0), position: n }, !1));
});
eet({ target: "String", proto: !0, forced: !0 }, { codePoints: function() {
  return new het(iet(ret(this)));
} });
var uet = zt, det = Ne, J5 = Rv, pet = kp, ag = ec, bP = Xa, K5 = lu, mp = fi, fet = $e, met = Hi, get = CS, $5 = DS, vet = Go, yet = pi, _et = je, wet = SS, xet = DL, bet = IL, Q5 = Fn, og = ln("matchAll"), tB = "RegExp String", eB = tB + " Iterator", Met = Q5.set, Tet = Q5.getterFor(eB), SP = RegExp.prototype, Eet = TypeError, $x = J5("".indexOf), Wv = J5("".matchAll), L1 = !!Wv && !_et(function() {
  Wv("a", /./);
}), Aet = pet(function(i, t, e, n) {
  Met(this, { type: eB, regexp: i, string: t, global: e, unicode: n, done: !1 });
}, tB, function() {
  var i = Tet(this);
  if (i.done)
    return ag(void 0, !0);
  var t = i.regexp, e = i.string, n = bet(t, e);
  return n === null ? (i.done = !0, ag(void 0, !0)) : i.global ? (mp(n[0]) === "" && (t.lastIndex = xet(e, K5(t.lastIndex), i.unicode)), ag(n, !1)) : (i.done = !0, ag(n, !1));
}), Cet = function(i) {
  var t, e, n, r = fet(this), s = mp(i), a = wet(r, RegExp), o = mp($5(r));
  return t = new a(a === RegExp ? r.source : r, o), e = !!~$x(o, "g"), n = !!~$x(o, "u"), t.lastIndex = K5(r.lastIndex), new Aet(t, s, e, n);
};
uet({ target: "String", proto: !0, forced: L1 }, { matchAll: function(i) {
  var t, e, n, r = bP(this);
  if (met(i)) {
    if (L1)
      return Wv(r, i);
  } else {
    if (get(i) && (t = mp(bP($5(i))), !~$x(t, "g")))
      throw new Eet("`.matchAll` does not allow non-global regexes");
    if (L1)
      return Wv(r, i);
    if (n = vet(i, og))
      return det(n, i, r);
  }
  return e = mp(r), new RegExp(i, "g")[og](e);
} }), og in SP || yet(SP, og, Cet);
var Pet = zt, Det = Ne, JS = Ae, MP = Xa, Ret = Ke, Iet = Hi, Oet = CS, ad = fi, Let = Go, Bet = DS, zet = RL, ket = ln("replace"), Net = TypeError, B1 = JS("".indexOf);
JS("".replace);
var TP = JS("".slice), Fet = Math.max;
Pet({ target: "String", proto: !0 }, { replaceAll: function(i, t) {
  var e, n, r, s, a, o, l, c, u = MP(this), h = 0, p = 0, f = "";
  if (!Iet(i)) {
    if (Oet(i) && (e = ad(MP(Bet(i))), !~B1(e, "g")))
      throw new Net("`.replaceAll` does not allow non-global regexes");
    if (n = Let(i, ket))
      return Det(n, i, u, t);
  }
  for (r = ad(u), s = ad(i), (a = Ret(t)) || (t = ad(t)), o = s.length, l = Fet(1, o), h = B1(r, s); h !== -1; )
    c = a ? ad(t(s, h, r)) : zet(s, r, h, [], void 0, t), f += TP(r, p, h) + c, p = h + o, h = h + l > r.length ? -1 : B1(r, s, h + l);
  return p < r.length && (f += TP(r, p)), f;
} });
var Uet = Oe, nB = {}, Vet = ln;
nB.f = Vet;
var EP = Uet, Het = sr, jet = nB, Get = di.f, Qx = function(i) {
  var t = EP.Symbol || (EP.Symbol = {});
  Het(t, i) || Get(t, i, { value: jet.f(i) });
}, Wet = Oe, Zet = Qx, qet = di.f, Xet = Tp.f, z1 = Wet.Symbol;
if (Zet("dispose"), z1) {
  var lg = Xet(z1, "dispose");
  lg.enumerable && lg.configurable && lg.writable && qet(z1, "dispose", { value: lg.value, enumerable: !1, configurable: !1, writable: !1 });
}
Qx("observable"), Qx("patternMatch");
var cg = Ae, hg = WeakMap.prototype, qh = { WeakMap, set: cg(hg.set), get: cg(hg.get), has: cg(hg.has), remove: cg(hg.delete) }, Yet = qh.has, Jet = function(i) {
  return Yet(i), i;
}, Ket = qh.remove;
zt({ target: "WeakMap", proto: !0, real: !0, forced: !0 }, { deleteAll: function() {
  for (var i, t = Jet(this), e = !0, n = 0, r = arguments.length; n < r; n++)
    i = Ket(t, arguments[n]), e = e && i;
  return !!e;
} });
zt({ target: "WeakMap", stat: !0, forced: !0 }, { from: A0(qh.WeakMap, qh.set, !0) });
zt({ target: "WeakMap", stat: !0, forced: !0 }, { of: C0(qh.WeakMap, qh.set, !0) });
var k1 = Ae, N1 = WeakSet.prototype, Kl = { WeakSet, add: k1(N1.add), has: k1(N1.has), remove: k1(N1.delete) }, $et = Kl.has, rB = function(i) {
  return $et(i), i;
}, Qet = rB, tnt = Kl.add;
zt({ target: "WeakSet", proto: !0, real: !0, forced: !0 }, { addAll: function() {
  for (var i = Qet(this), t = 0, e = arguments.length; t < e; t++)
    tnt(i, arguments[t]);
  return i;
} });
var ent = rB, nnt = Kl.remove;
zt({ target: "WeakSet", proto: !0, real: !0, forced: !0 }, { deleteAll: function() {
  for (var i, t = ent(this), e = !0, n = 0, r = arguments.length; n < r; n++)
    i = nnt(t, arguments[n]), e = e && i;
  return !!e;
} });
zt({ target: "WeakSet", stat: !0, forced: !0 }, { from: A0(Kl.WeakSet, Kl.add, !1) });
zt({ target: "WeakSet", stat: !0, forced: !0 }, { of: C0(Kl.WeakSet, Kl.add, !1) });
var F1 = d0("span").classList, AP = F1 && F1.constructor && F1.constructor.prototype, rnt = AP === Object.prototype ? void 0 : AP, int = su, U1 = Hh, CP = uu, iB = Fn, snt = di.f, ant = GS, ug = ec, ont = Mn, sB = "Array Iterator", lnt = iB.set, cnt = iB.getterFor(sB), hnt = ant(Array, "Array", function(i, t) {
  lnt(this, { type: sB, target: int(i), index: 0, kind: t });
}, function() {
  var i = cnt(this), t = i.target, e = i.index++;
  if (!t || e >= t.length)
    return i.target = void 0, ug(void 0, !0);
  switch (i.kind) {
    case "keys":
      return ug(e, !1);
    case "values":
      return ug(t[e], !1);
  }
  return ug([e, t[e]], !1);
}, "values"), PP = CP.Arguments = CP.Array;
if (U1("keys"), U1("values"), U1("entries"), ont && PP.name !== "values")
  try {
    snt(PP, "name", { value: "values" });
  } catch {
  }
var DP = Oe, aB = { CSSRuleList: 0, CSSStyleDeclaration: 0, CSSValueList: 0, ClientRectList: 0, DOMRectList: 0, DOMStringList: 0, DOMTokenList: 1, DataTransferItemList: 0, FileList: 0, HTMLAllCollection: 0, HTMLCollection: 0, HTMLFormElement: 0, HTMLSelectElement: 0, MediaList: 0, MimeTypeArray: 0, NamedNodeMap: 0, NodeList: 1, PaintRequestList: 0, Plugin: 0, PluginArray: 0, SVGLengthList: 0, SVGNumberList: 0, SVGPathSegList: 0, SVGPointList: 0, SVGStringList: 0, SVGTransformList: 0, SourceBufferList: 0, StyleSheetList: 0, TextTrackCueList: 0, TextTrackList: 0, TouchList: 0 }, unt = rnt, wd = hnt, RP = os, dnt = Zo, V1 = ln("iterator"), H1 = wd.values, oB = function(i, t) {
  if (i) {
    if (i[V1] !== H1)
      try {
        RP(i, V1, H1);
      } catch {
        i[V1] = H1;
      }
    if (dnt(i, t, !0), aB[t]) {
      for (var e in wd)
        if (i[e] !== wd[e])
          try {
            RP(i, e, wd[e]);
          } catch {
            i[e] = wd[e];
          }
    }
  }
};
for (var j1 in aB)
  oB(DP[j1] && DP[j1].prototype, j1);
oB(unt, "DOMTokenList");
var IP = v0.clear;
zt({ global: !0, bind: !0, enumerable: !0, forced: Oe.clearImmediate !== IP }, { clearImmediate: IP });
var pnt = typeof Bun == "function" && Bun && typeof Bun.version == "string", lB = Oe, fnt = Ip, mnt = Ke, gnt = pnt, vnt = jo, ynt = hu, _nt = Op, wnt = lB.Function, xnt = /MSIE .\./.test(vnt) || gnt && function() {
  var i = lB.Bun.version.split(".");
  return i.length < 3 || i[0] === "0" && (i[1] < 3 || i[1] === "3" && i[2] === "0");
}(), bnt = zt, cB = Oe, OP = v0.set, Snt = function(i, t) {
  var e = t ? 2 : 1;
  return xnt ? function(n, r) {
    var s = _nt(arguments.length, 1) > e, a = mnt(n) ? n : wnt(n), o = s ? ynt(arguments, e) : [], l = s ? function() {
      fnt(a, this, o);
    } : a;
    return t ? i(l, r) : i(l);
  } : i;
}, LP = cB.setImmediate ? Snt(OP, !1) : OP;
bnt({ global: !0, bind: !0, enumerable: !0, forced: cB.setImmediate !== LP }, { setImmediate: LP });
var Mnt = nL, Tnt = Wn, Ent = Op;
zt({ global: !0, enumerable: !0, dontCallGetSet: !0 }, { queueMicrotask: function(i) {
  Ent(arguments.length, 1), Mnt(Tnt(i));
} });
var Ant = pu.charAt, Cnt = fi, hB = Fn, Pnt = GS, BP = ec, uB = "String Iterator", Dnt = hB.set, Rnt = hB.getterFor(uB);
Pnt(String, "String", function(i) {
  Dnt(this, { type: uB, string: Cnt(i), index: 0 });
}, function() {
  var i, t = Rnt(this), e = t.string, n = t.index;
  return n >= e.length ? BP(void 0, !0) : (i = Ant(e, n), t.index += i.length, BP(i, !1));
});
var Int = je, Ont = Mn, Lnt = ln("iterator"), dB = !Int(function() {
  var i = new URL("b?a=1&b=2&c=3", "http://a"), t = i.searchParams, e = new URLSearchParams("a=1&a=2&b=3"), n = "";
  return i.pathname = "c%20d", t.forEach(function(r, s) {
    t.delete("b"), n += s + r;
  }), e.delete("a", 2), e.delete("b", void 0), !t.size && !Ont || !t.sort || i.href !== "http://a/c%20d?a=1&c=3" || t.get("c") !== "3" || String(new URLSearchParams("?a=1")) !== "a=1" || !t[Lnt] || new URL("https://a@b").username !== "a" || new URLSearchParams(new URLSearchParams("a=b")).get("a") !== "b" || new URL("http://тест").host !== "xn--e1aybc" || new URL("http://a#б").hash !== "#%D0%B1" || n !== "a1c3" || new URL("http://x", void 0).host !== "x";
}), zP = Mn, Bnt = Ae, znt = Ne, knt = je, G1 = NO, Nnt = gS, Fnt = oS, Unt = Br, Vnt = c0, Yc = Object.assign, kP = Object.defineProperty, Hnt = Bnt([].concat), jnt = !Yc || knt(function() {
  if (zP && Yc({ b: 1 }, Yc(kP({}, "a", { enumerable: !0, get: function() {
    kP(this, "b", { value: 3, enumerable: !1 });
  } }), { b: 2 })).b !== 1)
    return !0;
  var i = {}, t = {}, e = Symbol("assign detection"), n = "abcdefghijklmnopqrst";
  return i[e] = 7, n.split("").forEach(function(r) {
    t[r] = r;
  }), Yc({}, i)[e] !== 7 || G1(Yc({}, t)).join("") !== n;
}) ? function(i, t) {
  for (var e = Unt(i), n = arguments.length, r = 1, s = Nnt.f, a = Fnt.f; n > r; )
    for (var o, l = Vnt(arguments[r++]), c = s ? Hnt(G1(l), s(l)) : G1(l), u = c.length, h = 0; u > h; )
      o = c[h++], zP && !znt(a, l, o) || (e[o] = l[o]);
  return e;
} : Yc, Gnt = $e, Wnt = g0, Znt = Zn, qnt = Ne, Xnt = Br, Ynt = function(i, t, e, n) {
  try {
    return n ? t(Gnt(e)[0], e[1]) : t(e);
  } catch (r) {
    Wnt(i, "throw", r);
  }
}, Jnt = bS, Knt = Cp, $nt = Qr, NP = qO, Qnt = Dp, trt = Pp, FP = Array, ic = Ae, W1 = 2147483647, ert = /[^\0-\u007E]/, pB = /[.\u3002\uFF0E\uFF61]/g, UP = "Overflow: input needs wider integers to process", VP = RangeError, nrt = ic(pB.exec), Eh = Math.floor, Z1 = String.fromCharCode, HP = ic("".charCodeAt), fB = ic([].join), So = ic([].push), rrt = ic("".replace), irt = ic("".split), srt = ic("".toLowerCase), jP = function(i) {
  return i + 22 + 75 * (i < 26);
}, art = function(i, t, e) {
  var n = 0;
  for (i = e ? Eh(i / 700) : i >> 1, i += Eh(i / t); i > 455; )
    i = Eh(i / 35), n += 36;
  return Eh(n + 36 * i / (i + 38));
}, ort = function(i) {
  var t = [];
  i = function(_) {
    for (var w = [], b = 0, T = _.length; b < T; ) {
      var M = HP(_, b++);
      if (M >= 55296 && M <= 56319 && b < T) {
        var A = HP(_, b++);
        (64512 & A) == 56320 ? So(w, ((1023 & M) << 10) + (1023 & A) + 65536) : (So(w, M), b--);
      } else
        So(w, M);
    }
    return w;
  }(i);
  var e, n, r = i.length, s = 128, a = 0, o = 72;
  for (e = 0; e < i.length; e++)
    (n = i[e]) < 128 && So(t, Z1(n));
  var l = t.length, c = l;
  for (l && So(t, "-"); c < r; ) {
    var u = W1;
    for (e = 0; e < i.length; e++)
      (n = i[e]) >= s && n < u && (u = n);
    var h = c + 1;
    if (u - s > Eh((W1 - a) / h))
      throw new VP(UP);
    for (a += (u - s) * h, s = u, e = 0; e < i.length; e++) {
      if ((n = i[e]) < s && ++a > W1)
        throw new VP(UP);
      if (n === s) {
        for (var p = a, f = 36; ; ) {
          var v = f <= o ? 1 : f >= o + 26 ? 26 : f - o;
          if (p < v)
            break;
          var m = p - v, y = 36 - v;
          So(t, Z1(jP(v + m % y))), p = Eh(m / y), f += 36;
        }
        So(t, Z1(jP(p))), o = art(a, h, c === l), a = 0, c++;
      }
    }
    a++, s++;
  }
  return fB(t, "");
}, q1 = zt, P0 = Oe, KS = QO, dg = Ne, ia = Ae, xd = Mn, GP = dB, WP = pi, lrt = ls, crt = fu, hrt = Zo, urt = kp, $S = Fn, mB = Ja, X1 = Ke, drt = sr, prt = Zn, frt = Wo, mrt = $e, gB = Rn, oi = fi, grt = sa, ZP = Ho, qP = Dp, vrt = Pp, pg = ec, Jc = Op, yrt = wS, _rt = ln("iterator"), Xh = "URLSearchParams", vB = Xh + "Iterator", yB = $S.set, es = $S.getterFor(Xh), wrt = $S.getterFor(vB), XP = KS("fetch"), Zv = KS("Request"), Nd = KS("Headers"), Y1 = Zv && Zv.prototype, YP = Nd && Nd.prototype, xrt = P0.RegExp, brt = P0.TypeError, _B = P0.decodeURIComponent, Srt = P0.encodeURIComponent, Mrt = ia("".charAt), JP = ia([].join), Nl = ia([].push), tb = ia("".replace), Trt = ia([].shift), KP = ia([].splice), $P = ia("".split), Ert = ia("".slice), Art = /\+/g, QP = Array(4), Crt = function(i) {
  return QP[i - 1] || (QP[i - 1] = xrt("((?:%[\\da-f]{2}){" + i + "})", "gi"));
}, Prt = function(i) {
  try {
    return _B(i);
  } catch {
    return i;
  }
}, tD = function(i) {
  var t = tb(i, Art, " "), e = 4;
  try {
    return _B(t);
  } catch {
    for (; e; )
      t = tb(t, Crt(e--), Prt);
    return t;
  }
}, Drt = /[!'()~]|%20/g, Rrt = { "!": "%21", "'": "%27", "(": "%28", ")": "%29", "~": "%7E", "%20": "+" }, Irt = function(i) {
  return Rrt[i];
}, eD = function(i) {
  return tb(Srt(i), Drt, Irt);
}, J1 = urt(function(i, t) {
  yB(this, { type: vB, target: es(i).entries, index: 0, kind: t });
}, Xh, function() {
  var i = wrt(this), t = i.target, e = i.index++;
  if (!t || e >= t.length)
    return i.target = void 0, pg(void 0, !0);
  var n = t[e];
  switch (i.kind) {
    case "keys":
      return pg(n.key, !1);
    case "values":
      return pg(n.value, !1);
  }
  return pg([n.key, n.value], !1);
}, !0), wB = function(i) {
  this.entries = [], this.url = null, i !== void 0 && (gB(i) ? this.parseObject(i) : this.parseQuery(typeof i == "string" ? Mrt(i, 0) === "?" ? Ert(i, 1) : i : oi(i)));
};
wB.prototype = { type: Xh, bindURL: function(i) {
  this.url = i, this.update();
}, parseObject: function(i) {
  var t, e, n, r, s, a, o, l = this.entries, c = vrt(i);
  if (c)
    for (e = (t = qP(i, c)).next; !(n = dg(e, t)).done; ) {
      if (s = (r = qP(mrt(n.value))).next, (a = dg(s, r)).done || (o = dg(s, r)).done || !dg(s, r).done)
        throw new brt("Expected sequence with length 2");
      Nl(l, { key: oi(a.value), value: oi(o.value) });
    }
  else
    for (var u in i)
      drt(i, u) && Nl(l, { key: u, value: oi(i[u]) });
}, parseQuery: function(i) {
  if (i)
    for (var t, e, n = this.entries, r = $P(i, "&"), s = 0; s < r.length; )
      (t = r[s++]).length && (e = $P(t, "="), Nl(n, { key: tD(Trt(e)), value: tD(JP(e, "=")) }));
}, serialize: function() {
  for (var i, t = this.entries, e = [], n = 0; n < t.length; )
    i = t[n++], Nl(e, eD(i.key) + "=" + eD(i.value));
  return JP(e, "&");
}, update: function() {
  this.entries.length = 0, this.parseQuery(this.url.query);
}, updateURL: function() {
  this.url && this.url.update();
} };
var qv = function() {
  mB(this, fh);
  var i = yB(this, new wB(arguments.length > 0 ? arguments[0] : void 0));
  xd || (this.size = i.entries.length);
}, fh = qv.prototype;
if (crt(fh, { append: function(i, t) {
  var e = es(this);
  Jc(arguments.length, 2), Nl(e.entries, { key: oi(i), value: oi(t) }), xd || this.length++, e.updateURL();
}, delete: function(i) {
  for (var t = es(this), e = Jc(arguments.length, 1), n = t.entries, r = oi(i), s = e < 2 ? void 0 : arguments[1], a = s === void 0 ? s : oi(s), o = 0; o < n.length; ) {
    var l = n[o];
    if (l.key !== r || a !== void 0 && l.value !== a)
      o++;
    else if (KP(n, o, 1), a !== void 0)
      break;
  }
  xd || (this.size = n.length), t.updateURL();
}, get: function(i) {
  var t = es(this).entries;
  Jc(arguments.length, 1);
  for (var e = oi(i), n = 0; n < t.length; n++)
    if (t[n].key === e)
      return t[n].value;
  return null;
}, getAll: function(i) {
  var t = es(this).entries;
  Jc(arguments.length, 1);
  for (var e = oi(i), n = [], r = 0; r < t.length; r++)
    t[r].key === e && Nl(n, t[r].value);
  return n;
}, has: function(i) {
  for (var t = es(this).entries, e = Jc(arguments.length, 1), n = oi(i), r = e < 2 ? void 0 : arguments[1], s = r === void 0 ? r : oi(r), a = 0; a < t.length; ) {
    var o = t[a++];
    if (o.key === n && (s === void 0 || o.value === s))
      return !0;
  }
  return !1;
}, set: function(i, t) {
  var e = es(this);
  Jc(arguments.length, 1);
  for (var n, r = e.entries, s = !1, a = oi(i), o = oi(t), l = 0; l < r.length; l++)
    (n = r[l]).key === a && (s ? KP(r, l--, 1) : (s = !0, n.value = o));
  s || Nl(r, { key: a, value: o }), xd || (this.size = r.length), e.updateURL();
}, sort: function() {
  var i = es(this);
  yrt(i.entries, function(t, e) {
    return t.key > e.key ? 1 : -1;
  }), i.updateURL();
}, forEach: function(i) {
  for (var t, e = es(this).entries, n = prt(i, arguments.length > 1 ? arguments[1] : void 0), r = 0; r < e.length; )
    n((t = e[r++]).value, t.key, this);
}, keys: function() {
  return new J1(this, "keys");
}, values: function() {
  return new J1(this, "values");
}, entries: function() {
  return new J1(this, "entries");
} }, { enumerable: !0 }), WP(fh, _rt, fh.entries, { name: "entries" }), WP(fh, "toString", function() {
  return es(this).serialize();
}, { enumerable: !0 }), xd && lrt(fh, "size", { get: function() {
  return es(this).entries.length;
}, configurable: !0, enumerable: !0 }), hrt(qv, Xh), q1({ global: !0, constructor: !0, forced: !GP }, { URLSearchParams: qv }), !GP && X1(Nd)) {
  var Ort = ia(YP.has), Lrt = ia(YP.set), nD = function(i) {
    if (gB(i)) {
      var t, e = i.body;
      if (frt(e) === Xh)
        return t = i.headers ? new Nd(i.headers) : new Nd(), Ort(t, "content-type") || Lrt(t, "content-type", "application/x-www-form-urlencoded;charset=UTF-8"), grt(i, { body: ZP(0, oi(e)), headers: ZP(0, t) });
    }
    return i;
  };
  if (X1(XP) && q1({ global: !0, enumerable: !0, dontCallGetSet: !0, forced: !0 }, { fetch: function(i) {
    return XP(i, arguments.length > 1 ? nD(arguments[1]) : {});
  } }), X1(Zv)) {
    var K1 = function(i) {
      return mB(this, Y1), new Zv(i, arguments.length > 1 ? nD(arguments[1]) : {});
    };
    Y1.constructor = K1, K1.prototype = Y1, q1({ global: !0, constructor: !0, dontCallGetSet: !0, forced: !0 }, { Request: K1 });
  }
}
var $i, Brt = zt, QS = Mn, zrt = dB, tM = Oe, rD = Zn, hs = Ae, fg = pi, Qi = ls, krt = Ja, eb = sr, eM = jnt, Kc = function(i) {
  var t = Xnt(i), e = Knt(this), n = arguments.length, r = n > 1 ? arguments[1] : void 0, s = r !== void 0;
  s && (r = Znt(r, n > 2 ? arguments[2] : void 0));
  var a, o, l, c, u, h, p = trt(t), f = 0;
  if (!p || this === FP && Jnt(p))
    for (a = $nt(t), o = e ? new this(a) : FP(a); a > f; f++)
      h = s ? r(t[f], f) : t[f], NP(o, f, h);
  else
    for (u = (c = Qnt(t, p)).next, o = e ? new this() : []; !(l = qnt(u, c)).done; f++)
      h = s ? Ynt(c, r, [l.value, f], !0) : l.value, NP(o, f, h);
  return o.length = f, o;
}, ys = hu, Nrt = pu.codeAt, Frt = function(i) {
  var t, e, n = [], r = irt(rrt(srt(i), pB, "."), ".");
  for (t = 0; t < r.length; t++)
    e = r[t], So(n, nrt(ert, e) ? "xn--" + ort(e) : e);
  return fB(n, ".");
}, Ca = fi, Urt = Zo, Vrt = Op, xB = { URLSearchParams: qv, getState: es }, bB = Fn, Hrt = bB.set, Xv = bB.getterFor("URL"), jrt = xB.URLSearchParams, Grt = xB.getState, od = tM.URL, nb = tM.TypeError, mg = tM.parseInt, Wrt = Math.floor, iD = Math.pow, ns = hs("".charAt), bs = hs(/./.exec), bd = hs([].join), Zrt = hs(1 .toString), qrt = hs([].pop), $c = hs([].push), $1 = hs("".replace), Xrt = hs([].shift), Yrt = hs("".split), Sd = hs("".slice), uv = hs("".toLowerCase), Jrt = hs([].unshift), Q1 = "Invalid scheme", gl = "Invalid host", sD = "Invalid port", SB = /[a-z]/i, Krt = /[\d+-.a-z]/i, tw = /\d/, $rt = /^0x/i, Qrt = /^[0-7]+$/, tit = /^\d+$/, aD = /^[\da-f]+$/i, eit = /[\0\t\n\r #%/:<>?@[\\\]^|]/, nit = /[\0\t\n\r #/:<>?@[\\\]^|]/, rit = /^[\u0000-\u0020]+/, iit = /(^|[^\u0000-\u0020])[\u0000-\u0020]+$/, sit = /[\t\n\r]/g, ld = function(i) {
  var t, e, n, r;
  if (typeof i == "number") {
    for (t = [], e = 0; e < 4; e++)
      Jrt(t, i % 256), i = Wrt(i / 256);
    return bd(t, ".");
  }
  if (typeof i == "object") {
    for (t = "", n = function(s) {
      for (var a = null, o = 1, l = null, c = 0, u = 0; u < 8; u++)
        s[u] !== 0 ? (c > o && (a = l, o = c), l = null, c = 0) : (l === null && (l = u), ++c);
      return c > o && (a = l, o = c), a;
    }(i), e = 0; e < 8; e++)
      r && i[e] === 0 || (r && (r = !1), n === e ? (t += e ? ":" : "::", r = !0) : (t += Zrt(i[e], 16), e < 7 && (t += ":")));
    return "[" + t + "]";
  }
  return i;
}, dv = {}, MB = eM({}, dv, { " ": 1, '"': 1, "<": 1, ">": 1, "`": 1 }), TB = eM({}, MB, { "#": 1, "?": 1, "{": 1, "}": 1 }), ew = eM({}, TB, { "/": 1, ":": 1, ";": 1, "=": 1, "@": 1, "[": 1, "\\": 1, "]": 1, "^": 1, "|": 1 }), wo = function(i, t) {
  var e = Nrt(i, 0);
  return e > 32 && e < 127 && !eb(t, i) ? i : encodeURIComponent(i);
}, gg = { ftp: 21, file: null, http: 80, https: 443, ws: 80, wss: 443 }, Md = function(i, t) {
  var e;
  return i.length === 2 && bs(SB, ns(i, 0)) && ((e = ns(i, 1)) === ":" || !t && e === "|");
}, oD = function(i) {
  var t;
  return i.length > 1 && Md(Sd(i, 0, 2)) && (i.length === 2 || (t = ns(i, 2)) === "/" || t === "\\" || t === "?" || t === "#");
}, ait = function(i) {
  return i === "." || uv(i) === "%2e";
}, nw = {}, lD = {}, rw = {}, cD = {}, hD = {}, iw = {}, uD = {}, dD = {}, vg = {}, yg = {}, sw = {}, aw = {}, ow = {}, lw = {}, pD = {}, cw = {}, Qc = {}, Us = {}, fD = {}, vl = {}, Ma = {}, nM = function(i, t, e) {
  var n, r, s, a = Ca(i);
  if (t) {
    if (r = this.parse(a))
      throw new nb(r);
    this.searchParams = null;
  } else {
    if (e !== void 0 && (n = new nM(e, !0)), r = this.parse(a, null, n))
      throw new nb(r);
    (s = Grt(new jrt())).bindURL(this), this.searchParams = s;
  }
};
nM.prototype = { type: "URL", parse: function(i, t, e) {
  var n, r, s, a, o, l = this, c = t || nw, u = 0, h = "", p = !1, f = !1, v = !1;
  for (i = Ca(i), t || (l.scheme = "", l.username = "", l.password = "", l.host = null, l.port = null, l.path = [], l.query = null, l.fragment = null, l.cannotBeABaseURL = !1, i = $1(i, rit, ""), i = $1(i, iit, "$1")), i = $1(i, sit, ""), n = Kc(i); u <= n.length; ) {
    switch (r = n[u], c) {
      case nw:
        if (!r || !bs(SB, r)) {
          if (t)
            return Q1;
          c = rw;
          continue;
        }
        h += uv(r), c = lD;
        break;
      case lD:
        if (r && (bs(Krt, r) || r === "+" || r === "-" || r === "."))
          h += uv(r);
        else {
          if (r !== ":") {
            if (t)
              return Q1;
            h = "", c = rw, u = 0;
            continue;
          }
          if (t && (l.isSpecial() !== eb(gg, h) || h === "file" && (l.includesCredentials() || l.port !== null) || l.scheme === "file" && !l.host))
            return;
          if (l.scheme = h, t)
            return void (l.isSpecial() && gg[l.scheme] === l.port && (l.port = null));
          h = "", l.scheme === "file" ? c = lw : l.isSpecial() && e && e.scheme === l.scheme ? c = cD : l.isSpecial() ? c = dD : n[u + 1] === "/" ? (c = hD, u++) : (l.cannotBeABaseURL = !0, $c(l.path, ""), c = fD);
        }
        break;
      case rw:
        if (!e || e.cannotBeABaseURL && r !== "#")
          return Q1;
        if (e.cannotBeABaseURL && r === "#") {
          l.scheme = e.scheme, l.path = ys(e.path), l.query = e.query, l.fragment = "", l.cannotBeABaseURL = !0, c = Ma;
          break;
        }
        c = e.scheme === "file" ? lw : iw;
        continue;
      case cD:
        if (r !== "/" || n[u + 1] !== "/") {
          c = iw;
          continue;
        }
        c = vg, u++;
        break;
      case hD:
        if (r === "/") {
          c = yg;
          break;
        }
        c = Us;
        continue;
      case iw:
        if (l.scheme = e.scheme, r === $i)
          l.username = e.username, l.password = e.password, l.host = e.host, l.port = e.port, l.path = ys(e.path), l.query = e.query;
        else if (r === "/" || r === "\\" && l.isSpecial())
          c = uD;
        else if (r === "?")
          l.username = e.username, l.password = e.password, l.host = e.host, l.port = e.port, l.path = ys(e.path), l.query = "", c = vl;
        else {
          if (r !== "#") {
            l.username = e.username, l.password = e.password, l.host = e.host, l.port = e.port, l.path = ys(e.path), l.path.length--, c = Us;
            continue;
          }
          l.username = e.username, l.password = e.password, l.host = e.host, l.port = e.port, l.path = ys(e.path), l.query = e.query, l.fragment = "", c = Ma;
        }
        break;
      case uD:
        if (!l.isSpecial() || r !== "/" && r !== "\\") {
          if (r !== "/") {
            l.username = e.username, l.password = e.password, l.host = e.host, l.port = e.port, c = Us;
            continue;
          }
          c = yg;
        } else
          c = vg;
        break;
      case dD:
        if (c = vg, r !== "/" || ns(h, u + 1) !== "/")
          continue;
        u++;
        break;
      case vg:
        if (r !== "/" && r !== "\\") {
          c = yg;
          continue;
        }
        break;
      case yg:
        if (r === "@") {
          p && (h = "%40" + h), p = !0, s = Kc(h);
          for (var m = 0; m < s.length; m++) {
            var y = s[m];
            if (y !== ":" || v) {
              var _ = wo(y, ew);
              v ? l.password += _ : l.username += _;
            } else
              v = !0;
          }
          h = "";
        } else if (r === $i || r === "/" || r === "?" || r === "#" || r === "\\" && l.isSpecial()) {
          if (p && h === "")
            return "Invalid authority";
          u -= Kc(h).length + 1, h = "", c = sw;
        } else
          h += r;
        break;
      case sw:
      case aw:
        if (t && l.scheme === "file") {
          c = cw;
          continue;
        }
        if (r !== ":" || f) {
          if (r === $i || r === "/" || r === "?" || r === "#" || r === "\\" && l.isSpecial()) {
            if (l.isSpecial() && h === "")
              return gl;
            if (t && h === "" && (l.includesCredentials() || l.port !== null))
              return;
            if (a = l.parseHost(h))
              return a;
            if (h = "", c = Qc, t)
              return;
            continue;
          }
          r === "[" ? f = !0 : r === "]" && (f = !1), h += r;
        } else {
          if (h === "")
            return gl;
          if (a = l.parseHost(h))
            return a;
          if (h = "", c = ow, t === aw)
            return;
        }
        break;
      case ow:
        if (!bs(tw, r)) {
          if (r === $i || r === "/" || r === "?" || r === "#" || r === "\\" && l.isSpecial() || t) {
            if (h !== "") {
              var w = mg(h, 10);
              if (w > 65535)
                return sD;
              l.port = l.isSpecial() && w === gg[l.scheme] ? null : w, h = "";
            }
            if (t)
              return;
            c = Qc;
            continue;
          }
          return sD;
        }
        h += r;
        break;
      case lw:
        if (l.scheme = "file", r === "/" || r === "\\")
          c = pD;
        else {
          if (!e || e.scheme !== "file") {
            c = Us;
            continue;
          }
          switch (r) {
            case $i:
              l.host = e.host, l.path = ys(e.path), l.query = e.query;
              break;
            case "?":
              l.host = e.host, l.path = ys(e.path), l.query = "", c = vl;
              break;
            case "#":
              l.host = e.host, l.path = ys(e.path), l.query = e.query, l.fragment = "", c = Ma;
              break;
            default:
              oD(bd(ys(n, u), "")) || (l.host = e.host, l.path = ys(e.path), l.shortenPath()), c = Us;
              continue;
          }
        }
        break;
      case pD:
        if (r === "/" || r === "\\") {
          c = cw;
          break;
        }
        e && e.scheme === "file" && !oD(bd(ys(n, u), "")) && (Md(e.path[0], !0) ? $c(l.path, e.path[0]) : l.host = e.host), c = Us;
        continue;
      case cw:
        if (r === $i || r === "/" || r === "\\" || r === "?" || r === "#") {
          if (!t && Md(h))
            c = Us;
          else if (h === "") {
            if (l.host = "", t)
              return;
            c = Qc;
          } else {
            if (a = l.parseHost(h))
              return a;
            if (l.host === "localhost" && (l.host = ""), t)
              return;
            h = "", c = Qc;
          }
          continue;
        }
        h += r;
        break;
      case Qc:
        if (l.isSpecial()) {
          if (c = Us, r !== "/" && r !== "\\")
            continue;
        } else if (t || r !== "?")
          if (t || r !== "#") {
            if (r !== $i && (c = Us, r !== "/"))
              continue;
          } else
            l.fragment = "", c = Ma;
        else
          l.query = "", c = vl;
        break;
      case Us:
        if (r === $i || r === "/" || r === "\\" && l.isSpecial() || !t && (r === "?" || r === "#")) {
          if ((o = uv(o = h)) === ".." || o === "%2e." || o === ".%2e" || o === "%2e%2e" ? (l.shortenPath(), r === "/" || r === "\\" && l.isSpecial() || $c(l.path, "")) : ait(h) ? r === "/" || r === "\\" && l.isSpecial() || $c(l.path, "") : (l.scheme === "file" && !l.path.length && Md(h) && (l.host && (l.host = ""), h = ns(h, 0) + ":"), $c(l.path, h)), h = "", l.scheme === "file" && (r === $i || r === "?" || r === "#"))
            for (; l.path.length > 1 && l.path[0] === ""; )
              Xrt(l.path);
          r === "?" ? (l.query = "", c = vl) : r === "#" && (l.fragment = "", c = Ma);
        } else
          h += wo(r, TB);
        break;
      case fD:
        r === "?" ? (l.query = "", c = vl) : r === "#" ? (l.fragment = "", c = Ma) : r !== $i && (l.path[0] += wo(r, dv));
        break;
      case vl:
        t || r !== "#" ? r !== $i && (r === "'" && l.isSpecial() ? l.query += "%27" : l.query += r === "#" ? "%23" : wo(r, dv)) : (l.fragment = "", c = Ma);
        break;
      case Ma:
        r !== $i && (l.fragment += wo(r, MB));
    }
    u++;
  }
}, parseHost: function(i) {
  var t, e, n;
  if (ns(i, 0) === "[") {
    if (ns(i, i.length - 1) !== "]" || (t = function(r) {
      var s, a, o, l, c, u, h, p = [0, 0, 0, 0, 0, 0, 0, 0], f = 0, v = null, m = 0, y = function() {
        return ns(r, m);
      };
      if (y() === ":") {
        if (ns(r, 1) !== ":")
          return;
        m += 2, v = ++f;
      }
      for (; y(); ) {
        if (f === 8)
          return;
        if (y() !== ":") {
          for (s = a = 0; a < 4 && bs(aD, y()); )
            s = 16 * s + mg(y(), 16), m++, a++;
          if (y() === ".") {
            if (a === 0 || (m -= a, f > 6))
              return;
            for (o = 0; y(); ) {
              if (l = null, o > 0) {
                if (!(y() === "." && o < 4))
                  return;
                m++;
              }
              if (!bs(tw, y()))
                return;
              for (; bs(tw, y()); ) {
                if (c = mg(y(), 10), l === null)
                  l = c;
                else {
                  if (l === 0)
                    return;
                  l = 10 * l + c;
                }
                if (l > 255)
                  return;
                m++;
              }
              p[f] = 256 * p[f] + l, ++o != 2 && o !== 4 || f++;
            }
            if (o !== 4)
              return;
            break;
          }
          if (y() === ":") {
            if (m++, !y())
              return;
          } else if (y())
            return;
          p[f++] = s;
        } else {
          if (v !== null)
            return;
          m++, v = ++f;
        }
      }
      if (v !== null)
        for (u = f - v, f = 7; f !== 0 && u > 0; )
          h = p[f], p[f--] = p[v + u - 1], p[v + --u] = h;
      else if (f !== 8)
        return;
      return p;
    }(Sd(i, 1, -1)), !t))
      return gl;
    this.host = t;
  } else if (this.isSpecial()) {
    if (i = Frt(i), bs(eit, i) || (t = function(r) {
      var s, a, o, l, c, u, h, p = Yrt(r, ".");
      if (p.length && p[p.length - 1] === "" && p.length--, (s = p.length) > 4)
        return r;
      for (a = [], o = 0; o < s; o++) {
        if ((l = p[o]) === "")
          return r;
        if (c = 10, l.length > 1 && ns(l, 0) === "0" && (c = bs($rt, l) ? 16 : 8, l = Sd(l, c === 8 ? 1 : 2)), l === "")
          u = 0;
        else {
          if (!bs(c === 10 ? tit : c === 8 ? Qrt : aD, l))
            return r;
          u = mg(l, c);
        }
        $c(a, u);
      }
      for (o = 0; o < s; o++)
        if (u = a[o], o === s - 1) {
          if (u >= iD(256, 5 - s))
            return null;
        } else if (u > 255)
          return null;
      for (h = qrt(a), o = 0; o < a.length; o++)
        h += a[o] * iD(256, 3 - o);
      return h;
    }(i), t === null))
      return gl;
    this.host = t;
  } else {
    if (bs(nit, i))
      return gl;
    for (t = "", e = Kc(i), n = 0; n < e.length; n++)
      t += wo(e[n], dv);
    this.host = t;
  }
}, cannotHaveUsernamePasswordPort: function() {
  return !this.host || this.cannotBeABaseURL || this.scheme === "file";
}, includesCredentials: function() {
  return this.username !== "" || this.password !== "";
}, isSpecial: function() {
  return eb(gg, this.scheme);
}, shortenPath: function() {
  var i = this.path, t = i.length;
  !t || this.scheme === "file" && t === 1 && Md(i[0], !0) || i.length--;
}, serialize: function() {
  var i = this, t = i.scheme, e = i.username, n = i.password, r = i.host, s = i.port, a = i.path, o = i.query, l = i.fragment, c = t + ":";
  return r !== null ? (c += "//", i.includesCredentials() && (c += e + (n ? ":" + n : "") + "@"), c += ld(r), s !== null && (c += ":" + s)) : t === "file" && (c += "//"), c += i.cannotBeABaseURL ? a[0] : a.length ? "/" + bd(a, "/") : "", o !== null && (c += "?" + o), l !== null && (c += "#" + l), c;
}, setHref: function(i) {
  var t = this.parse(i);
  if (t)
    throw new nb(t);
  this.searchParams.update();
}, getOrigin: function() {
  var i = this.scheme, t = this.port;
  if (i === "blob")
    try {
      return new Yh(i.path[0]).origin;
    } catch {
      return "null";
    }
  return i !== "file" && this.isSpecial() ? i + "://" + ld(this.host) + (t !== null ? ":" + t : "") : "null";
}, getProtocol: function() {
  return this.scheme + ":";
}, setProtocol: function(i) {
  this.parse(Ca(i) + ":", nw);
}, getUsername: function() {
  return this.username;
}, setUsername: function(i) {
  var t = Kc(Ca(i));
  if (!this.cannotHaveUsernamePasswordPort()) {
    this.username = "";
    for (var e = 0; e < t.length; e++)
      this.username += wo(t[e], ew);
  }
}, getPassword: function() {
  return this.password;
}, setPassword: function(i) {
  var t = Kc(Ca(i));
  if (!this.cannotHaveUsernamePasswordPort()) {
    this.password = "";
    for (var e = 0; e < t.length; e++)
      this.password += wo(t[e], ew);
  }
}, getHost: function() {
  var i = this.host, t = this.port;
  return i === null ? "" : t === null ? ld(i) : ld(i) + ":" + t;
}, setHost: function(i) {
  this.cannotBeABaseURL || this.parse(i, sw);
}, getHostname: function() {
  var i = this.host;
  return i === null ? "" : ld(i);
}, setHostname: function(i) {
  this.cannotBeABaseURL || this.parse(i, aw);
}, getPort: function() {
  var i = this.port;
  return i === null ? "" : Ca(i);
}, setPort: function(i) {
  this.cannotHaveUsernamePasswordPort() || ((i = Ca(i)) === "" ? this.port = null : this.parse(i, ow));
}, getPathname: function() {
  var i = this.path;
  return this.cannotBeABaseURL ? i[0] : i.length ? "/" + bd(i, "/") : "";
}, setPathname: function(i) {
  this.cannotBeABaseURL || (this.path = [], this.parse(i, Qc));
}, getSearch: function() {
  var i = this.query;
  return i ? "?" + i : "";
}, setSearch: function(i) {
  (i = Ca(i)) === "" ? this.query = null : (ns(i, 0) === "?" && (i = Sd(i, 1)), this.query = "", this.parse(i, vl)), this.searchParams.update();
}, getSearchParams: function() {
  return this.searchParams.facade;
}, getHash: function() {
  var i = this.fragment;
  return i ? "#" + i : "";
}, setHash: function(i) {
  (i = Ca(i)) !== "" ? (ns(i, 0) === "#" && (i = Sd(i, 1)), this.fragment = "", this.parse(i, Ma)) : this.fragment = null;
}, update: function() {
  this.query = this.searchParams.serialize() || null;
} };
var Yh = function(i) {
  var t = krt(this, si), e = Vrt(arguments.length, 1) > 1 ? arguments[1] : void 0, n = Hrt(t, new nM(i, !1, e));
  QS || (t.href = n.serialize(), t.origin = n.getOrigin(), t.protocol = n.getProtocol(), t.username = n.getUsername(), t.password = n.getPassword(), t.host = n.getHost(), t.hostname = n.getHostname(), t.port = n.getPort(), t.pathname = n.getPathname(), t.search = n.getSearch(), t.searchParams = n.getSearchParams(), t.hash = n.getHash());
}, si = Yh.prototype, ts = function(i, t) {
  return { get: function() {
    return Xv(this)[i]();
  }, set: t && function(e) {
    return Xv(this)[t](e);
  }, configurable: !0, enumerable: !0 };
};
if (QS && (Qi(si, "href", ts("serialize", "setHref")), Qi(si, "origin", ts("getOrigin")), Qi(si, "protocol", ts("getProtocol", "setProtocol")), Qi(si, "username", ts("getUsername", "setUsername")), Qi(si, "password", ts("getPassword", "setPassword")), Qi(si, "host", ts("getHost", "setHost")), Qi(si, "hostname", ts("getHostname", "setHostname")), Qi(si, "port", ts("getPort", "setPort")), Qi(si, "pathname", ts("getPathname", "setPathname")), Qi(si, "search", ts("getSearch", "setSearch")), Qi(si, "searchParams", ts("getSearchParams")), Qi(si, "hash", ts("getHash", "setHash"))), fg(si, "toJSON", function() {
  return Xv(this).serialize();
}, { enumerable: !0 }), fg(si, "toString", function() {
  return Xv(this).serialize();
}, { enumerable: !0 }), od) {
  var mD = od.createObjectURL, gD = od.revokeObjectURL;
  mD && fg(Yh, "createObjectURL", rD(mD, od)), gD && fg(Yh, "revokeObjectURL", rD(gD, od));
}
Urt(Yh, "URL"), Brt({ global: !0, constructor: !0, forced: !zrt, sham: !QS }, { URL: Yh });
var oit = Ne;
zt({ target: "URL", proto: !0, enumerable: !0 }, { toJSON: function() {
  return oit(URL.prototype.toString, this);
} });
var rb = { exports: {} };
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
(function(i, t) {
  (function() {
    var e, n = "Expected a function", r = "__lodash_hash_undefined__", s = "__lodash_placeholder__", a = 16, o = 32, l = 64, c = 128, u = 256, h = 1 / 0, p = 9007199254740991, f = NaN, v = 4294967295, m = [["ary", c], ["bind", 1], ["bindKey", 2], ["curry", 8], ["curryRight", a], ["flip", 512], ["partial", o], ["partialRight", l], ["rearg", u]], y = "[object Arguments]", _ = "[object Array]", w = "[object Boolean]", b = "[object Date]", T = "[object Error]", M = "[object Function]", A = "[object GeneratorFunction]", C = "[object Map]", I = "[object Number]", k = "[object Object]", R = "[object Promise]", L = "[object RegExp]", E = "[object Set]", q = "[object String]", it = "[object Symbol]", rt = "[object WeakMap]", ft = "[object ArrayBuffer]", nt = "[object DataView]", vt = "[object Float32Array]", $ = "[object Float64Array]", W = "[object Int8Array]", ct = "[object Int16Array]", mt = "[object Int32Array]", dt = "[object Uint8Array]", Mt = "[object Uint8ClampedArray]", At = "[object Uint16Array]", H = "[object Uint32Array]", N = /\b__p \+= '';/g, st = /\b(__p \+=) '' \+/g, et = /(__e\(.*?\)|\b__t\)) \+\n'';/g, J = /&(?:amp|lt|gt|quot|#39);/g, K = /[&<>"']/g, S = RegExp(J.source), Z = RegExp(K.source), G = /<%-([\s\S]+?)%>/g, F = /<%([\s\S]+?)%>/g, z = /<%=([\s\S]+?)%>/g, Y = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, pt = /^\w*$/, ht = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, lt = /[\\^$.*+?()[\]{}|]/g, yt = RegExp(lt.source), O = /^\s+/, V = /\s/, tt = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, gt = /\{\n\/\* \[wrapped with (.+)\] \*/, Tt = /,? & /, ot = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g, St = /[()=,{}\[\]\/\s]/, It = /\\(\\)?/g, xt = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g, Ft = /\w*$/, Kt = /^[-+]0x[0-9a-f]+$/i, jt = /^0b[01]+$/i, qt = /^\[object .+?Constructor\]$/, $t = /^0o[0-7]+$/i, fe = /^(?:0|[1-9]\d*)$/, Yt = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, te = /($^)/, oe = /['\n\r\u2028\u2029\\]/g, ce = "\\ud800-\\udfff", Ve = "\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff", sn = "\\u2700-\\u27bf", he = "a-z\\xdf-\\xf6\\xf8-\\xff", Te = "A-Z\\xc0-\\xd6\\xd8-\\xde", Tn = "\\ufe0e\\ufe0f", Kn = "\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", cr = "['’]", Q = "[" + ce + "]", Et = "[" + Kn + "]", Pt = "[" + Ve + "]", Dt = "\\d+", kt = "[" + sn + "]", re = "[" + he + "]", we = "[^" + ce + Kn + Dt + sn + he + Te + "]", de = "\\ud83c[\\udffb-\\udfff]", Re = "[^" + ce + "]", Ge = "(?:\\ud83c[\\udde6-\\uddff]){2}", ie = "[\\ud800-\\udbff][\\udc00-\\udfff]", xe = "[" + Te + "]", _n = "\\u200d", cn = "(?:" + re + "|" + we + ")", be = "(?:" + xe + "|" + we + ")", We = "(?:['’](?:d|ll|m|re|s|t|ve))?", Qe = "(?:['’](?:D|LL|M|RE|S|T|VE))?", wn = "(?:" + Pt + "|" + de + ")?", $n = "[" + Tn + "]?", hr = $n + wn + ("(?:" + _n + "(?:" + [Re, Ge, ie].join("|") + ")" + $n + wn + ")*"), Se = "(?:" + [kt, Ge, ie].join("|") + ")" + hr, ar = "(?:" + [Re + Pt + "?", Pt, Ge, ie, Q].join("|") + ")", vu = RegExp(cr, "g"), O0 = RegExp(Pt, "g"), yu = RegExp(de + "(?=" + de + ")|" + ar + hr, "g"), lc = RegExp([xe + "?" + re + "+" + We + "(?=" + [Et, xe, "$"].join("|") + ")", be + "+" + Qe + "(?=" + [Et, xe + cn, "$"].join("|") + ")", xe + "?" + cn + "+" + We, xe + "+" + Qe, "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", Dt, Se].join("|"), "g"), L0 = RegExp("[" + _n + ce + Ve + Tn + "]"), B0 = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/, z0 = ["Array", "Buffer", "DataView", "Date", "Error", "Float32Array", "Float64Array", "Function", "Int8Array", "Int16Array", "Int32Array", "Map", "Math", "Object", "Promise", "RegExp", "Set", "String", "Symbol", "TypeError", "Uint8Array", "Uint8ClampedArray", "Uint16Array", "Uint32Array", "WeakMap", "_", "clearTimeout", "isFinite", "parseInt", "setTimeout"], k0 = -1, fn = {};
    fn[vt] = fn[$] = fn[W] = fn[ct] = fn[mt] = fn[dt] = fn[Mt] = fn[At] = fn[H] = !0, fn[y] = fn[_] = fn[ft] = fn[w] = fn[nt] = fn[b] = fn[T] = fn[M] = fn[C] = fn[I] = fn[k] = fn[L] = fn[E] = fn[q] = fn[rt] = !1;
    var hn = {};
    hn[y] = hn[_] = hn[ft] = hn[nt] = hn[w] = hn[b] = hn[vt] = hn[$] = hn[W] = hn[ct] = hn[mt] = hn[C] = hn[I] = hn[k] = hn[L] = hn[E] = hn[q] = hn[it] = hn[dt] = hn[Mt] = hn[At] = hn[H] = !0, hn[T] = hn[M] = hn[rt] = !1;
    var Zp = { "\\": "\\", "'": "'", "\n": "n", "\r": "r", "\u2028": "u2028", "\u2029": "u2029" }, N0 = parseFloat, en = parseInt, qp = typeof bn == "object" && bn && bn.Object === Object && bn, us = typeof self == "object" && self && self.Object === Object && self, En = qp || us || Function("return this")(), cc = t && !t.nodeType && t, Ei = cc && i && !i.nodeType && i, hc = Ei && Ei.exports === cc, ur = hc && qp.process, or = function() {
      try {
        var bt = Ei && Ei.require && Ei.require("util").types;
        return bt || ur && ur.binding && ur.binding("util");
      } catch {
      }
    }(), uc = or && or.isArrayBuffer, Ai = or && or.isDate, mi = or && or.isMap, zr = or && or.isRegExp, dc = or && or.isSet, Xp = or && or.isTypedArray;
    function kr(bt, Bt, Ct) {
      switch (Ct.length) {
        case 0:
          return bt.call(Bt);
        case 1:
          return bt.call(Bt, Ct[0]);
        case 2:
          return bt.call(Bt, Ct[0], Ct[1]);
        case 3:
          return bt.call(Bt, Ct[0], Ct[1], Ct[2]);
      }
      return bt.apply(Bt, Ct);
    }
    function n4(bt, Bt, Ct, le) {
      for (var Ee = -1, qe = bt == null ? 0 : bt.length; ++Ee < qe; ) {
        var Un = bt[Ee];
        Bt(le, Un, Ct(Un), bt);
      }
      return le;
    }
    function Gi(bt, Bt) {
      for (var Ct = -1, le = bt == null ? 0 : bt.length; ++Ct < le && Bt(bt[Ct], Ct, bt) !== !1; )
        ;
      return bt;
    }
    function r4(bt, Bt) {
      for (var Ct = bt == null ? 0 : bt.length; Ct-- && Bt(bt[Ct], Ct, bt) !== !1; )
        ;
      return bt;
    }
    function xM(bt, Bt) {
      for (var Ct = -1, le = bt == null ? 0 : bt.length; ++Ct < le; )
        if (!Bt(bt[Ct], Ct, bt))
          return !1;
      return !0;
    }
    function to(bt, Bt) {
      for (var Ct = -1, le = bt == null ? 0 : bt.length, Ee = 0, qe = []; ++Ct < le; ) {
        var Un = bt[Ct];
        Bt(Un, Ct, bt) && (qe[Ee++] = Un);
      }
      return qe;
    }
    function Yp(bt, Bt) {
      return !!(bt != null && bt.length) && pc(bt, Bt, 0) > -1;
    }
    function F0(bt, Bt, Ct) {
      for (var le = -1, Ee = bt == null ? 0 : bt.length; ++le < Ee; )
        if (Ct(Bt, bt[le]))
          return !0;
      return !1;
    }
    function In(bt, Bt) {
      for (var Ct = -1, le = bt == null ? 0 : bt.length, Ee = Array(le); ++Ct < le; )
        Ee[Ct] = Bt(bt[Ct], Ct, bt);
      return Ee;
    }
    function eo(bt, Bt) {
      for (var Ct = -1, le = Bt.length, Ee = bt.length; ++Ct < le; )
        bt[Ee + Ct] = Bt[Ct];
      return bt;
    }
    function U0(bt, Bt, Ct, le) {
      var Ee = -1, qe = bt == null ? 0 : bt.length;
      for (le && qe && (Ct = bt[++Ee]); ++Ee < qe; )
        Ct = Bt(Ct, bt[Ee], Ee, bt);
      return Ct;
    }
    function i4(bt, Bt, Ct, le) {
      var Ee = bt == null ? 0 : bt.length;
      for (le && Ee && (Ct = bt[--Ee]); Ee--; )
        Ct = Bt(Ct, bt[Ee], Ee, bt);
      return Ct;
    }
    function V0(bt, Bt) {
      for (var Ct = -1, le = bt == null ? 0 : bt.length; ++Ct < le; )
        if (Bt(bt[Ct], Ct, bt))
          return !0;
      return !1;
    }
    var s4 = H0("length");
    function bM(bt, Bt, Ct) {
      var le;
      return Ct(bt, function(Ee, qe, Un) {
        if (Bt(Ee, qe, Un))
          return le = qe, !1;
      }), le;
    }
    function Jp(bt, Bt, Ct, le) {
      for (var Ee = bt.length, qe = Ct + (le ? 1 : -1); le ? qe-- : ++qe < Ee; )
        if (Bt(bt[qe], qe, bt))
          return qe;
      return -1;
    }
    function pc(bt, Bt, Ct) {
      return Bt == Bt ? function(le, Ee, qe) {
        for (var Un = qe - 1, an = le.length; ++Un < an; )
          if (le[Un] === Ee)
            return Un;
        return -1;
      }(bt, Bt, Ct) : Jp(bt, SM, Ct);
    }
    function a4(bt, Bt, Ct, le) {
      for (var Ee = Ct - 1, qe = bt.length; ++Ee < qe; )
        if (le(bt[Ee], Bt))
          return Ee;
      return -1;
    }
    function SM(bt) {
      return bt != bt;
    }
    function MM(bt, Bt) {
      var Ct = bt == null ? 0 : bt.length;
      return Ct ? G0(bt, Bt) / Ct : f;
    }
    function H0(bt) {
      return function(Bt) {
        return Bt == null ? e : Bt[bt];
      };
    }
    function j0(bt) {
      return function(Bt) {
        return bt == null ? e : bt[Bt];
      };
    }
    function TM(bt, Bt, Ct, le, Ee) {
      return Ee(bt, function(qe, Un, an) {
        Ct = le ? (le = !1, qe) : Bt(Ct, qe, Un, an);
      }), Ct;
    }
    function G0(bt, Bt) {
      for (var Ct, le = -1, Ee = bt.length; ++le < Ee; ) {
        var qe = Bt(bt[le]);
        qe !== e && (Ct = Ct === e ? qe : Ct + qe);
      }
      return Ct;
    }
    function W0(bt, Bt) {
      for (var Ct = -1, le = Array(bt); ++Ct < bt; )
        le[Ct] = Bt(Ct);
      return le;
    }
    function EM(bt) {
      return bt && bt.slice(0, DM(bt) + 1).replace(O, "");
    }
    function Ci(bt) {
      return function(Bt) {
        return bt(Bt);
      };
    }
    function Z0(bt, Bt) {
      return In(Bt, function(Ct) {
        return bt[Ct];
      });
    }
    function _u(bt, Bt) {
      return bt.has(Bt);
    }
    function AM(bt, Bt) {
      for (var Ct = -1, le = bt.length; ++Ct < le && pc(Bt, bt[Ct], 0) > -1; )
        ;
      return Ct;
    }
    function CM(bt, Bt) {
      for (var Ct = bt.length; Ct-- && pc(Bt, bt[Ct], 0) > -1; )
        ;
      return Ct;
    }
    var o4 = j0({ À: "A", Á: "A", Â: "A", Ã: "A", Ä: "A", Å: "A", à: "a", á: "a", â: "a", ã: "a", ä: "a", å: "a", Ç: "C", ç: "c", Ð: "D", ð: "d", È: "E", É: "E", Ê: "E", Ë: "E", è: "e", é: "e", ê: "e", ë: "e", Ì: "I", Í: "I", Î: "I", Ï: "I", ì: "i", í: "i", î: "i", ï: "i", Ñ: "N", ñ: "n", Ò: "O", Ó: "O", Ô: "O", Õ: "O", Ö: "O", Ø: "O", ò: "o", ó: "o", ô: "o", õ: "o", ö: "o", ø: "o", Ù: "U", Ú: "U", Û: "U", Ü: "U", ù: "u", ú: "u", û: "u", ü: "u", Ý: "Y", ý: "y", ÿ: "y", Æ: "Ae", æ: "ae", Þ: "Th", þ: "th", ß: "ss", Ā: "A", Ă: "A", Ą: "A", ā: "a", ă: "a", ą: "a", Ć: "C", Ĉ: "C", Ċ: "C", Č: "C", ć: "c", ĉ: "c", ċ: "c", č: "c", Ď: "D", Đ: "D", ď: "d", đ: "d", Ē: "E", Ĕ: "E", Ė: "E", Ę: "E", Ě: "E", ē: "e", ĕ: "e", ė: "e", ę: "e", ě: "e", Ĝ: "G", Ğ: "G", Ġ: "G", Ģ: "G", ĝ: "g", ğ: "g", ġ: "g", ģ: "g", Ĥ: "H", Ħ: "H", ĥ: "h", ħ: "h", Ĩ: "I", Ī: "I", Ĭ: "I", Į: "I", İ: "I", ĩ: "i", ī: "i", ĭ: "i", į: "i", ı: "i", Ĵ: "J", ĵ: "j", Ķ: "K", ķ: "k", ĸ: "k", Ĺ: "L", Ļ: "L", Ľ: "L", Ŀ: "L", Ł: "L", ĺ: "l", ļ: "l", ľ: "l", ŀ: "l", ł: "l", Ń: "N", Ņ: "N", Ň: "N", Ŋ: "N", ń: "n", ņ: "n", ň: "n", ŋ: "n", Ō: "O", Ŏ: "O", Ő: "O", ō: "o", ŏ: "o", ő: "o", Ŕ: "R", Ŗ: "R", Ř: "R", ŕ: "r", ŗ: "r", ř: "r", Ś: "S", Ŝ: "S", Ş: "S", Š: "S", ś: "s", ŝ: "s", ş: "s", š: "s", Ţ: "T", Ť: "T", Ŧ: "T", ţ: "t", ť: "t", ŧ: "t", Ũ: "U", Ū: "U", Ŭ: "U", Ů: "U", Ű: "U", Ų: "U", ũ: "u", ū: "u", ŭ: "u", ů: "u", ű: "u", ų: "u", Ŵ: "W", ŵ: "w", Ŷ: "Y", ŷ: "y", Ÿ: "Y", Ź: "Z", Ż: "Z", Ž: "Z", ź: "z", ż: "z", ž: "z", Ĳ: "IJ", ĳ: "ij", Œ: "Oe", œ: "oe", ŉ: "'n", ſ: "s" }), l4 = j0({ "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" });
    function c4(bt) {
      return "\\" + Zp[bt];
    }
    function fc(bt) {
      return L0.test(bt);
    }
    function q0(bt) {
      var Bt = -1, Ct = Array(bt.size);
      return bt.forEach(function(le, Ee) {
        Ct[++Bt] = [Ee, le];
      }), Ct;
    }
    function PM(bt, Bt) {
      return function(Ct) {
        return bt(Bt(Ct));
      };
    }
    function no(bt, Bt) {
      for (var Ct = -1, le = bt.length, Ee = 0, qe = []; ++Ct < le; ) {
        var Un = bt[Ct];
        Un !== Bt && Un !== s || (bt[Ct] = s, qe[Ee++] = Ct);
      }
      return qe;
    }
    function Kp(bt) {
      var Bt = -1, Ct = Array(bt.size);
      return bt.forEach(function(le) {
        Ct[++Bt] = le;
      }), Ct;
    }
    function h4(bt) {
      var Bt = -1, Ct = Array(bt.size);
      return bt.forEach(function(le) {
        Ct[++Bt] = [le, le];
      }), Ct;
    }
    function mc(bt) {
      return fc(bt) ? function(Bt) {
        for (var Ct = yu.lastIndex = 0; yu.test(Bt); )
          ++Ct;
        return Ct;
      }(bt) : s4(bt);
    }
    function ds(bt) {
      return fc(bt) ? function(Bt) {
        return Bt.match(yu) || [];
      }(bt) : function(Bt) {
        return Bt.split("");
      }(bt);
    }
    function DM(bt) {
      for (var Bt = bt.length; Bt-- && V.test(bt.charAt(Bt)); )
        ;
      return Bt;
    }
    var u4 = j0({ "&amp;": "&", "&lt;": "<", "&gt;": ">", "&quot;": '"', "&#39;": "'" }), gc = function bt(Bt) {
      var Ct = (Bt = Bt == null ? En : gc.defaults(En.Object(), Bt, gc.pick(En, z0))).Array, le = Bt.Date, Ee = Bt.Error, qe = Bt.Function, Un = Bt.Math, an = Bt.Object, X0 = Bt.RegExp, d4 = Bt.String, Wi = Bt.TypeError, $p = Ct.prototype, p4 = qe.prototype, vc = an.prototype, Qp = Bt["__core-js_shared__"], tf = p4.toString, on = vc.hasOwnProperty, f4 = 0, RM = function() {
        var d = /[^.]+$/.exec(Qp && Qp.keys && Qp.keys.IE_PROTO || "");
        return d ? "Symbol(src)_1." + d : "";
      }(), ef = vc.toString, m4 = tf.call(an), g4 = En._, v4 = X0("^" + tf.call(on).replace(lt, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"), nf = hc ? Bt.Buffer : e, ro = Bt.Symbol, rf = Bt.Uint8Array, IM = nf ? nf.allocUnsafe : e, sf = PM(an.getPrototypeOf, an), OM = an.create, LM = vc.propertyIsEnumerable, af = $p.splice, BM = ro ? ro.isConcatSpreadable : e, wu = ro ? ro.iterator : e, Yo = ro ? ro.toStringTag : e, of = function() {
        try {
          var d = tl(an, "defineProperty");
          return d({}, "", {}), d;
        } catch {
        }
      }(), y4 = Bt.clearTimeout !== En.clearTimeout && Bt.clearTimeout, _4 = le && le.now !== En.Date.now && le.now, w4 = Bt.setTimeout !== En.setTimeout && Bt.setTimeout, lf = Un.ceil, cf = Un.floor, Y0 = an.getOwnPropertySymbols, x4 = nf ? nf.isBuffer : e, zM = Bt.isFinite, b4 = $p.join, S4 = PM(an.keys, an), dr = Un.max, Nr = Un.min, M4 = le.now, T4 = Bt.parseInt, kM = Un.random, E4 = $p.reverse, J0 = tl(Bt, "DataView"), xu = tl(Bt, "Map"), K0 = tl(Bt, "Promise"), yc = tl(Bt, "Set"), bu = tl(Bt, "WeakMap"), Su = tl(an, "create"), hf = bu && new bu(), _c = {}, A4 = el(J0), C4 = el(xu), P4 = el(K0), D4 = el(yc), R4 = el(bu), uf = ro ? ro.prototype : e, Mu = uf ? uf.valueOf : e, NM = uf ? uf.toString : e;
      function j(d) {
        if (qn(d) && !Ce(d) && !(d instanceof He)) {
          if (d instanceof Zi)
            return d;
          if (on.call(d, "__wrapped__"))
            return F2(d);
        }
        return new Zi(d);
      }
      var wc = function() {
        function d() {
        }
        return function(g) {
          if (!Vn(g))
            return {};
          if (OM)
            return OM(g);
          d.prototype = g;
          var x = new d();
          return d.prototype = e, x;
        };
      }();
      function df() {
      }
      function Zi(d, g) {
        this.__wrapped__ = d, this.__actions__ = [], this.__chain__ = !!g, this.__index__ = 0, this.__values__ = e;
      }
      function He(d) {
        this.__wrapped__ = d, this.__actions__ = [], this.__dir__ = 1, this.__filtered__ = !1, this.__iteratees__ = [], this.__takeCount__ = v, this.__views__ = [];
      }
      function Jo(d) {
        var g = -1, x = d == null ? 0 : d.length;
        for (this.clear(); ++g < x; ) {
          var P = d[g];
          this.set(P[0], P[1]);
        }
      }
      function oa(d) {
        var g = -1, x = d == null ? 0 : d.length;
        for (this.clear(); ++g < x; ) {
          var P = d[g];
          this.set(P[0], P[1]);
        }
      }
      function la(d) {
        var g = -1, x = d == null ? 0 : d.length;
        for (this.clear(); ++g < x; ) {
          var P = d[g];
          this.set(P[0], P[1]);
        }
      }
      function Ko(d) {
        var g = -1, x = d == null ? 0 : d.length;
        for (this.__data__ = new la(); ++g < x; )
          this.add(d[g]);
      }
      function ps(d) {
        var g = this.__data__ = new oa(d);
        this.size = g.size;
      }
      function FM(d, g) {
        var x = Ce(d), P = !x && nl(d), B = !x && !P && lo(d), X = !x && !P && !B && Mc(d), at = x || P || B || X, ut = at ? W0(d.length, d4) : [], _t = ut.length;
        for (var Ot in d)
          !g && !on.call(d, Ot) || at && (Ot == "length" || B && (Ot == "offset" || Ot == "parent") || X && (Ot == "buffer" || Ot == "byteLength" || Ot == "byteOffset") || da(Ot, _t)) || ut.push(Ot);
        return ut;
      }
      function UM(d) {
        var g = d.length;
        return g ? d[ly(0, g - 1)] : e;
      }
      function I4(d, g) {
        return Ef(gi(d), $o(g, 0, d.length));
      }
      function O4(d) {
        return Ef(gi(d));
      }
      function $0(d, g, x) {
        (x !== e && !fs(d[g], x) || x === e && !(g in d)) && ca(d, g, x);
      }
      function Tu(d, g, x) {
        var P = d[g];
        on.call(d, g) && fs(P, x) && (x !== e || g in d) || ca(d, g, x);
      }
      function pf(d, g) {
        for (var x = d.length; x--; )
          if (fs(d[x][0], g))
            return x;
        return -1;
      }
      function L4(d, g, x, P) {
        return io(d, function(B, X, at) {
          g(P, B, x(B), at);
        }), P;
      }
      function VM(d, g) {
        return d && zs(g, yr(g), d);
      }
      function ca(d, g, x) {
        g == "__proto__" && of ? of(d, g, { configurable: !0, enumerable: !0, value: x, writable: !0 }) : d[g] = x;
      }
      function Q0(d, g) {
        for (var x = -1, P = g.length, B = Ct(P), X = d == null; ++x < P; )
          B[x] = X ? e : Oy(d, g[x]);
        return B;
      }
      function $o(d, g, x) {
        return d == d && (x !== e && (d = d <= x ? d : x), g !== e && (d = d >= g ? d : g)), d;
      }
      function qi(d, g, x, P, B, X) {
        var at, ut = 1 & g, _t = 2 & g, Ot = 4 & g;
        if (x && (at = B ? x(d, P, B, X) : x(d)), at !== e)
          return at;
        if (!Vn(d))
          return d;
        var Rt = Ce(d);
        if (Rt) {
          if (at = function(Lt) {
            var Gt = Lt.length, ve = new Lt.constructor(Gt);
            return Gt && typeof Lt[0] == "string" && on.call(Lt, "index") && (ve.index = Lt.index, ve.input = Lt.input), ve;
          }(d), !ut)
            return gi(d, at);
        } else {
          var Ut = Fr(d), ne = Ut == M || Ut == A;
          if (lo(d))
            return u2(d, ut);
          if (Ut == k || Ut == y || ne && !B) {
            if (at = _t || ne ? {} : D2(d), !ut)
              return _t ? function(Lt, Gt) {
                return zs(Lt, C2(Lt), Gt);
              }(d, function(Lt, Gt) {
                return Lt && zs(Gt, yi(Gt), Lt);
              }(at, d)) : function(Lt, Gt) {
                return zs(Lt, by(Lt), Gt);
              }(d, VM(at, d));
          } else {
            if (!hn[Ut])
              return B ? d : {};
            at = function(Lt, Gt, ve) {
              var Jt = Lt.constructor;
              switch (Gt) {
                case ft:
                  return my(Lt);
                case w:
                case b:
                  return new Jt(+Lt);
                case nt:
                  return function(Me, Je) {
                    var ue = Je ? my(Me.buffer) : Me.buffer;
                    return new Me.constructor(ue, Me.byteOffset, Me.byteLength);
                  }(Lt, ve);
                case vt:
                case $:
                case W:
                case ct:
                case mt:
                case dt:
                case Mt:
                case At:
                case H:
                  return d2(Lt, ve);
                case C:
                  return new Jt();
                case I:
                case q:
                  return new Jt(Lt);
                case L:
                  return function(Me) {
                    var Je = new Me.constructor(Me.source, Ft.exec(Me));
                    return Je.lastIndex = Me.lastIndex, Je;
                  }(Lt);
                case E:
                  return new Jt();
                case it:
                  return Pe = Lt, Mu ? an(Mu.call(Pe)) : {};
              }
              var Pe;
            }(d, Ut, ut);
          }
        }
        X || (X = new ps());
        var se = X.get(d);
        if (se)
          return se;
        X.set(d, at), rT(d) ? d.forEach(function(Lt) {
          at.add(qi(Lt, g, x, Lt, d, X));
        }) : eT(d) && d.forEach(function(Lt, Gt) {
          at.set(Gt, qi(Lt, g, x, Gt, d, X));
        });
        var me = Rt ? e : (Ot ? _t ? _y : yy : _t ? yi : yr)(d);
        return Gi(me || d, function(Lt, Gt) {
          me && (Lt = d[Gt = Lt]), Tu(at, Gt, qi(Lt, g, x, Gt, d, X));
        }), at;
      }
      function HM(d, g, x) {
        var P = x.length;
        if (d == null)
          return !P;
        for (d = an(d); P--; ) {
          var B = x[P], X = g[B], at = d[B];
          if (at === e && !(B in d) || !X(at))
            return !1;
        }
        return !0;
      }
      function jM(d, g, x) {
        if (typeof d != "function")
          throw new Wi(n);
        return Iu(function() {
          d.apply(e, x);
        }, g);
      }
      function Eu(d, g, x, P) {
        var B = -1, X = Yp, at = !0, ut = d.length, _t = [], Ot = g.length;
        if (!ut)
          return _t;
        x && (g = In(g, Ci(x))), P ? (X = F0, at = !1) : g.length >= 200 && (X = _u, at = !1, g = new Ko(g));
        t:
          for (; ++B < ut; ) {
            var Rt = d[B], Ut = x == null ? Rt : x(Rt);
            if (Rt = P || Rt !== 0 ? Rt : 0, at && Ut == Ut) {
              for (var ne = Ot; ne--; )
                if (g[ne] === Ut)
                  continue t;
              _t.push(Rt);
            } else
              X(g, Ut, P) || _t.push(Rt);
          }
        return _t;
      }
      j.templateSettings = { escape: G, evaluate: F, interpolate: z, variable: "", imports: { _: j } }, j.prototype = df.prototype, j.prototype.constructor = j, Zi.prototype = wc(df.prototype), Zi.prototype.constructor = Zi, He.prototype = wc(df.prototype), He.prototype.constructor = He, Jo.prototype.clear = function() {
        this.__data__ = Su ? Su(null) : {}, this.size = 0;
      }, Jo.prototype.delete = function(d) {
        var g = this.has(d) && delete this.__data__[d];
        return this.size -= g ? 1 : 0, g;
      }, Jo.prototype.get = function(d) {
        var g = this.__data__;
        if (Su) {
          var x = g[d];
          return x === r ? e : x;
        }
        return on.call(g, d) ? g[d] : e;
      }, Jo.prototype.has = function(d) {
        var g = this.__data__;
        return Su ? g[d] !== e : on.call(g, d);
      }, Jo.prototype.set = function(d, g) {
        var x = this.__data__;
        return this.size += this.has(d) ? 0 : 1, x[d] = Su && g === e ? r : g, this;
      }, oa.prototype.clear = function() {
        this.__data__ = [], this.size = 0;
      }, oa.prototype.delete = function(d) {
        var g = this.__data__, x = pf(g, d);
        return !(x < 0) && (x == g.length - 1 ? g.pop() : af.call(g, x, 1), --this.size, !0);
      }, oa.prototype.get = function(d) {
        var g = this.__data__, x = pf(g, d);
        return x < 0 ? e : g[x][1];
      }, oa.prototype.has = function(d) {
        return pf(this.__data__, d) > -1;
      }, oa.prototype.set = function(d, g) {
        var x = this.__data__, P = pf(x, d);
        return P < 0 ? (++this.size, x.push([d, g])) : x[P][1] = g, this;
      }, la.prototype.clear = function() {
        this.size = 0, this.__data__ = { hash: new Jo(), map: new (xu || oa)(), string: new Jo() };
      }, la.prototype.delete = function(d) {
        var g = Tf(this, d).delete(d);
        return this.size -= g ? 1 : 0, g;
      }, la.prototype.get = function(d) {
        return Tf(this, d).get(d);
      }, la.prototype.has = function(d) {
        return Tf(this, d).has(d);
      }, la.prototype.set = function(d, g) {
        var x = Tf(this, d), P = x.size;
        return x.set(d, g), this.size += x.size == P ? 0 : 1, this;
      }, Ko.prototype.add = Ko.prototype.push = function(d) {
        return this.__data__.set(d, r), this;
      }, Ko.prototype.has = function(d) {
        return this.__data__.has(d);
      }, ps.prototype.clear = function() {
        this.__data__ = new oa(), this.size = 0;
      }, ps.prototype.delete = function(d) {
        var g = this.__data__, x = g.delete(d);
        return this.size = g.size, x;
      }, ps.prototype.get = function(d) {
        return this.__data__.get(d);
      }, ps.prototype.has = function(d) {
        return this.__data__.has(d);
      }, ps.prototype.set = function(d, g) {
        var x = this.__data__;
        if (x instanceof oa) {
          var P = x.__data__;
          if (!xu || P.length < 199)
            return P.push([d, g]), this.size = ++x.size, this;
          x = this.__data__ = new la(P);
        }
        return x.set(d, g), this.size = x.size, this;
      };
      var io = g2(Bs), GM = g2(ey, !0);
      function B4(d, g) {
        var x = !0;
        return io(d, function(P, B, X) {
          return x = !!g(P, B, X);
        }), x;
      }
      function ff(d, g, x) {
        for (var P = -1, B = d.length; ++P < B; ) {
          var X = d[P], at = g(X);
          if (at != null && (ut === e ? at == at && !Di(at) : x(at, ut)))
            var ut = at, _t = X;
        }
        return _t;
      }
      function WM(d, g) {
        var x = [];
        return io(d, function(P, B, X) {
          g(P, B, X) && x.push(P);
        }), x;
      }
      function Dr(d, g, x, P, B) {
        var X = -1, at = d.length;
        for (x || (x = q4), B || (B = []); ++X < at; ) {
          var ut = d[X];
          g > 0 && x(ut) ? g > 1 ? Dr(ut, g - 1, x, P, B) : eo(B, ut) : P || (B[B.length] = ut);
        }
        return B;
      }
      var ty = v2(), ZM = v2(!0);
      function Bs(d, g) {
        return d && ty(d, g, yr);
      }
      function ey(d, g) {
        return d && ZM(d, g, yr);
      }
      function mf(d, g) {
        return to(g, function(x) {
          return pa(d[x]);
        });
      }
      function Qo(d, g) {
        for (var x = 0, P = (g = ao(g, d)).length; d != null && x < P; )
          d = d[ks(g[x++])];
        return x && x == P ? d : e;
      }
      function qM(d, g, x) {
        var P = g(d);
        return Ce(d) ? P : eo(P, x(d));
      }
      function ei(d) {
        return d == null ? d === e ? "[object Undefined]" : "[object Null]" : Yo && Yo in an(d) ? function(g) {
          var x = on.call(g, Yo), P = g[Yo];
          try {
            g[Yo] = e;
            var B = !0;
          } catch {
          }
          var X = ef.call(g);
          return B && (x ? g[Yo] = P : delete g[Yo]), X;
        }(d) : function(g) {
          return ef.call(g);
        }(d);
      }
      function ny(d, g) {
        return d > g;
      }
      function z4(d, g) {
        return d != null && on.call(d, g);
      }
      function k4(d, g) {
        return d != null && g in an(d);
      }
      function ry(d, g, x) {
        for (var P = x ? F0 : Yp, B = d[0].length, X = d.length, at = X, ut = Ct(X), _t = 1 / 0, Ot = []; at--; ) {
          var Rt = d[at];
          at && g && (Rt = In(Rt, Ci(g))), _t = Nr(Rt.length, _t), ut[at] = !x && (g || B >= 120 && Rt.length >= 120) ? new Ko(at && Rt) : e;
        }
        Rt = d[0];
        var Ut = -1, ne = ut[0];
        t:
          for (; ++Ut < B && Ot.length < _t; ) {
            var se = Rt[Ut], me = g ? g(se) : se;
            if (se = x || se !== 0 ? se : 0, !(ne ? _u(ne, me) : P(Ot, me, x))) {
              for (at = X; --at; ) {
                var Lt = ut[at];
                if (!(Lt ? _u(Lt, me) : P(d[at], me, x)))
                  continue t;
              }
              ne && ne.push(me), Ot.push(se);
            }
          }
        return Ot;
      }
      function Au(d, g, x) {
        var P = (d = L2(d, g = ao(g, d))) == null ? d : d[ks(Yi(g))];
        return P == null ? e : kr(P, d, x);
      }
      function XM(d) {
        return qn(d) && ei(d) == y;
      }
      function Cu(d, g, x, P, B) {
        return d === g || (d == null || g == null || !qn(d) && !qn(g) ? d != d && g != g : function(X, at, ut, _t, Ot, Rt) {
          var Ut = Ce(X), ne = Ce(at), se = Ut ? _ : Fr(X), me = ne ? _ : Fr(at), Lt = (se = se == y ? k : se) == k, Gt = (me = me == y ? k : me) == k, ve = se == me;
          if (ve && lo(X)) {
            if (!lo(at))
              return !1;
            Ut = !0, Lt = !1;
          }
          if (ve && !Lt)
            return Rt || (Rt = new ps()), Ut || Mc(X) ? A2(X, at, ut, _t, Ot, Rt) : function(ue, ye, pr, tr, ri, An, Ur) {
              switch (pr) {
                case nt:
                  if (ue.byteLength != ye.byteLength || ue.byteOffset != ye.byteOffset)
                    return !1;
                  ue = ue.buffer, ye = ye.buffer;
                case ft:
                  return !(ue.byteLength != ye.byteLength || !An(new rf(ue), new rf(ye)));
                case w:
                case b:
                case I:
                  return fs(+ue, +ye);
                case T:
                  return ue.name == ye.name && ue.message == ye.message;
                case L:
                case q:
                  return ue == ye + "";
                case C:
                  var Ns = q0;
                case E:
                  var co = 1 & tr;
                  if (Ns || (Ns = Kp), ue.size != ye.size && !co)
                    return !1;
                  var Bf = Ur.get(ue);
                  if (Bf)
                    return Bf == ye;
                  tr |= 2, Ur.set(ue, ye);
                  var jy = A2(Ns(ue), Ns(ye), tr, ri, An, Ur);
                  return Ur.delete(ue), jy;
                case it:
                  if (Mu)
                    return Mu.call(ue) == Mu.call(ye);
              }
              return !1;
            }(X, at, se, ut, _t, Ot, Rt);
          if (!(1 & ut)) {
            var Jt = Lt && on.call(X, "__wrapped__"), Pe = Gt && on.call(at, "__wrapped__");
            if (Jt || Pe) {
              var Me = Jt ? X.value() : X, Je = Pe ? at.value() : at;
              return Rt || (Rt = new ps()), Ot(Me, Je, ut, _t, Rt);
            }
          }
          return ve ? (Rt || (Rt = new ps()), function(ue, ye, pr, tr, ri, An) {
            var Ur = 1 & pr, Ns = yy(ue), co = Ns.length, Bf = yy(ye), jy = Bf.length;
            if (co != jy && !Ur)
              return !1;
            for (var zf = co; zf--; ) {
              var rl = Ns[zf];
              if (!(Ur ? rl in ye : on.call(ye, rl)))
                return !1;
            }
            var vT = An.get(ue), yT = An.get(ye);
            if (vT && yT)
              return vT == ye && yT == ue;
            var kf = !0;
            An.set(ue, ye), An.set(ye, ue);
            for (var Gy = Ur; ++zf < co; ) {
              var Nf = ue[rl = Ns[zf]], Ff = ye[rl];
              if (tr)
                var _T = Ur ? tr(Ff, Nf, rl, ye, ue, An) : tr(Nf, Ff, rl, ue, ye, An);
              if (!(_T === e ? Nf === Ff || ri(Nf, Ff, pr, tr, An) : _T)) {
                kf = !1;
                break;
              }
              Gy || (Gy = rl == "constructor");
            }
            if (kf && !Gy) {
              var Uf = ue.constructor, Vf = ye.constructor;
              Uf == Vf || !("constructor" in ue) || !("constructor" in ye) || typeof Uf == "function" && Uf instanceof Uf && typeof Vf == "function" && Vf instanceof Vf || (kf = !1);
            }
            return An.delete(ue), An.delete(ye), kf;
          }(X, at, ut, _t, Ot, Rt)) : !1;
        }(d, g, x, P, Cu, B));
      }
      function iy(d, g, x, P) {
        var B = x.length, X = B, at = !P;
        if (d == null)
          return !X;
        for (d = an(d); B--; ) {
          var ut = x[B];
          if (at && ut[2] ? ut[1] !== d[ut[0]] : !(ut[0] in d))
            return !1;
        }
        for (; ++B < X; ) {
          var _t = (ut = x[B])[0], Ot = d[_t], Rt = ut[1];
          if (at && ut[2]) {
            if (Ot === e && !(_t in d))
              return !1;
          } else {
            var Ut = new ps();
            if (P)
              var ne = P(Ot, Rt, _t, d, g, Ut);
            if (!(ne === e ? Cu(Rt, Ot, 3, P, Ut) : ne))
              return !1;
          }
        }
        return !0;
      }
      function YM(d) {
        return !(!Vn(d) || (g = d, RM && RM in g)) && (pa(d) ? v4 : qt).test(el(d));
        var g;
      }
      function JM(d) {
        return typeof d == "function" ? d : d == null ? _i : typeof d == "object" ? Ce(d) ? QM(d[0], d[1]) : $M(d) : gT(d);
      }
      function sy(d) {
        if (!Ru(d))
          return S4(d);
        var g = [];
        for (var x in an(d))
          on.call(d, x) && x != "constructor" && g.push(x);
        return g;
      }
      function N4(d) {
        if (!Vn(d))
          return function(B) {
            var X = [];
            if (B != null)
              for (var at in an(B))
                X.push(at);
            return X;
          }(d);
        var g = Ru(d), x = [];
        for (var P in d)
          (P != "constructor" || !g && on.call(d, P)) && x.push(P);
        return x;
      }
      function ay(d, g) {
        return d < g;
      }
      function KM(d, g) {
        var x = -1, P = vi(d) ? Ct(d.length) : [];
        return io(d, function(B, X, at) {
          P[++x] = g(B, X, at);
        }), P;
      }
      function $M(d) {
        var g = xy(d);
        return g.length == 1 && g[0][2] ? I2(g[0][0], g[0][1]) : function(x) {
          return x === d || iy(x, d, g);
        };
      }
      function QM(d, g) {
        return Sy(d) && R2(g) ? I2(ks(d), g) : function(x) {
          var P = Oy(x, d);
          return P === e && P === g ? Ly(x, d) : Cu(g, P, 3);
        };
      }
      function gf(d, g, x, P, B) {
        d !== g && ty(g, function(X, at) {
          if (B || (B = new ps()), Vn(X))
            (function(_t, Ot, Rt, Ut, ne, se, me) {
              var Lt = Ty(_t, Rt), Gt = Ty(Ot, Rt), ve = me.get(Gt);
              if (ve)
                return void $0(_t, Rt, ve);
              var Jt = se ? se(Lt, Gt, Rt + "", _t, Ot, me) : e, Pe = Jt === e;
              if (Pe) {
                var Me = Ce(Gt), Je = !Me && lo(Gt), ue = !Me && !Je && Mc(Gt);
                Jt = Gt, Me || Je || ue ? Ce(Lt) ? Jt = Lt : Qn(Lt) ? Jt = gi(Lt) : Je ? (Pe = !1, Jt = u2(Gt, !0)) : ue ? (Pe = !1, Jt = d2(Gt, !0)) : Jt = [] : Ou(Gt) || nl(Gt) ? (Jt = Lt, nl(Lt) ? Jt = aT(Lt) : Vn(Lt) && !pa(Lt) || (Jt = D2(Gt))) : Pe = !1;
              }
              Pe && (me.set(Gt, Jt), ne(Jt, Gt, Ut, se, me), me.delete(Gt)), $0(_t, Rt, Jt);
            })(d, g, at, x, gf, P, B);
          else {
            var ut = P ? P(Ty(d, at), X, at + "", d, g, B) : e;
            ut === e && (ut = X), $0(d, at, ut);
          }
        }, yi);
      }
      function t2(d, g) {
        var x = d.length;
        if (x)
          return da(g += g < 0 ? x : 0, x) ? d[g] : e;
      }
      function e2(d, g, x) {
        g = g.length ? In(g, function(X) {
          return Ce(X) ? function(at) {
            return Qo(at, X.length === 1 ? X[0] : X);
          } : X;
        }) : [_i];
        var P = -1;
        g = In(g, Ci(ge()));
        var B = KM(d, function(X, at, ut) {
          var _t = In(g, function(Ot) {
            return Ot(X);
          });
          return { criteria: _t, index: ++P, value: X };
        });
        return function(X, at) {
          var ut = X.length;
          for (X.sort(at); ut--; )
            X[ut] = X[ut].value;
          return X;
        }(B, function(X, at) {
          return function(ut, _t, Ot) {
            for (var Rt = -1, Ut = ut.criteria, ne = _t.criteria, se = Ut.length, me = Ot.length; ++Rt < se; ) {
              var Lt = p2(Ut[Rt], ne[Rt]);
              if (Lt)
                return Rt >= me ? Lt : Lt * (Ot[Rt] == "desc" ? -1 : 1);
            }
            return ut.index - _t.index;
          }(X, at, x);
        });
      }
      function n2(d, g, x) {
        for (var P = -1, B = g.length, X = {}; ++P < B; ) {
          var at = g[P], ut = Qo(d, at);
          x(ut, at) && Pu(X, ao(at, d), ut);
        }
        return X;
      }
      function oy(d, g, x, P) {
        var B = P ? a4 : pc, X = -1, at = g.length, ut = d;
        for (d === g && (g = gi(g)), x && (ut = In(d, Ci(x))); ++X < at; )
          for (var _t = 0, Ot = g[X], Rt = x ? x(Ot) : Ot; (_t = B(ut, Rt, _t, P)) > -1; )
            ut !== d && af.call(ut, _t, 1), af.call(d, _t, 1);
        return d;
      }
      function r2(d, g) {
        for (var x = d ? g.length : 0, P = x - 1; x--; ) {
          var B = g[x];
          if (x == P || B !== X) {
            var X = B;
            da(B) ? af.call(d, B, 1) : uy(d, B);
          }
        }
        return d;
      }
      function ly(d, g) {
        return d + cf(kM() * (g - d + 1));
      }
      function cy(d, g) {
        var x = "";
        if (!d || g < 1 || g > p)
          return x;
        do
          g % 2 && (x += d), (g = cf(g / 2)) && (d += d);
        while (g);
        return x;
      }
      function Be(d, g) {
        return Ey(O2(d, g, _i), d + "");
      }
      function F4(d) {
        return UM(Tc(d));
      }
      function U4(d, g) {
        var x = Tc(d);
        return Ef(x, $o(g, 0, x.length));
      }
      function Pu(d, g, x, P) {
        if (!Vn(d))
          return d;
        for (var B = -1, X = (g = ao(g, d)).length, at = X - 1, ut = d; ut != null && ++B < X; ) {
          var _t = ks(g[B]), Ot = x;
          if (_t === "__proto__" || _t === "constructor" || _t === "prototype")
            return d;
          if (B != at) {
            var Rt = ut[_t];
            (Ot = P ? P(Rt, _t, ut) : e) === e && (Ot = Vn(Rt) ? Rt : da(g[B + 1]) ? [] : {});
          }
          Tu(ut, _t, Ot), ut = ut[_t];
        }
        return d;
      }
      var i2 = hf ? function(d, g) {
        return hf.set(d, g), d;
      } : _i, V4 = of ? function(d, g) {
        return of(d, "toString", { configurable: !0, enumerable: !1, value: zy(g), writable: !0 });
      } : _i;
      function H4(d) {
        return Ef(Tc(d));
      }
      function Xi(d, g, x) {
        var P = -1, B = d.length;
        g < 0 && (g = -g > B ? 0 : B + g), (x = x > B ? B : x) < 0 && (x += B), B = g > x ? 0 : x - g >>> 0, g >>>= 0;
        for (var X = Ct(B); ++P < B; )
          X[P] = d[P + g];
        return X;
      }
      function j4(d, g) {
        var x;
        return io(d, function(P, B, X) {
          return !(x = g(P, B, X));
        }), !!x;
      }
      function vf(d, g, x) {
        var P = 0, B = d == null ? P : d.length;
        if (typeof g == "number" && g == g && B <= 2147483647) {
          for (; P < B; ) {
            var X = P + B >>> 1, at = d[X];
            at !== null && !Di(at) && (x ? at <= g : at < g) ? P = X + 1 : B = X;
          }
          return B;
        }
        return hy(d, g, _i, x);
      }
      function hy(d, g, x, P) {
        var B = 0, X = d == null ? 0 : d.length;
        if (X === 0)
          return 0;
        for (var at = (g = x(g)) != g, ut = g === null, _t = Di(g), Ot = g === e; B < X; ) {
          var Rt = cf((B + X) / 2), Ut = x(d[Rt]), ne = Ut !== e, se = Ut === null, me = Ut == Ut, Lt = Di(Ut);
          if (at)
            var Gt = P || me;
          else
            Gt = Ot ? me && (P || ne) : ut ? me && ne && (P || !se) : _t ? me && ne && !se && (P || !Lt) : !se && !Lt && (P ? Ut <= g : Ut < g);
          Gt ? B = Rt + 1 : X = Rt;
        }
        return Nr(X, 4294967294);
      }
      function s2(d, g) {
        for (var x = -1, P = d.length, B = 0, X = []; ++x < P; ) {
          var at = d[x], ut = g ? g(at) : at;
          if (!x || !fs(ut, _t)) {
            var _t = ut;
            X[B++] = at === 0 ? 0 : at;
          }
        }
        return X;
      }
      function a2(d) {
        return typeof d == "number" ? d : Di(d) ? f : +d;
      }
      function Pi(d) {
        if (typeof d == "string")
          return d;
        if (Ce(d))
          return In(d, Pi) + "";
        if (Di(d))
          return NM ? NM.call(d) : "";
        var g = d + "";
        return g == "0" && 1 / d == -1 / 0 ? "-0" : g;
      }
      function so(d, g, x) {
        var P = -1, B = Yp, X = d.length, at = !0, ut = [], _t = ut;
        if (x)
          at = !1, B = F0;
        else if (X >= 200) {
          var Ot = g ? null : W4(d);
          if (Ot)
            return Kp(Ot);
          at = !1, B = _u, _t = new Ko();
        } else
          _t = g ? [] : ut;
        t:
          for (; ++P < X; ) {
            var Rt = d[P], Ut = g ? g(Rt) : Rt;
            if (Rt = x || Rt !== 0 ? Rt : 0, at && Ut == Ut) {
              for (var ne = _t.length; ne--; )
                if (_t[ne] === Ut)
                  continue t;
              g && _t.push(Ut), ut.push(Rt);
            } else
              B(_t, Ut, x) || (_t !== ut && _t.push(Ut), ut.push(Rt));
          }
        return ut;
      }
      function uy(d, g) {
        return (d = L2(d, g = ao(g, d))) == null || delete d[ks(Yi(g))];
      }
      function o2(d, g, x, P) {
        return Pu(d, g, x(Qo(d, g)), P);
      }
      function yf(d, g, x, P) {
        for (var B = d.length, X = P ? B : -1; (P ? X-- : ++X < B) && g(d[X], X, d); )
          ;
        return x ? Xi(d, P ? 0 : X, P ? X + 1 : B) : Xi(d, P ? X + 1 : 0, P ? B : X);
      }
      function l2(d, g) {
        var x = d;
        return x instanceof He && (x = x.value()), U0(g, function(P, B) {
          return B.func.apply(B.thisArg, eo([P], B.args));
        }, x);
      }
      function dy(d, g, x) {
        var P = d.length;
        if (P < 2)
          return P ? so(d[0]) : [];
        for (var B = -1, X = Ct(P); ++B < P; )
          for (var at = d[B], ut = -1; ++ut < P; )
            ut != B && (X[B] = Eu(X[B] || at, d[ut], g, x));
        return so(Dr(X, 1), g, x);
      }
      function c2(d, g, x) {
        for (var P = -1, B = d.length, X = g.length, at = {}; ++P < B; ) {
          var ut = P < X ? g[P] : e;
          x(at, d[P], ut);
        }
        return at;
      }
      function py(d) {
        return Qn(d) ? d : [];
      }
      function fy(d) {
        return typeof d == "function" ? d : _i;
      }
      function ao(d, g) {
        return Ce(d) ? d : Sy(d, g) ? [d] : N2(nn(d));
      }
      var G4 = Be;
      function oo(d, g, x) {
        var P = d.length;
        return x = x === e ? P : x, !g && x >= P ? d : Xi(d, g, x);
      }
      var h2 = y4 || function(d) {
        return En.clearTimeout(d);
      };
      function u2(d, g) {
        if (g)
          return d.slice();
        var x = d.length, P = IM ? IM(x) : new d.constructor(x);
        return d.copy(P), P;
      }
      function my(d) {
        var g = new d.constructor(d.byteLength);
        return new rf(g).set(new rf(d)), g;
      }
      function d2(d, g) {
        var x = g ? my(d.buffer) : d.buffer;
        return new d.constructor(x, d.byteOffset, d.length);
      }
      function p2(d, g) {
        if (d !== g) {
          var x = d !== e, P = d === null, B = d == d, X = Di(d), at = g !== e, ut = g === null, _t = g == g, Ot = Di(g);
          if (!ut && !Ot && !X && d > g || X && at && _t && !ut && !Ot || P && at && _t || !x && _t || !B)
            return 1;
          if (!P && !X && !Ot && d < g || Ot && x && B && !P && !X || ut && x && B || !at && B || !_t)
            return -1;
        }
        return 0;
      }
      function f2(d, g, x, P) {
        for (var B = -1, X = d.length, at = x.length, ut = -1, _t = g.length, Ot = dr(X - at, 0), Rt = Ct(_t + Ot), Ut = !P; ++ut < _t; )
          Rt[ut] = g[ut];
        for (; ++B < at; )
          (Ut || B < X) && (Rt[x[B]] = d[B]);
        for (; Ot--; )
          Rt[ut++] = d[B++];
        return Rt;
      }
      function m2(d, g, x, P) {
        for (var B = -1, X = d.length, at = -1, ut = x.length, _t = -1, Ot = g.length, Rt = dr(X - ut, 0), Ut = Ct(Rt + Ot), ne = !P; ++B < Rt; )
          Ut[B] = d[B];
        for (var se = B; ++_t < Ot; )
          Ut[se + _t] = g[_t];
        for (; ++at < ut; )
          (ne || B < X) && (Ut[se + x[at]] = d[B++]);
        return Ut;
      }
      function gi(d, g) {
        var x = -1, P = d.length;
        for (g || (g = Ct(P)); ++x < P; )
          g[x] = d[x];
        return g;
      }
      function zs(d, g, x, P) {
        var B = !x;
        x || (x = {});
        for (var X = -1, at = g.length; ++X < at; ) {
          var ut = g[X], _t = P ? P(x[ut], d[ut], ut, x, d) : e;
          _t === e && (_t = d[ut]), B ? ca(x, ut, _t) : Tu(x, ut, _t);
        }
        return x;
      }
      function _f(d, g) {
        return function(x, P) {
          var B = Ce(x) ? n4 : L4, X = g ? g() : {};
          return B(x, d, ge(P, 2), X);
        };
      }
      function xc(d) {
        return Be(function(g, x) {
          var P = -1, B = x.length, X = B > 1 ? x[B - 1] : e, at = B > 2 ? x[2] : e;
          for (X = d.length > 3 && typeof X == "function" ? (B--, X) : e, at && ni(x[0], x[1], at) && (X = B < 3 ? e : X, B = 1), g = an(g); ++P < B; ) {
            var ut = x[P];
            ut && d(g, ut, P, X);
          }
          return g;
        });
      }
      function g2(d, g) {
        return function(x, P) {
          if (x == null)
            return x;
          if (!vi(x))
            return d(x, P);
          for (var B = x.length, X = g ? B : -1, at = an(x); (g ? X-- : ++X < B) && P(at[X], X, at) !== !1; )
            ;
          return x;
        };
      }
      function v2(d) {
        return function(g, x, P) {
          for (var B = -1, X = an(g), at = P(g), ut = at.length; ut--; ) {
            var _t = at[d ? ut : ++B];
            if (x(X[_t], _t, X) === !1)
              break;
          }
          return g;
        };
      }
      function y2(d) {
        return function(g) {
          var x = fc(g = nn(g)) ? ds(g) : e, P = x ? x[0] : g.charAt(0), B = x ? oo(x, 1).join("") : g.slice(1);
          return P[d]() + B;
        };
      }
      function bc(d) {
        return function(g) {
          return U0(fT(pT(g).replace(vu, "")), d, "");
        };
      }
      function Du(d) {
        return function() {
          var g = arguments;
          switch (g.length) {
            case 0:
              return new d();
            case 1:
              return new d(g[0]);
            case 2:
              return new d(g[0], g[1]);
            case 3:
              return new d(g[0], g[1], g[2]);
            case 4:
              return new d(g[0], g[1], g[2], g[3]);
            case 5:
              return new d(g[0], g[1], g[2], g[3], g[4]);
            case 6:
              return new d(g[0], g[1], g[2], g[3], g[4], g[5]);
            case 7:
              return new d(g[0], g[1], g[2], g[3], g[4], g[5], g[6]);
          }
          var x = wc(d.prototype), P = d.apply(x, g);
          return Vn(P) ? P : x;
        };
      }
      function _2(d) {
        return function(g, x, P) {
          var B = an(g);
          if (!vi(g)) {
            var X = ge(x, 3);
            g = yr(g), x = function(ut) {
              return X(B[ut], ut, B);
            };
          }
          var at = d(g, x, P);
          return at > -1 ? B[X ? g[at] : at] : e;
        };
      }
      function w2(d) {
        return ua(function(g) {
          var x = g.length, P = x, B = Zi.prototype.thru;
          for (d && g.reverse(); P--; ) {
            var X = g[P];
            if (typeof X != "function")
              throw new Wi(n);
            if (B && !at && Mf(X) == "wrapper")
              var at = new Zi([], !0);
          }
          for (P = at ? P : x; ++P < x; ) {
            var ut = Mf(X = g[P]), _t = ut == "wrapper" ? wy(X) : e;
            at = _t && My(_t[0]) && _t[1] == 424 && !_t[4].length && _t[9] == 1 ? at[Mf(_t[0])].apply(at, _t[3]) : X.length == 1 && My(X) ? at[ut]() : at.thru(X);
          }
          return function() {
            var Ot = arguments, Rt = Ot[0];
            if (at && Ot.length == 1 && Ce(Rt))
              return at.plant(Rt).value();
            for (var Ut = 0, ne = x ? g[Ut].apply(this, Ot) : Rt; ++Ut < x; )
              ne = g[Ut].call(this, ne);
            return ne;
          };
        });
      }
      function wf(d, g, x, P, B, X, at, ut, _t, Ot) {
        var Rt = g & c, Ut = 1 & g, ne = 2 & g, se = 24 & g, me = 512 & g, Lt = ne ? e : Du(d);
        return function Gt() {
          for (var ve = arguments.length, Jt = Ct(ve), Pe = ve; Pe--; )
            Jt[Pe] = arguments[Pe];
          if (se)
            var Me = Sc(Gt), Je = function(tr, ri) {
              for (var An = tr.length, Ur = 0; An--; )
                tr[An] === ri && ++Ur;
              return Ur;
            }(Jt, Me);
          if (P && (Jt = f2(Jt, P, B, se)), X && (Jt = m2(Jt, X, at, se)), ve -= Je, se && ve < Ot) {
            var ue = no(Jt, Me);
            return S2(d, g, wf, Gt.placeholder, x, Jt, ue, ut, _t, Ot - ve);
          }
          var ye = Ut ? x : this, pr = ne ? ye[d] : d;
          return ve = Jt.length, ut ? Jt = function(tr, ri) {
            for (var An = tr.length, Ur = Nr(ri.length, An), Ns = gi(tr); Ur--; ) {
              var co = ri[Ur];
              tr[Ur] = da(co, An) ? Ns[co] : e;
            }
            return tr;
          }(Jt, ut) : me && ve > 1 && Jt.reverse(), Rt && _t < ve && (Jt.length = _t), this && this !== En && this instanceof Gt && (pr = Lt || Du(pr)), pr.apply(ye, Jt);
        };
      }
      function x2(d, g) {
        return function(x, P) {
          return function(B, X, at, ut) {
            return Bs(B, function(_t, Ot, Rt) {
              X(ut, at(_t), Ot, Rt);
            }), ut;
          }(x, d, g(P), {});
        };
      }
      function xf(d, g) {
        return function(x, P) {
          var B;
          if (x === e && P === e)
            return g;
          if (x !== e && (B = x), P !== e) {
            if (B === e)
              return P;
            typeof x == "string" || typeof P == "string" ? (x = Pi(x), P = Pi(P)) : (x = a2(x), P = a2(P)), B = d(x, P);
          }
          return B;
        };
      }
      function gy(d) {
        return ua(function(g) {
          return g = In(g, Ci(ge())), Be(function(x) {
            var P = this;
            return d(g, function(B) {
              return kr(B, P, x);
            });
          });
        });
      }
      function bf(d, g) {
        var x = (g = g === e ? " " : Pi(g)).length;
        if (x < 2)
          return x ? cy(g, d) : g;
        var P = cy(g, lf(d / mc(g)));
        return fc(g) ? oo(ds(P), 0, d).join("") : P.slice(0, d);
      }
      function b2(d) {
        return function(g, x, P) {
          return P && typeof P != "number" && ni(g, x, P) && (x = P = e), g = fa(g), x === e ? (x = g, g = 0) : x = fa(x), function(B, X, at, ut) {
            for (var _t = -1, Ot = dr(lf((X - B) / (at || 1)), 0), Rt = Ct(Ot); Ot--; )
              Rt[ut ? Ot : ++_t] = B, B += at;
            return Rt;
          }(g, x, P = P === e ? g < x ? 1 : -1 : fa(P), d);
        };
      }
      function Sf(d) {
        return function(g, x) {
          return typeof g == "string" && typeof x == "string" || (g = Ji(g), x = Ji(x)), d(g, x);
        };
      }
      function S2(d, g, x, P, B, X, at, ut, _t, Ot) {
        var Rt = 8 & g;
        g |= Rt ? o : l, 4 & (g &= ~(Rt ? l : o)) || (g &= -4);
        var Ut = [d, g, B, Rt ? X : e, Rt ? at : e, Rt ? e : X, Rt ? e : at, ut, _t, Ot], ne = x.apply(e, Ut);
        return My(d) && B2(ne, Ut), ne.placeholder = P, z2(ne, d, g);
      }
      function vy(d) {
        var g = Un[d];
        return function(x, P) {
          if (x = Ji(x), (P = P == null ? 0 : Nr(Ie(P), 292)) && zM(x)) {
            var B = (nn(x) + "e").split("e");
            return +((B = (nn(g(B[0] + "e" + (+B[1] + P))) + "e").split("e"))[0] + "e" + (+B[1] - P));
          }
          return g(x);
        };
      }
      var W4 = yc && 1 / Kp(new yc([, -0]))[1] == h ? function(d) {
        return new yc(d);
      } : Fy;
      function M2(d) {
        return function(g) {
          var x = Fr(g);
          return x == C ? q0(g) : x == E ? h4(g) : function(P, B) {
            return In(B, function(X) {
              return [X, P[X]];
            });
          }(g, d(g));
        };
      }
      function ha(d, g, x, P, B, X, at, ut) {
        var _t = 2 & g;
        if (!_t && typeof d != "function")
          throw new Wi(n);
        var Ot = P ? P.length : 0;
        if (Ot || (g &= -97, P = B = e), at = at === e ? at : dr(Ie(at), 0), ut = ut === e ? ut : Ie(ut), Ot -= B ? B.length : 0, g & l) {
          var Rt = P, Ut = B;
          P = B = e;
        }
        var ne = _t ? e : wy(d), se = [d, g, x, P, B, Rt, Ut, X, at, ut];
        if (ne && function(Lt, Gt) {
          var ve = Lt[1], Jt = Gt[1], Pe = ve | Jt, Me = Pe < 131, Je = Jt == c && ve == 8 || Jt == c && ve == u && Lt[7].length <= Gt[8] || Jt == 384 && Gt[7].length <= Gt[8] && ve == 8;
          if (!Me && !Je)
            return Lt;
          1 & Jt && (Lt[2] = Gt[2], Pe |= 1 & ve ? 0 : 4);
          var ue = Gt[3];
          if (ue) {
            var ye = Lt[3];
            Lt[3] = ye ? f2(ye, ue, Gt[4]) : ue, Lt[4] = ye ? no(Lt[3], s) : Gt[4];
          }
          (ue = Gt[5]) && (ye = Lt[5], Lt[5] = ye ? m2(ye, ue, Gt[6]) : ue, Lt[6] = ye ? no(Lt[5], s) : Gt[6]), (ue = Gt[7]) && (Lt[7] = ue), Jt & c && (Lt[8] = Lt[8] == null ? Gt[8] : Nr(Lt[8], Gt[8])), Lt[9] == null && (Lt[9] = Gt[9]), Lt[0] = Gt[0], Lt[1] = Pe;
        }(se, ne), d = se[0], g = se[1], x = se[2], P = se[3], B = se[4], !(ut = se[9] = se[9] === e ? _t ? 0 : d.length : dr(se[9] - Ot, 0)) && 24 & g && (g &= -25), g && g != 1)
          me = g == 8 || g == a ? function(Lt, Gt, ve) {
            var Jt = Du(Lt);
            return function Pe() {
              for (var Me = arguments.length, Je = Ct(Me), ue = Me, ye = Sc(Pe); ue--; )
                Je[ue] = arguments[ue];
              var pr = Me < 3 && Je[0] !== ye && Je[Me - 1] !== ye ? [] : no(Je, ye);
              return (Me -= pr.length) < ve ? S2(Lt, Gt, wf, Pe.placeholder, e, Je, pr, e, e, ve - Me) : kr(this && this !== En && this instanceof Pe ? Jt : Lt, this, Je);
            };
          }(d, g, ut) : g != o && g != 33 || B.length ? wf.apply(e, se) : function(Lt, Gt, ve, Jt) {
            var Pe = 1 & Gt, Me = Du(Lt);
            return function Je() {
              for (var ue = -1, ye = arguments.length, pr = -1, tr = Jt.length, ri = Ct(tr + ye), An = this && this !== En && this instanceof Je ? Me : Lt; ++pr < tr; )
                ri[pr] = Jt[pr];
              for (; ye--; )
                ri[pr++] = arguments[++ue];
              return kr(An, Pe ? ve : this, ri);
            };
          }(d, g, x, P);
        else
          var me = function(Lt, Gt, ve) {
            var Jt = 1 & Gt, Pe = Du(Lt);
            return function Me() {
              return (this && this !== En && this instanceof Me ? Pe : Lt).apply(Jt ? ve : this, arguments);
            };
          }(d, g, x);
        return z2((ne ? i2 : B2)(me, se), d, g);
      }
      function T2(d, g, x, P) {
        return d === e || fs(d, vc[x]) && !on.call(P, x) ? g : d;
      }
      function E2(d, g, x, P, B, X) {
        return Vn(d) && Vn(g) && (X.set(g, d), gf(d, g, e, E2, X), X.delete(g)), d;
      }
      function Z4(d) {
        return Ou(d) ? e : d;
      }
      function A2(d, g, x, P, B, X) {
        var at = 1 & x, ut = d.length, _t = g.length;
        if (ut != _t && !(at && _t > ut))
          return !1;
        var Ot = X.get(d), Rt = X.get(g);
        if (Ot && Rt)
          return Ot == g && Rt == d;
        var Ut = -1, ne = !0, se = 2 & x ? new Ko() : e;
        for (X.set(d, g), X.set(g, d); ++Ut < ut; ) {
          var me = d[Ut], Lt = g[Ut];
          if (P)
            var Gt = at ? P(Lt, me, Ut, g, d, X) : P(me, Lt, Ut, d, g, X);
          if (Gt !== e) {
            if (Gt)
              continue;
            ne = !1;
            break;
          }
          if (se) {
            if (!V0(g, function(ve, Jt) {
              if (!_u(se, Jt) && (me === ve || B(me, ve, x, P, X)))
                return se.push(Jt);
            })) {
              ne = !1;
              break;
            }
          } else if (me !== Lt && !B(me, Lt, x, P, X)) {
            ne = !1;
            break;
          }
        }
        return X.delete(d), X.delete(g), ne;
      }
      function ua(d) {
        return Ey(O2(d, e, H2), d + "");
      }
      function yy(d) {
        return qM(d, yr, by);
      }
      function _y(d) {
        return qM(d, yi, C2);
      }
      var wy = hf ? function(d) {
        return hf.get(d);
      } : Fy;
      function Mf(d) {
        for (var g = d.name + "", x = _c[g], P = on.call(_c, g) ? x.length : 0; P--; ) {
          var B = x[P], X = B.func;
          if (X == null || X == d)
            return B.name;
        }
        return g;
      }
      function Sc(d) {
        return (on.call(j, "placeholder") ? j : d).placeholder;
      }
      function ge() {
        var d = j.iteratee || ky;
        return d = d === ky ? JM : d, arguments.length ? d(arguments[0], arguments[1]) : d;
      }
      function Tf(d, g) {
        var x, P, B = d.__data__;
        return ((P = typeof (x = g)) == "string" || P == "number" || P == "symbol" || P == "boolean" ? x !== "__proto__" : x === null) ? B[typeof g == "string" ? "string" : "hash"] : B.map;
      }
      function xy(d) {
        for (var g = yr(d), x = g.length; x--; ) {
          var P = g[x], B = d[P];
          g[x] = [P, B, R2(B)];
        }
        return g;
      }
      function tl(d, g) {
        var x = function(P, B) {
          return P == null ? e : P[B];
        }(d, g);
        return YM(x) ? x : e;
      }
      var by = Y0 ? function(d) {
        return d == null ? [] : (d = an(d), to(Y0(d), function(g) {
          return LM.call(d, g);
        }));
      } : Uy, C2 = Y0 ? function(d) {
        for (var g = []; d; )
          eo(g, by(d)), d = sf(d);
        return g;
      } : Uy, Fr = ei;
      function P2(d, g, x) {
        for (var P = -1, B = (g = ao(g, d)).length, X = !1; ++P < B; ) {
          var at = ks(g[P]);
          if (!(X = d != null && x(d, at)))
            break;
          d = d[at];
        }
        return X || ++P != B ? X : !!(B = d == null ? 0 : d.length) && If(B) && da(at, B) && (Ce(d) || nl(d));
      }
      function D2(d) {
        return typeof d.constructor != "function" || Ru(d) ? {} : wc(sf(d));
      }
      function q4(d) {
        return Ce(d) || nl(d) || !!(BM && d && d[BM]);
      }
      function da(d, g) {
        var x = typeof d;
        return !!(g = g ?? p) && (x == "number" || x != "symbol" && fe.test(d)) && d > -1 && d % 1 == 0 && d < g;
      }
      function ni(d, g, x) {
        if (!Vn(x))
          return !1;
        var P = typeof g;
        return !!(P == "number" ? vi(x) && da(g, x.length) : P == "string" && g in x) && fs(x[g], d);
      }
      function Sy(d, g) {
        if (Ce(d))
          return !1;
        var x = typeof d;
        return !(x != "number" && x != "symbol" && x != "boolean" && d != null && !Di(d)) || pt.test(d) || !Y.test(d) || g != null && d in an(g);
      }
      function My(d) {
        var g = Mf(d), x = j[g];
        if (typeof x != "function" || !(g in He.prototype))
          return !1;
        if (d === x)
          return !0;
        var P = wy(x);
        return !!P && d === P[0];
      }
      (J0 && Fr(new J0(new ArrayBuffer(1))) != nt || xu && Fr(new xu()) != C || K0 && Fr(K0.resolve()) != R || yc && Fr(new yc()) != E || bu && Fr(new bu()) != rt) && (Fr = function(d) {
        var g = ei(d), x = g == k ? d.constructor : e, P = x ? el(x) : "";
        if (P)
          switch (P) {
            case A4:
              return nt;
            case C4:
              return C;
            case P4:
              return R;
            case D4:
              return E;
            case R4:
              return rt;
          }
        return g;
      });
      var X4 = Qp ? pa : Vy;
      function Ru(d) {
        var g = d && d.constructor;
        return d === (typeof g == "function" && g.prototype || vc);
      }
      function R2(d) {
        return d == d && !Vn(d);
      }
      function I2(d, g) {
        return function(x) {
          return x != null && x[d] === g && (g !== e || d in an(x));
        };
      }
      function O2(d, g, x) {
        return g = dr(g === e ? d.length - 1 : g, 0), function() {
          for (var P = arguments, B = -1, X = dr(P.length - g, 0), at = Ct(X); ++B < X; )
            at[B] = P[g + B];
          B = -1;
          for (var ut = Ct(g + 1); ++B < g; )
            ut[B] = P[B];
          return ut[g] = x(at), kr(d, this, ut);
        };
      }
      function L2(d, g) {
        return g.length < 2 ? d : Qo(d, Xi(g, 0, -1));
      }
      function Ty(d, g) {
        if ((g !== "constructor" || typeof d[g] != "function") && g != "__proto__")
          return d[g];
      }
      var B2 = k2(i2), Iu = w4 || function(d, g) {
        return En.setTimeout(d, g);
      }, Ey = k2(V4);
      function z2(d, g, x) {
        var P = g + "";
        return Ey(d, function(B, X) {
          var at = X.length;
          if (!at)
            return B;
          var ut = at - 1;
          return X[ut] = (at > 1 ? "& " : "") + X[ut], X = X.join(at > 2 ? ", " : " "), B.replace(tt, `{
/* [wrapped with ` + X + `] */
`);
        }(P, function(B, X) {
          return Gi(m, function(at) {
            var ut = "_." + at[0];
            X & at[1] && !Yp(B, ut) && B.push(ut);
          }), B.sort();
        }(function(B) {
          var X = B.match(gt);
          return X ? X[1].split(Tt) : [];
        }(P), x)));
      }
      function k2(d) {
        var g = 0, x = 0;
        return function() {
          var P = M4(), B = 16 - (P - x);
          if (x = P, B > 0) {
            if (++g >= 800)
              return arguments[0];
          } else
            g = 0;
          return d.apply(e, arguments);
        };
      }
      function Ef(d, g) {
        var x = -1, P = d.length, B = P - 1;
        for (g = g === e ? P : g; ++x < g; ) {
          var X = ly(x, B), at = d[X];
          d[X] = d[x], d[x] = at;
        }
        return d.length = g, d;
      }
      var N2 = function(d) {
        var g = Df(d, function(P) {
          return x.size === 500 && x.clear(), P;
        }), x = g.cache;
        return g;
      }(function(d) {
        var g = [];
        return d.charCodeAt(0) === 46 && g.push(""), d.replace(ht, function(x, P, B, X) {
          g.push(B ? X.replace(It, "$1") : P || x);
        }), g;
      });
      function ks(d) {
        if (typeof d == "string" || Di(d))
          return d;
        var g = d + "";
        return g == "0" && 1 / d == -1 / 0 ? "-0" : g;
      }
      function el(d) {
        if (d != null) {
          try {
            return tf.call(d);
          } catch {
          }
          try {
            return d + "";
          } catch {
          }
        }
        return "";
      }
      function F2(d) {
        if (d instanceof He)
          return d.clone();
        var g = new Zi(d.__wrapped__, d.__chain__);
        return g.__actions__ = gi(d.__actions__), g.__index__ = d.__index__, g.__values__ = d.__values__, g;
      }
      var Y4 = Be(function(d, g) {
        return Qn(d) ? Eu(d, Dr(g, 1, Qn, !0)) : [];
      }), J4 = Be(function(d, g) {
        var x = Yi(g);
        return Qn(x) && (x = e), Qn(d) ? Eu(d, Dr(g, 1, Qn, !0), ge(x, 2)) : [];
      }), K4 = Be(function(d, g) {
        var x = Yi(g);
        return Qn(x) && (x = e), Qn(d) ? Eu(d, Dr(g, 1, Qn, !0), e, x) : [];
      });
      function U2(d, g, x) {
        var P = d == null ? 0 : d.length;
        if (!P)
          return -1;
        var B = x == null ? 0 : Ie(x);
        return B < 0 && (B = dr(P + B, 0)), Jp(d, ge(g, 3), B);
      }
      function V2(d, g, x) {
        var P = d == null ? 0 : d.length;
        if (!P)
          return -1;
        var B = P - 1;
        return x !== e && (B = Ie(x), B = x < 0 ? dr(P + B, 0) : Nr(B, P - 1)), Jp(d, ge(g, 3), B, !0);
      }
      function H2(d) {
        return d != null && d.length ? Dr(d, 1) : [];
      }
      function j2(d) {
        return d && d.length ? d[0] : e;
      }
      var $4 = Be(function(d) {
        var g = In(d, py);
        return g.length && g[0] === d[0] ? ry(g) : [];
      }), Q4 = Be(function(d) {
        var g = Yi(d), x = In(d, py);
        return g === Yi(x) ? g = e : x.pop(), x.length && x[0] === d[0] ? ry(x, ge(g, 2)) : [];
      }), tk = Be(function(d) {
        var g = Yi(d), x = In(d, py);
        return (g = typeof g == "function" ? g : e) && x.pop(), x.length && x[0] === d[0] ? ry(x, e, g) : [];
      });
      function Yi(d) {
        var g = d == null ? 0 : d.length;
        return g ? d[g - 1] : e;
      }
      var ek = Be(G2);
      function G2(d, g) {
        return d && d.length && g && g.length ? oy(d, g) : d;
      }
      var nk = ua(function(d, g) {
        var x = d == null ? 0 : d.length, P = Q0(d, g);
        return r2(d, In(g, function(B) {
          return da(B, x) ? +B : B;
        }).sort(p2)), P;
      });
      function Ay(d) {
        return d == null ? d : E4.call(d);
      }
      var rk = Be(function(d) {
        return so(Dr(d, 1, Qn, !0));
      }), ik = Be(function(d) {
        var g = Yi(d);
        return Qn(g) && (g = e), so(Dr(d, 1, Qn, !0), ge(g, 2));
      }), sk = Be(function(d) {
        var g = Yi(d);
        return g = typeof g == "function" ? g : e, so(Dr(d, 1, Qn, !0), e, g);
      });
      function Cy(d) {
        if (!d || !d.length)
          return [];
        var g = 0;
        return d = to(d, function(x) {
          if (Qn(x))
            return g = dr(x.length, g), !0;
        }), W0(g, function(x) {
          return In(d, H0(x));
        });
      }
      function W2(d, g) {
        if (!d || !d.length)
          return [];
        var x = Cy(d);
        return g == null ? x : In(x, function(P) {
          return kr(g, e, P);
        });
      }
      var ak = Be(function(d, g) {
        return Qn(d) ? Eu(d, g) : [];
      }), ok = Be(function(d) {
        return dy(to(d, Qn));
      }), lk = Be(function(d) {
        var g = Yi(d);
        return Qn(g) && (g = e), dy(to(d, Qn), ge(g, 2));
      }), ck = Be(function(d) {
        var g = Yi(d);
        return g = typeof g == "function" ? g : e, dy(to(d, Qn), e, g);
      }), hk = Be(Cy), uk = Be(function(d) {
        var g = d.length, x = g > 1 ? d[g - 1] : e;
        return x = typeof x == "function" ? (d.pop(), x) : e, W2(d, x);
      });
      function Z2(d) {
        var g = j(d);
        return g.__chain__ = !0, g;
      }
      function Af(d, g) {
        return g(d);
      }
      var dk = ua(function(d) {
        var g = d.length, x = g ? d[0] : 0, P = this.__wrapped__, B = function(X) {
          return Q0(X, d);
        };
        return !(g > 1 || this.__actions__.length) && P instanceof He && da(x) ? ((P = P.slice(x, +x + (g ? 1 : 0))).__actions__.push({ func: Af, args: [B], thisArg: e }), new Zi(P, this.__chain__).thru(function(X) {
          return g && !X.length && X.push(e), X;
        })) : this.thru(B);
      }), pk = _f(function(d, g, x) {
        on.call(d, x) ? ++d[x] : ca(d, x, 1);
      }), fk = _2(U2), mk = _2(V2);
      function q2(d, g) {
        return (Ce(d) ? Gi : io)(d, ge(g, 3));
      }
      function X2(d, g) {
        return (Ce(d) ? r4 : GM)(d, ge(g, 3));
      }
      var gk = _f(function(d, g, x) {
        on.call(d, x) ? d[x].push(g) : ca(d, x, [g]);
      }), vk = Be(function(d, g, x) {
        var P = -1, B = typeof g == "function", X = vi(d) ? Ct(d.length) : [];
        return io(d, function(at) {
          X[++P] = B ? kr(g, at, x) : Au(at, g, x);
        }), X;
      }), yk = _f(function(d, g, x) {
        ca(d, x, g);
      });
      function Cf(d, g) {
        return (Ce(d) ? In : KM)(d, ge(g, 3));
      }
      var _k = _f(function(d, g, x) {
        d[x ? 0 : 1].push(g);
      }, function() {
        return [[], []];
      }), wk = Be(function(d, g) {
        if (d == null)
          return [];
        var x = g.length;
        return x > 1 && ni(d, g[0], g[1]) ? g = [] : x > 2 && ni(g[0], g[1], g[2]) && (g = [g[0]]), e2(d, Dr(g, 1), []);
      }), Pf = _4 || function() {
        return En.Date.now();
      };
      function Y2(d, g, x) {
        return g = x ? e : g, g = d && g == null ? d.length : g, ha(d, c, e, e, e, e, g);
      }
      function J2(d, g) {
        var x;
        if (typeof g != "function")
          throw new Wi(n);
        return d = Ie(d), function() {
          return --d > 0 && (x = g.apply(this, arguments)), d <= 1 && (g = e), x;
        };
      }
      var Py = Be(function(d, g, x) {
        var P = 1;
        if (x.length) {
          var B = no(x, Sc(Py));
          P |= o;
        }
        return ha(d, P, g, x, B);
      }), K2 = Be(function(d, g, x) {
        var P = 3;
        if (x.length) {
          var B = no(x, Sc(K2));
          P |= o;
        }
        return ha(g, P, d, x, B);
      });
      function $2(d, g, x) {
        var P, B, X, at, ut, _t, Ot = 0, Rt = !1, Ut = !1, ne = !0;
        if (typeof d != "function")
          throw new Wi(n);
        function se(Jt) {
          var Pe = P, Me = B;
          return P = B = e, Ot = Jt, at = d.apply(Me, Pe);
        }
        function me(Jt) {
          var Pe = Jt - _t;
          return _t === e || Pe >= g || Pe < 0 || Ut && Jt - Ot >= X;
        }
        function Lt() {
          var Jt = Pf();
          if (me(Jt))
            return Gt(Jt);
          ut = Iu(Lt, function(Pe) {
            var Me = g - (Pe - _t);
            return Ut ? Nr(Me, X - (Pe - Ot)) : Me;
          }(Jt));
        }
        function Gt(Jt) {
          return ut = e, ne && P ? se(Jt) : (P = B = e, at);
        }
        function ve() {
          var Jt = Pf(), Pe = me(Jt);
          if (P = arguments, B = this, _t = Jt, Pe) {
            if (ut === e)
              return function(Me) {
                return Ot = Me, ut = Iu(Lt, g), Rt ? se(Me) : at;
              }(_t);
            if (Ut)
              return h2(ut), ut = Iu(Lt, g), se(_t);
          }
          return ut === e && (ut = Iu(Lt, g)), at;
        }
        return g = Ji(g) || 0, Vn(x) && (Rt = !!x.leading, X = (Ut = "maxWait" in x) ? dr(Ji(x.maxWait) || 0, g) : X, ne = "trailing" in x ? !!x.trailing : ne), ve.cancel = function() {
          ut !== e && h2(ut), Ot = 0, P = _t = B = ut = e;
        }, ve.flush = function() {
          return ut === e ? at : Gt(Pf());
        }, ve;
      }
      var xk = Be(function(d, g) {
        return jM(d, 1, g);
      }), bk = Be(function(d, g, x) {
        return jM(d, Ji(g) || 0, x);
      });
      function Df(d, g) {
        if (typeof d != "function" || g != null && typeof g != "function")
          throw new Wi(n);
        var x = function() {
          var P = arguments, B = g ? g.apply(this, P) : P[0], X = x.cache;
          if (X.has(B))
            return X.get(B);
          var at = d.apply(this, P);
          return x.cache = X.set(B, at) || X, at;
        };
        return x.cache = new (Df.Cache || la)(), x;
      }
      function Rf(d) {
        if (typeof d != "function")
          throw new Wi(n);
        return function() {
          var g = arguments;
          switch (g.length) {
            case 0:
              return !d.call(this);
            case 1:
              return !d.call(this, g[0]);
            case 2:
              return !d.call(this, g[0], g[1]);
            case 3:
              return !d.call(this, g[0], g[1], g[2]);
          }
          return !d.apply(this, g);
        };
      }
      Df.Cache = la;
      var Sk = G4(function(d, g) {
        var x = (g = g.length == 1 && Ce(g[0]) ? In(g[0], Ci(ge())) : In(Dr(g, 1), Ci(ge()))).length;
        return Be(function(P) {
          for (var B = -1, X = Nr(P.length, x); ++B < X; )
            P[B] = g[B].call(this, P[B]);
          return kr(d, this, P);
        });
      }), Dy = Be(function(d, g) {
        var x = no(g, Sc(Dy));
        return ha(d, o, e, g, x);
      }), Q2 = Be(function(d, g) {
        var x = no(g, Sc(Q2));
        return ha(d, l, e, g, x);
      }), Mk = ua(function(d, g) {
        return ha(d, u, e, e, e, g);
      });
      function fs(d, g) {
        return d === g || d != d && g != g;
      }
      var Tk = Sf(ny), Ek = Sf(function(d, g) {
        return d >= g;
      }), nl = XM(function() {
        return arguments;
      }()) ? XM : function(d) {
        return qn(d) && on.call(d, "callee") && !LM.call(d, "callee");
      }, Ce = Ct.isArray, Ak = uc ? Ci(uc) : function(d) {
        return qn(d) && ei(d) == ft;
      };
      function vi(d) {
        return d != null && If(d.length) && !pa(d);
      }
      function Qn(d) {
        return qn(d) && vi(d);
      }
      var lo = x4 || Vy, Ck = Ai ? Ci(Ai) : function(d) {
        return qn(d) && ei(d) == b;
      };
      function Ry(d) {
        if (!qn(d))
          return !1;
        var g = ei(d);
        return g == T || g == "[object DOMException]" || typeof d.message == "string" && typeof d.name == "string" && !Ou(d);
      }
      function pa(d) {
        if (!Vn(d))
          return !1;
        var g = ei(d);
        return g == M || g == A || g == "[object AsyncFunction]" || g == "[object Proxy]";
      }
      function tT(d) {
        return typeof d == "number" && d == Ie(d);
      }
      function If(d) {
        return typeof d == "number" && d > -1 && d % 1 == 0 && d <= p;
      }
      function Vn(d) {
        var g = typeof d;
        return d != null && (g == "object" || g == "function");
      }
      function qn(d) {
        return d != null && typeof d == "object";
      }
      var eT = mi ? Ci(mi) : function(d) {
        return qn(d) && Fr(d) == C;
      };
      function nT(d) {
        return typeof d == "number" || qn(d) && ei(d) == I;
      }
      function Ou(d) {
        if (!qn(d) || ei(d) != k)
          return !1;
        var g = sf(d);
        if (g === null)
          return !0;
        var x = on.call(g, "constructor") && g.constructor;
        return typeof x == "function" && x instanceof x && tf.call(x) == m4;
      }
      var Iy = zr ? Ci(zr) : function(d) {
        return qn(d) && ei(d) == L;
      }, rT = dc ? Ci(dc) : function(d) {
        return qn(d) && Fr(d) == E;
      };
      function Of(d) {
        return typeof d == "string" || !Ce(d) && qn(d) && ei(d) == q;
      }
      function Di(d) {
        return typeof d == "symbol" || qn(d) && ei(d) == it;
      }
      var Mc = Xp ? Ci(Xp) : function(d) {
        return qn(d) && If(d.length) && !!fn[ei(d)];
      }, Pk = Sf(ay), Dk = Sf(function(d, g) {
        return d <= g;
      });
      function iT(d) {
        if (!d)
          return [];
        if (vi(d))
          return Of(d) ? ds(d) : gi(d);
        if (wu && d[wu])
          return function(x) {
            for (var P, B = []; !(P = x.next()).done; )
              B.push(P.value);
            return B;
          }(d[wu]());
        var g = Fr(d);
        return (g == C ? q0 : g == E ? Kp : Tc)(d);
      }
      function fa(d) {
        return d ? (d = Ji(d)) === h || d === -1 / 0 ? 17976931348623157e292 * (d < 0 ? -1 : 1) : d == d ? d : 0 : d === 0 ? d : 0;
      }
      function Ie(d) {
        var g = fa(d), x = g % 1;
        return g == g ? x ? g - x : g : 0;
      }
      function sT(d) {
        return d ? $o(Ie(d), 0, v) : 0;
      }
      function Ji(d) {
        if (typeof d == "number")
          return d;
        if (Di(d))
          return f;
        if (Vn(d)) {
          var g = typeof d.valueOf == "function" ? d.valueOf() : d;
          d = Vn(g) ? g + "" : g;
        }
        if (typeof d != "string")
          return d === 0 ? d : +d;
        d = EM(d);
        var x = jt.test(d);
        return x || $t.test(d) ? en(d.slice(2), x ? 2 : 8) : Kt.test(d) ? f : +d;
      }
      function aT(d) {
        return zs(d, yi(d));
      }
      function nn(d) {
        return d == null ? "" : Pi(d);
      }
      var Rk = xc(function(d, g) {
        if (Ru(g) || vi(g))
          zs(g, yr(g), d);
        else
          for (var x in g)
            on.call(g, x) && Tu(d, x, g[x]);
      }), oT = xc(function(d, g) {
        zs(g, yi(g), d);
      }), Lf = xc(function(d, g, x, P) {
        zs(g, yi(g), d, P);
      }), Ik = xc(function(d, g, x, P) {
        zs(g, yr(g), d, P);
      }), Ok = ua(Q0), Lk = Be(function(d, g) {
        d = an(d);
        var x = -1, P = g.length, B = P > 2 ? g[2] : e;
        for (B && ni(g[0], g[1], B) && (P = 1); ++x < P; )
          for (var X = g[x], at = yi(X), ut = -1, _t = at.length; ++ut < _t; ) {
            var Ot = at[ut], Rt = d[Ot];
            (Rt === e || fs(Rt, vc[Ot]) && !on.call(d, Ot)) && (d[Ot] = X[Ot]);
          }
        return d;
      }), Bk = Be(function(d) {
        return d.push(e, E2), kr(lT, e, d);
      });
      function Oy(d, g, x) {
        var P = d == null ? e : Qo(d, g);
        return P === e ? x : P;
      }
      function Ly(d, g) {
        return d != null && P2(d, g, k4);
      }
      var zk = x2(function(d, g, x) {
        g != null && typeof g.toString != "function" && (g = ef.call(g)), d[g] = x;
      }, zy(_i)), kk = x2(function(d, g, x) {
        g != null && typeof g.toString != "function" && (g = ef.call(g)), on.call(d, g) ? d[g].push(x) : d[g] = [x];
      }, ge), Nk = Be(Au);
      function yr(d) {
        return vi(d) ? FM(d) : sy(d);
      }
      function yi(d) {
        return vi(d) ? FM(d, !0) : N4(d);
      }
      var Fk = xc(function(d, g, x) {
        gf(d, g, x);
      }), lT = xc(function(d, g, x, P) {
        gf(d, g, x, P);
      }), Uk = ua(function(d, g) {
        var x = {};
        if (d == null)
          return x;
        var P = !1;
        g = In(g, function(X) {
          return X = ao(X, d), P || (P = X.length > 1), X;
        }), zs(d, _y(d), x), P && (x = qi(x, 7, Z4));
        for (var B = g.length; B--; )
          uy(x, g[B]);
        return x;
      }), Vk = ua(function(d, g) {
        return d == null ? {} : function(x, P) {
          return n2(x, P, function(B, X) {
            return Ly(x, X);
          });
        }(d, g);
      });
      function cT(d, g) {
        if (d == null)
          return {};
        var x = In(_y(d), function(P) {
          return [P];
        });
        return g = ge(g), n2(d, x, function(P, B) {
          return g(P, B[0]);
        });
      }
      var hT = M2(yr), uT = M2(yi);
      function Tc(d) {
        return d == null ? [] : Z0(d, yr(d));
      }
      var Hk = bc(function(d, g, x) {
        return g = g.toLowerCase(), d + (x ? dT(g) : g);
      });
      function dT(d) {
        return By(nn(d).toLowerCase());
      }
      function pT(d) {
        return (d = nn(d)) && d.replace(Yt, o4).replace(O0, "");
      }
      var jk = bc(function(d, g, x) {
        return d + (x ? "-" : "") + g.toLowerCase();
      }), Gk = bc(function(d, g, x) {
        return d + (x ? " " : "") + g.toLowerCase();
      }), Wk = y2("toLowerCase"), Zk = bc(function(d, g, x) {
        return d + (x ? "_" : "") + g.toLowerCase();
      }), qk = bc(function(d, g, x) {
        return d + (x ? " " : "") + By(g);
      }), Xk = bc(function(d, g, x) {
        return d + (x ? " " : "") + g.toUpperCase();
      }), By = y2("toUpperCase");
      function fT(d, g, x) {
        return d = nn(d), (g = x ? e : g) === e ? function(P) {
          return B0.test(P);
        }(d) ? function(P) {
          return P.match(lc) || [];
        }(d) : function(P) {
          return P.match(ot) || [];
        }(d) : d.match(g) || [];
      }
      var mT = Be(function(d, g) {
        try {
          return kr(d, e, g);
        } catch (x) {
          return Ry(x) ? x : new Ee(x);
        }
      }), Yk = ua(function(d, g) {
        return Gi(g, function(x) {
          x = ks(x), ca(d, x, Py(d[x], d));
        }), d;
      });
      function zy(d) {
        return function() {
          return d;
        };
      }
      var Jk = w2(), Kk = w2(!0);
      function _i(d) {
        return d;
      }
      function ky(d) {
        return JM(typeof d == "function" ? d : qi(d, 1));
      }
      var $k = Be(function(d, g) {
        return function(x) {
          return Au(x, d, g);
        };
      }), Qk = Be(function(d, g) {
        return function(x) {
          return Au(d, x, g);
        };
      });
      function Ny(d, g, x) {
        var P = yr(g), B = mf(g, P);
        x != null || Vn(g) && (B.length || !P.length) || (x = g, g = d, d = this, B = mf(g, yr(g)));
        var X = !(Vn(x) && "chain" in x && !x.chain), at = pa(d);
        return Gi(B, function(ut) {
          var _t = g[ut];
          d[ut] = _t, at && (d.prototype[ut] = function() {
            var Ot = this.__chain__;
            if (X || Ot) {
              var Rt = d(this.__wrapped__);
              return (Rt.__actions__ = gi(this.__actions__)).push({ func: _t, args: arguments, thisArg: d }), Rt.__chain__ = Ot, Rt;
            }
            return _t.apply(d, eo([this.value()], arguments));
          });
        }), d;
      }
      function Fy() {
      }
      var tN = gy(In), eN = gy(xM), nN = gy(V0);
      function gT(d) {
        return Sy(d) ? H0(ks(d)) : function(g) {
          return function(x) {
            return Qo(x, g);
          };
        }(d);
      }
      var rN = b2(), iN = b2(!0);
      function Uy() {
        return [];
      }
      function Vy() {
        return !1;
      }
      var sN = xf(function(d, g) {
        return d + g;
      }, 0), aN = vy("ceil"), oN = xf(function(d, g) {
        return d / g;
      }, 1), lN = vy("floor"), Hy, cN = xf(function(d, g) {
        return d * g;
      }, 1), hN = vy("round"), uN = xf(function(d, g) {
        return d - g;
      }, 0);
      return j.after = function(d, g) {
        if (typeof g != "function")
          throw new Wi(n);
        return d = Ie(d), function() {
          if (--d < 1)
            return g.apply(this, arguments);
        };
      }, j.ary = Y2, j.assign = Rk, j.assignIn = oT, j.assignInWith = Lf, j.assignWith = Ik, j.at = Ok, j.before = J2, j.bind = Py, j.bindAll = Yk, j.bindKey = K2, j.castArray = function() {
        if (!arguments.length)
          return [];
        var d = arguments[0];
        return Ce(d) ? d : [d];
      }, j.chain = Z2, j.chunk = function(d, g, x) {
        g = (x ? ni(d, g, x) : g === e) ? 1 : dr(Ie(g), 0);
        var P = d == null ? 0 : d.length;
        if (!P || g < 1)
          return [];
        for (var B = 0, X = 0, at = Ct(lf(P / g)); B < P; )
          at[X++] = Xi(d, B, B += g);
        return at;
      }, j.compact = function(d) {
        for (var g = -1, x = d == null ? 0 : d.length, P = 0, B = []; ++g < x; ) {
          var X = d[g];
          X && (B[P++] = X);
        }
        return B;
      }, j.concat = function() {
        var d = arguments.length;
        if (!d)
          return [];
        for (var g = Ct(d - 1), x = arguments[0], P = d; P--; )
          g[P - 1] = arguments[P];
        return eo(Ce(x) ? gi(x) : [x], Dr(g, 1));
      }, j.cond = function(d) {
        var g = d == null ? 0 : d.length, x = ge();
        return d = g ? In(d, function(P) {
          if (typeof P[1] != "function")
            throw new Wi(n);
          return [x(P[0]), P[1]];
        }) : [], Be(function(P) {
          for (var B = -1; ++B < g; ) {
            var X = d[B];
            if (kr(X[0], this, P))
              return kr(X[1], this, P);
          }
        });
      }, j.conforms = function(d) {
        return function(g) {
          var x = yr(g);
          return function(P) {
            return HM(P, g, x);
          };
        }(qi(d, 1));
      }, j.constant = zy, j.countBy = pk, j.create = function(d, g) {
        var x = wc(d);
        return g == null ? x : VM(x, g);
      }, j.curry = function d(g, x, P) {
        var B = ha(g, 8, e, e, e, e, e, x = P ? e : x);
        return B.placeholder = d.placeholder, B;
      }, j.curryRight = function d(g, x, P) {
        var B = ha(g, a, e, e, e, e, e, x = P ? e : x);
        return B.placeholder = d.placeholder, B;
      }, j.debounce = $2, j.defaults = Lk, j.defaultsDeep = Bk, j.defer = xk, j.delay = bk, j.difference = Y4, j.differenceBy = J4, j.differenceWith = K4, j.drop = function(d, g, x) {
        var P = d == null ? 0 : d.length;
        return P ? Xi(d, (g = x || g === e ? 1 : Ie(g)) < 0 ? 0 : g, P) : [];
      }, j.dropRight = function(d, g, x) {
        var P = d == null ? 0 : d.length;
        return P ? Xi(d, 0, (g = P - (g = x || g === e ? 1 : Ie(g))) < 0 ? 0 : g) : [];
      }, j.dropRightWhile = function(d, g) {
        return d && d.length ? yf(d, ge(g, 3), !0, !0) : [];
      }, j.dropWhile = function(d, g) {
        return d && d.length ? yf(d, ge(g, 3), !0) : [];
      }, j.fill = function(d, g, x, P) {
        var B = d == null ? 0 : d.length;
        return B ? (x && typeof x != "number" && ni(d, g, x) && (x = 0, P = B), function(X, at, ut, _t) {
          var Ot = X.length;
          for ((ut = Ie(ut)) < 0 && (ut = -ut > Ot ? 0 : Ot + ut), (_t = _t === e || _t > Ot ? Ot : Ie(_t)) < 0 && (_t += Ot), _t = ut > _t ? 0 : sT(_t); ut < _t; )
            X[ut++] = at;
          return X;
        }(d, g, x, P)) : [];
      }, j.filter = function(d, g) {
        return (Ce(d) ? to : WM)(d, ge(g, 3));
      }, j.flatMap = function(d, g) {
        return Dr(Cf(d, g), 1);
      }, j.flatMapDeep = function(d, g) {
        return Dr(Cf(d, g), h);
      }, j.flatMapDepth = function(d, g, x) {
        return x = x === e ? 1 : Ie(x), Dr(Cf(d, g), x);
      }, j.flatten = H2, j.flattenDeep = function(d) {
        return d != null && d.length ? Dr(d, h) : [];
      }, j.flattenDepth = function(d, g) {
        return d != null && d.length ? Dr(d, g = g === e ? 1 : Ie(g)) : [];
      }, j.flip = function(d) {
        return ha(d, 512);
      }, j.flow = Jk, j.flowRight = Kk, j.fromPairs = function(d) {
        for (var g = -1, x = d == null ? 0 : d.length, P = {}; ++g < x; ) {
          var B = d[g];
          P[B[0]] = B[1];
        }
        return P;
      }, j.functions = function(d) {
        return d == null ? [] : mf(d, yr(d));
      }, j.functionsIn = function(d) {
        return d == null ? [] : mf(d, yi(d));
      }, j.groupBy = gk, j.initial = function(d) {
        return d != null && d.length ? Xi(d, 0, -1) : [];
      }, j.intersection = $4, j.intersectionBy = Q4, j.intersectionWith = tk, j.invert = zk, j.invertBy = kk, j.invokeMap = vk, j.iteratee = ky, j.keyBy = yk, j.keys = yr, j.keysIn = yi, j.map = Cf, j.mapKeys = function(d, g) {
        var x = {};
        return g = ge(g, 3), Bs(d, function(P, B, X) {
          ca(x, g(P, B, X), P);
        }), x;
      }, j.mapValues = function(d, g) {
        var x = {};
        return g = ge(g, 3), Bs(d, function(P, B, X) {
          ca(x, B, g(P, B, X));
        }), x;
      }, j.matches = function(d) {
        return $M(qi(d, 1));
      }, j.matchesProperty = function(d, g) {
        return QM(d, qi(g, 1));
      }, j.memoize = Df, j.merge = Fk, j.mergeWith = lT, j.method = $k, j.methodOf = Qk, j.mixin = Ny, j.negate = Rf, j.nthArg = function(d) {
        return d = Ie(d), Be(function(g) {
          return t2(g, d);
        });
      }, j.omit = Uk, j.omitBy = function(d, g) {
        return cT(d, Rf(ge(g)));
      }, j.once = function(d) {
        return J2(2, d);
      }, j.orderBy = function(d, g, x, P) {
        return d == null ? [] : (Ce(g) || (g = g == null ? [] : [g]), Ce(x = P ? e : x) || (x = x == null ? [] : [x]), e2(d, g, x));
      }, j.over = tN, j.overArgs = Sk, j.overEvery = eN, j.overSome = nN, j.partial = Dy, j.partialRight = Q2, j.partition = _k, j.pick = Vk, j.pickBy = cT, j.property = gT, j.propertyOf = function(d) {
        return function(g) {
          return d == null ? e : Qo(d, g);
        };
      }, j.pull = ek, j.pullAll = G2, j.pullAllBy = function(d, g, x) {
        return d && d.length && g && g.length ? oy(d, g, ge(x, 2)) : d;
      }, j.pullAllWith = function(d, g, x) {
        return d && d.length && g && g.length ? oy(d, g, e, x) : d;
      }, j.pullAt = nk, j.range = rN, j.rangeRight = iN, j.rearg = Mk, j.reject = function(d, g) {
        return (Ce(d) ? to : WM)(d, Rf(ge(g, 3)));
      }, j.remove = function(d, g) {
        var x = [];
        if (!d || !d.length)
          return x;
        var P = -1, B = [], X = d.length;
        for (g = ge(g, 3); ++P < X; ) {
          var at = d[P];
          g(at, P, d) && (x.push(at), B.push(P));
        }
        return r2(d, B), x;
      }, j.rest = function(d, g) {
        if (typeof d != "function")
          throw new Wi(n);
        return Be(d, g = g === e ? g : Ie(g));
      }, j.reverse = Ay, j.sampleSize = function(d, g, x) {
        return g = (x ? ni(d, g, x) : g === e) ? 1 : Ie(g), (Ce(d) ? I4 : U4)(d, g);
      }, j.set = function(d, g, x) {
        return d == null ? d : Pu(d, g, x);
      }, j.setWith = function(d, g, x, P) {
        return P = typeof P == "function" ? P : e, d == null ? d : Pu(d, g, x, P);
      }, j.shuffle = function(d) {
        return (Ce(d) ? O4 : H4)(d);
      }, j.slice = function(d, g, x) {
        var P = d == null ? 0 : d.length;
        return P ? (x && typeof x != "number" && ni(d, g, x) ? (g = 0, x = P) : (g = g == null ? 0 : Ie(g), x = x === e ? P : Ie(x)), Xi(d, g, x)) : [];
      }, j.sortBy = wk, j.sortedUniq = function(d) {
        return d && d.length ? s2(d) : [];
      }, j.sortedUniqBy = function(d, g) {
        return d && d.length ? s2(d, ge(g, 2)) : [];
      }, j.split = function(d, g, x) {
        return x && typeof x != "number" && ni(d, g, x) && (g = x = e), (x = x === e ? v : x >>> 0) ? (d = nn(d)) && (typeof g == "string" || g != null && !Iy(g)) && !(g = Pi(g)) && fc(d) ? oo(ds(d), 0, x) : d.split(g, x) : [];
      }, j.spread = function(d, g) {
        if (typeof d != "function")
          throw new Wi(n);
        return g = g == null ? 0 : dr(Ie(g), 0), Be(function(x) {
          var P = x[g], B = oo(x, 0, g);
          return P && eo(B, P), kr(d, this, B);
        });
      }, j.tail = function(d) {
        var g = d == null ? 0 : d.length;
        return g ? Xi(d, 1, g) : [];
      }, j.take = function(d, g, x) {
        return d && d.length ? Xi(d, 0, (g = x || g === e ? 1 : Ie(g)) < 0 ? 0 : g) : [];
      }, j.takeRight = function(d, g, x) {
        var P = d == null ? 0 : d.length;
        return P ? Xi(d, (g = P - (g = x || g === e ? 1 : Ie(g))) < 0 ? 0 : g, P) : [];
      }, j.takeRightWhile = function(d, g) {
        return d && d.length ? yf(d, ge(g, 3), !1, !0) : [];
      }, j.takeWhile = function(d, g) {
        return d && d.length ? yf(d, ge(g, 3)) : [];
      }, j.tap = function(d, g) {
        return g(d), d;
      }, j.throttle = function(d, g, x) {
        var P = !0, B = !0;
        if (typeof d != "function")
          throw new Wi(n);
        return Vn(x) && (P = "leading" in x ? !!x.leading : P, B = "trailing" in x ? !!x.trailing : B), $2(d, g, { leading: P, maxWait: g, trailing: B });
      }, j.thru = Af, j.toArray = iT, j.toPairs = hT, j.toPairsIn = uT, j.toPath = function(d) {
        return Ce(d) ? In(d, ks) : Di(d) ? [d] : gi(N2(nn(d)));
      }, j.toPlainObject = aT, j.transform = function(d, g, x) {
        var P = Ce(d), B = P || lo(d) || Mc(d);
        if (g = ge(g, 4), x == null) {
          var X = d && d.constructor;
          x = B ? P ? new X() : [] : Vn(d) && pa(X) ? wc(sf(d)) : {};
        }
        return (B ? Gi : Bs)(d, function(at, ut, _t) {
          return g(x, at, ut, _t);
        }), x;
      }, j.unary = function(d) {
        return Y2(d, 1);
      }, j.union = rk, j.unionBy = ik, j.unionWith = sk, j.uniq = function(d) {
        return d && d.length ? so(d) : [];
      }, j.uniqBy = function(d, g) {
        return d && d.length ? so(d, ge(g, 2)) : [];
      }, j.uniqWith = function(d, g) {
        return g = typeof g == "function" ? g : e, d && d.length ? so(d, e, g) : [];
      }, j.unset = function(d, g) {
        return d == null || uy(d, g);
      }, j.unzip = Cy, j.unzipWith = W2, j.update = function(d, g, x) {
        return d == null ? d : o2(d, g, fy(x));
      }, j.updateWith = function(d, g, x, P) {
        return P = typeof P == "function" ? P : e, d == null ? d : o2(d, g, fy(x), P);
      }, j.values = Tc, j.valuesIn = function(d) {
        return d == null ? [] : Z0(d, yi(d));
      }, j.without = ak, j.words = fT, j.wrap = function(d, g) {
        return Dy(fy(g), d);
      }, j.xor = ok, j.xorBy = lk, j.xorWith = ck, j.zip = hk, j.zipObject = function(d, g) {
        return c2(d || [], g || [], Tu);
      }, j.zipObjectDeep = function(d, g) {
        return c2(d || [], g || [], Pu);
      }, j.zipWith = uk, j.entries = hT, j.entriesIn = uT, j.extend = oT, j.extendWith = Lf, Ny(j, j), j.add = sN, j.attempt = mT, j.camelCase = Hk, j.capitalize = dT, j.ceil = aN, j.clamp = function(d, g, x) {
        return x === e && (x = g, g = e), x !== e && (x = (x = Ji(x)) == x ? x : 0), g !== e && (g = (g = Ji(g)) == g ? g : 0), $o(Ji(d), g, x);
      }, j.clone = function(d) {
        return qi(d, 4);
      }, j.cloneDeep = function(d) {
        return qi(d, 5);
      }, j.cloneDeepWith = function(d, g) {
        return qi(d, 5, g = typeof g == "function" ? g : e);
      }, j.cloneWith = function(d, g) {
        return qi(d, 4, g = typeof g == "function" ? g : e);
      }, j.conformsTo = function(d, g) {
        return g == null || HM(d, g, yr(g));
      }, j.deburr = pT, j.defaultTo = function(d, g) {
        return d == null || d != d ? g : d;
      }, j.divide = oN, j.endsWith = function(d, g, x) {
        d = nn(d), g = Pi(g);
        var P = d.length, B = x = x === e ? P : $o(Ie(x), 0, P);
        return (x -= g.length) >= 0 && d.slice(x, B) == g;
      }, j.eq = fs, j.escape = function(d) {
        return (d = nn(d)) && Z.test(d) ? d.replace(K, l4) : d;
      }, j.escapeRegExp = function(d) {
        return (d = nn(d)) && yt.test(d) ? d.replace(lt, "\\$&") : d;
      }, j.every = function(d, g, x) {
        var P = Ce(d) ? xM : B4;
        return x && ni(d, g, x) && (g = e), P(d, ge(g, 3));
      }, j.find = fk, j.findIndex = U2, j.findKey = function(d, g) {
        return bM(d, ge(g, 3), Bs);
      }, j.findLast = mk, j.findLastIndex = V2, j.findLastKey = function(d, g) {
        return bM(d, ge(g, 3), ey);
      }, j.floor = lN, j.forEach = q2, j.forEachRight = X2, j.forIn = function(d, g) {
        return d == null ? d : ty(d, ge(g, 3), yi);
      }, j.forInRight = function(d, g) {
        return d == null ? d : ZM(d, ge(g, 3), yi);
      }, j.forOwn = function(d, g) {
        return d && Bs(d, ge(g, 3));
      }, j.forOwnRight = function(d, g) {
        return d && ey(d, ge(g, 3));
      }, j.get = Oy, j.gt = Tk, j.gte = Ek, j.has = function(d, g) {
        return d != null && P2(d, g, z4);
      }, j.hasIn = Ly, j.head = j2, j.identity = _i, j.includes = function(d, g, x, P) {
        d = vi(d) ? d : Tc(d), x = x && !P ? Ie(x) : 0;
        var B = d.length;
        return x < 0 && (x = dr(B + x, 0)), Of(d) ? x <= B && d.indexOf(g, x) > -1 : !!B && pc(d, g, x) > -1;
      }, j.indexOf = function(d, g, x) {
        var P = d == null ? 0 : d.length;
        if (!P)
          return -1;
        var B = x == null ? 0 : Ie(x);
        return B < 0 && (B = dr(P + B, 0)), pc(d, g, B);
      }, j.inRange = function(d, g, x) {
        return g = fa(g), x === e ? (x = g, g = 0) : x = fa(x), function(P, B, X) {
          return P >= Nr(B, X) && P < dr(B, X);
        }(d = Ji(d), g, x);
      }, j.invoke = Nk, j.isArguments = nl, j.isArray = Ce, j.isArrayBuffer = Ak, j.isArrayLike = vi, j.isArrayLikeObject = Qn, j.isBoolean = function(d) {
        return d === !0 || d === !1 || qn(d) && ei(d) == w;
      }, j.isBuffer = lo, j.isDate = Ck, j.isElement = function(d) {
        return qn(d) && d.nodeType === 1 && !Ou(d);
      }, j.isEmpty = function(d) {
        if (d == null)
          return !0;
        if (vi(d) && (Ce(d) || typeof d == "string" || typeof d.splice == "function" || lo(d) || Mc(d) || nl(d)))
          return !d.length;
        var g = Fr(d);
        if (g == C || g == E)
          return !d.size;
        if (Ru(d))
          return !sy(d).length;
        for (var x in d)
          if (on.call(d, x))
            return !1;
        return !0;
      }, j.isEqual = function(d, g) {
        return Cu(d, g);
      }, j.isEqualWith = function(d, g, x) {
        var P = (x = typeof x == "function" ? x : e) ? x(d, g) : e;
        return P === e ? Cu(d, g, e, x) : !!P;
      }, j.isError = Ry, j.isFinite = function(d) {
        return typeof d == "number" && zM(d);
      }, j.isFunction = pa, j.isInteger = tT, j.isLength = If, j.isMap = eT, j.isMatch = function(d, g) {
        return d === g || iy(d, g, xy(g));
      }, j.isMatchWith = function(d, g, x) {
        return x = typeof x == "function" ? x : e, iy(d, g, xy(g), x);
      }, j.isNaN = function(d) {
        return nT(d) && d != +d;
      }, j.isNative = function(d) {
        if (X4(d))
          throw new Ee("Unsupported core-js use. Try https://npms.io/search?q=ponyfill.");
        return YM(d);
      }, j.isNil = function(d) {
        return d == null;
      }, j.isNull = function(d) {
        return d === null;
      }, j.isNumber = nT, j.isObject = Vn, j.isObjectLike = qn, j.isPlainObject = Ou, j.isRegExp = Iy, j.isSafeInteger = function(d) {
        return tT(d) && d >= -9007199254740991 && d <= p;
      }, j.isSet = rT, j.isString = Of, j.isSymbol = Di, j.isTypedArray = Mc, j.isUndefined = function(d) {
        return d === e;
      }, j.isWeakMap = function(d) {
        return qn(d) && Fr(d) == rt;
      }, j.isWeakSet = function(d) {
        return qn(d) && ei(d) == "[object WeakSet]";
      }, j.join = function(d, g) {
        return d == null ? "" : b4.call(d, g);
      }, j.kebabCase = jk, j.last = Yi, j.lastIndexOf = function(d, g, x) {
        var P = d == null ? 0 : d.length;
        if (!P)
          return -1;
        var B = P;
        return x !== e && (B = (B = Ie(x)) < 0 ? dr(P + B, 0) : Nr(B, P - 1)), g == g ? function(X, at, ut) {
          for (var _t = ut + 1; _t--; )
            if (X[_t] === at)
              return _t;
          return _t;
        }(d, g, B) : Jp(d, SM, B, !0);
      }, j.lowerCase = Gk, j.lowerFirst = Wk, j.lt = Pk, j.lte = Dk, j.max = function(d) {
        return d && d.length ? ff(d, _i, ny) : e;
      }, j.maxBy = function(d, g) {
        return d && d.length ? ff(d, ge(g, 2), ny) : e;
      }, j.mean = function(d) {
        return MM(d, _i);
      }, j.meanBy = function(d, g) {
        return MM(d, ge(g, 2));
      }, j.min = function(d) {
        return d && d.length ? ff(d, _i, ay) : e;
      }, j.minBy = function(d, g) {
        return d && d.length ? ff(d, ge(g, 2), ay) : e;
      }, j.stubArray = Uy, j.stubFalse = Vy, j.stubObject = function() {
        return {};
      }, j.stubString = function() {
        return "";
      }, j.stubTrue = function() {
        return !0;
      }, j.multiply = cN, j.nth = function(d, g) {
        return d && d.length ? t2(d, Ie(g)) : e;
      }, j.noConflict = function() {
        return En._ === this && (En._ = g4), this;
      }, j.noop = Fy, j.now = Pf, j.pad = function(d, g, x) {
        d = nn(d);
        var P = (g = Ie(g)) ? mc(d) : 0;
        if (!g || P >= g)
          return d;
        var B = (g - P) / 2;
        return bf(cf(B), x) + d + bf(lf(B), x);
      }, j.padEnd = function(d, g, x) {
        d = nn(d);
        var P = (g = Ie(g)) ? mc(d) : 0;
        return g && P < g ? d + bf(g - P, x) : d;
      }, j.padStart = function(d, g, x) {
        d = nn(d);
        var P = (g = Ie(g)) ? mc(d) : 0;
        return g && P < g ? bf(g - P, x) + d : d;
      }, j.parseInt = function(d, g, x) {
        return x || g == null ? g = 0 : g && (g = +g), T4(nn(d).replace(O, ""), g || 0);
      }, j.random = function(d, g, x) {
        if (x && typeof x != "boolean" && ni(d, g, x) && (g = x = e), x === e && (typeof g == "boolean" ? (x = g, g = e) : typeof d == "boolean" && (x = d, d = e)), d === e && g === e ? (d = 0, g = 1) : (d = fa(d), g === e ? (g = d, d = 0) : g = fa(g)), d > g) {
          var P = d;
          d = g, g = P;
        }
        if (x || d % 1 || g % 1) {
          var B = kM();
          return Nr(d + B * (g - d + N0("1e-" + ((B + "").length - 1))), g);
        }
        return ly(d, g);
      }, j.reduce = function(d, g, x) {
        var P = Ce(d) ? U0 : TM, B = arguments.length < 3;
        return P(d, ge(g, 4), x, B, io);
      }, j.reduceRight = function(d, g, x) {
        var P = Ce(d) ? i4 : TM, B = arguments.length < 3;
        return P(d, ge(g, 4), x, B, GM);
      }, j.repeat = function(d, g, x) {
        return g = (x ? ni(d, g, x) : g === e) ? 1 : Ie(g), cy(nn(d), g);
      }, j.replace = function() {
        var d = arguments, g = nn(d[0]);
        return d.length < 3 ? g : g.replace(d[1], d[2]);
      }, j.result = function(d, g, x) {
        var P = -1, B = (g = ao(g, d)).length;
        for (B || (B = 1, d = e); ++P < B; ) {
          var X = d == null ? e : d[ks(g[P])];
          X === e && (P = B, X = x), d = pa(X) ? X.call(d) : X;
        }
        return d;
      }, j.round = hN, j.runInContext = bt, j.sample = function(d) {
        return (Ce(d) ? UM : F4)(d);
      }, j.size = function(d) {
        if (d == null)
          return 0;
        if (vi(d))
          return Of(d) ? mc(d) : d.length;
        var g = Fr(d);
        return g == C || g == E ? d.size : sy(d).length;
      }, j.snakeCase = Zk, j.some = function(d, g, x) {
        var P = Ce(d) ? V0 : j4;
        return x && ni(d, g, x) && (g = e), P(d, ge(g, 3));
      }, j.sortedIndex = function(d, g) {
        return vf(d, g);
      }, j.sortedIndexBy = function(d, g, x) {
        return hy(d, g, ge(x, 2));
      }, j.sortedIndexOf = function(d, g) {
        var x = d == null ? 0 : d.length;
        if (x) {
          var P = vf(d, g);
          if (P < x && fs(d[P], g))
            return P;
        }
        return -1;
      }, j.sortedLastIndex = function(d, g) {
        return vf(d, g, !0);
      }, j.sortedLastIndexBy = function(d, g, x) {
        return hy(d, g, ge(x, 2), !0);
      }, j.sortedLastIndexOf = function(d, g) {
        if (d != null && d.length) {
          var x = vf(d, g, !0) - 1;
          if (fs(d[x], g))
            return x;
        }
        return -1;
      }, j.startCase = qk, j.startsWith = function(d, g, x) {
        return d = nn(d), x = x == null ? 0 : $o(Ie(x), 0, d.length), g = Pi(g), d.slice(x, x + g.length) == g;
      }, j.subtract = uN, j.sum = function(d) {
        return d && d.length ? G0(d, _i) : 0;
      }, j.sumBy = function(d, g) {
        return d && d.length ? G0(d, ge(g, 2)) : 0;
      }, j.template = function(d, g, x) {
        var P = j.templateSettings;
        x && ni(d, g, x) && (g = e), d = nn(d), g = Lf({}, g, P, T2);
        var B, X, at = Lf({}, g.imports, P.imports, T2), ut = yr(at), _t = Z0(at, ut), Ot = 0, Rt = g.interpolate || te, Ut = "__p += '", ne = X0((g.escape || te).source + "|" + Rt.source + "|" + (Rt === z ? xt : te).source + "|" + (g.evaluate || te).source + "|$", "g"), se = "//# sourceURL=" + (on.call(g, "sourceURL") ? (g.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++k0 + "]") + `
`;
        d.replace(ne, function(Gt, ve, Jt, Pe, Me, Je) {
          return Jt || (Jt = Pe), Ut += d.slice(Ot, Je).replace(oe, c4), ve && (B = !0, Ut += `' +
__e(` + ve + `) +
'`), Me && (X = !0, Ut += `';
` + Me + `;
__p += '`), Jt && (Ut += `' +
((__t = (` + Jt + `)) == null ? '' : __t) +
'`), Ot = Je + Gt.length, Gt;
        }), Ut += `';
`;
        var me = on.call(g, "variable") && g.variable;
        if (me) {
          if (St.test(me))
            throw new Ee("Invalid `variable` option passed into `_.template`");
        } else
          Ut = `with (obj) {
` + Ut + `
}
`;
        Ut = (X ? Ut.replace(N, "") : Ut).replace(st, "$1").replace(et, "$1;"), Ut = "function(" + (me || "obj") + `) {
` + (me ? "" : `obj || (obj = {});
`) + "var __t, __p = ''" + (B ? ", __e = _.escape" : "") + (X ? `, __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }
` : `;
`) + Ut + `return __p
}`;
        var Lt = mT(function() {
          return qe(ut, se + "return " + Ut).apply(e, _t);
        });
        if (Lt.source = Ut, Ry(Lt))
          throw Lt;
        return Lt;
      }, j.times = function(d, g) {
        if ((d = Ie(d)) < 1 || d > p)
          return [];
        var x = v, P = Nr(d, v);
        g = ge(g), d -= v;
        for (var B = W0(P, g); ++x < d; )
          g(x);
        return B;
      }, j.toFinite = fa, j.toInteger = Ie, j.toLength = sT, j.toLower = function(d) {
        return nn(d).toLowerCase();
      }, j.toNumber = Ji, j.toSafeInteger = function(d) {
        return d ? $o(Ie(d), -9007199254740991, p) : d === 0 ? d : 0;
      }, j.toString = nn, j.toUpper = function(d) {
        return nn(d).toUpperCase();
      }, j.trim = function(d, g, x) {
        if ((d = nn(d)) && (x || g === e))
          return EM(d);
        if (!d || !(g = Pi(g)))
          return d;
        var P = ds(d), B = ds(g);
        return oo(P, AM(P, B), CM(P, B) + 1).join("");
      }, j.trimEnd = function(d, g, x) {
        if ((d = nn(d)) && (x || g === e))
          return d.slice(0, DM(d) + 1);
        if (!d || !(g = Pi(g)))
          return d;
        var P = ds(d);
        return oo(P, 0, CM(P, ds(g)) + 1).join("");
      }, j.trimStart = function(d, g, x) {
        if ((d = nn(d)) && (x || g === e))
          return d.replace(O, "");
        if (!d || !(g = Pi(g)))
          return d;
        var P = ds(d);
        return oo(P, AM(P, ds(g))).join("");
      }, j.truncate = function(d, g) {
        var x = 30, P = "...";
        if (Vn(g)) {
          var B = "separator" in g ? g.separator : B;
          x = "length" in g ? Ie(g.length) : x, P = "omission" in g ? Pi(g.omission) : P;
        }
        var X = (d = nn(d)).length;
        if (fc(d)) {
          var at = ds(d);
          X = at.length;
        }
        if (x >= X)
          return d;
        var ut = x - mc(P);
        if (ut < 1)
          return P;
        var _t = at ? oo(at, 0, ut).join("") : d.slice(0, ut);
        if (B === e)
          return _t + P;
        if (at && (ut += _t.length - ut), Iy(B)) {
          if (d.slice(ut).search(B)) {
            var Ot, Rt = _t;
            for (B.global || (B = X0(B.source, nn(Ft.exec(B)) + "g")), B.lastIndex = 0; Ot = B.exec(Rt); )
              var Ut = Ot.index;
            _t = _t.slice(0, Ut === e ? ut : Ut);
          }
        } else if (d.indexOf(Pi(B), ut) != ut) {
          var ne = _t.lastIndexOf(B);
          ne > -1 && (_t = _t.slice(0, ne));
        }
        return _t + P;
      }, j.unescape = function(d) {
        return (d = nn(d)) && S.test(d) ? d.replace(J, u4) : d;
      }, j.uniqueId = function(d) {
        var g = ++f4;
        return nn(d) + g;
      }, j.upperCase = Xk, j.upperFirst = By, j.each = q2, j.eachRight = X2, j.first = j2, Ny(j, (Hy = {}, Bs(j, function(d, g) {
        on.call(j.prototype, g) || (Hy[g] = d);
      }), Hy), { chain: !1 }), j.VERSION = "4.17.21", Gi(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(d) {
        j[d].placeholder = j;
      }), Gi(["drop", "take"], function(d, g) {
        He.prototype[d] = function(x) {
          x = x === e ? 1 : dr(Ie(x), 0);
          var P = this.__filtered__ && !g ? new He(this) : this.clone();
          return P.__filtered__ ? P.__takeCount__ = Nr(x, P.__takeCount__) : P.__views__.push({ size: Nr(x, v), type: d + (P.__dir__ < 0 ? "Right" : "") }), P;
        }, He.prototype[d + "Right"] = function(x) {
          return this.reverse()[d](x).reverse();
        };
      }), Gi(["filter", "map", "takeWhile"], function(d, g) {
        var x = g + 1, P = x == 1 || x == 3;
        He.prototype[d] = function(B) {
          var X = this.clone();
          return X.__iteratees__.push({ iteratee: ge(B, 3), type: x }), X.__filtered__ = X.__filtered__ || P, X;
        };
      }), Gi(["head", "last"], function(d, g) {
        var x = "take" + (g ? "Right" : "");
        He.prototype[d] = function() {
          return this[x](1).value()[0];
        };
      }), Gi(["initial", "tail"], function(d, g) {
        var x = "drop" + (g ? "" : "Right");
        He.prototype[d] = function() {
          return this.__filtered__ ? new He(this) : this[x](1);
        };
      }), He.prototype.compact = function() {
        return this.filter(_i);
      }, He.prototype.find = function(d) {
        return this.filter(d).head();
      }, He.prototype.findLast = function(d) {
        return this.reverse().find(d);
      }, He.prototype.invokeMap = Be(function(d, g) {
        return typeof d == "function" ? new He(this) : this.map(function(x) {
          return Au(x, d, g);
        });
      }), He.prototype.reject = function(d) {
        return this.filter(Rf(ge(d)));
      }, He.prototype.slice = function(d, g) {
        d = Ie(d);
        var x = this;
        return x.__filtered__ && (d > 0 || g < 0) ? new He(x) : (d < 0 ? x = x.takeRight(-d) : d && (x = x.drop(d)), g !== e && (x = (g = Ie(g)) < 0 ? x.dropRight(-g) : x.take(g - d)), x);
      }, He.prototype.takeRightWhile = function(d) {
        return this.reverse().takeWhile(d).reverse();
      }, He.prototype.toArray = function() {
        return this.take(v);
      }, Bs(He.prototype, function(d, g) {
        var x = /^(?:filter|find|map|reject)|While$/.test(g), P = /^(?:head|last)$/.test(g), B = j[P ? "take" + (g == "last" ? "Right" : "") : g], X = P || /^find/.test(g);
        B && (j.prototype[g] = function() {
          var at = this.__wrapped__, ut = P ? [1] : arguments, _t = at instanceof He, Ot = ut[0], Rt = _t || Ce(at), Ut = function(ve) {
            var Jt = B.apply(j, eo([ve], ut));
            return P && ne ? Jt[0] : Jt;
          };
          Rt && x && typeof Ot == "function" && Ot.length != 1 && (_t = Rt = !1);
          var ne = this.__chain__, se = !!this.__actions__.length, me = X && !ne, Lt = _t && !se;
          if (!X && Rt) {
            at = Lt ? at : new He(this);
            var Gt = d.apply(at, ut);
            return Gt.__actions__.push({ func: Af, args: [Ut], thisArg: e }), new Zi(Gt, ne);
          }
          return me && Lt ? d.apply(this, ut) : (Gt = this.thru(Ut), me ? P ? Gt.value()[0] : Gt.value() : Gt);
        });
      }), Gi(["pop", "push", "shift", "sort", "splice", "unshift"], function(d) {
        var g = $p[d], x = /^(?:push|sort|unshift)$/.test(d) ? "tap" : "thru", P = /^(?:pop|shift)$/.test(d);
        j.prototype[d] = function() {
          var B = arguments;
          if (P && !this.__chain__) {
            var X = this.value();
            return g.apply(Ce(X) ? X : [], B);
          }
          return this[x](function(at) {
            return g.apply(Ce(at) ? at : [], B);
          });
        };
      }), Bs(He.prototype, function(d, g) {
        var x = j[g];
        if (x) {
          var P = x.name + "";
          on.call(_c, P) || (_c[P] = []), _c[P].push({ name: g, func: x });
        }
      }), _c[wf(e, 2).name] = [{ name: "wrapper", func: e }], He.prototype.clone = function() {
        var d = new He(this.__wrapped__);
        return d.__actions__ = gi(this.__actions__), d.__dir__ = this.__dir__, d.__filtered__ = this.__filtered__, d.__iteratees__ = gi(this.__iteratees__), d.__takeCount__ = this.__takeCount__, d.__views__ = gi(this.__views__), d;
      }, He.prototype.reverse = function() {
        if (this.__filtered__) {
          var d = new He(this);
          d.__dir__ = -1, d.__filtered__ = !0;
        } else
          (d = this.clone()).__dir__ *= -1;
        return d;
      }, He.prototype.value = function() {
        var d = this.__wrapped__.value(), g = this.__dir__, x = Ce(d), P = g < 0, B = x ? d.length : 0, X = function(Je, ue, ye) {
          for (var pr = -1, tr = ye.length; ++pr < tr; ) {
            var ri = ye[pr], An = ri.size;
            switch (ri.type) {
              case "drop":
                Je += An;
                break;
              case "dropRight":
                ue -= An;
                break;
              case "take":
                ue = Nr(ue, Je + An);
                break;
              case "takeRight":
                Je = dr(Je, ue - An);
            }
          }
          return { start: Je, end: ue };
        }(0, B, this.__views__), at = X.start, ut = X.end, _t = ut - at, Ot = P ? ut : at - 1, Rt = this.__iteratees__, Ut = Rt.length, ne = 0, se = Nr(_t, this.__takeCount__);
        if (!x || !P && B == _t && se == _t)
          return l2(d, this.__actions__);
        var me = [];
        t:
          for (; _t-- && ne < se; ) {
            for (var Lt = -1, Gt = d[Ot += g]; ++Lt < Ut; ) {
              var ve = Rt[Lt], Jt = ve.iteratee, Pe = ve.type, Me = Jt(Gt);
              if (Pe == 2)
                Gt = Me;
              else if (!Me) {
                if (Pe == 1)
                  continue t;
                break t;
              }
            }
            me[ne++] = Gt;
          }
        return me;
      }, j.prototype.at = dk, j.prototype.chain = function() {
        return Z2(this);
      }, j.prototype.commit = function() {
        return new Zi(this.value(), this.__chain__);
      }, j.prototype.next = function() {
        this.__values__ === e && (this.__values__ = iT(this.value()));
        var d = this.__index__ >= this.__values__.length;
        return { done: d, value: d ? e : this.__values__[this.__index__++] };
      }, j.prototype.plant = function(d) {
        for (var g, x = this; x instanceof df; ) {
          var P = F2(x);
          P.__index__ = 0, P.__values__ = e, g ? B.__wrapped__ = P : g = P;
          var B = P;
          x = x.__wrapped__;
        }
        return B.__wrapped__ = d, g;
      }, j.prototype.reverse = function() {
        var d = this.__wrapped__;
        if (d instanceof He) {
          var g = d;
          return this.__actions__.length && (g = new He(this)), (g = g.reverse()).__actions__.push({ func: Af, args: [Ay], thisArg: e }), new Zi(g, this.__chain__);
        }
        return this.thru(Ay);
      }, j.prototype.toJSON = j.prototype.valueOf = j.prototype.value = function() {
        return l2(this.__wrapped__, this.__actions__);
      }, j.prototype.first = j.prototype.head, wu && (j.prototype[wu] = function() {
        return this;
      }), j;
    }();
    Ei ? ((Ei.exports = gc)._ = gc, cc._ = gc) : En._ = gc;
  }).call(bn);
})(rb, rb.exports);
var EB = rb.exports;
const lit = Mp(EB);
var ib = { exports: {} };
function cit(i) {
  try {
    return JSON.stringify(i);
  } catch {
    return '"[Circular]"';
  }
}
var hit = function(i, t, e) {
  var n = e && e.stringify || cit;
  if (typeof i == "object" && i !== null) {
    var r = t.length + 1;
    if (r === 1)
      return i;
    var s = new Array(r);
    s[0] = n(i);
    for (var a = 1; a < r; a++)
      s[a] = n(t[a]);
    return s.join(" ");
  }
  if (typeof i != "string")
    return i;
  var o = t.length;
  if (o === 0)
    return i;
  for (var l = "", c = 0, u = -1, h = i && i.length || 0, p = 0; p < h; ) {
    if (i.charCodeAt(p) === 37 && p + 1 < h) {
      switch (u = u > -1 ? u : 0, i.charCodeAt(p + 1)) {
        case 100:
        case 102:
          if (c >= o || t[c] == null)
            break;
          u < p && (l += i.slice(u, p)), l += Number(t[c]), u = p + 2, p++;
          break;
        case 105:
          if (c >= o || t[c] == null)
            break;
          u < p && (l += i.slice(u, p)), l += Math.floor(Number(t[c])), u = p + 2, p++;
          break;
        case 79:
        case 111:
        case 106:
          if (c >= o || t[c] === void 0)
            break;
          u < p && (l += i.slice(u, p));
          var f = typeof t[c];
          if (f === "string") {
            l += "'" + t[c] + "'", u = p + 2, p++;
            break;
          }
          if (f === "function") {
            l += t[c].name || "<anonymous>", u = p + 2, p++;
            break;
          }
          l += n(t[c]), u = p + 2, p++;
          break;
        case 115:
          if (c >= o)
            break;
          u < p && (l += i.slice(u, p)), l += String(t[c]), u = p + 2, p++;
          break;
        case 37:
          u < p && (l += i.slice(u, p)), l += "%", u = p + 2, p++, c--;
      }
      ++c;
    }
    ++p;
  }
  return u === -1 ? i : (u < h && (l += i.slice(u)), l);
};
const vD = hit;
ib.exports = za;
const Fd = function() {
  function i(t) {
    return t !== void 0 && t;
  }
  try {
    return typeof globalThis < "u" || Object.defineProperty(Object.prototype, "globalThis", { get: function() {
      return delete Object.prototype.globalThis, this.globalThis = this;
    }, configurable: !0 }), globalThis;
  } catch {
    return i(self) || i(window) || i(this) || {};
  }
}().console || {}, uit = { mapHttpRequest: _g, mapHttpResponse: _g, wrapRequestSerializer: hw, wrapResponseSerializer: hw, wrapErrorSerializer: hw, req: _g, res: _g, err: _D, errWithCause: _D };
function pv(i, t) {
  return i === "silent" ? 1 / 0 : t.levels.values[i];
}
const sb = Symbol("pino.logFuncs"), ab = Symbol("pino.hierarchy"), dit = { error: "log", fatal: "error", warn: "error", info: "log", debug: "log", trace: "log" };
function yD(i, t) {
  const e = { logger: t, parent: i[ab] };
  t[ab] = e;
}
function za(i) {
  (i = i || {}).browser = i.browser || {};
  const t = i.browser.transmit;
  if (t && typeof t.send != "function")
    throw Error("pino: transmit option must have a send function");
  const e = i.browser.write || Fd;
  i.browser.write && (i.browser.asObject = !0);
  const n = i.serializers || {}, r = function(h, p) {
    return Array.isArray(h) ? h.filter(function(f) {
      return f !== "!stdSerializers.err";
    }) : h === !0 && Object.keys(p);
  }(i.browser.serialize, n);
  let s = i.browser.serialize;
  Array.isArray(i.browser.serialize) && i.browser.serialize.indexOf("!stdSerializers.err") > -1 && (s = !1);
  const a = Object.keys(i.customLevels || {}), o = ["error", "fatal", "warn", "info", "debug", "trace"].concat(a);
  typeof e == "function" && o.forEach(function(h) {
    e[h] = e;
  }), (i.enabled === !1 || i.browser.disabled) && (i.level = "silent");
  const l = i.level || "info", c = Object.create(e);
  c.log || (c.log = Ud), function(h, p, f) {
    const v = {};
    p.forEach((m) => {
      v[m] = f[m] ? f[m] : Fd[m] || Fd[dit[m] || "log"] || Ud;
    }), h[sb] = v;
  }(c, o, e), yD({}, c), Object.defineProperty(c, "levelVal", { get: function() {
    return pv(this.level, this);
  } }), Object.defineProperty(c, "level", { get: function() {
    return this._level;
  }, set: function(h) {
    if (h !== "silent" && !this.levels.values[h])
      throw Error("unknown level " + h);
    this._level = h, yl(this, u, c, "error"), yl(this, u, c, "fatal"), yl(this, u, c, "warn"), yl(this, u, c, "info"), yl(this, u, c, "debug"), yl(this, u, c, "trace"), a.forEach((p) => {
      yl(this, u, c, p);
    });
  } });
  const u = { transmit: t, serialize: r, asObject: i.browser.asObject, formatters: i.browser.formatters, levels: o, timestamp: pit(i) };
  return c.levels = function(h) {
    const p = h.customLevels || {}, f = Object.assign({}, za.levels.values, p), v = Object.assign({}, za.levels.labels, function(m) {
      const y = {};
      return Object.keys(m).forEach(function(_) {
        y[m[_]] = _;
      }), y;
    }(p));
    return { values: f, labels: v };
  }(i), c.level = l, c.setMaxListeners = c.getMaxListeners = c.emit = c.addListener = c.on = c.prependListener = c.once = c.prependOnceListener = c.removeListener = c.removeAllListeners = c.listeners = c.listenerCount = c.eventNames = c.write = c.flush = Ud, c.serializers = n, c._serialize = r, c._stdErrSerialize = s, c.child = function(h, p) {
    if (!h)
      throw new Error("missing bindings for child Pino");
    p = p || {}, r && h.serializers && (p.serializers = h.serializers);
    const f = p.serializers;
    if (r && f) {
      var v = Object.assign({}, n, f), m = i.browser.serialize === !0 ? Object.keys(v) : r;
      delete h.serializers, fv([h], m, v, this._stdErrSerialize);
    }
    function y(w) {
      this._childLevel = 1 + (0 | w._childLevel), this.bindings = h, v && (this.serializers = v, this._serialize = m), t && (this._logEvent = ob([].concat(w._logEvent.bindings, h)));
    }
    y.prototype = this;
    const _ = new y(this);
    return yD(this, _), _.level = this.level, _;
  }, t && (c._logEvent = ob()), c;
}
function yl(i, t, e, n) {
  if (i[n] = pv(i.level, e) > pv(n, e) ? Ud : e[sb][n], !t.transmit && i[n] === Ud)
    return;
  i[n] = function(s, a, o, l) {
    return c = s[sb][l], function() {
      const u = a.timestamp(), h = new Array(arguments.length), p = Object.getPrototypeOf && Object.getPrototypeOf(this) === Fd ? Fd : this;
      for (var f = 0; f < h.length; f++)
        h[f] = arguments[f];
      if (a.serialize && !a.asObject && fv(h, this._serialize, this.serializers, this._stdErrSerialize), a.asObject || a.formatters ? c.call(p, function(v, m, y, _, w = {}) {
        const { level: b = () => v.levels.values[m], log: T = (k) => k } = w;
        v._serialize && fv(y, v._serialize, v.serializers, v._stdErrSerialize);
        const M = y.slice();
        let A = M[0];
        const C = {};
        _ && (C.time = _), C.level = b(m, v.levels.values[m]);
        let I = 1 + (0 | v._childLevel);
        if (I < 1 && (I = 1), A !== null && typeof A == "object") {
          for (; I-- && typeof M[0] == "object"; )
            Object.assign(C, M.shift());
          A = M.length ? vD(M.shift(), M) : void 0;
        } else
          typeof A == "string" && (A = vD(M.shift(), M));
        return A !== void 0 && (C.msg = A), T(C);
      }(this, l, h, u, a.formatters)) : c.apply(p, h), a.transmit) {
        const v = a.transmit.level || s._level, m = o.levels.values[v], y = o.levels.values[l];
        if (y < m)
          return;
        (function(_, w, b) {
          const T = w.send, M = w.ts, A = w.methodLevel, C = w.methodValue, I = w.val, k = _._logEvent.bindings;
          fv(b, _._serialize || Object.keys(_.serializers), _.serializers, _._stdErrSerialize === void 0 || _._stdErrSerialize), _._logEvent.ts = M, _._logEvent.messages = b.filter(function(R) {
            return k.indexOf(R) === -1;
          }), _._logEvent.level.label = A, _._logEvent.level.value = C, T(A, _._logEvent, I), _._logEvent = ob(k);
        })(this, { ts: u, methodLevel: l, methodValue: y, transmitLevel: v, transmitValue: o.levels.values[a.transmit.level || s._level], send: a.transmit.send, val: pv(s._level, o) }, h);
      }
    };
    var c;
  }(i, t, e, n);
  const r = function(s) {
    const a = [];
    s.bindings && a.push(s.bindings);
    let o = s[ab];
    for (; o.parent; )
      o = o.parent, o.logger.bindings && a.push(o.logger.bindings);
    return a.reverse();
  }(i);
  r.length !== 0 && (i[n] = function(s, a) {
    return function() {
      return a.apply(this, [...s, ...arguments]);
    };
  }(r, i[n]));
}
function fv(i, t, e, n) {
  for (const r in i)
    if (n && i[r] instanceof Error)
      i[r] = za.stdSerializers.err(i[r]);
    else if (typeof i[r] == "object" && !Array.isArray(i[r]))
      for (const s in i[r])
        t && t.indexOf(s) > -1 && s in e && (i[r][s] = e[s](i[r][s]));
}
function ob(i) {
  return { ts: 0, messages: [], bindings: i || [], level: { label: "", value: 0 } };
}
function _D(i) {
  const t = { type: i.constructor.name, msg: i.message, stack: i.stack };
  for (const e in i)
    t[e] === void 0 && (t[e] = i[e]);
  return t;
}
function pit(i) {
  return typeof i.timestamp == "function" ? i.timestamp : i.timestamp === !1 ? AB : CB;
}
function _g() {
  return {};
}
function hw(i) {
  return i;
}
function Ud() {
}
function AB() {
  return !1;
}
function CB() {
  return Date.now();
}
function th(i, t, e, n) {
  if (e === "a" && !n)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof t == "function" ? i !== t || !n : !t.has(i))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return e === "m" ? n : e === "a" ? n.call(i) : n ? n.value : t.get(i);
}
var wD, xD;
za.levels = { values: { fatal: 60, error: 50, warn: 40, info: 30, debug: 20, trace: 10 }, labels: { 10: "trace", 20: "debug", 30: "info", 40: "warn", 50: "error", 60: "fatal" } }, za.stdSerializers = uit, za.stdTimeFunctions = Object.assign({}, { nullTime: AB, epochTime: CB, unixTime: function() {
  return Math.round(Date.now() / 1e3);
}, isoTime: function() {
  return new Date(Date.now()).toISOString();
} }), ib.exports.default = za, ib.exports.pino = za, function(i) {
  i.Model = "Model", i.Object = "Object", i.ModelFolder = "ModelFolder", i.AllModels = "all-models";
}(wD || (wD = {})), function(i) {
  i[i.PERPENDICULAR = 0] = "PERPENDICULAR", i[i.POINTTOPOINT = 1] = "POINTTOPOINT";
}(xD || (xD = {}));
const _l = Object.freeze({ Stream: { Owner: "stream:owner", Contributor: "stream:contributor", Reviewer: "stream:reviewer" }, Server: { Admin: "server:admin", User: "server:user", Guest: "server:guest", ArchivedUser: "server:archived-user" } });
Object.freeze({ Stream: { [_l.Stream.Owner]: { title: "Owner", description: "Owners have full access, including deletion rights & access control." }, [_l.Stream.Contributor]: { title: "Contributor", description: "Contributors can create new branches and commits, but they cannot edit stream details or manage collaborators." }, [_l.Stream.Reviewer]: { title: "Reviewer", description: "Reviewers can only view (read) the data from this stream." } }, Server: { [_l.Server.Admin]: "Admin", [_l.Server.User]: "User", [_l.Server.Guest]: "Guest", [_l.Server.ArchivedUser]: "Archived" } });
const fit = Object.freeze({ Streams: { Read: "streams:read", Write: "streams:write" }, Profile: { Read: "profile:read", Email: "profile:email", Delete: "profile:delete" }, Users: { Read: "users:read", Email: "users:email", Invite: "users:invite" }, Server: { Stats: "server:stats", Setup: "server:setup" }, Tokens: { Read: "tokens:read", Write: "tokens:write" }, Apps: { Read: "apps:read", Write: "apps:write" }, Automate: { ReportResults: "automate:report-results" } });
function uw(i, t) {
  let e = i[0], n = i[1], r = i[2], s = i[3];
  e = Hr(e, n, r, s, t[0], 7, -680876936), s = Hr(s, e, n, r, t[1], 12, -389564586), r = Hr(r, s, e, n, t[2], 17, 606105819), n = Hr(n, r, s, e, t[3], 22, -1044525330), e = Hr(e, n, r, s, t[4], 7, -176418897), s = Hr(s, e, n, r, t[5], 12, 1200080426), r = Hr(r, s, e, n, t[6], 17, -1473231341), n = Hr(n, r, s, e, t[7], 22, -45705983), e = Hr(e, n, r, s, t[8], 7, 1770035416), s = Hr(s, e, n, r, t[9], 12, -1958414417), r = Hr(r, s, e, n, t[10], 17, -42063), n = Hr(n, r, s, e, t[11], 22, -1990404162), e = Hr(e, n, r, s, t[12], 7, 1804603682), s = Hr(s, e, n, r, t[13], 12, -40341101), r = Hr(r, s, e, n, t[14], 17, -1502002290), n = Hr(n, r, s, e, t[15], 22, 1236535329), e = jr(e, n, r, s, t[1], 5, -165796510), s = jr(s, e, n, r, t[6], 9, -1069501632), r = jr(r, s, e, n, t[11], 14, 643717713), n = jr(n, r, s, e, t[0], 20, -373897302), e = jr(e, n, r, s, t[5], 5, -701558691), s = jr(s, e, n, r, t[10], 9, 38016083), r = jr(r, s, e, n, t[15], 14, -660478335), n = jr(n, r, s, e, t[4], 20, -405537848), e = jr(e, n, r, s, t[9], 5, 568446438), s = jr(s, e, n, r, t[14], 9, -1019803690), r = jr(r, s, e, n, t[3], 14, -187363961), n = jr(n, r, s, e, t[8], 20, 1163531501), e = jr(e, n, r, s, t[13], 5, -1444681467), s = jr(s, e, n, r, t[2], 9, -51403784), r = jr(r, s, e, n, t[7], 14, 1735328473), n = jr(n, r, s, e, t[12], 20, -1926607734), e = Gr(e, n, r, s, t[5], 4, -378558), s = Gr(s, e, n, r, t[8], 11, -2022574463), r = Gr(r, s, e, n, t[11], 16, 1839030562), n = Gr(n, r, s, e, t[14], 23, -35309556), e = Gr(e, n, r, s, t[1], 4, -1530992060), s = Gr(s, e, n, r, t[4], 11, 1272893353), r = Gr(r, s, e, n, t[7], 16, -155497632), n = Gr(n, r, s, e, t[10], 23, -1094730640), e = Gr(e, n, r, s, t[13], 4, 681279174), s = Gr(s, e, n, r, t[0], 11, -358537222), r = Gr(r, s, e, n, t[3], 16, -722521979), n = Gr(n, r, s, e, t[6], 23, 76029189), e = Gr(e, n, r, s, t[9], 4, -640364487), s = Gr(s, e, n, r, t[12], 11, -421815835), r = Gr(r, s, e, n, t[15], 16, 530742520), n = Gr(n, r, s, e, t[2], 23, -995338651), e = Wr(e, n, r, s, t[0], 6, -198630844), s = Wr(s, e, n, r, t[7], 10, 1126891415), r = Wr(r, s, e, n, t[14], 15, -1416354905), n = Wr(n, r, s, e, t[5], 21, -57434055), e = Wr(e, n, r, s, t[12], 6, 1700485571), s = Wr(s, e, n, r, t[3], 10, -1894986606), r = Wr(r, s, e, n, t[10], 15, -1051523), n = Wr(n, r, s, e, t[1], 21, -2054922799), e = Wr(e, n, r, s, t[8], 6, 1873313359), s = Wr(s, e, n, r, t[15], 10, -30611744), r = Wr(r, s, e, n, t[6], 15, -1560198380), n = Wr(n, r, s, e, t[13], 21, 1309151649), e = Wr(e, n, r, s, t[4], 6, -145523070), s = Wr(s, e, n, r, t[11], 10, -1120210379), r = Wr(r, s, e, n, t[2], 15, 718787259), n = Wr(n, r, s, e, t[9], 21, -343485551), i[0] = Ua(e, i[0]), i[1] = Ua(n, i[1]), i[2] = Ua(r, i[2]), i[3] = Ua(s, i[3]);
}
function D0(i, t, e, n, r, s) {
  return t = Ua(Ua(t, i), Ua(n, s)), Ua(t << r | t >>> 32 - r, e);
}
function Hr(i, t, e, n, r, s, a) {
  return D0(t & e | ~t & n, i, t, r, s, a);
}
function jr(i, t, e, n, r, s, a) {
  return D0(t & n | e & ~n, i, t, r, s, a);
}
function Gr(i, t, e, n, r, s, a) {
  return D0(t ^ e ^ n, i, t, r, s, a);
}
function Wr(i, t, e, n, r, s, a) {
  return D0(e ^ (t | ~n), i, t, r, s, a);
}
function mit(i) {
  const t = [];
  let e;
  for (e = 0; e < 64; e += 4)
    t[e >> 2] = i.charCodeAt(e) + (i.charCodeAt(e + 1) << 8) + (i.charCodeAt(e + 2) << 16) + (i.charCodeAt(e + 3) << 24);
  return t;
}
lit.flatMap(fit, (i) => Object.values(i));
const bD = "0123456789abcdef".split("");
function git(i) {
  let t = "", e = 0;
  for (; e < 4; e++)
    t += bD[i >> 8 * e + 4 & 15] + bD[i >> 8 * e & 15];
  return t;
}
let Ua = (i, t) => i + t & 4294967295;
var Mo;
(function(i) {
  for (let t = 0; t < i.length; t++)
    i[t] = git(i[t]);
  return i.join("");
})(function(i) {
  const t = i.length, e = [1732584193, -271733879, -1732584194, 271733878];
  let n;
  for (n = 64; n <= i.length; n += 64)
    uw(e, mit(i.substring(n - 64, n)));
  i = i.substring(n - 64);
  const r = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
  for (n = 0; n < i.length; n++)
    r[n >> 2] |= i.charCodeAt(n) << (n % 4 << 3);
  if (r[n >> 2] |= 128 << (n % 4 << 3), n > 55)
    for (uw(e, r), n = 0; n < 16; n++)
      r[n] = 0;
  return r[14] = 8 * t, uw(e, r), e;
}("hello")) !== "5d41402abc4b2a76b9719d911017c592" && (Ua = (i, t) => {
  const e = (65535 & i) + (65535 & t);
  return (i >> 16) + (t >> 16) + (e >> 16) << 16 | 65535 & e;
});
Mo = /* @__PURE__ */ new WeakMap();
const PB = function() {
  try {
    const i = "___localStorageAvailabilityTest", t = globalThis.localStorage;
    return t.setItem(i, i), t.getItem(i), t.removeItem(i), !0;
  } catch {
    return !1;
  }
}(), dw = PB ? globalThis.localStorage : new class {
  constructor() {
    Mo.set(this, /* @__PURE__ */ new Map());
  }
  clear() {
    th(this, Mo, "f").clear();
  }
  getItem(i) {
    return th(this, Mo, "f").get(i) || null;
  }
  key(i) {
    return [...th(this, Mo, "f").keys()][i] || null;
  }
  removeItem(i) {
    th(this, Mo, "f").delete(i);
  }
  setItem(i, t) {
    th(this, Mo, "f").set(i, t);
  }
  get length() {
    return th(this, Mo, "f").size;
  }
}(), vit = { get: (i) => dw.getItem(i), set(i, t) {
  dw.setItem(i, t);
}, remove(i) {
  dw.removeItem(i);
}, isRealLocalStorage: PB };
var SD;
function rM(i, t, e) {
  return t in i ? Object.defineProperty(i, t, { value: e, enumerable: !0, configurable: !0, writable: !0 }) : i[t] = e, i;
}
(function(i) {
  i.Windows = "win", i.Mac = "mac", i.Linux = "linux", i.Android = "android", i.iOS = "ios", i.Other = "other";
})(SD || (SD = {}));
class iM extends Error {
  constructor(t, e) {
    t || (t = new.target.defaultMessage), super(t, e);
  }
}
rM(iM, "defaultMessage", "Unexpected error occurred");
class mv extends iM {
}
rM(mv, "defaultMessage", "Object loader configured incorrectly!");
let DB = class extends iM {
};
rM(DB, "defaultMessage", "Object loader encountered a runtime problem!");
class yit {
  constructor(t) {
    var e;
    let { serverUrl: n, streamId: r, token: s, objectId: a, options: o = { enableCaching: !0, fullyTraverseArrays: !1, excludeProps: [], fetch: null, customLogger: void 0, customWarner: void 0 } } = t;
    if (this.logger = o.customLogger || console.log, this.warner = o.customWarner || console.warn, this.INTERVAL_MS = 20, this.TIMEOUT_MS = 18e4, this.serverUrl = n || (globalThis == null || (e = globalThis.location) === null || e === void 0 ? void 0 : e.origin), !this.serverUrl)
      throw new mv("Invalid serverUrl specified!");
    if (this.streamId = r, this.objectId = a, !this.streamId)
      throw new mv("Invalid streamId specified!");
    if (!this.objectId)
      throw new mv("Invalid objectId specified!");
    this.logger("Object loader constructor called!");
    try {
      this.token = s || vit.get("AuthToken");
    } catch {
    }
    this.headers = { Accept: "text/plain" }, this.token && (this.headers.Authorization = "Bearer ".concat(this.token)), this.requestUrlRootObj = "".concat(this.serverUrl, "/objects/").concat(this.streamId, "/").concat(this.objectId, "/single"), this.requestUrlChildren = "".concat(this.serverUrl, "/api/getobjects/").concat(this.streamId), this.promises = [], this.intervals = {}, this.buffer = [], this.isLoading = !1, this.totalChildrenCount = 0, this.traversedReferencesCount = 0, this.options = o, this.options.numConnections = this.options.numConnections || 4, this.cacheDB = null, this.lastAsyncPause = Date.now(), this.existingAsyncPause = null, this.preferredFetch = o.fetch, this.fetch = function() {
      const l = this.preferredFetch || fetch;
      if (!l)
        throw new DB("Couldn't find fetch implementation! If running in a node environment, make sure you pass it in through the constructor!");
      return l(...arguments);
    };
  }
  async asyncPause() {
    Date.now() - this.lastAsyncPause >= 100 && (this.lastAsyncPause = Date.now(), this.existingAsyncPause = new Promise((t) => setTimeout(t, 0)), await this.existingAsyncPause, this.existingAsyncPause = null, Date.now() - this.lastAsyncPause > 500 && this.logger("Loader Event loop lag: ", Date.now() - this.lastAsyncPause));
  }
  dispose() {
    this.buffer = [], this.promises = [], Object.values(this.intervals).forEach((t) => clearInterval(t.interval));
  }
  async getAndConstructObject(t) {
    await this.downloadObjectsInBuffer(t);
    const e = await this.getObject(this.objectId);
    return this.traverseAndConstruct(e, t);
  }
  async downloadObjectsInBuffer(t) {
    let e = !0, n = 0;
    for await (const r of this.getObjectIterator())
      e && (this.totalChildrenCount = r.totalChildrenCount, e = !1, this.isLoading = !0), n++, t && t({ stage: "download", current: n, total: this.totalChildrenCount });
    this.isLoading = !1;
  }
  async traverseAndConstruct(t, e) {
    if (t) {
      if (typeof t != "object")
        return t;
      if (Array.isArray(t) && t.length !== 0) {
        var n, r;
        const s = [];
        for (const a of t) {
          if (!a)
            continue;
          if (typeof a != "object" && !this.options.fullyTraverseArrays)
            return t;
          const o = a.referencedId ? await this.getObject(a.referencedId) : a;
          a.referencedId && e && e({ stage: "construction", current: ++this.traversedReferencesCount > this.totalChildrenCount ? this.totalChildrenCount : this.traversedReferencesCount, total: this.totalChildrenCount }), s.push(await this.traverseAndConstruct(o, e));
        }
        return (n = s[0]) !== null && n !== void 0 && (r = n.speckle_type) !== null && r !== void 0 && r.toLowerCase().includes("datachunk") ? s.reduce((a, o) => a.concat(o.data), []) : s;
      }
      for (const s of this.options.excludeProps)
        delete t[s];
      for (const s in t)
        typeof t[s] == "object" && t[s] !== null && (t[s].referencedId && (t[s] = await this.getObject(t[s].referencedId), e && e({ stage: "construction", current: ++this.traversedReferencesCount > this.totalChildrenCount ? this.totalChildrenCount : this.traversedReferencesCount, total: this.totalChildrenCount })), t[s] = await this.traverseAndConstruct(t[s], e));
      return t;
    }
  }
  async getObject(t) {
    return this.buffer[t] ? this.buffer[t] : new Promise((e, n) => {
      if (this.promises.push({ id: t, resolve: e, reject: n }), this.intervals[t])
        this.intervals[t].elapsed = 0;
      else {
        const r = setInterval(this.tryResolvePromise.bind(this), this.INTERVAL_MS, t);
        this.intervals[t] = { interval: r, elapsed: 0 };
      }
    });
  }
  tryResolvePromise(t) {
    if (this.intervals[t].elapsed += this.INTERVAL_MS, this.buffer[t]) {
      for (const e of this.promises.filter((n) => n.id === t))
        e.resolve(this.buffer[t]);
      return clearInterval(this.intervals[t].interval), void delete this.intervals[t];
    }
    this.intervals[t].elapsed > this.TIMEOUT_MS && (this.warner("Timeout resolving ".concat(t, ". HIC SVNT DRACONES.")), clearInterval(this.intervals[t].interval), this.promises.filter((e) => e.id === t).forEach((e) => e.reject()), this.promises = this.promises.filter((e) => e.id != e.id));
  }
  async *getObjectIterator() {
    const t = Date.now();
    let e = 0;
    for await (const n of this.getRawObjectIterator()) {
      const { id: r, obj: s } = this.processLine(n);
      this.buffer[r] = s, e += 1, yield s;
    }
    this.logger("Loaded ".concat(e, " objects in: ").concat((Date.now() - t) / 1e3));
  }
  processLine(t) {
    const e = t.split("	");
    return { id: e[0], obj: JSON.parse(e[1]) };
  }
  supportsCache() {
    return !(!this.options.enableCaching || !globalThis.indexedDB);
  }
  async setupCacheDb() {
    if (!this.supportsCache() || this.cacheDB !== null)
      return;
    await function() {
      if (navigator.userAgentData || !/Safari\//.test(navigator.userAgent) || /Chrom(e|ium)\//.test(navigator.userAgent) || !indexedDB.databases)
        return Promise.resolve();
      let e;
      return new Promise((n) => {
        const r = () => indexedDB.databases().finally(n);
        e = setInterval(r, 100), r();
      }).finally(() => clearInterval(e));
    }();
    const t = indexedDB.open("speckle-object-cache", 1);
    t.onupgradeneeded = () => t.result.createObjectStore("objects"), this.cacheDB = await this.promisifyIdbRequest(t);
  }
  async *getRawObjectIterator() {
    await this.setupCacheDb();
    const t = await this.getRawRootObject();
    yield "".concat(this.objectId, "	").concat(t);
    const e = JSON.parse(t);
    if (!e.__closure)
      return;
    let n = Object.keys(e.__closure).filter((u) => !u.includes("blob")).sort((u, h) => e.__closure[u] - e.__closure[h]);
    if (n.length === 0)
      return;
    let r = [];
    if (n.length > 50) {
      const u = [[], [], [], []];
      let h = 0;
      for (; h < 0.05 * n.length; h++)
        u[0].push(n[h]);
      for (; h < 0.2 * n.length; h++)
        u[1].push(n[h]);
      for (; h < 0.6 * n.length; h++)
        u[2].push(n[h]);
      for (; h < n.length; h++)
        u[3].push(n[h]);
      this.logger("Cache check for: ", u);
      const p = [];
      let f = this.cacheGetObjects(u[0]);
      for (let v = 0; v < 4; v++) {
        const m = await f;
        v < 3 && (f = this.cacheGetObjects(u[v + 1]));
        const y = Object.keys(m).sort((b, T) => e.__closure[b] - e.__closure[T]);
        for (const b of y)
          yield "".concat(b, "	").concat(m[b]);
        const _ = u[v].filter((b) => !(b in m)), w = EB.chunk(_, 500);
        for (let b = 0; b < w.length; b++)
          p.push.apply(p, w[b]);
      }
      if (p.length === 0)
        return;
      if (p.length <= 50)
        r.push(p);
      else {
        for (r = [[], [], [], []], h = 0; h < 0.05 * p.length; h++)
          r[0].push(p[h]);
        for (; h < 0.2 * p.length; h++)
          r[1].push(p[h]);
        for (; h < 0.6 * p.length; h++)
          r[2].push(p[h]);
        for (; h < p.length; h++)
          r[3].push(p[h]);
      }
    } else {
      const u = await this.cacheGetObjects(n), h = Object.keys(u).sort((p, f) => e.__closure[p] - e.__closure[f]);
      for (const p of h)
        yield "".concat(p, "	").concat(u[p]);
      if (n = n.filter((p) => !(p in u)), n.length === 0)
        return;
      r.push(n);
    }
    const s = [], a = [], o = [], l = [], c = [];
    for (let u = 0; u < r.length; u++)
      s.push(new TextDecoder()), a.push(null), o.push(null), l.push(""), c.push(!1), this.fetch(this.requestUrlChildren, { method: "POST", headers: { ...this.headers, "Content-Type": "application/json" }, body: JSON.stringify({ objects: JSON.stringify(r[u]) }) }).then((h) => {
        h.body.getReader && (h.body.iterator = async function* () {
          const v = this.getReader();
          for (; ; ) {
            const m = await v.read();
            if (m.done)
              return m.value;
            yield m.value;
          }
        });
        const p = h.body.iterator();
        a[u] = p;
        const f = p.next().then((v) => (v.reqId = u, v));
        o[u] = f;
      });
    for (; ; ) {
      const u = o.filter((_) => !!_);
      if (u.length === 0) {
        if (c.every((_) => _))
          break;
        await new Promise((_) => {
          setTimeout(_, 10);
        });
        continue;
      }
      const h = await Promise.any(u);
      let { value: p, done: f, reqId: v } = h;
      if (c[v] = f, f)
        l[v].length > 0 && (yield l[v], l[v] = ""), o[v] = null;
      else {
        const _ = a[v].next().then((w) => (w.reqId = v, w));
        o[v] = _;
      }
      if (!p)
        continue;
      p = s[v].decode(p);
      const m = (l[v] + p).split(/\r\n|\n|\r/), y = m.pop();
      l[v] = y;
      for (const _ of m)
        yield _;
      this.cacheStoreObjects(m);
    }
  }
  async getRawRootObject() {
    const t = await this.cacheGetObjects([this.objectId]);
    if (t[this.objectId])
      return t[this.objectId];
    const e = await this.fetch(this.requestUrlRootObj, { headers: this.headers }), n = await e.text();
    return this.cacheStoreObjects(["".concat(this.objectId, "	").concat(n)]), n;
  }
  promisifyIdbRequest(t) {
    return new Promise((e, n) => {
      t.oncomplete = t.onsuccess = () => e(t.result), t.onabort = t.onerror = () => n(t.error);
    });
  }
  async cacheGetObjects(t) {
    if (!this.supportsCache())
      return {};
    const e = {};
    for (let n = 0; n < t.length; n += 500) {
      const r = t.slice(n, n + 500), s = this.cacheDB.transaction("objects", "readonly").objectStore("objects"), a = r.map((l) => this.promisifyIdbRequest(s.get(l)).then((c) => ({ id: l, data: c }))), o = await Promise.all(a);
      for (const l of o)
        l.data && (e[l.id] = l.data);
    }
    return e;
  }
  cacheStoreObjects(t) {
    if (!this.supportsCache())
      return {};
    const e = this.cacheDB.transaction("objects", "readwrite").objectStore("objects");
    for (const n of t) {
      const r = n.split("	");
      e.put(r[1], r[0]);
    }
    return this.promisifyIdbRequest(e.transaction);
  }
}
var Td = ((i) => (i.TEXTURE_8BPP = "png", i.TEXTURE_HDR = "hdr", i.TEXTURE_EXR = "exr", i))(Td || {});
const Oi = { showStats: !1, verbose: !1, keepGeometryData: !1 };
var tn = ((i) => (i.ObjectClicked = "object-clicked", i.ObjectDoubleClicked = "object-doubleclicked", i.DownloadComplete = "download-complete", i.LoadComplete = "load-complete", i.LoadProgress = "load-progress", i.UnloadComplete = "unload-complete", i.LoadCancelled = "load-cancelled", i.UnloadAllComplete = "unload-all-complete", i.Busy = "busy", i.SectionBoxChanged = "section-box-changed", i.SectionBoxUpdated = "section-box-updated", i))(tn || {});
const RB = { enabled: !0, castShadow: !0, intensity: 5, color: 16777215, elevation: 1.8, azimuth: 0.75, radius: 0, indirectLightIntensity: 1, shadowcatcher: !1 }, Zr = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
function IB() {
  const i = 4294967295 * Math.random() | 0, t = 4294967295 * Math.random() | 0, e = 4294967295 * Math.random() | 0, n = 4294967295 * Math.random() | 0;
  return (Zr[255 & i] + Zr[i >> 8 & 255] + Zr[i >> 16 & 255] + Zr[i >> 24 & 255] + "-" + Zr[255 & t] + Zr[t >> 8 & 255] + "-" + Zr[t >> 16 & 15 | 64] + Zr[t >> 24 & 255] + "-" + Zr[63 & e | 128] + Zr[e >> 8 & 255] + "-" + Zr[e >> 16 & 255] + Zr[e >> 24 & 255] + Zr[255 & n] + Zr[n >> 8 & 255] + Zr[n >> 16 & 255] + Zr[n >> 24 & 255]).toLowerCase();
}
var OB, LB, _it = function i(t, e) {
  var n, r, s = e.length;
  return s >= 2 ? (n = e.slice(0, s / 2), r = e.slice(s / 2, s), function(a, o, l) {
    for (var c = [], u = o.length, h = l.length; u > 0 && h > 0; )
      a(o[0], l[0]) <= 0 ? (c.push(o.shift()), u--) : (c.push(l.shift()), h--);
    return u > 0 ? c.push.apply(c, o) : c.push.apply(c, l), c;
  }(t, i(t, n), i(t, r))) : e.slice();
}, wit = function(i, t, e) {
  var n, r;
  for (n = 0, r = t.length; n < r && !(i(t[n], e) > 0); n++)
    ;
  return n;
};
OB = _it, LB = wit;
var xit = function() {
  var i;
  function t(l) {
    return function() {
      return l;
    };
  }
  function e(l) {
    l = l || {}, this.config = l, this.config.childrenPropertyName = l.childrenPropertyName || "children", this.config.modelComparatorFn = l.modelComparatorFn;
  }
  function n(l, c) {
    return c.parent = l, l.children.push(c), c;
  }
  function r(l, c) {
    this.config = l, this.model = c, this.children = [];
  }
  function s(l) {
    return typeof l.config.modelComparatorFn == "function";
  }
  function a(l, c, u) {
    var h;
    if (!(c instanceof r))
      throw new TypeError("Child must be of type Node.");
    if (c.parent = l, l.model[l.config.childrenPropertyName] instanceof Array || (l.model[l.config.childrenPropertyName] = []), s(l))
      h = LB(l.config.modelComparatorFn, l.model[l.config.childrenPropertyName], c.model), l.model[l.config.childrenPropertyName].splice(h, 0, c.model), l.children.splice(h, 0, c);
    else if (u === void 0)
      l.model[l.config.childrenPropertyName].push(c.model), l.children.push(c);
    else {
      if (u < 0 || u > l.children.length)
        throw new Error("Invalid index.");
      l.model[l.config.childrenPropertyName].splice(u, 0, c.model), l.children.splice(u, 0, c);
    }
    return c;
  }
  function o() {
    var l = {};
    if (arguments.length === 1 ? typeof arguments[0] == "function" ? l.fn = arguments[0] : l.options = arguments[0] : arguments.length === 2 ? typeof arguments[0] == "function" ? (l.fn = arguments[0], l.ctx = arguments[1]) : (l.options = arguments[0], l.fn = arguments[1]) : (l.options = arguments[0], l.fn = arguments[1], l.ctx = arguments[2]), l.options = l.options || {}, l.options.strategy || (l.options.strategy = "pre"), !i[l.options.strategy])
      throw new Error("Unknown tree walk strategy. Valid strategies are 'pre' [default], 'post' and 'breadth'.");
    return l;
  }
  return i = {}, e.prototype.parse = function(l) {
    var c, u, h;
    if (!(l instanceof Object))
      throw new TypeError("Model must be of type object.");
    if (h = new r(this.config, l), l[this.config.childrenPropertyName] instanceof Array)
      for (this.config.modelComparatorFn && (l[this.config.childrenPropertyName] = OB(this.config.modelComparatorFn, l[this.config.childrenPropertyName])), c = 0, u = l[this.config.childrenPropertyName].length; c < u; c++)
        n(h, this.parse(l[this.config.childrenPropertyName][c]));
    return h;
  }, r.prototype.isRoot = function() {
    return this.parent === void 0;
  }, r.prototype.hasChildren = function() {
    return this.children.length > 0;
  }, r.prototype.addChild = function(l) {
    return a(this, l);
  }, r.prototype.addChildAtIndex = function(l, c) {
    if (s(this))
      throw new Error("Cannot add child at index when using a comparator function.");
    return a(this, l, c);
  }, r.prototype.setIndex = function(l) {
    if (s(this))
      throw new Error("Cannot set node index when using a comparator function.");
    if (this.isRoot()) {
      if (l === 0)
        return this;
      throw new Error("Invalid index.");
    }
    if (l < 0 || l >= this.parent.children.length)
      throw new Error("Invalid index.");
    var c = this.parent.children.indexOf(this);
    return this.parent.children.splice(l, 0, this.parent.children.splice(c, 1)[0]), this.parent.model[this.parent.config.childrenPropertyName].splice(l, 0, this.parent.model[this.parent.config.childrenPropertyName].splice(c, 1)[0]), this;
  }, r.prototype.getPath = function() {
    var l = [];
    return function c(u) {
      l.unshift(u), u.isRoot() || c(u.parent);
    }(this), l;
  }, r.prototype.getIndex = function() {
    return this.isRoot() ? 0 : this.parent.children.indexOf(this);
  }, r.prototype.walk = function() {
    var l;
    l = o.apply(this, arguments), i[l.options.strategy].call(this, l.fn, l.ctx);
  }, i.pre = function l(c, u) {
    var h, p, f;
    for (f = c.call(u, this), h = 0, p = this.children.length; h < p; h++) {
      if (f === !1)
        return !1;
      f = l.call(this.children[h], c, u);
    }
    return f;
  }, i.post = function l(c, u) {
    var h, p;
    for (h = 0, p = this.children.length; h < p; h++)
      if (l.call(this.children[h], c, u) === !1)
        return !1;
    return c.call(u, this);
  }, i.breadth = function(l, c) {
    var u = [this];
    (function h() {
      var p, f, v;
      if (u.length !== 0) {
        for (p = 0, f = (v = u.shift()).children.length; p < f; p++)
          u.push(v.children[p]);
        l.call(c, v) !== !1 && h();
      }
    })();
  }, r.prototype.all = function() {
    var l, c = [];
    return (l = o.apply(this, arguments)).fn = l.fn || t(!0), i[l.options.strategy].call(this, function(u) {
      l.fn.call(l.ctx, u) && c.push(u);
    }, l.ctx), c;
  }, r.prototype.first = function() {
    var l, c;
    return (l = o.apply(this, arguments)).fn = l.fn || t(!0), i[l.options.strategy].call(this, function(u) {
      if (l.fn.call(l.ctx, u))
        return c = u, !1;
    }, l.ctx), c;
  }, r.prototype.drop = function() {
    var l;
    return this.isRoot() || (l = this.parent.children.indexOf(this), this.parent.children.splice(l, 1), this.parent.model[this.config.childrenPropertyName].splice(l, 1), this.parent = void 0, delete this.parent), this;
  }, e;
}();
const lb = Mp(xit);
class bit {
  constructor() {
    U(this, "tree");
    U(this, "root");
    this.tree = new lb(), this.root = this.tree.parse({ guid: "MOTHERSHIP" });
  }
  findAll(t) {
    return this.root.all((e) => !!e.model.data && t(e.model.guid, e.model.data)).map((e) => e.model.data);
  }
  findFirst(t) {
    return this.root.first((e) => !!e.model.data && t(e.model.guid, e.model.data)).model.data;
  }
  walk(t) {
    this.root.walk((e) => !e.model.data || t(e.model.guid, e.model.data));
  }
}
class Sit {
  static build(t) {
    const e = new bit();
    let n = null;
    return Qt.getInstance().walk((r) => {
      if (!r.parent)
        return n = e.root, !0;
      n = e.root.first((a) => a.model.guid === r.parent.model.id);
      const s = Qt.getInstance().parse({ guid: r.model.id, data: r.model.raw, atomic: r.model.atomic, children: [] });
      return n.addChild(s), !0;
    }, t), e;
  }
}
const sM = 0, Mit = 1, Tit = 2, pw = 1.25, MD = 1, fw = 65535, Eit = Math.pow(2, -24);
class wg {
  constructor() {
  }
}
function Cs(i, t, e) {
  return e.min.x = t[i], e.min.y = t[i + 1], e.min.z = t[i + 2], e.max.x = t[i + 3], e.max.y = t[i + 4], e.max.z = t[i + 5], e;
}
function TD(i) {
  let t = -1, e = -1 / 0;
  for (let n = 0; n < 3; n++) {
    const r = i[n + 3] - i[n];
    r > e && (e = r, t = n);
  }
  return t;
}
function ED(i, t) {
  t.set(i);
}
function AD(i, t, e) {
  let n, r;
  for (let s = 0; s < 3; s++) {
    const a = s + 3;
    n = i[s], r = t[s], e[s] = n < r ? n : r, n = i[a], r = t[a], e[a] = n > r ? n : r;
  }
}
function xg(i, t, e) {
  for (let n = 0; n < 3; n++) {
    const r = t[i + 2 * n], s = t[i + 2 * n + 1], a = r - s, o = r + s;
    a < e[n] && (e[n] = a), o > e[n + 3] && (e[n + 3] = o);
  }
}
function cd(i) {
  const t = i[3] - i[0], e = i[4] - i[1], n = i[5] - i[2];
  return 2 * (t * e + e * n + n * t);
}
function mw(i, t, e, n, r = null) {
  let s = 1 / 0, a = 1 / 0, o = 1 / 0, l = -1 / 0, c = -1 / 0, u = -1 / 0, h = 1 / 0, p = 1 / 0, f = 1 / 0, v = -1 / 0, m = -1 / 0, y = -1 / 0;
  const _ = r !== null;
  for (let w = 6 * t, b = 6 * (t + e); w < b; w += 6) {
    const T = i[w + 0], M = i[w + 1], A = T - M, C = T + M;
    A < s && (s = A), C > l && (l = C), _ && T < h && (h = T), _ && T > v && (v = T);
    const I = i[w + 2], k = i[w + 3], R = I - k, L = I + k;
    R < a && (a = R), L > c && (c = L), _ && I < p && (p = I), _ && I > m && (m = I);
    const E = i[w + 4], q = i[w + 5], it = E - q, rt = E + q;
    it < o && (o = it), rt > u && (u = rt), _ && E < f && (f = E), _ && E > y && (y = E);
  }
  n[0] = s, n[1] = a, n[2] = o, n[3] = l, n[4] = c, n[5] = u, _ && (r[0] = h, r[1] = p, r[2] = f, r[3] = v, r[4] = m, r[5] = y);
}
const Pa = 32, Ait = (i, t) => i.candidate - t.candidate, xo = new Array(Pa).fill().map(() => ({ count: 0, bounds: new Float32Array(6), rightCacheBounds: new Float32Array(6), leftCacheBounds: new Float32Array(6), candidate: 0 })), bg = new Float32Array(6);
function Cit(i, t) {
  function e(_) {
    p && p(_ / f);
  }
  function n(_, w, b, T = null, M = 0) {
    if (!v && M >= l && (v = !0, c && (console.warn(`MeshBVH: Max depth of ${l} reached when generating BVH. Consider increasing maxDepth.`), console.warn(i))), b <= u || M >= l)
      return e(w + b), _.offset = w, _.count = b, _;
    const A = function(I, k, R, L, E, q) {
      let it = -1, rt = 0;
      if (q === sM)
        it = TD(k), it !== -1 && (rt = (k[it] + k[it + 3]) / 2);
      else if (q === Mit)
        it = TD(I), it !== -1 && (rt = function(ft, nt, vt, $) {
          let W = 0;
          for (let ct = nt, mt = nt + vt; ct < mt; ct++)
            W += ft[6 * ct + 2 * $];
          return W / vt;
        }(R, L, E, it));
      else if (q === Tit) {
        const ft = cd(I);
        let nt = pw * E;
        const vt = 6 * L, $ = 6 * (L + E);
        for (let W = 0; W < 3; W++) {
          const ct = k[W], mt = (k[W + 3] - ct) / Pa;
          if (E < Pa / 4) {
            const dt = [...xo];
            dt.length = E;
            let Mt = 0;
            for (let H = vt; H < $; H += 6, Mt++) {
              const N = dt[Mt];
              N.candidate = R[H + 2 * W], N.count = 0;
              const { bounds: st, leftCacheBounds: et, rightCacheBounds: J } = N;
              for (let K = 0; K < 3; K++)
                J[K] = 1 / 0, J[K + 3] = -1 / 0, et[K] = 1 / 0, et[K + 3] = -1 / 0, st[K] = 1 / 0, st[K + 3] = -1 / 0;
              xg(H, R, st);
            }
            dt.sort(Ait);
            let At = E;
            for (let H = 0; H < At; H++) {
              const N = dt[H];
              for (; H + 1 < At && dt[H + 1].candidate === N.candidate; )
                dt.splice(H + 1, 1), At--;
            }
            for (let H = vt; H < $; H += 6) {
              const N = R[H + 2 * W];
              for (let st = 0; st < At; st++) {
                const et = dt[st];
                N >= et.candidate ? xg(H, R, et.rightCacheBounds) : (xg(H, R, et.leftCacheBounds), et.count++);
              }
            }
            for (let H = 0; H < At; H++) {
              const N = dt[H], st = N.count, et = E - N.count, J = N.leftCacheBounds, K = N.rightCacheBounds;
              let S = 0;
              st !== 0 && (S = cd(J) / ft);
              let Z = 0;
              et !== 0 && (Z = cd(K) / ft);
              const G = MD + pw * (S * st + Z * et);
              G < nt && (it = W, nt = G, rt = N.candidate);
            }
          } else {
            for (let At = 0; At < Pa; At++) {
              const H = xo[At];
              H.count = 0, H.candidate = ct + mt + At * mt;
              const N = H.bounds;
              for (let st = 0; st < 3; st++)
                N[st] = 1 / 0, N[st + 3] = -1 / 0;
            }
            for (let At = vt; At < $; At += 6) {
              let H = ~~((R[At + 2 * W] - ct) / mt);
              H >= Pa && (H = Pa - 1);
              const N = xo[H];
              N.count++, xg(At, R, N.bounds);
            }
            const dt = xo[Pa - 1];
            ED(dt.bounds, dt.rightCacheBounds);
            for (let At = Pa - 2; At >= 0; At--) {
              const H = xo[At], N = xo[At + 1];
              AD(H.bounds, N.rightCacheBounds, H.rightCacheBounds);
            }
            let Mt = 0;
            for (let At = 0; At < Pa - 1; At++) {
              const H = xo[At], N = H.count, st = H.bounds, et = xo[At + 1].rightCacheBounds;
              N !== 0 && (Mt === 0 ? ED(st, bg) : AD(st, bg, bg)), Mt += N;
              let J = 0, K = 0;
              Mt !== 0 && (J = cd(bg) / ft);
              const S = E - Mt;
              S !== 0 && (K = cd(et) / ft);
              const Z = MD + pw * (J * Mt + K * S);
              Z < nt && (it = W, nt = Z, rt = H.candidate);
            }
          }
        }
      } else
        console.warn(`MeshBVH: Invalid build strategy value ${q} used.`);
      return { axis: it, pos: rt };
    }(_.boundingData, T, a, w, b, h);
    if (A.axis === -1)
      return e(w + b), _.offset = w, _.count = b, _;
    const C = function(I, k, R, L, E) {
      let q = R, it = R + L - 1;
      const rt = E.pos, ft = 2 * E.axis;
      for (; ; ) {
        for (; q <= it && k[6 * q + ft] < rt; )
          q++;
        for (; q <= it && k[6 * it + ft] >= rt; )
          it--;
        if (!(q < it))
          return q;
        for (let nt = 0; nt < 3; nt++) {
          let vt = I[3 * q + nt];
          I[3 * q + nt] = I[3 * it + nt], I[3 * it + nt] = vt;
          let $ = k[6 * q + 2 * nt + 0];
          k[6 * q + 2 * nt + 0] = k[6 * it + 2 * nt + 0], k[6 * it + 2 * nt + 0] = $;
          let W = k[6 * q + 2 * nt + 1];
          k[6 * q + 2 * nt + 1] = k[6 * it + 2 * nt + 1], k[6 * it + 2 * nt + 1] = W;
        }
        q++, it--;
      }
    }(o, a, w, b, A);
    if (C === w || C === w + b)
      e(w + b), _.offset = w, _.count = b;
    else {
      _.splitAxis = A.axis;
      const I = new wg(), k = w, R = C - w;
      _.left = I, I.boundingData = new Float32Array(6), mw(a, k, R, I.boundingData, s), n(I, k, R, s, M + 1);
      const L = new wg(), E = C, q = b - R;
      _.right = L, L.boundingData = new Float32Array(6), mw(a, E, q, L.boundingData, s), n(L, E, q, s, M + 1);
    }
    return _;
  }
  (function(_, w) {
    if (!_.index) {
      const b = _.attributes.position.count, T = w.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;
      let M;
      M = b > 65535 ? new Uint32Array(new T(4 * b)) : new Uint16Array(new T(2 * b)), _.setIndex(new Ze(M, 1));
      for (let A = 0; A < b; A++)
        M[A] = A;
    }
  })(i, t);
  const r = new Float32Array(6), s = new Float32Array(6), a = function(_, w) {
    const b = _.attributes.position, T = _.index.array, M = T.length / 3, A = new Float32Array(6 * M), C = b.normalized, I = b.array, k = b.offset || 0;
    let R = 3;
    b.isInterleavedBufferAttribute && (R = b.data.stride);
    const L = ["getX", "getY", "getZ"];
    for (let E = 0; E < M; E++) {
      const q = 3 * E, it = 6 * E;
      let rt, ft, nt;
      C ? (rt = T[q + 0], ft = T[q + 1], nt = T[q + 2]) : (rt = T[q + 0] * R + k, ft = T[q + 1] * R + k, nt = T[q + 2] * R + k);
      for (let vt = 0; vt < 3; vt++) {
        let $, W, ct;
        C ? ($ = b[L[vt]](rt), W = b[L[vt]](ft), ct = b[L[vt]](nt)) : ($ = I[rt + vt], W = I[ft + vt], ct = I[nt + vt]);
        let mt = $;
        W < mt && (mt = W), ct < mt && (mt = ct);
        let dt = $;
        W > dt && (dt = W), ct > dt && (dt = ct);
        const Mt = (dt - mt) / 2, At = 2 * vt;
        A[it + At + 0] = mt + Mt, A[it + At + 1] = Mt + (Math.abs(mt) + Mt) * Eit, mt < w[vt] && (w[vt] = mt), dt > w[vt + 3] && (w[vt + 3] = dt);
      }
    }
    return A;
  }(i, r), o = i.index.array, l = t.maxDepth, c = t.verbose, u = t.maxLeafTris, h = t.strategy, p = t.onProgress, f = i.index.count / 3;
  let v = !1;
  const m = [], y = function(_) {
    if (!_.groups || !_.groups.length)
      return [{ offset: 0, count: _.index.count / 3 }];
    const w = [], b = /* @__PURE__ */ new Set();
    for (const M of _.groups)
      b.add(M.start), b.add(M.start + M.count);
    const T = Array.from(b.values()).sort((M, A) => M - A);
    for (let M = 0; M < T.length - 1; M++) {
      const A = T[M], C = T[M + 1];
      w.push({ offset: A / 3, count: (C - A) / 3 });
    }
    return w;
  }(i);
  if (y.length === 1) {
    const _ = y[0], w = new wg();
    w.boundingData = r, function(b, T, M, A) {
      let C = 1 / 0, I = 1 / 0, k = 1 / 0, R = -1 / 0, L = -1 / 0, E = -1 / 0;
      for (let q = 6 * T, it = 6 * (T + M); q < it; q += 6) {
        const rt = b[q + 0];
        rt < C && (C = rt), rt > R && (R = rt);
        const ft = b[q + 2];
        ft < I && (I = ft), ft > L && (L = ft);
        const nt = b[q + 4];
        nt < k && (k = nt), nt > E && (E = nt);
      }
      A[0] = C, A[1] = I, A[2] = k, A[3] = R, A[4] = L, A[5] = E;
    }(a, _.offset, _.count, s), n(w, _.offset, _.count, s), m.push(w);
  } else
    for (let _ of y) {
      const w = new wg();
      w.boundingData = new Float32Array(6), mw(a, _.offset, _.count, w.boundingData, s), n(w, _.offset, _.count, s), m.push(w);
    }
  return m;
}
class ja {
  constructor() {
    this.min = 1 / 0, this.max = -1 / 0;
  }
  setFromPointsField(t, e) {
    let n = 1 / 0, r = -1 / 0;
    for (let s = 0, a = t.length; s < a; s++) {
      const o = t[s][e];
      n = o < n ? o : n, r = o > r ? o : r;
    }
    this.min = n, this.max = r;
  }
  setFromPoints(t, e) {
    let n = 1 / 0, r = -1 / 0;
    for (let s = 0, a = e.length; s < a; s++) {
      const o = e[s], l = t.dot(o);
      n = l < n ? l : n, r = l > r ? l : r;
    }
    this.min = n, this.max = r;
  }
  isSeparated(t) {
    return this.min > t.max || t.min > this.max;
  }
}
ja.prototype.setFromBox = function() {
  const i = new D();
  return function(t, e) {
    const n = e.min, r = e.max;
    let s = 1 / 0, a = -1 / 0;
    for (let o = 0; o <= 1; o++)
      for (let l = 0; l <= 1; l++)
        for (let c = 0; c <= 1; c++) {
          i.x = n.x * o + r.x * (1 - o), i.y = n.y * l + r.y * (1 - l), i.z = n.z * c + r.z * (1 - c);
          const u = t.dot(i);
          s = Math.min(u, s), a = Math.max(u, a);
        }
    this.min = s, this.max = a;
  };
}();
const Pit = function() {
  const i = new D(), t = new D(), e = new D();
  return function(n, r, s) {
    const a = n.start, o = i, l = r.start, c = t;
    e.subVectors(a, l), i.subVectors(n.end, n.start), t.subVectors(r.end, r.start);
    const u = e.dot(c), h = c.dot(o), p = c.dot(c), f = e.dot(o), v = o.dot(o) * p - h * h;
    let m, y;
    m = v !== 0 ? (u * h - f * p) / v : 0, y = (u + m * h) / p, s.x = m, s.y = y;
  };
}(), cb = function() {
  const i = new wt(), t = new D(), e = new D();
  return function(n, r, s, a) {
    Pit(n, r, i);
    let o = i.x, l = i.y;
    if (o >= 0 && o <= 1 && l >= 0 && l <= 1)
      return n.at(o, s), void r.at(l, a);
    if (o >= 0 && o <= 1)
      return l < 0 ? r.at(0, a) : r.at(1, a), void n.closestPointToPoint(a, !0, s);
    if (l >= 0 && l <= 1)
      return o < 0 ? n.at(0, s) : n.at(1, s), void r.closestPointToPoint(s, !0, a);
    {
      let c, u;
      c = o < 0 ? n.start : n.end, u = l < 0 ? r.start : r.end;
      const h = t, p = e;
      return n.closestPointToPoint(u, !0, t), r.closestPointToPoint(c, !0, e), h.distanceToSquared(u) <= p.distanceToSquared(c) ? (s.copy(h), void a.copy(u)) : (s.copy(c), void a.copy(p));
    }
  };
}(), Dit = function() {
  const i = new D(), t = new D(), e = new Hn(), n = new ss();
  return function(r, s) {
    const { radius: a, center: o } = r, { a: l, b: c, c: u } = s;
    if (n.start = l, n.end = c, n.closestPointToPoint(o, !0, i).distanceTo(o) <= a || (n.start = l, n.end = u, n.closestPointToPoint(o, !0, i).distanceTo(o) <= a) || (n.start = c, n.end = u, n.closestPointToPoint(o, !0, i).distanceTo(o) <= a))
      return !0;
    const h = s.getPlane(e);
    if (Math.abs(h.distanceToPoint(o)) <= a) {
      const p = h.projectPoint(o, t);
      if (s.containsPoint(p))
        return !0;
    }
    return !1;
  };
}();
function eh(i) {
  return Math.abs(i) < 1e-15;
}
class ta extends Pr {
  constructor(...t) {
    super(...t), this.isExtendedTriangle = !0, this.satAxes = new Array(4).fill().map(() => new D()), this.satBounds = new Array(4).fill().map(() => new ja()), this.points = [this.a, this.b, this.c], this.sphere = new Mi(), this.plane = new Hn(), this.needsUpdate = !0;
  }
  intersectsSphere(t) {
    return Dit(t, this);
  }
  update() {
    const t = this.a, e = this.b, n = this.c, r = this.points, s = this.satAxes, a = this.satBounds, o = s[0], l = a[0];
    this.getNormal(o), l.setFromPoints(o, r);
    const c = s[1], u = a[1];
    c.subVectors(t, e), u.setFromPoints(c, r);
    const h = s[2], p = a[2];
    h.subVectors(e, n), p.setFromPoints(h, r);
    const f = s[3], v = a[3];
    f.subVectors(n, t), v.setFromPoints(f, r), this.sphere.setFromPoints(this.points), this.plane.setFromNormalAndCoplanarPoint(o, t), this.needsUpdate = !1;
  }
}
ta.prototype.closestPointToSegment = function() {
  const i = new D(), t = new D(), e = new ss();
  return function(n, r = null, s = null) {
    const { start: a, end: o } = n, l = this.points;
    let c, u = 1 / 0;
    for (let h = 0; h < 3; h++) {
      const p = (h + 1) % 3;
      e.start.copy(l[h]), e.end.copy(l[p]), cb(e, n, i, t), c = i.distanceToSquared(t), c < u && (u = c, r && r.copy(i), s && s.copy(t));
    }
    return this.closestPointToPoint(a, i), c = a.distanceToSquared(i), c < u && (u = c, r && r.copy(i), s && s.copy(a)), this.closestPointToPoint(o, i), c = o.distanceToSquared(i), c < u && (u = c, r && r.copy(i), s && s.copy(o)), Math.sqrt(u);
  };
}(), ta.prototype.intersectsTriangle = function() {
  const i = new ta(), t = new Array(3), e = new Array(3), n = new ja(), r = new ja(), s = new D(), a = new D(), o = new D(), l = new D(), c = new ss(), u = new ss(), h = new ss();
  return function(p, f = null) {
    this.needsUpdate && this.update(), p.isExtendedTriangle ? p.needsUpdate && p.update() : (i.copy(p), i.update(), p = i);
    const v = this.plane, m = p.plane;
    if (Math.abs(v.normal.dot(m.normal)) > 1 - 1e-10) {
      const y = this.satBounds, _ = this.satAxes;
      e[0] = p.a, e[1] = p.b, e[2] = p.c;
      for (let T = 0; T < 4; T++) {
        const M = y[T], A = _[T];
        if (n.setFromPoints(A, e), M.isSeparated(n))
          return !1;
      }
      const w = p.satBounds, b = p.satAxes;
      t[0] = this.a, t[1] = this.b, t[2] = this.c;
      for (let T = 0; T < 4; T++) {
        const M = w[T], A = b[T];
        if (n.setFromPoints(A, t), M.isSeparated(n))
          return !1;
      }
      for (let T = 0; T < 4; T++) {
        const M = _[T];
        for (let A = 0; A < 4; A++) {
          const C = b[A];
          if (s.crossVectors(M, C), n.setFromPoints(s, t), r.setFromPoints(s, e), n.isSeparated(r))
            return !1;
        }
      }
      return f && (console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."), f.start.set(0, 0, 0), f.end.set(0, 0, 0)), !0;
    }
    {
      const y = this.points;
      let _ = !1, w = 0;
      for (let R = 0; R < 3; R++) {
        const L = y[R], E = y[(R + 1) % 3];
        c.start.copy(L), c.end.copy(E), c.delta(a);
        const q = _ ? u.start : u.end, it = eh(m.distanceToPoint(L));
        if (eh(m.normal.dot(a)) && it) {
          u.copy(c), w = 2;
          break;
        }
        if ((m.intersectLine(c, q) || it) && !eh(q.distanceTo(E))) {
          if (w++, _)
            break;
          _ = !0;
        }
      }
      if (w === 1 && this.containsPoint(u.end))
        return f && (f.start.copy(u.end), f.end.copy(u.end)), !0;
      if (w !== 2)
        return !1;
      const b = p.points;
      let T = !1, M = 0;
      for (let R = 0; R < 3; R++) {
        const L = b[R], E = b[(R + 1) % 3];
        c.start.copy(L), c.end.copy(E), c.delta(o);
        const q = T ? h.start : h.end, it = eh(v.distanceToPoint(L));
        if (eh(v.normal.dot(o)) && it) {
          h.copy(c), M = 2;
          break;
        }
        if ((v.intersectLine(c, q) || it) && !eh(q.distanceTo(E))) {
          if (M++, T)
            break;
          T = !0;
        }
      }
      if (M === 1 && this.containsPoint(h.end))
        return f && (f.start.copy(h.end), f.end.copy(h.end)), !0;
      if (M !== 2)
        return !1;
      if (u.delta(a), h.delta(o), a.dot(o) < 0) {
        let R = h.start;
        h.start = h.end, h.end = R;
      }
      const A = u.start.dot(a), C = u.end.dot(a), I = h.start.dot(a), k = h.end.dot(a);
      return (A === k || I === C || C < I != A < k) && (f && (l.subVectors(u.start, h.start), l.dot(a) > 0 ? f.start.copy(u.start) : f.start.copy(h.start), l.subVectors(u.end, h.end), l.dot(a) < 0 ? f.end.copy(u.end) : f.end.copy(h.end)), !0);
    }
  };
}(), ta.prototype.distanceToPoint = function() {
  const i = new D();
  return function(t) {
    return this.closestPointToPoint(t, i), t.distanceTo(i);
  };
}(), ta.prototype.distanceToTriangle = function() {
  const i = new D(), t = new D(), e = ["a", "b", "c"], n = new ss(), r = new ss();
  return function(s, a = null, o = null) {
    const l = a || o ? n : null;
    if (this.intersectsTriangle(s, l))
      return (a || o) && (a && l.getCenter(a), o && l.getCenter(o)), 0;
    let c = 1 / 0;
    for (let u = 0; u < 3; u++) {
      let h;
      const p = e[u], f = s[p];
      this.closestPointToPoint(f, i), h = f.distanceToSquared(i), h < c && (c = h, a && a.copy(i), o && o.copy(f));
      const v = this[p];
      s.closestPointToPoint(v, i), h = v.distanceToSquared(i), h < c && (c = h, a && a.copy(v), o && o.copy(i));
    }
    for (let u = 0; u < 3; u++) {
      const h = e[u], p = e[(u + 1) % 3];
      n.set(this[h], this[p]);
      for (let f = 0; f < 3; f++) {
        const v = e[f], m = e[(f + 1) % 3];
        r.set(s[v], s[m]), cb(n, r, i, t);
        const y = i.distanceToSquared(t);
        y < c && (c = y, a && a.copy(i), o && o.copy(t));
      }
    }
    return Math.sqrt(c);
  };
}();
class Js {
  constructor(t, e, n) {
    this.isOrientedBox = !0, this.min = new D(), this.max = new D(), this.matrix = new Vt(), this.invMatrix = new Vt(), this.points = new Array(8).fill().map(() => new D()), this.satAxes = new Array(3).fill().map(() => new D()), this.satBounds = new Array(3).fill().map(() => new ja()), this.alignedSatBounds = new Array(3).fill().map(() => new ja()), this.needsUpdate = !1, t && this.min.copy(t), e && this.max.copy(e), n && this.matrix.copy(n);
  }
  set(t, e, n) {
    this.min.copy(t), this.max.copy(e), this.matrix.copy(n), this.needsUpdate = !0;
  }
  copy(t) {
    this.min.copy(t.min), this.max.copy(t.max), this.matrix.copy(t.matrix), this.needsUpdate = !0;
  }
}
Js.prototype.update = function() {
  const i = this.matrix, t = this.min, e = this.max, n = this.points;
  for (let l = 0; l <= 1; l++)
    for (let c = 0; c <= 1; c++)
      for (let u = 0; u <= 1; u++) {
        const h = n[1 * l | 2 * c | 4 * u];
        h.x = l ? e.x : t.x, h.y = c ? e.y : t.y, h.z = u ? e.z : t.z, h.applyMatrix4(i);
      }
  const r = this.satBounds, s = this.satAxes, a = n[0];
  for (let l = 0; l < 3; l++) {
    const c = s[l], u = r[l], h = n[1 << l];
    c.subVectors(a, h), u.setFromPoints(c, n);
  }
  const o = this.alignedSatBounds;
  o[0].setFromPointsField(n, "x"), o[1].setFromPointsField(n, "y"), o[2].setFromPointsField(n, "z"), this.invMatrix.copy(this.matrix).invert(), this.needsUpdate = !1;
}, Js.prototype.intersectsBox = function() {
  const i = new ja();
  return function(t) {
    this.needsUpdate && this.update();
    const e = t.min, n = t.max, r = this.satBounds, s = this.satAxes, a = this.alignedSatBounds;
    if (i.min = e.x, i.max = n.x, a[0].isSeparated(i) || (i.min = e.y, i.max = n.y, a[1].isSeparated(i)) || (i.min = e.z, i.max = n.z, a[2].isSeparated(i)))
      return !1;
    for (let o = 0; o < 3; o++) {
      const l = s[o], c = r[o];
      if (i.setFromBox(l, t), c.isSeparated(i))
        return !1;
    }
    return !0;
  };
}(), Js.prototype.intersectsTriangle = function() {
  const i = new ta(), t = new Array(3), e = new ja(), n = new ja(), r = new D();
  return function(s) {
    this.needsUpdate && this.update(), s.isExtendedTriangle ? s.needsUpdate && s.update() : (i.copy(s), i.update(), s = i);
    const a = this.satBounds, o = this.satAxes;
    t[0] = s.a, t[1] = s.b, t[2] = s.c;
    for (let h = 0; h < 3; h++) {
      const p = a[h], f = o[h];
      if (e.setFromPoints(f, t), p.isSeparated(e))
        return !1;
    }
    const l = s.satBounds, c = s.satAxes, u = this.points;
    for (let h = 0; h < 3; h++) {
      const p = l[h], f = c[h];
      if (e.setFromPoints(f, u), p.isSeparated(e))
        return !1;
    }
    for (let h = 0; h < 3; h++) {
      const p = o[h];
      for (let f = 0; f < 4; f++) {
        const v = c[f];
        if (r.crossVectors(p, v), e.setFromPoints(r, t), n.setFromPoints(r, u), e.isSeparated(n))
          return !1;
      }
    }
    return !0;
  };
}(), Js.prototype.closestPointToPoint = function(i, t) {
  return this.needsUpdate && this.update(), t.copy(i).applyMatrix4(this.invMatrix).clamp(this.min, this.max).applyMatrix4(this.matrix), t;
}, Js.prototype.distanceToPoint = function() {
  const i = new D();
  return function(t) {
    return this.closestPointToPoint(t, i), t.distanceTo(i);
  };
}(), Js.prototype.distanceToBox = function() {
  const i = ["x", "y", "z"], t = new Array(12).fill().map(() => new ss()), e = new Array(12).fill().map(() => new ss()), n = new D(), r = new D();
  return function(s, a = 0, o = null, l = null) {
    if (this.needsUpdate && this.update(), this.intersectsBox(s))
      return (o || l) && (s.getCenter(r), this.closestPointToPoint(r, n), s.closestPointToPoint(n, r), o && o.copy(n), l && l.copy(r)), 0;
    const c = a * a, u = s.min, h = s.max, p = this.points;
    let f = 1 / 0;
    for (let m = 0; m < 8; m++) {
      const y = p[m];
      r.copy(y).clamp(u, h);
      const _ = y.distanceToSquared(r);
      if (_ < f && (f = _, o && o.copy(y), l && l.copy(r), _ < c))
        return Math.sqrt(_);
    }
    let v = 0;
    for (let m = 0; m < 3; m++)
      for (let y = 0; y <= 1; y++)
        for (let _ = 0; _ <= 1; _++) {
          const w = (m + 1) % 3, b = (m + 2) % 3, T = 1 << m | y << w | _ << b, M = p[y << w | _ << b], A = p[T];
          t[v].set(M, A);
          const C = i[m], I = i[w], k = i[b], R = e[v], L = R.start, E = R.end;
          L[C] = u[C], L[I] = y ? u[I] : h[I], L[k] = _ ? u[k] : h[I], E[C] = h[C], E[I] = y ? u[I] : h[I], E[k] = _ ? u[k] : h[I], v++;
        }
    for (let m = 0; m <= 1; m++)
      for (let y = 0; y <= 1; y++)
        for (let _ = 0; _ <= 1; _++) {
          r.x = m ? h.x : u.x, r.y = y ? h.y : u.y, r.z = _ ? h.z : u.z, this.closestPointToPoint(r, n);
          const w = r.distanceToSquared(n);
          if (w < f && (f = w, o && o.copy(n), l && l.copy(r), w < c))
            return Math.sqrt(w);
        }
    for (let m = 0; m < 12; m++) {
      const y = t[m];
      for (let _ = 0; _ < 12; _++) {
        const w = e[_];
        cb(y, w, n, r);
        const b = n.distanceToSquared(r);
        if (b < f && (f = b, o && o.copy(n), l && l.copy(r), b < c))
          return Math.sqrt(b);
      }
    }
    return Math.sqrt(f);
  };
}();
const Sg = new D(), Mg = new D(), Tg = new D(), CD = new wt(), PD = new wt(), DD = new wt(), RD = new D();
function Rit(i, t, e, n, r, s, a) {
  Sg.fromBufferAttribute(t, n), Mg.fromBufferAttribute(t, r), Tg.fromBufferAttribute(t, s);
  const o = function(l, c, u, h, p, f) {
    let v;
    return v = f === 1 ? l.intersectTriangle(h, u, c, !0, p) : l.intersectTriangle(c, u, h, f !== 2, p), v === null ? null : { distance: l.origin.distanceTo(p), point: p.clone() };
  }(i, Sg, Mg, Tg, RD, a);
  if (o) {
    e && (CD.fromBufferAttribute(e, n), PD.fromBufferAttribute(e, r), DD.fromBufferAttribute(e, s), o.uv = Pr.getUV(RD, Sg, Mg, Tg, CD, PD, DD, new wt()));
    const l = { a: n, b: r, c: s, normal: new D(), materialIndex: 0 };
    Pr.getNormal(Sg, Mg, Tg, l.normal), o.face = l, o.faceIndex = n;
  }
  return o;
}
function BB(i, t, e, n, r) {
  const s = 3 * n, a = i.index.getX(s), o = i.index.getX(s + 1), l = i.index.getX(s + 2), c = Rit(e, i.attributes.position, i.attributes.uv, a, o, l, t);
  return c ? (c.faceIndex = n, r && r.push(c), c) : null;
}
function Ks(i, t, e, n) {
  const r = i.a, s = i.b, a = i.c;
  let o = t, l = t + 1, c = t + 2;
  e && (o = e.getX(t), l = e.getX(t + 1), c = e.getX(t + 2)), r.x = n.getX(o), r.y = n.getY(o), r.z = n.getZ(o), s.x = n.getX(l), s.y = n.getY(l), s.z = n.getZ(l), a.x = n.getX(c), a.y = n.getY(c), a.z = n.getZ(c);
}
function ID(i, t, e, n, r, s, a) {
  const o = e.index, l = e.attributes.position;
  for (let c = i, u = t + i; c < u; c++)
    if (Ks(a, 3 * c, o, l), a.needsUpdate = !0, n(a, c, r, s))
      return !0;
  return !1;
}
class zB {
  constructor(t) {
    this._getNewPrimitive = t, this._primitives = [];
  }
  getPrimitive() {
    const t = this._primitives;
    return t.length === 0 ? this._getNewPrimitive() : t.pop();
  }
  releasePrimitive(t) {
    this._primitives.push(t);
  }
}
function Do(i, t) {
  return t[i + 15] === 65535;
}
function Nh(i, t) {
  return t[i + 6];
}
function gp(i, t) {
  return t[i + 14];
}
function vp(i) {
  return i + 8;
}
function yp(i, t) {
  return t[i + 6];
}
const Ah = new ke(), Yv = new D(), Iit = ["x", "y", "z"];
function hb(i, t, e, n, r) {
  let s = 2 * i, a = mu, o = zo, l = ko;
  if (Do(s, o))
    (function(c, u, h, p, f, v) {
      for (let m = p, y = p + f; m < y; m++)
        BB(c, u, h, m, v);
    })(t, e, n, Nh(i, l), gp(s, o), r);
  else {
    const c = vp(i);
    Jv(c, a, n, Yv) && hb(c, t, e, n, r);
    const u = yp(i, l);
    Jv(u, a, n, Yv) && hb(u, t, e, n, r);
  }
}
function ub(i, t, e, n) {
  let r = 2 * i, s = mu, a = zo, o = ko;
  if (Do(r, a))
    return function(l, c, u, h, p) {
      let f = 1 / 0, v = null;
      for (let m = h, y = h + p; m < y; m++) {
        const _ = BB(l, c, u, m);
        _ && _.distance < f && (v = _, f = _.distance);
      }
      return v;
    }(t, e, n, Nh(i, o), gp(r, a));
  {
    const l = function(m, y) {
      return y[m + 7];
    }(i, o), c = Iit[l], u = n.direction[c] >= 0;
    let h, p;
    u ? (h = vp(i), p = yp(i, o)) : (h = yp(i, o), p = vp(i));
    const f = Jv(h, s, n, Yv) ? ub(h, t, e, n) : null;
    if (f) {
      const m = f.point[c];
      if (u ? m <= s[p + l] : m >= s[p + l + 3])
        return f;
    }
    const v = Jv(p, s, n, Yv) ? ub(p, t, e, n) : null;
    return f && v ? f.distance <= v.distance ? f : v : f || v || null;
  }
}
const Oit = function() {
  let i, t;
  const e = [], n = new zB(() => new ke());
  return function(...s) {
    i = n.getPrimitive(), t = n.getPrimitive(), e.push(i, t);
    const a = r(...s);
    n.releasePrimitive(i), n.releasePrimitive(t), e.pop(), e.pop();
    const o = e.length;
    return o > 0 && (t = e[o - 1], i = e[o - 2]), a;
  };
  function r(s, a, o, l, c = null, u = 0, h = 0) {
    function p(w) {
      let b = 2 * w, T = zo, M = ko;
      for (; !Do(b, T); )
        b = 2 * (w = vp(w));
      return Nh(w, M);
    }
    function f(w) {
      let b = 2 * w, T = zo, M = ko;
      for (; !Do(b, T); )
        b = 2 * (w = yp(w, M));
      return Nh(w, M) + gp(b, T);
    }
    let v = 2 * s, m = mu, y = zo, _ = ko;
    if (Do(v, y)) {
      const w = Nh(s, _), b = gp(v, y);
      return Cs(s, m, i), l(w, b, !1, h, u + s, i);
    }
    {
      const w = vp(s), b = yp(s, _);
      let T, M, A, C, I = w, k = b;
      if (c && (A = i, C = t, Cs(I, m, A), Cs(k, m, C), T = c(A), M = c(C), M < T)) {
        I = b, k = w;
        const it = T;
        T = M, M = it, A = C;
      }
      A || (A = i, Cs(I, m, A));
      const R = o(A, Do(2 * I, y), T, h + 1, u + I);
      let L;
      if (R === 2) {
        const it = p(I);
        L = l(it, f(I) - it, !0, h + 1, u + I, A);
      } else
        L = R && r(I, a, o, l, c, u, h + 1);
      if (L)
        return !0;
      C = t, Cs(k, m, C);
      const E = o(C, Do(2 * k, y), M, h + 1, u + k);
      let q;
      if (E === 2) {
        const it = p(k);
        q = l(it, f(k) - it, !0, h + 1, u + k, C);
      } else
        q = E && r(k, a, o, l, c, u, h + 1);
      return !!q;
    }
  }
}(), Lit = function() {
  const i = new ta(), t = new ta(), e = new Vt(), n = new Js(), r = new Js();
  return function s(a, o, l, c, u = null) {
    let h = 2 * a, p = mu, f = zo, v = ko;
    if (u === null && (l.boundingBox || l.computeBoundingBox(), n.set(l.boundingBox.min, l.boundingBox.max, c), u = n), !Do(h, f)) {
      const m = a + 8, y = v[a + 6];
      return Cs(m, p, Ah), u.intersectsBox(Ah) && s(m, o, l, c, u) ? !0 : (Cs(y, p, Ah), !!(u.intersectsBox(Ah) && s(y, o, l, c, u)));
    }
    {
      const m = o, y = m.index, _ = m.attributes.position, w = l.index, b = l.attributes.position, T = Nh(a, v), M = gp(h, f);
      if (e.copy(c).invert(), l.boundsTree)
        return Cs(a, p, r), r.matrix.copy(e), r.needsUpdate = !0, l.boundsTree.shapecast({ intersectsBounds: (C) => r.intersectsBox(C), intersectsTriangle: (C) => {
          C.a.applyMatrix4(c), C.b.applyMatrix4(c), C.c.applyMatrix4(c), C.needsUpdate = !0;
          for (let I = 3 * T, k = 3 * (M + T); I < k; I += 3)
            if (Ks(t, I, y, _), t.needsUpdate = !0, C.intersectsTriangle(t))
              return !0;
          return !1;
        } });
      for (let A = 3 * T, C = M + 3 * T; A < C; A += 3) {
        Ks(i, A, y, _), i.a.applyMatrix4(e), i.b.applyMatrix4(e), i.c.applyMatrix4(e), i.needsUpdate = !0;
        for (let I = 0, k = w.count; I < k; I += 3)
          if (Ks(t, I, w, b), t.needsUpdate = !0, i.intersectsTriangle(t))
            return !0;
      }
    }
  };
}();
function Jv(i, t, e, n) {
  return Cs(i, t, Ah), e.intersectBox(Ah, n);
}
const db = [];
let gv, mu, zo, ko;
function Ed(i) {
  gv && db.push(gv), gv = i, mu = new Float32Array(i), zo = new Uint16Array(i), ko = new Uint32Array(i);
}
function Eg() {
  gv = null, mu = null, zo = null, ko = null, db.length && Ed(db.pop());
}
const gw = Symbol("skip tree generation"), vw = new ke(), yw = new ke(), nh = new Vt(), wl = new Js(), hd = new Js(), ud = new D(), Ag = new D(), Bit = new D(), zit = new D(), kit = new D(), OD = new ke(), Vs = new zB(() => new ta());
class Vd {
  static serialize(t, e = {}) {
    if (e.isBufferGeometry)
      return console.warn("MeshBVH.serialize: The arguments for the function have changed. See documentation for new signature."), Vd.serialize(arguments[0], { cloneBuffers: arguments[2] === void 0 || arguments[2] });
    e = { cloneBuffers: !0, ...e };
    const n = t.geometry, r = t._roots, s = n.getIndex();
    let a;
    return a = e.cloneBuffers ? { roots: r.map((o) => o.slice()), index: s.array.slice() } : { roots: r, index: s.array }, a;
  }
  static deserialize(t, e, n = {}) {
    if (typeof n == "boolean")
      return console.warn("MeshBVH.deserialize: The arguments for the function have changed. See documentation for new signature."), Vd.deserialize(arguments[0], arguments[1], { setIndex: arguments[2] === void 0 || arguments[2] });
    n = { setIndex: !0, ...n };
    const { index: r, roots: s } = t, a = new Vd(e, { ...n, [gw]: !0 });
    if (a._roots = s, n.setIndex) {
      const o = e.getIndex();
      if (o === null) {
        const l = new Ze(t.index, 1, !1);
        e.setIndex(l);
      } else
        o.array !== r && (o.array.set(r), o.needsUpdate = !0);
    }
    return a;
  }
  constructor(t, e = {}) {
    if (!t.isBufferGeometry)
      throw new Error("MeshBVH: Only BufferGeometries are supported.");
    if (t.index && t.index.isInterleavedBufferAttribute)
      throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.");
    if ((e = Object.assign({ strategy: sM, maxDepth: 40, maxLeafTris: 10, verbose: !0, useSharedArrayBuffer: !1, setBoundingBox: !0, onProgress: null, [gw]: !1 }, e)).useSharedArrayBuffer && typeof SharedArrayBuffer > "u")
      throw new Error("MeshBVH: SharedArrayBuffer is not available.");
    this._roots = null, e[gw] || (this._roots = function(n, r) {
      const s = Cit(n, r);
      let a, o, l;
      const c = [], u = r.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;
      for (let f = 0; f < s.length; f++) {
        const v = s[f], m = new u(32 * h(v));
        a = new Float32Array(m), o = new Uint32Array(m), l = new Uint16Array(m), p(0, v), c.push(m);
      }
      return c;
      function h(f) {
        return f.count ? 1 : 1 + h(f.left) + h(f.right);
      }
      function p(f, v) {
        const m = f / 4, y = f / 2, _ = !!v.count, w = v.boundingData;
        for (let b = 0; b < 6; b++)
          a[m + b] = w[b];
        if (_) {
          const b = v.offset, T = v.count;
          return o[m + 6] = b, l[y + 14] = T, l[y + 15] = fw, f + 32;
        }
        {
          const b = v.left, T = v.right, M = v.splitAxis;
          let A;
          if (A = p(f + 32, b), A / 4 > Math.pow(2, 32))
            throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");
          return o[m + 6] = A / 4, A = p(A, T), o[m + 7] = M, A;
        }
      }
    }(t, e), !t.boundingBox && e.setBoundingBox && (t.boundingBox = this.getBoundingBox(new ke()))), this.geometry = t;
  }
  refit(t = null) {
    t && Array.isArray(t) && (t = new Set(t));
    const e = this.geometry, n = e.index.array, r = e.attributes.position;
    let s, a, o, l, c = 0;
    const u = this._roots;
    for (let p = 0, f = u.length; p < f; p++)
      s = u[p], a = new Uint32Array(s), o = new Uint16Array(s), l = new Float32Array(s), h(0, c), c += s.byteLength;
    function h(p, f, v = !1) {
      const m = 2 * p;
      if (o[m + 15] === fw) {
        const y = a[p + 6];
        let _ = 1 / 0, w = 1 / 0, b = 1 / 0, T = -1 / 0, M = -1 / 0, A = -1 / 0;
        for (let C = 3 * y, I = 3 * (y + o[m + 14]); C < I; C++) {
          const k = n[C], R = r.getX(k), L = r.getY(k), E = r.getZ(k);
          R < _ && (_ = R), R > T && (T = R), L < w && (w = L), L > M && (M = L), E < b && (b = E), E > A && (A = E);
        }
        return (l[p + 0] !== _ || l[p + 1] !== w || l[p + 2] !== b || l[p + 3] !== T || l[p + 4] !== M || l[p + 5] !== A) && (l[p + 0] = _, l[p + 1] = w, l[p + 2] = b, l[p + 3] = T, l[p + 4] = M, l[p + 5] = A, !0);
      }
      {
        const y = p + 8, _ = a[p + 6], w = y + f, b = _ + f;
        let T = v, M = !1, A = !1;
        t ? T || (M = t.has(w), A = t.has(b), T = !M && !A) : (M = !0, A = !0);
        const C = T || A;
        let I = !1;
        (T || M) && (I = h(y, f, T));
        let k = !1;
        C && (k = h(_, f, T));
        const R = I || k;
        if (R)
          for (let L = 0; L < 3; L++) {
            const E = y + L, q = _ + L, it = l[E], rt = l[E + 3], ft = l[q], nt = l[q + 3];
            l[p + L] = it < ft ? it : ft, l[p + L + 3] = rt > nt ? rt : nt;
          }
        return R;
      }
    }
  }
  traverse(t, e = 0) {
    const n = this._roots[e], r = new Uint32Array(n), s = new Uint16Array(n);
    (function a(o, l = 0) {
      const c = 2 * o, u = s[c + 15] === fw;
      if (u) {
        const h = r[o + 6], p = s[c + 14];
        t(l, u, new Float32Array(n, 4 * o, 6), h, p);
      } else {
        const h = o + 8, p = r[o + 6], f = r[o + 7];
        t(l, u, new Float32Array(n, 4 * o, 6), f) || (a(h, l + 1), a(p, l + 1));
      }
    })(0);
  }
  raycast(t, e = 0) {
    const n = this._roots, r = this.geometry, s = [], a = e.isMaterial, o = Array.isArray(e), l = r.groups, c = a ? e.side : e;
    for (let u = 0, h = n.length; u < h; u++) {
      const p = o ? e[l[u].materialIndex].side : c, f = s.length;
      if (Ed(n[u]), hb(0, r, p, t, s), Eg(), o) {
        const v = l[u].materialIndex;
        for (let m = f, y = s.length; m < y; m++)
          s[m].face.materialIndex = v;
      }
    }
    return s;
  }
  raycastFirst(t, e = 0) {
    const n = this._roots, r = this.geometry, s = e.isMaterial, a = Array.isArray(e);
    let o = null;
    const l = r.groups, c = s ? e.side : e;
    for (let u = 0, h = n.length; u < h; u++) {
      const p = a ? e[l[u].materialIndex].side : c;
      Ed(n[u]);
      const f = ub(0, r, p, t);
      Eg(), f != null && (o == null || f.distance < o.distance) && (o = f, a && (f.face.materialIndex = l[u].materialIndex));
    }
    return o;
  }
  intersectsGeometry(t, e) {
    const n = this.geometry;
    let r = !1;
    for (const s of this._roots)
      if (Ed(s), r = Lit(0, n, t, e), Eg(), r)
        break;
    return r;
  }
  shapecast(t, e, n) {
    const r = this.geometry;
    if (t instanceof Function) {
      if (e) {
        const p = e;
        e = (f, v, m, y) => {
          const _ = 3 * v;
          return p(f, _, _ + 1, _ + 2, m, y);
        };
      }
      t = { boundsTraverseOrder: n, intersectsBounds: t, intersectsTriangle: e, intersectsRange: null }, console.warn("MeshBVH: Shapecast function signature has changed and now takes an object of callbacks as a second argument. See docs for new signature.");
    }
    const s = Vs.getPrimitive();
    let { boundsTraverseOrder: a, intersectsBounds: o, intersectsRange: l, intersectsTriangle: c } = t;
    if (l && c) {
      const p = l;
      l = (f, v, m, y, _) => !!p(f, v, m, y, _) || ID(f, v, r, c, m, y, s);
    } else
      l || (l = c ? (p, f, v, m) => ID(p, f, r, c, v, m, s) : (p, f, v) => v);
    let u = !1, h = 0;
    for (const p of this._roots) {
      if (Ed(p), u = Oit(0, r, o, l, a, h), Eg(), u)
        break;
      h += p.byteLength;
    }
    return Vs.releasePrimitive(s), u;
  }
  bvhcast(t, e, n) {
    let { intersectsRanges: r, intersectsTriangles: s } = n;
    const a = this.geometry.index, o = this.geometry.attributes.position, l = t.geometry.index, c = t.geometry.attributes.position;
    nh.copy(e).invert();
    const u = Vs.getPrimitive(), h = Vs.getPrimitive();
    if (s) {
      let f = function(v, m, y, _, w, b, T, M) {
        for (let A = y, C = y + _; A < C; A++) {
          Ks(h, 3 * A, l, c), h.a.applyMatrix4(e), h.b.applyMatrix4(e), h.c.applyMatrix4(e), h.needsUpdate = !0;
          for (let I = v, k = v + m; I < k; I++)
            if (Ks(u, 3 * I, a, o), u.needsUpdate = !0, s(u, h, I, A, w, b, T, M))
              return !0;
        }
        return !1;
      };
      if (r) {
        const v = r;
        r = function(m, y, _, w, b, T, M, A) {
          return !!v(m, y, _, w, b, T, M, A) || f(m, y, _, w, b, T, M, A);
        };
      } else
        r = f;
    }
    t.getBoundingBox(yw), yw.applyMatrix4(e);
    const p = this.shapecast({ intersectsBounds: (f) => yw.intersectsBox(f), intersectsRange: (f, v, m, y, _, w) => (vw.copy(w), vw.applyMatrix4(nh), t.shapecast({ intersectsBounds: (b) => vw.intersectsBox(b), intersectsRange: (b, T, M, A, C) => r(f, v, b, T, y, _, A, C) })) });
    return Vs.releasePrimitive(u), Vs.releasePrimitive(h), p;
  }
  intersectsBox(t, e) {
    return wl.set(t.min, t.max, e), wl.needsUpdate = !0, this.shapecast({ intersectsBounds: (n) => wl.intersectsBox(n), intersectsTriangle: (n) => wl.intersectsTriangle(n) });
  }
  intersectsSphere(t) {
    return this.shapecast({ intersectsBounds: (e) => t.intersectsBox(e), intersectsTriangle: (e) => e.intersectsSphere(t) });
  }
  closestPointToGeometry(t, e, n = {}, r = {}, s = 0, a = 1 / 0) {
    t.boundingBox || t.computeBoundingBox(), wl.set(t.boundingBox.min, t.boundingBox.max, e), wl.needsUpdate = !0;
    const o = this.geometry, l = o.attributes.position, c = o.index, u = t.attributes.position, h = t.index, p = Vs.getPrimitive(), f = Vs.getPrimitive();
    let v = Ag, m = Bit, y = null, _ = null;
    r && (y = zit, _ = kit);
    let w = 1 / 0, b = null, T = null;
    return nh.copy(e).invert(), hd.matrix.copy(nh), this.shapecast({ boundsTraverseOrder: (M) => wl.distanceToBox(M), intersectsBounds: (M, A, C) => C < w && C < a && (A && (hd.min.copy(M.min), hd.max.copy(M.max), hd.needsUpdate = !0), !0), intersectsRange: (M, A) => {
      if (t.boundsTree)
        return t.boundsTree.shapecast({ boundsTraverseOrder: (C) => hd.distanceToBox(C), intersectsBounds: (C, I, k) => k < w && k < a, intersectsRange: (C, I) => {
          for (let k = 3 * C, R = 3 * (C + I); k < R; k += 3) {
            Ks(f, k, h, u), f.a.applyMatrix4(e), f.b.applyMatrix4(e), f.c.applyMatrix4(e), f.needsUpdate = !0;
            for (let L = 3 * M, E = 3 * (M + A); L < E; L += 3) {
              Ks(p, L, c, l), p.needsUpdate = !0;
              const q = p.distanceToTriangle(f, v, y);
              if (q < w && (m.copy(v), _ && _.copy(y), w = q, b = L / 3, T = k / 3), q < s)
                return !0;
            }
          }
        } });
      for (let C = 0, I = h ? h.count : u.count; C < I; C += 3) {
        Ks(f, C, h, u), f.a.applyMatrix4(e), f.b.applyMatrix4(e), f.c.applyMatrix4(e), f.needsUpdate = !0;
        for (let k = 3 * M, R = 3 * (M + A); k < R; k += 3) {
          Ks(p, k, c, l), p.needsUpdate = !0;
          const L = p.distanceToTriangle(f, v, y);
          if (L < w && (m.copy(v), _ && _.copy(y), w = L, b = k / 3, T = C / 3), L < s)
            return !0;
        }
      }
    } }), Vs.releasePrimitive(p), Vs.releasePrimitive(f), w === 1 / 0 ? null : (n.point ? n.point.copy(m) : n.point = m.clone(), n.distance = w, n.faceIndex = b, r && (r.point ? r.point.copy(_) : r.point = _.clone(), r.point.applyMatrix4(nh), m.applyMatrix4(nh), r.distance = m.sub(r.point).length(), r.faceIndex = T), n);
  }
  closestPointToPoint(t, e = {}, n = 0, r = 1 / 0) {
    const s = n * n, a = r * r;
    let o = 1 / 0, l = null;
    if (this.shapecast({ boundsTraverseOrder: (u) => (ud.copy(t).clamp(u.min, u.max), ud.distanceToSquared(t)), intersectsBounds: (u, h, p) => p < o && p < a, intersectsTriangle: (u, h) => {
      u.closestPointToPoint(t, ud);
      const p = t.distanceToSquared(ud);
      return p < o && (Ag.copy(ud), o = p, l = h), p < s;
    } }), o === 1 / 0)
      return null;
    const c = Math.sqrt(o);
    return e.point ? e.point.copy(Ag) : e.point = Ag.clone(), e.distance = c, e.faceIndex = l, e;
  }
  getBoundingBox(t) {
    return t.makeEmpty(), this._roots.forEach((e) => {
      Cs(0, new Float32Array(e), OD), t.union(OD);
    }), t;
  }
}
const LD = new ke();
class Nit extends Ue {
  get isMesh() {
    return !this.displayEdges;
  }
  get isLineSegments() {
    return this.displayEdges;
  }
  get isLine() {
    return this.displayEdges;
  }
  constructor(t, e, n = 10, r = 0) {
    super(), this.material = e, this.geometry = new _e(), this.name = "MeshBVHRootVisualizer", this.depth = n, this.displayParents = !1, this.mesh = t, this.displayEdges = !0, this._group = r;
  }
  raycast() {
  }
  update() {
    const t = this.geometry, e = this.mesh.geometry.boundsTree, n = this._group;
    if (t.dispose(), this.visible = !1, e) {
      const r = this.depth - 1, s = this.displayParents;
      let a = 0;
      e.traverse((p, f) => {
        if (p === r || f)
          return a++, !0;
        s && a++;
      }, n);
      let o = 0;
      const l = new Float32Array(24 * a);
      let c, u;
      e.traverse((p, f, v) => {
        const m = p === r || f;
        if (m || s) {
          Cs(0, v, LD);
          const { min: y, max: _ } = LD;
          for (let w = -1; w <= 1; w += 2) {
            const b = w < 0 ? y.x : _.x;
            for (let T = -1; T <= 1; T += 2) {
              const M = T < 0 ? y.y : _.y;
              for (let A = -1; A <= 1; A += 2) {
                const C = A < 0 ? y.z : _.z;
                l[o + 0] = b, l[o + 1] = M, l[o + 2] = C, o += 3;
              }
            }
          }
          return m;
        }
      }, n), u = this.displayEdges ? new Uint8Array([0, 4, 1, 5, 2, 6, 3, 7, 0, 2, 1, 3, 4, 6, 5, 7, 0, 1, 2, 3, 4, 5, 6, 7]) : new Uint8Array([0, 1, 2, 2, 1, 3, 4, 6, 5, 6, 7, 5, 1, 4, 5, 0, 4, 1, 2, 3, 6, 3, 7, 6, 0, 2, 4, 2, 6, 4, 1, 5, 3, 3, 5, 7]), c = l.length > 65535 ? new Uint32Array(u.length * a) : new Uint16Array(u.length * a);
      const h = u.length;
      for (let p = 0; p < a; p++) {
        const f = 8 * p, v = p * h;
        for (let m = 0; m < h; m++)
          c[v + m] = f + u[m];
      }
      t.setIndex(new Ze(c, 1, !1)), t.setAttribute("position", new Ze(l, 3, !1)), this.visible = !0;
    }
  }
}
class aM extends bi {
  get color() {
    return this.edgeMaterial.color;
  }
  get opacity() {
    return this.edgeMaterial.opacity;
  }
  set opacity(t) {
    this.edgeMaterial.opacity = t, this.meshMaterial.opacity = t;
  }
  constructor(t, e = 10) {
    super(), this.name = "MeshBVHVisualizer", this.depth = e, this.mesh = t, this.displayParents = !1, this.displayEdges = !0, this._roots = [];
    const n = new Ar({ color: 65416, transparent: !0, opacity: 0.3, depthWrite: !1 }), r = new ci({ color: 65416, transparent: !0, opacity: 0.3, depthWrite: !1 });
    r.color = n.color, this.edgeMaterial = n, this.meshMaterial = r, this.update();
  }
  update() {
    const t = this.mesh.geometry.boundsTree, e = t ? t._roots.length : 0;
    for (; this._roots.length > e; ) {
      const n = this._roots.pop();
      n.geometry.dispose(), this.remove(n);
    }
    for (let n = 0; n < e; n++) {
      if (n >= this._roots.length) {
        const s = new Nit(this.mesh, this.edgeMaterial, this.depth, n);
        this.add(s), this._roots.push(s);
      }
      const r = this._roots[n];
      r.depth = this.depth, r.mesh = this.mesh, r.displayParents = this.displayParents, r.displayEdges = this.displayEdges, r.material = this.displayEdges ? this.edgeMaterial : this.meshMaterial, r.update();
    }
  }
  updateMatrixWorld(...t) {
    this.position.copy(this.mesh.position), this.rotation.copy(this.mesh.rotation), this.scale.copy(this.mesh.scale), super.updateMatrixWorld(...t);
  }
  copy(t) {
    this.depth = t.depth, this.mesh = t.mesh;
  }
  clone() {
    return new aM(this.mesh, this.depth);
  }
  dispose() {
    this.edgeMaterial.dispose(), this.meshMaterial.dispose();
    const t = this.children;
    for (let e = 0, n = t.length; e < n; e++)
      t[e].geometry.dispose();
  }
}
function BD(i) {
  switch (typeof i) {
    case "number":
      return 8;
    case "string":
      return 2 * i.length;
    case "boolean":
      return 4;
    default:
      return 0;
  }
}
const Fit = Symbol("skip tree generation"), Uit = { strategy: sM, maxDepth: 40, maxLeafTris: 10, verbose: !0, useSharedArrayBuffer: !1, setBoundingBox: !1, onProgress: null, [Fit]: !1 };
class oM extends Vd {
  constructor(e, n = {}) {
    super(e, n);
    U(this, "relativeBounds");
    U(this, "localTransform");
    U(this, "localTransformInv");
  }
  static buildBVH(e, n, r = null, s = Uit) {
    const a = new _e();
    let o = null;
    n.length >= 65535 || e.length >= 65535 ? (o = new Uint32Array(e.length), o.set(e, 0), a.setIndex(new Wl(o, 1))) : (o = new Uint16Array(e.length), o.set(e, 0), a.setIndex(new Gl(o, 1)));
    const l = r.getCenter(new D()), c = new Vt().makeTranslation(l.x, l.y, l.z);
    c.invert();
    const u = new Float32Array(n.length), h = new D();
    for (let f = 0; f < n.length; f += 3)
      h.set(n[f], n[f + 1], n[f + 2]), h.applyMatrix4(c), u[f] = h.x, u[f + 1] = h.y, u[f + 2] = h.z;
    a.setAttribute("position", new Wt(u, 3));
    const p = new oM(a, s);
    return p.localTransform = c, p.localTransformInv = new Vt().copy(c).invert(), p.relativeBounds = r, p.geometry.boundingBox = p.getBoundingBox(new ke()), p;
  }
  raycast(e, n = 0) {
    const r = super.raycast(this.transformInput(e), n);
    return r.forEach((s) => {
      s.point = this.transformOutput(s.point);
    }), r;
  }
  raycastFirst(e, n = 0) {
    const r = super.raycastFirst(this.transformInput(e), n);
    return r.point = this.transformOutput(r.point), r;
  }
  shapecast(e) {
    const n = new ke(), r = new ta(), s = /* @__PURE__ */ Object.create(null);
    return e.intersectsBounds && (s.intersectsBounds = (a, o, l, c, u) => (n.copy(a), this.transformOutput(n), e.intersectsBounds(n, o, l, c, u))), e.intersectsTriangle && (s.intersectsTriangle = (a, o, l, c) => (r.copy(a), this.transformOutput(r.a), this.transformOutput(r.b), this.transformOutput(r.c), e.intersectsTriangle(r, o, l, c))), s.intersectsRange = e.intersectsRange, s.traverseBoundsOrder = e.traverseBoundsOrder, super.shapecast(s);
  }
  transformInput(e) {
    return e.applyMatrix4(this.localTransform);
  }
  transformOutput(e) {
    return e.applyMatrix4(this.localTransformInv);
  }
  getBoundingBox(e) {
    return super.getBoundingBox(e), this.transformOutput(e);
  }
}
const Co = class Co {
  static buildBVH(t, e, n) {
    return oM.buildBVH(t, e, n);
  }
  static updateRTEGeometry(t, e) {
    if (t.type === "BufferGeometry" || t.type === "PlaneGeometry") {
      const n = new Float32Array(e.length), r = t.attributes.position.array;
      Co.DoubleToHighLowBuffer(e, n, r), t.setAttribute("position_low", new Wt(n, 3));
    } else if (t.type === "LineGeometry" || t.type === "LineSegmentsGeometry") {
      const n = new Float32Array(e.length), r = t.attributes.instanceStart.array;
      Co.DoubleToHighLowBuffer(e, n, r);
      const s = new Vh(new Float32Array(n), 6, 1);
      t.setAttribute("instanceStartLow", new Lr(s, 3, 0)), t.setAttribute("instanceEndLow", new Lr(s, 3, 3));
    }
  }
  static mergeGeometryAttribute(t, e) {
    let n = 0;
    for (let r = 0; r < t.length; r++)
      e.set(t[r], n), n += t[r].length;
    return e;
  }
  static mergeIndexAttribute(t, e) {
    let n = 0;
    const r = [];
    for (let s = 0; s < t.length; ++s) {
      const a = t[s];
      for (let o = 0; o < a.length; ++o)
        r.push(a[o] + n);
      n += e.length;
    }
    return r;
  }
  static mergeGeometryData(t) {
    const e = t[0].attributes, n = { attributes: {}, bakeTransform: null, transform: null };
    for (let r = 0; r < t.length; r++)
      t[r].bakeTransform && Co.transformGeometryData(t[r], t[r].bakeTransform);
    if (e.INDEX) {
      const r = t.map((a) => a.attributes.INDEX), s = t.map((a) => a.attributes.POSITION);
      n.attributes.INDEX = Co.mergeIndexAttribute(r, s);
    }
    for (const r in e)
      if (r !== "INDEX") {
        const s = t.map((a) => a.attributes[r]);
        n.attributes[r] = Co.mergeGeometryAttribute(s, r === "POSITION" ? new Float64Array(s.reduce((a, o) => a + o.length, 0)) : new Float32Array(s.reduce((a, o) => a + o.length, 0)));
      }
    return t.forEach((r) => {
      for (const s in r.attributes)
        delete r.attributes[s];
    }), n;
  }
  static transformGeometryData(t, e) {
    if (!t.attributes.POSITION)
      return;
    const n = e.elements;
    for (let r = 0; r < t.attributes.POSITION.length; r += 3) {
      const s = t.attributes.POSITION[r], a = t.attributes.POSITION[r + 1], o = t.attributes.POSITION[r + 2], l = 1 / (n[3] * s + n[7] * a + n[11] * o + n[15]);
      t.attributes.POSITION[r] = (n[0] * s + n[4] * a + n[8] * o + n[12]) * l, t.attributes.POSITION[r + 1] = (n[1] * s + n[5] * a + n[9] * o + n[13]) * l, t.attributes.POSITION[r + 2] = (n[2] * s + n[6] * a + n[10] * o + n[14]) * l;
    }
  }
  static unpackColors(t) {
    const e = new Array(3 * t.length);
    for (let n = 0; n < t.length; n++) {
      const r = t[n], s = r >> 16 & 255, a = r >> 8 & 255, o = 255 & r;
      e[3 * n] = s / 255, e[3 * n + 1] = a / 255, e[3 * n + 2] = o / 255;
    }
    return e;
  }
  static DoubleToHighLowVector(t, e, n) {
    let r = t.x;
    if (r >= 0) {
      this.floatArrayBuff[0] = r;
      const s = this.floatArrayBuff[0];
      n.x = s, e.x = r - s;
    } else {
      this.floatArrayBuff[0] = -r;
      const s = this.floatArrayBuff[0];
      n.x = -s, e.x = r + s;
    }
    if (r = t.y, r >= 0) {
      this.floatArrayBuff[0] = r;
      const s = this.floatArrayBuff[0];
      n.y = s, e.y = r - s;
    } else {
      this.floatArrayBuff[0] = -r;
      const s = this.floatArrayBuff[0];
      n.y = -s, e.y = r + s;
    }
    if (r = t.z, r >= 0) {
      this.floatArrayBuff[0] = r;
      const s = this.floatArrayBuff[0];
      n.z = s, e.z = r - s;
    } else {
      this.floatArrayBuff[0] = -r;
      const s = this.floatArrayBuff[0];
      n.z = -s, e.z = r + s;
    }
  }
  static DoubleToHighLowBuffer(t, e, n) {
    for (let r = 0; r < t.length; r++) {
      const s = t[r];
      if (s >= 0) {
        this.floatArrayBuff[0] = s;
        const a = this.floatArrayBuff[0];
        n[r] = a, e[r] = s - a;
      } else {
        this.floatArrayBuff[0] = -s;
        const a = this.floatArrayBuff[0];
        n[r] = -a, e[r] = s + a;
      }
    }
  }
  static computeVertexNormals(t, e) {
    const n = t.index, r = t.getAttribute("position");
    let s = t.getAttribute("normal");
    if (!s && r !== void 0) {
      if (s === void 0)
        s = new Ze(new Float32Array(3 * r.count), 3), t.setAttribute("normal", s);
      else
        for (let v = 0, m = s.count; v < m; v++)
          s.setXYZ(v, 0, 0, 0);
      const a = new D(), o = new D(), l = new D(), c = new D(), u = new D(), h = new D(), p = new D(), f = new D();
      if (n)
        for (let v = 0, m = n.count; v < m; v += 3) {
          const y = n.getX(v + 0), _ = n.getX(v + 1), w = n.getX(v + 2);
          a.fromArray(e, 3 * y), o.fromArray(e, 3 * _), l.fromArray(e, 3 * w), p.subVectors(l, o), f.subVectors(a, o), p.cross(f), c.fromBufferAttribute(s, y), u.fromBufferAttribute(s, _), h.fromBufferAttribute(s, w), c.add(p), u.add(p), h.add(p), s.setXYZ(y, c.x, c.y, c.z), s.setXYZ(_, u.x, u.y, u.z), s.setXYZ(w, h.x, h.y, h.z);
        }
      else
        for (let v = 0, m = r.count; v < m; v += 3)
          a.fromArray(e, 3 * v), o.fromArray(e, 3 * v + 1), l.fromArray(e, 3 * v + 2), p.subVectors(l, o), f.subVectors(a, o), p.cross(f), s.setXYZ(v + 0, p.x, p.y, p.z), s.setXYZ(v + 1, p.x, p.y, p.z), s.setXYZ(v + 2, p.x, p.y, p.z);
      t.normalizeNormals(), s.needsUpdate = !0;
    }
  }
};
U(Co, "floatArrayBuff", new Float32Array(1));
let Nn = Co;
class Vit {
  static triangulateFace(t, e, n) {
    let r = e[t];
    function s(f) {
      return t + f + 1;
    }
    function a(f) {
      const v = 3 * e[s(f)];
      return new Fl(n[v], n[v + 1], n[v + 2]);
    }
    r < 3 && (r += 3);
    const o = Array(3 * (r - 2)), l = new Fl(0, 0, 0);
    for (let f = r - 1, v = 0; v < r; f = v, v++) {
      const m = a(f), y = a(v);
      l.x += (y.y - m.y) * (m.z + y.z), l.y += (y.z - m.z) * (m.x + y.x), l.z += (y.x - m.x) * (m.y + y.y);
    }
    l.normalize();
    const c = Array(r), u = Array(r);
    for (let f = 0; f < r; f++)
      c[f] = f - 1, u[f] = f + 1;
    c[0] = r - 1, u[r - 1] = 0;
    let h = 0, p = 0;
    for (; r >= 3; ) {
      let f = !0;
      if (r > 3 && p < r) {
        const v = a(c[h]), m = a(h), y = a(u[h]);
        if (this.triangleIsCCW(l, v, m, y)) {
          let _ = u[u[h]];
          do {
            if (this.testPointTriangle(a(_), v, m, y)) {
              f = !1;
              break;
            }
            _ = u[_];
          } while (_ !== c[h]);
        } else
          f = !1;
      }
      if (f) {
        const v = e[s(h)], m = e[s(u[h])], y = e[s(c[h])];
        o.push(v, m, y), u[c[h]] = u[h], c[u[h]] = c[h], r--, h = c[h], p = 0;
      } else
        h = u[h], p++;
    }
    return o;
  }
  static testPointTriangle(t, e, n, r) {
    function s(a, o, l) {
      const c = a.cross(o), u = a.cross(l), h = Number.EPSILON + c.dot(u);
      return Math.sign(h) !== -1;
    }
    return s(n.sub(e), t.sub(e), r.sub(e)) && s(r.sub(n), t.sub(n), e.sub(n)) && s(e.sub(r), t.sub(r), n.sub(r));
  }
  static triangleIsCCW(t, e, n, r) {
    const s = r.sub(e).cross(n.sub(e));
    return s.normalize(), t.dot(s) > 0;
  }
}
class Fl {
  constructor(t, e, n) {
    this.x = t, this.y = e, this.z = n;
  }
  add(t) {
    return new Fl(this.x + t.x, this.y + t.y, this.z + t.z);
  }
  sub(t) {
    return new Fl(this.x - t.x, this.y - t.y, this.z - t.z);
  }
  mul(t) {
    return new Fl(this.x - t, this.y - t, this.z - t);
  }
  dot(t) {
    return this.x * t.x + this.y * t.y + this.z * t.z;
  }
  cross(t) {
    const e = this.y * t.z - this.z * t.y, n = this.z * t.x - this.x * t.z, r = this.x * t.y - this.y * t.x;
    return new Fl(e, n, r);
  }
  squareSum() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  normalize() {
    const t = 1 / Math.sqrt(this.squareSum());
    this.x *= t, this.y *= t, this.z *= t;
  }
}
const ee = { Millimeters: "mm", Centimeters: "cm", Meters: "m", Kilometers: "km", Inches: "in", Feet: "ft", Yards: "yd", Miles: "mi" };
function Li(i, t = ee.Meters) {
  switch (i = zD(i), t = zD(t), i) {
    case ee.Millimeters:
      switch (t) {
        case ee.Centimeters:
          return 0.1;
        case ee.Meters:
          return 1e-3;
        case ee.Kilometers:
          return 1e-6;
        case ee.Inches:
          return 0.0393701;
        case ee.Feet:
          return 328084e-8;
        case ee.Yards:
          return 109361e-8;
        case ee.Miles:
          return 621371e-12;
      }
      break;
    case ee.Centimeters:
      switch (t) {
        case ee.Millimeters:
          return 10;
        case ee.Meters:
          return 0.01;
        case ee.Kilometers:
          return 1e-5;
        case ee.Inches:
          return 0.393701;
        case ee.Feet:
          return 0.0328084;
        case ee.Yards:
          return 0.0109361;
        case ee.Miles:
          return 621371e-11;
      }
      break;
    case ee.Meters:
      switch (t) {
        case ee.Millimeters:
          return 1e3;
        case ee.Centimeters:
          return 100;
        case ee.Kilometers:
          return 1e3;
        case ee.Inches:
          return 39.3701;
        case ee.Feet:
          return 3.28084;
        case ee.Yards:
          return 1.09361;
        case ee.Miles:
          return 621371e-9;
      }
      break;
    case ee.Kilometers:
      switch (t) {
        case ee.Millimeters:
          return 1e6;
        case ee.Centimeters:
          return 1e5;
        case ee.Meters:
          return 1e3;
        case ee.Inches:
          return 39370.1;
        case ee.Feet:
          return 3280.84;
        case ee.Yards:
          return 1093.61;
        case ee.Miles:
          return 0.621371;
      }
      break;
    case ee.Inches:
      switch (t) {
        case ee.Millimeters:
          return 25.4;
        case ee.Centimeters:
          return 2.54;
        case ee.Meters:
          return 0.0254;
        case ee.Kilometers:
          return 254e-7;
        case ee.Feet:
          return 0.0833333;
        case ee.Yards:
          return 0.027777694;
        case ee.Miles:
          return 157828e-10;
      }
      break;
    case ee.Feet:
      switch (t) {
        case ee.Millimeters:
          return 304.8;
        case ee.Centimeters:
          return 30.48;
        case ee.Meters:
          return 0.3048;
        case ee.Kilometers:
          return 3048e-7;
        case ee.Inches:
          return 12;
        case ee.Yards:
          return 0.333332328;
        case ee.Miles:
          return 189394e-9;
      }
      break;
    case ee.Miles:
      switch (t) {
        case ee.Millimeters:
          return 1609e3;
        case ee.Centimeters:
          return 160934;
        case ee.Meters:
          return 1609.34;
        case ee.Kilometers:
          return 1.60934;
        case ee.Inches:
          return 63360;
        case ee.Feet:
          return 5280;
        case ee.Yards:
          return 1759.99469184;
      }
  }
  return 1;
}
function zD(i) {
  if (!i)
    return ee.Meters;
  switch (i.toLowerCase()) {
    case "mm":
    case "mil":
    case "millimeters":
    case "millimetres":
      return ee.Millimeters;
    case "cm":
    case "centimetre":
    case "centimeter":
    case "centimetres":
    case "centimeters":
      return ee.Centimeters;
    case "m":
    case "meter":
    case "metre":
    case "meters":
    case "metres":
    default:
      return ee.Meters;
    case "inches":
    case "inch":
    case "in":
      return ee.Inches;
    case "feet":
    case "foot":
    case "ft":
      return ee.Feet;
    case "yard":
    case "yards":
    case "yd":
      return ee.Yards;
    case "miles":
    case "mile":
    case "mi":
      return ee.Miles;
  }
}
var kB = { exports: {} };
/*!
 * js-logger - http://github.com/jonnyreeves/js-logger
 * Jonny Reeves, http://jonnyreeves.co.uk/
 * js-logger may be freely distributed under the MIT license.
 */
(function(i) {
  (function(t) {
    var e, n = {};
    n.VERSION = "1.6.1";
    var r = {}, s = function(h, p) {
      return function() {
        return p.apply(h, arguments);
      };
    }, a = function() {
      var h, p, f = arguments, v = f[0];
      for (p = 1; p < f.length; p++)
        for (h in f[p])
          !(h in v) && f[p].hasOwnProperty(h) && (v[h] = f[p][h]);
      return v;
    }, o = function(h, p) {
      return { value: h, name: p };
    };
    n.TRACE = o(1, "TRACE"), n.DEBUG = o(2, "DEBUG"), n.INFO = o(3, "INFO"), n.TIME = o(4, "TIME"), n.WARN = o(5, "WARN"), n.ERROR = o(8, "ERROR"), n.OFF = o(99, "OFF");
    var l = function(h) {
      this.context = h, this.setLevel(h.filterLevel), this.log = this.info;
    };
    l.prototype = { setLevel: function(h) {
      h && "value" in h && (this.context.filterLevel = h);
    }, getLevel: function() {
      return this.context.filterLevel;
    }, enabledFor: function(h) {
      var p = this.context.filterLevel;
      return h.value >= p.value;
    }, trace: function() {
      this.invoke(n.TRACE, arguments);
    }, debug: function() {
      this.invoke(n.DEBUG, arguments);
    }, info: function() {
      this.invoke(n.INFO, arguments);
    }, warn: function() {
      this.invoke(n.WARN, arguments);
    }, error: function() {
      this.invoke(n.ERROR, arguments);
    }, time: function(h) {
      typeof h == "string" && h.length > 0 && this.invoke(n.TIME, [h, "start"]);
    }, timeEnd: function(h) {
      typeof h == "string" && h.length > 0 && this.invoke(n.TIME, [h, "end"]);
    }, invoke: function(h, p) {
      e && this.enabledFor(h) && e(p, a({ level: h }, this.context));
    } };
    var c, u = new l({ filterLevel: n.OFF });
    (c = n).enabledFor = s(u, u.enabledFor), c.trace = s(u, u.trace), c.debug = s(u, u.debug), c.time = s(u, u.time), c.timeEnd = s(u, u.timeEnd), c.info = s(u, u.info), c.warn = s(u, u.warn), c.error = s(u, u.error), c.log = c.info, n.setHandler = function(h) {
      e = h;
    }, n.setLevel = function(h) {
      for (var p in u.setLevel(h), r)
        r.hasOwnProperty(p) && r[p].setLevel(h);
    }, n.getLevel = function() {
      return u.getLevel();
    }, n.get = function(h) {
      return r[h] || (r[h] = new l(a({ name: h }, u.context)));
    }, n.createDefaultHandler = function(h) {
      (h = h || {}).formatter = h.formatter || function(v, m) {
        m.name && v.unshift("[" + m.name + "]");
      };
      var p = {}, f = function(v, m) {
        Function.prototype.apply.call(v, console, m);
      };
      return typeof console > "u" ? function() {
      } : function(v, m) {
        v = Array.prototype.slice.call(v);
        var y, _ = console.log;
        m.level === n.TIME ? (y = (m.name ? "[" + m.name + "] " : "") + v[0], v[1] === "start" ? console.time ? console.time(y) : p[y] = (/* @__PURE__ */ new Date()).getTime() : console.timeEnd ? console.timeEnd(y) : f(_, [y + ": " + ((/* @__PURE__ */ new Date()).getTime() - p[y]) + "ms"])) : (m.level === n.WARN && console.warn ? _ = console.warn : m.level === n.ERROR && console.error ? _ = console.error : m.level === n.INFO && console.info ? _ = console.info : m.level === n.DEBUG && console.debug ? _ = console.debug : m.level === n.TRACE && console.trace && (_ = console.trace), h.formatter(v, m), f(_, v));
      };
    }, n.useDefaults = function(h) {
      n.setLevel(h && h.defaultLevel || n.DEBUG), n.setHandler(n.createDefaultHandler(h));
    }, n.setDefaults = n.useDefaults, i.exports ? i.exports = n : (n._prevLogger = t.Logger, n.noConflict = function() {
      return t.Logger = n._prevLogger, n;
    }, t.Logger = n);
  })(bn);
})(kB);
const De = Mp(kB.exports);
var li = ((i) => (i.View3D = "View3D", i.BlockInstance = "BlockInstance", i.Pointcloud = "Pointcloud", i.Brep = "Brep", i.Mesh = "Mesh", i.Point = "Point", i.Line = "Line", i.Polyline = "Polyline", i.Box = "Box", i.Polycurve = "Polycurve", i.Curve = "Curve", i.Circle = "Circle", i.Arc = "Arc", i.Ellipse = "Ellipse", i.RevitInstance = "RevitInstance", i.Unknown = "Unknown", i))(li || {});
const kD = ["Pointcloud", "Brep", "Mesh", "Point", "Line", "Polyline", "Box", "Polycurve", "Curve", "Circle", "Arc", "Ellipse"], dn = class dn {
  static getSpeckleType(t) {
    let e = "Base";
    return e = t.raw.data ? t.raw.data.speckle_type ? t.raw.data.speckle_type.split(".").reverse()[0] : e : t.raw.speckle_type ? t.raw.speckle_type.split(".").reverse()[0] : e, e in li ? e : "Unknown";
  }
  static convertNodeToGeometryData(t) {
    switch (dn.getSpeckleType(t)) {
      case "BlockInstance":
        return dn.BlockInstanceToGeometryData(t);
      case "Pointcloud":
        return dn.PointcloudToGeometryData(t);
      case "Brep":
        return dn.BrepToGeometryData(t);
      case "Mesh":
        return dn.MeshToGeometryData(t);
      case "Point":
        return dn.PointToGeometryData(t);
      case "Line":
        return dn.LineToGeometryData(t);
      case "Polyline":
        return dn.PolylineToGeometryData(t);
      case "Box":
        return dn.BoxToGeometryData(t);
      case "Polycurve":
        return dn.PolycurveToGeometryData(t);
      case "Curve":
        return dn.CurveToGeometryData(t);
      case "Circle":
        return dn.CircleToGeometryData(t);
      case "Arc":
        return dn.ArcToGeometryData(t);
      case "Ellipse":
        return dn.EllipseToGeometryData(t);
      case "View3D":
        return dn.View3DToGeometryData(t);
      case "RevitInstance":
        return dn.RevitInstanceToGeometryData(t);
      default:
        return null;
    }
  }
  static disposeNodeGeometryData(t) {
    switch (dn.getSpeckleType(t)) {
      case "Pointcloud":
        t.raw.vertices = [], t.raw.colors = [];
        break;
      case "Mesh":
        t.raw.vertices = [], t.raw.faces = [], t.raw.colors = [];
        break;
      case "Point":
        t.raw.value ? t.raw.value = [] : (delete t.raw.x, delete t.raw.y, delete t.raw.z);
        break;
      case "Line":
        t.raw.start.value ? t.raw.start.value = [] : (delete t.raw.start.x, delete t.raw.start.y, delete t.raw.start.z), t.raw.end.value ? t.raw.end.value = [] : (delete t.raw.end.x, delete t.raw.end.y, delete t.raw.end.z);
        break;
      case "Polyline":
        t.raw.value = [];
    }
  }
  static View3DToGeometryData(t) {
    const e = dn.PointToVector3(t.raw.origin), n = dn.PointToVector3(t.raw.target);
    return t.raw.origin = e, t.raw.target = n, { attributes: null, bakeTransform: null, transform: null };
  }
  static BlockInstanceToGeometryData(t) {
    const e = Li(t.raw.units), n = Array.isArray(t.raw.transform) ? t.raw.transform : t.raw.transform.value ? t.raw.transform.value : t.raw.transform.matrix, r = new Vt().fromArray(n).transpose();
    return { attributes: null, bakeTransform: null, transform: new Vt().makeScale(e, e, e).multiply(r).multiply(new Vt().makeScale(1 / e, 1 / e, 1 / e)) };
  }
  static RevitInstanceToGeometryData(t) {
    const e = Li(t.raw.units), n = Array.isArray(t.raw.transform) ? t.raw.transform : t.raw.transform.value ? t.raw.transform.value : t.raw.transform.matrix, r = new Vt().fromArray(n).transpose();
    return { attributes: null, bakeTransform: null, transform: new Vt().makeScale(e, e, e).multiply(r).multiply(new Vt().makeScale(1 / e, 1 / e, 1 / e)) };
  }
  static PointcloudToGeometryData(t) {
    const e = Li(t.raw.units), n = t.raw.points, r = t.raw.colors;
    let s = null;
    return r && r.length !== 0 && (r.length !== n.length / 3 && De.warn(`Mesh (id ${t.raw.id}) colours are mismatched with vertice counts. The number of colours must equal the number of vertices.`), s = dn.unpackColors(r, !0)), { attributes: { POSITION: n, COLOR: s }, bakeTransform: new Vt().makeScale(e, e, e), transform: null };
  }
  static BrepToGeometryData(t) {
    return null;
  }
  static MeshToGeometryData(t) {
    if (!t.raw)
      return;
    const e = Li(t.raw.units), n = [];
    if (!t.raw.vertices || !t.raw.faces)
      return;
    const r = t.raw.vertices, s = t.raw.faces, a = t.raw.colors, o = t.raw.textureCoordinates, l = t.raw.uv2, c = t.raw.tangent, u = t.raw.morphTargetDictionary, h = t.raw.morphTargetInfluences, p = t.raw.morphAttributes, f = t.raw.normal;
    let v, m = null, y = 0;
    for (; y < s.length; ) {
      let _ = s[y];
      if (_ < 3 && (_ += 3), _ === 3)
        n.push(s[y + 1], s[y + 2], s[y + 3]);
      else {
        const w = Vit.triangulateFace(y, s, r);
        n.push(...w.filter((b) => b !== void 0));
      }
      y += _ + 1;
    }
    if (a && a.length !== 0 && (a.length !== r.length / 3 && De.warn(`Mesh (id ${t.raw.id}) colours are mismatched with vertice counts. The number of colours must equal the number of vertices.`), m = dn.unpackColors(a)), Array.isArray(t.raw.renderMaterial)) {
      const _ = [];
      for (let T = 0; T < t.raw.drawRange.length; T++)
        _.push({ ...t.raw.drawRange[T] });
      const w = t.raw.drawRange[t.raw.drawRange.length - 1], b = w.start + w.count;
      b < n.length && _.push({ start: b, count: n.length - b, materialIndex: 0 }), v = _;
    }
    return { attributes: { POSITION: r, INDEX: n, COLOR: m, NORMAL: f, UV: o, UV2: l, TANGENT: c, MORPHATTRIBUTES: p }, bakeTransform: new Vt().makeScale(e, e, e), transform: null, textureCoordinates: o, uv2: l, tangent: c, groups: v, morphTargetDictionary: u, morphTargetInfluences: h };
  }
  static PointToGeometryData(t) {
    const e = Li(t.raw.units);
    return { attributes: { POSITION: this.PointToFloatArray(t.raw) }, bakeTransform: new Vt().makeScale(e, e, e), transform: null };
  }
  static LineToGeometryData(t) {
    const e = Li(t.raw.units);
    return { attributes: { POSITION: this.PointToFloatArray(t.raw.start).concat(this.PointToFloatArray(t.raw.end)) }, bakeTransform: new Vt().makeScale(e, e, e), transform: null };
  }
  static PolylineToGeometryData(t) {
    const e = Li(t.raw.units);
    return t.raw.closed && t.raw.value.push(t.raw.value[0], t.raw.value[1], t.raw.value[2]), { attributes: { POSITION: t.raw.value.slice(0) }, bakeTransform: new Vt().makeScale(e, e, e), transform: null };
  }
  static BoxToGeometryData(t) {
    const e = Li(t.raw.units), n = this.PointToVector3(t.raw.basePlane.origin), r = (t.raw.xSize.end - t.raw.xSize.start) * e, s = (t.raw.ySize.end - t.raw.ySize.start) * e, a = (t.raw.zSize.end - t.raw.zSize.start) * e, o = new lO(r, s, a, 1, 1, 1);
    return { attributes: { POSITION: o.attributes.position.array, INDEX: o.index.array }, bakeTransform: new Vt().setPosition(n), transform: null };
  }
  static PolycurveToGeometryData(t) {
    const e = [];
    for (let n = 0; n < t.nestedNodes.length; n++) {
      const r = t.nestedNodes[n].model, s = dn.convertNodeToGeometryData(r);
      e.push(s);
    }
    return Nn.mergeGeometryData(e);
  }
  static CurveToGeometryData(t) {
    if (t.children.length === 0)
      return null;
    const e = this.PolylineToGeometryData(t.children[0]);
    return { attributes: { POSITION: e.attributes.POSITION }, bakeTransform: e.bakeTransform, transform: null };
  }
  static CircleToGeometryData(t) {
    const e = Li(t.raw.units), n = 0.1 * e, r = this.getCircularCurvePoints(t.raw.plane, t.raw.radius * e, void 0, void 0, n);
    return { attributes: { POSITION: this.FlattenVector3Array(r) }, bakeTransform: null, transform: null };
  }
  static ArcToGeometryData(t) {
    const e = new D(t.raw.plane.origin.x, t.raw.plane.origin.y, t.raw.plane.origin.z), n = new D(t.raw.startPoint.x, t.raw.startPoint.y, t.raw.startPoint.z), r = new D(t.raw.endPoint.x, t.raw.endPoint.y, t.raw.endPoint.z), s = new D(t.raw.midPoint.x, t.raw.midPoint.y, t.raw.midPoint.z), a = new D().subVectors(n, s).normalize(), o = new D().subVectors(r, s).normalize(), l = a.dot(o) > 0, c = new D().subVectors(n, e);
    c.normalize();
    const u = new D().subVectors(r, e);
    u.normalize();
    const h = new D().crossVectors(c, u);
    if (h.normalize(), h.length() === 0) {
      const A = new D().subVectors(s, e);
      A.normalize(), h.copy(new D().crossVectors(c, A)), h.normalize();
    }
    const p = new D().crossVectors(h, c);
    p.normalize();
    const f = Math.min(Math.max(c.dot(u), -1), 1), v = Math.acos(f), m = t.raw.radius, y = new bp(0, 0, m, m, 0, v, l, 0).getPoints(50), _ = new Vt(), w = Li(t.raw.plane.units), b = new Vt().makeBasis(c, p, h), T = new Vt().setPosition(e.multiplyScalar(w));
    _.multiply(T).multiply(b);
    const M = new Vt().scale(new D(w, w, w));
    return _.multiply(M), { attributes: { POSITION: this.FlattenVector3Array(y) }, bakeTransform: _, transform: null };
  }
  static EllipseToGeometryData(t) {
    const e = Li(t.raw.units), n = new D(t.raw.plane.origin.x, t.raw.plane.origin.y, t.raw.plane.origin.z).multiplyScalar(e), r = new D(t.raw.plane.xdir.x, t.raw.plane.xdir.y, t.raw.plane.xdir.z).normalize(), s = new D(t.raw.plane.ydir.x, t.raw.plane.ydir.y, t.raw.plane.ydir.z).normalize();
    let a = 2 * Math.PI * t.raw.firstRadius * e * 10;
    a = parseInt(a.toString());
    const o = [];
    for (let l = 0; l <= a; l++) {
      const c = l * Math.PI * 2 / a, u = Math.cos(c) * t.raw.firstRadius * e, h = Math.sin(c) * t.raw.secondRadius * e, p = new D(r.x * u, r.y * u, r.z * u), f = new D(s.x * h, s.y * h, s.z * h), v = new D().addVectors(p, f).add(n);
      o.push(v);
    }
    return { attributes: { POSITION: this.FlattenVector3Array(o) }, bakeTransform: null, transform: null };
  }
  static getCircularCurvePoints(t, e, n = 0, r = 2 * Math.PI, s = 0.1) {
    const a = this.PointToVector3(t.origin), o = this.PointToVector3(t.xdir), l = this.PointToVector3(t.ydir);
    o.normalize(), l.normalize();
    let c = (r - n) * e / s;
    c = parseInt(c.toString());
    const u = [];
    for (let h = 0; h <= c; h++) {
      const p = n + h * (r - n) / c, f = Math.cos(p) * e, v = Math.sin(p) * e, m = new D(o.x * f, o.y * f, o.z * f), y = new D(l.x * v, l.y * v, l.z * v), _ = new D().addVectors(m, y).add(a);
      u.push(_);
    }
    return u;
  }
  static PointToVector3(t, e = !0) {
    const n = e ? Li(t.units) : 1;
    let r = null;
    return r = t.value ? new D(t.value[0] * n, t.value[1] * n, t.value[2] * n) : new D(t.x * n, t.y * n, t.z * n), r;
  }
  static PointToFloatArray(t) {
    return t.value ? [t.value[0], t.value[1], t.value[2]] : [t.x, t.y, t.z];
  }
  static FlattenVector3Array(t) {
    const e = new Array(3 * t.length), n = [];
    for (let r = 0, s = 0; r < t.length; r++, s += 3)
      t[r].toArray(n), e[s] = n[0], e[s + 1] = n[1], e[s + 2] = n[2] ? n[2] : 0;
    return e;
  }
  static unpackColors(t, e = !1) {
    const n = new Array(3 * t.length);
    for (let r = 0; r < t.length; r++) {
      const s = t[r], a = s >> 16 & 255, o = s >> 8 & 255, l = 255 & s;
      n[3 * r] = a / 255, n[3 * r + 1] = o / 255, n[3 * r + 2] = l / 255, e && (n[3 * r] = dn.srgbToLinear(n[3 * r]), n[3 * r + 1] = dn.srgbToLinear(n[3 * r + 1]), n[3 * r + 2] = dn.srgbToLinear(n[3 * r + 2]));
    }
    return n;
  }
  static srgbToLinear(t) {
    return t <= 0 ? 0 : t >= 1 ? 1 : t < 0.04045 ? t / 12.92 : Math.pow((t + 0.055) / 1.055, 2.4);
  }
};
U(dn, "keepGeometryData", !1);
let As = dn;
var ae = ((i) => (i[i.MESH = 0] = "MESH", i[i.LINE = 1] = "LINE", i[i.POINT = 2] = "POINT", i[i.POINT_CLOUD = 3] = "POINT_CLOUD", i))(ae || {});
const Jh = { offset: 0, count: 0 }, ra = { offset: 0, count: 1 / 0 }, Xr = class Xr {
  constructor(t) {
    U(this, "_batchId");
    U(this, "_batchIndexStart");
    U(this, "_batchIndexCount");
    U(this, "_batchVertexStart");
    U(this, "_batchVertexEnd");
    U(this, "_renderData");
    U(this, "_materialHash");
    U(this, "_geometryType");
    U(this, "_aabb", null);
    this._renderData = t, this._geometryType = this.getGeometryType(), this._materialHash = this.getMaterialHash(), this._batchId, this._batchIndexCount, this._batchIndexStart, this._batchVertexStart, this._batchVertexEnd;
  }
  static hashCode(t) {
    let e;
    for (let n = 0; n < t.length; n++)
      e = Math.imul(31, e) + t.charCodeAt(n) | 0;
    return e;
  }
  get renderData() {
    return this._renderData;
  }
  get renderMaterialHash() {
    return this._materialHash;
  }
  get hasGeometry() {
    return this._renderData.geometry && this._renderData.geometry.attributes;
  }
  get speckleType() {
    return this._renderData.speckleType;
  }
  get geometryType() {
    return this._geometryType;
  }
  get batchStart() {
    return this._batchIndexStart;
  }
  get batchEnd() {
    return this._batchIndexStart + this._batchIndexCount;
  }
  get batchCount() {
    return this._batchIndexCount;
  }
  get batchId() {
    return this._batchId;
  }
  get aabb() {
    return this._aabb;
  }
  get transparent() {
    return this._renderData.renderMaterial && this._renderData.renderMaterial.opacity < 1;
  }
  get vertStart() {
    return this._batchVertexStart;
  }
  get vertEnd() {
    return this._batchVertexEnd;
  }
  get needsSegmentConversion() {
    return this._renderData.speckleType === li.Curve || this._renderData.speckleType === li.Polyline || this._renderData.speckleType === li.Polycurve || this.renderData.speckleType === li.Arc || this.renderData.speckleType === li.Circle || this.renderData.speckleType === li.Ellipse;
  }
  get validGeometry() {
    return this._renderData.geometry.attributes.POSITION && this._renderData.geometry.attributes.POSITION.length > 0;
  }
  setBatchData(t, e, n, r, s) {
    this._batchId = t, this._batchIndexStart = e, this._batchIndexCount = n, r !== void 0 && (this._batchVertexStart = r), s !== void 0 && (this._batchVertexEnd = s);
  }
  computeAABB() {
    this._aabb = new ke().setFromArray(this._renderData.geometry.attributes.POSITION);
  }
  getGeometryType() {
    switch (this._renderData.speckleType) {
      case li.Mesh:
      case li.Brep:
        return ae.MESH;
      case li.Point:
        return ae.POINT;
      case li.Pointcloud:
        return ae.POINT_CLOUD;
      default:
        return ae.LINE;
    }
  }
  disposeGeometry() {
    for (const t in this._renderData.geometry.attributes)
      this._renderData.geometry.attributes[t] = [];
  }
  renderMaterialToString() {
    const t = this.renderData.renderMaterial;
    if (t && !Array.isArray(t))
      return t.color.toString() + "/" + t.opacity.toString() + "/" + t.roughness.toString() + "/" + t.metalness.toString();
    let e = "";
    for (let n = 0; n < t.length; n++)
      e += t[n].color.toString() + "/" + t[n].opacity.toString() + "/" + t[n].roughness.toString() + "/" + t[n].metalness.toString();
    return e;
  }
  blobIdString() {
    var r;
    const t = (s) => {
      let a = "";
      return s.blobIds && (a += s == null ? void 0 : s.blobIds.join("/")), s.emissiveBlobIds && (a += s == null ? void 0 : s.emissiveBlobIds.join("/")), s.normalBlobIds && (a += s == null ? void 0 : s.normalBlobIds.join("/")), s.metalnessBlobIds && (a += s == null ? void 0 : s.metalnessBlobIds.join("/")), s.roughnessBlobIds && (a += s == null ? void 0 : s.roughnessBlobIds.join("/")), s.side !== void 0 && (a += "__side" + (s == null ? void 0 : s.side)), s.depthWrite !== void 0 && (a += "__depthWrite" + (s == null ? void 0 : s.depthWrite)), s.depthTest !== void 0 && (a += "__depthTest" + (s == null ? void 0 : s.depthTest)), s.depthTest !== void 0 && (a += "transparent" + (s == null ? void 0 : s.transparent)), a;
    }, e = this.renderData.renderMaterial;
    let n = "";
    if (!e)
      return n;
    if (e && !Array.isArray(e))
      return n = t(e == null ? void 0 : e.userData), n;
    for (let s = 0; s < e.length; s++)
      n += t((r = e[s]) == null ? void 0 : r.userData);
    return n;
  }
  displayStyleToString() {
    var e, n;
    if (!this.renderData.displayStyle.pattern)
      return ((e = this.renderData.displayStyle.color) == null ? void 0 : e.toString()) + "/" + this.renderData.displayStyle.lineWeight.toString();
    const t = this.renderData.displayStyle.pattern.join("@");
    return ((n = this.renderData.displayStyle.color) == null ? void 0 : n.toString()) + "/" + this.renderData.displayStyle.lineWeight.toString() + "/" + t;
  }
  getMaterialHash() {
    var s, a, o, l;
    if ((a = (s = this.renderData) == null ? void 0 : s.renderMaterial) != null && a.trackName) {
      const c = `${this.renderData.id}-${(l = (o = this.renderData) == null ? void 0 : o.renderMaterial) == null ? void 0 : l.trackName}`;
      return Xr.hashCode(c);
    }
    const t = !this.renderData.renderMaterial || this.geometryType !== ae.MESH && this.geometryType !== ae.POINT ? this.renderData.displayStyle && this.geometryType !== ae.MESH && this.geometryType !== ae.POINT ? this.displayStyleToString() : "" : this.renderMaterialToString();
    let e = "";
    this.renderData.geometry.attributes && (e = this.renderData.geometry.attributes.COLOR ? "vertexColors" : "");
    const n = this.blobIdString(), r = this.geometryType.toString() + e + t + n;
    return Xr.hashCode(r);
  }
};
U(Xr, "NullRenderMaterialHash", Xr.hashCode(ae.MESH.toString())), U(Xr, "NullRenderMaterialVertexColorsHash", Xr.hashCode(ae.MESH.toString() + "vertexColors")), U(Xr, "NullDisplayStyleHash", Xr.hashCode(ae.LINE.toString())), U(Xr, "NullPointMaterialHash", Xr.hashCode(ae.POINT.toString())), U(Xr, "NullPointCloudMaterialHash", Xr.hashCode(ae.POINT_CLOUD.toString())), U(Xr, "NullPointCloudVertexColorsMaterialHash", Xr.hashCode(ae.POINT_CLOUD.toString() + "vertexColors"));
let zi = Xr;
Xt.line = { worldUnits: { value: 1 }, linewidth: { value: 1 }, resolution: { value: new wt(1, 1) }, dashOffset: { value: 0 }, dashScale: { value: 1 }, dashSize: { value: 1 }, gapSize: { value: 1 } }, Pn.line = { uniforms: Jn.merge([Xt.common, Xt.fog, Xt.line]), vertexShader: `
		#include <common>
		#include <color_pars_vertex>
		#include <fog_pars_vertex>
		#include <logdepthbuf_pars_vertex>
		#include <clipping_planes_pars_vertex>

		uniform float linewidth;
		uniform vec2 resolution;

		attribute vec3 instanceStart;
		attribute vec3 instanceEnd;

		attribute vec3 instanceColorStart;
		attribute vec3 instanceColorEnd;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#ifdef USE_DASH

			uniform float dashScale;
			attribute float instanceDistanceStart;
			attribute float instanceDistanceEnd;
			varying float vLineDistance;

		#endif

		void trimSegment( const in vec4 start, inout vec4 end ) {

			// trim end segment so it terminates between the camera plane and the near plane

			// conservative estimate of the near plane
			float a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column
			float b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column
			float nearEstimate = - 0.5 * b / a;

			float alpha = ( nearEstimate - start.z ) / ( end.z - start.z );

			end.xyz = mix( start.xyz, end.xyz, alpha );

		}

		void main() {

			#ifdef USE_COLOR

				vColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;

			#endif

			#ifdef USE_DASH

				vLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;
				vUv = uv;

			#endif

			float aspect = resolution.x / resolution.y;

			// camera space
			vec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );
			vec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );

			#ifdef WORLD_UNITS

				worldStart = start.xyz;
				worldEnd = end.xyz;

			#else

				vUv = uv;

			#endif

			// special case for perspective projection, and segments that terminate either in, or behind, the camera plane
			// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space
			// but we need to perform ndc-space calculations in the shader, so we must address this issue directly
			// perhaps there is a more elegant solution -- WestLangley

			bool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column

			if ( perspective ) {

				if ( start.z < 0.0 && end.z >= 0.0 ) {

					trimSegment( start, end );

				} else if ( end.z < 0.0 && start.z >= 0.0 ) {

					trimSegment( end, start );

				}

			}

			// clip space
			vec4 clipStart = projectionMatrix * start;
			vec4 clipEnd = projectionMatrix * end;

			// ndc space
			vec3 ndcStart = clipStart.xyz / clipStart.w;
			vec3 ndcEnd = clipEnd.xyz / clipEnd.w;

			// direction
			vec2 dir = ndcEnd.xy - ndcStart.xy;

			// account for clip-space aspect ratio
			dir.x *= aspect;
			dir = normalize( dir );

			#ifdef WORLD_UNITS

				// get the offset direction as perpendicular to the view vector
				vec3 worldDir = normalize( end.xyz - start.xyz );
				vec3 offset;
				if ( position.y < 0.5 ) {

					offset = normalize( cross( start.xyz, worldDir ) );

				} else {

					offset = normalize( cross( end.xyz, worldDir ) );

				}

				// sign flip
				if ( position.x < 0.0 ) offset *= - 1.0;

				float forwardOffset = dot( worldDir, vec3( 0.0, 0.0, 1.0 ) );

				// don't extend the line if we're rendering dashes because we
				// won't be rendering the endcaps
				#ifndef USE_DASH

					// extend the line bounds to encompass  endcaps
					start.xyz += - worldDir * linewidth * 0.5;
					end.xyz += worldDir * linewidth * 0.5;

					// shift the position of the quad so it hugs the forward edge of the line
					offset.xy -= dir * forwardOffset;
					offset.z += 0.5;

				#endif

				// endcaps
				if ( position.y > 1.0 || position.y < 0.0 ) {

					offset.xy += dir * 2.0 * forwardOffset;

				}

				// adjust for linewidth
				offset *= linewidth * 0.5;

				// set the world position
				worldPos = ( position.y < 0.5 ) ? start : end;
				worldPos.xyz += offset;

				// project the worldpos
				vec4 clip = projectionMatrix * worldPos;

				// shift the depth of the projected points so the line
				// segments overlap neatly
				vec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;
				clip.z = clipPose.z * clip.w;

			#else

				vec2 offset = vec2( dir.y, - dir.x );
				// undo aspect ratio adjustment
				dir.x /= aspect;
				offset.x /= aspect;

				// sign flip
				if ( position.x < 0.0 ) offset *= - 1.0;

				// endcaps
				if ( position.y < 0.0 ) {

					offset += - dir;

				} else if ( position.y > 1.0 ) {

					offset += dir;

				}

				// adjust for linewidth
				offset *= linewidth;

				// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...
				offset /= resolution.y;

				// select end
				vec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;

				// back to clip space
				offset *= clip.w;

				clip.xy += offset;

			#endif

			gl_Position = clip;

			vec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation

			#include <logdepthbuf_vertex>
			#include <clipping_planes_vertex>
			#include <fog_vertex>

		}
		`, fragmentShader: `
		uniform vec3 diffuse;
		uniform float opacity;
		uniform float linewidth;

		#ifdef USE_DASH

			uniform float dashOffset;
			uniform float dashSize;
			uniform float gapSize;

		#endif

		varying float vLineDistance;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#include <common>
		#include <color_pars_fragment>
		#include <fog_pars_fragment>
		#include <logdepthbuf_pars_fragment>
		#include <clipping_planes_pars_fragment>

		vec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {

			float mua;
			float mub;

			vec3 p13 = p1 - p3;
			vec3 p43 = p4 - p3;

			vec3 p21 = p2 - p1;

			float d1343 = dot( p13, p43 );
			float d4321 = dot( p43, p21 );
			float d1321 = dot( p13, p21 );
			float d4343 = dot( p43, p43 );
			float d2121 = dot( p21, p21 );

			float denom = d2121 * d4343 - d4321 * d4321;

			float numer = d1343 * d4321 - d1321 * d4343;

			mua = numer / denom;
			mua = clamp( mua, 0.0, 1.0 );
			mub = ( d1343 + d4321 * ( mua ) ) / d4343;
			mub = clamp( mub, 0.0, 1.0 );

			return vec2( mua, mub );

		}

		void main() {

			#include <clipping_planes_fragment>

			#ifdef USE_DASH

				if ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps

				if ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX

			#endif

			float alpha = opacity;

			#ifdef WORLD_UNITS

				// Find the closest points on the view ray and the line segment
				vec3 rayEnd = normalize( worldPos.xyz ) * 1e5;
				vec3 lineDir = worldEnd - worldStart;
				vec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );

				vec3 p1 = worldStart + lineDir * params.x;
				vec3 p2 = rayEnd * params.y;
				vec3 delta = p1 - p2;
				float len = length( delta );
				float norm = len / linewidth;

				#ifndef USE_DASH

					#ifdef USE_ALPHA_TO_COVERAGE

						float dnorm = fwidth( norm );
						alpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );

					#else

						if ( norm > 0.5 ) {

							discard;

						}

					#endif

				#endif

			#else

				#ifdef USE_ALPHA_TO_COVERAGE

					// artifacts appear on some hardware if a derivative is taken within a conditional
					float a = vUv.x;
					float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
					float len2 = a * a + b * b;
					float dlen = fwidth( len2 );

					if ( abs( vUv.y ) > 1.0 ) {

						alpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );

					}

				#else

					if ( abs( vUv.y ) > 1.0 ) {

						float a = vUv.x;
						float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
						float len2 = a * a + b * b;

						if ( len2 > 1.0 ) discard;

					}

				#endif

			#endif

			vec4 diffuseColor = vec4( diffuse, alpha );

			#include <logdepthbuf_fragment>
			#include <color_fragment>

			gl_FragColor = vec4( diffuseColor.rgb, alpha );

			#include <tonemapping_fragment>
			#include <encodings_fragment>
			#include <fog_fragment>
			#include <premultiplied_alpha_fragment>

		}
		` };
class NB extends Gn {
  constructor(t) {
    super({ type: "LineMaterial", uniforms: Jn.clone(Pn.line.uniforms), vertexShader: Pn.line.vertexShader, fragmentShader: Pn.line.fragmentShader, clipping: !0 }), this.isLineMaterial = !0, Object.defineProperties(this, { color: { enumerable: !0, get: function() {
      return this.uniforms.diffuse.value;
    }, set: function(e) {
      this.uniforms.diffuse.value = e;
    } }, worldUnits: { enumerable: !0, get: function() {
      return "WORLD_UNITS" in this.defines;
    }, set: function(e) {
      e === !0 ? this.defines.WORLD_UNITS = "" : delete this.defines.WORLD_UNITS;
    } }, linewidth: { enumerable: !0, get: function() {
      return this.uniforms.linewidth.value;
    }, set: function(e) {
      this.uniforms.linewidth.value = e;
    } }, dashed: { enumerable: !0, get: function() {
      return "USE_DASH" in this.defines;
    }, set(e) {
      !!e != "USE_DASH" in this.defines && (this.needsUpdate = !0), e === !0 ? this.defines.USE_DASH = "" : delete this.defines.USE_DASH;
    } }, dashScale: { enumerable: !0, get: function() {
      return this.uniforms.dashScale.value;
    }, set: function(e) {
      this.uniforms.dashScale.value = e;
    } }, dashSize: { enumerable: !0, get: function() {
      return this.uniforms.dashSize.value;
    }, set: function(e) {
      this.uniforms.dashSize.value = e;
    } }, dashOffset: { enumerable: !0, get: function() {
      return this.uniforms.dashOffset.value;
    }, set: function(e) {
      this.uniforms.dashOffset.value = e;
    } }, gapSize: { enumerable: !0, get: function() {
      return this.uniforms.gapSize.value;
    }, set: function(e) {
      this.uniforms.gapSize.value = e;
    } }, opacity: { enumerable: !0, get: function() {
      return this.uniforms.opacity.value;
    }, set: function(e) {
      this.uniforms.opacity.value = e;
    } }, resolution: { enumerable: !0, get: function() {
      return this.uniforms.resolution.value;
    }, set: function(e) {
      this.uniforms.resolution.value.copy(e);
    } }, alphaToCoverage: { enumerable: !0, get: function() {
      return "USE_ALPHA_TO_COVERAGE" in this.defines;
    }, set: function(e) {
      !!e != "USE_ALPHA_TO_COVERAGE" in this.defines && (this.needsUpdate = !0), e === !0 ? (this.defines.USE_ALPHA_TO_COVERAGE = "", this.extensions.derivatives = !0) : (delete this.defines.USE_ALPHA_TO_COVERAGE, this.extensions.derivatives = !1);
    } } }), this.setValues(t);
  }
}
const wr = class wr extends NB {
  set pixelThreshold(t) {
    this.userData.pixelThreshold.value = t, this.needsUpdate = !0;
  }
  constructor(t, e = []) {
    super(t), this.userData.uViewer_high = { value: new D() }, this.userData.uViewer_low = { value: new D() }, this.userData.pixelThreshold = { value: 0 }, this.vertProgram = `
		#include <common>
		#include <color_pars_vertex>
		#include <fog_pars_vertex>
		#include <logdepthbuf_pars_vertex>
		#include <clipping_planes_pars_vertex>

		uniform float linewidth;
		uniform vec2 resolution;
		uniform float pixelThreshold;
		#define SEARCH_STEPS 10

		attribute vec3 instanceStart;
		attribute vec3 instanceEnd;

		attribute vec4 instanceColorStart;
		attribute vec4 instanceColorEnd;
		// varying vec3 debugColor;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;
			varying float correctedLineWidth;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#ifdef USE_DASH

			uniform float dashScale;
			attribute float instanceDistanceStart;
			attribute float instanceDistanceEnd;
			varying float vLineDistance;

		#endif

        #ifdef USE_RTE
			attribute vec3 instanceStartLow;
			attribute vec3 instanceEndLow;
            uniform vec3 uViewer_high;
            uniform vec3 uViewer_low;
        #endif

		void trimSegment( const in vec4 start, inout vec4 end ) {

			// trim end segment so it terminates between the camera plane and the near plane

			// conservative estimate of the near plane
			float a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column
			float b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column
			float nearEstimate = - 0.5 * b / a;

			float alpha = ( nearEstimate - start.z ) / ( end.z - start.z );

			end.xyz = mix( start.xyz, end.xyz, alpha );

		}

		float screenSpaceDistance(vec4 p0, vec4 p1) {
			p0 = projectionMatrix * p0;
			p0 /= p0.w;
			p1 = projectionMatrix * p1;
			p1 /= p1.w;
			return length(p1.xy - p0.xy);
		}

		vec4 computeRelativePositionSeparate(in vec3 position_low, in vec3 position_high, in vec3 relativeTo_low, in vec3 relativeTo_high){
			/* 
			Vector calculation for the high and low differences works on everything 
			*BESIDES* Apple Silicon (or whatever they call it) GPUs

			It would seem that when this code gets compiled, vector types get a lower precision(?)
			which completely brakes the 2 float -> double reconstructio. Doing it separately for each 
			vector component using floats works fine.
			*/
			vec3 highDifference;
			vec3 lowDifference;
			float t1 = position_low.x - relativeTo_low.x;
			float e = t1 - position_low.x;
			float t2 = ((-relativeTo_low.x - e) + (position_low.x - (t1 - e))) + position_high.x - relativeTo_high.x;
			highDifference.x = t1 + t2;
			lowDifference.x = t2 - (highDifference.x - t1);

			t1 = position_low.y - relativeTo_low.y;
			e = t1 - position_low.y;
			t2 = ((-relativeTo_low.y - e) + (position_low.y - (t1 - e))) + position_high.y - relativeTo_high.y;
			highDifference.y = t1 + t2;
			lowDifference.y = t2 - (highDifference.y - t1);

			t1 = position_low.z - relativeTo_low.z;
			e = t1 - position_low.z;
			t2 = ((-relativeTo_low.z - e) + (position_low.z - (t1 - e))) + position_high.z - relativeTo_high.z;
			highDifference.z = t1 + t2;
			lowDifference.z = t2 - (highDifference.z - t1);

			vec3 position = highDifference.xyz + lowDifference.xyz;
			return vec4(position, 1.);
		}

		vec4 computeRelativePosition(in vec3 position_low, in vec3 position_high, in vec3 relativeTo_low, in vec3 relativeTo_high){
			/* 
			Source https://github.com/virtualglobebook/OpenGlobe/blob/master/Source/Examples/Chapter05/Jitter/GPURelativeToEyeDSFUN90/Shaders/VS.glsl 
			Note here, we're storing the high part of the position encoding inside three's default 'position' attribute buffer so we avoid redundancy 
			*/
			vec3 t1 = position_low.xyz - relativeTo_low;
			vec3 e = t1 - position_low.xyz;
			vec3 t2 = ((-relativeTo_low - e) + (position_low.xyz - (t1 - e))) + position_high.xyz - relativeTo_high;
			vec3 highDifference = t1 + t2;
			vec3 lowDifference = t2 - (highDifference - t1);
			
			vec3 position = highDifference.xyz + lowDifference.xyz;
			return vec4(position, 1.);
		}

		void main() {
			if(instanceColorStart.w == 0.) {
				gl_Position = vec4(0.);
				return;
			}
			
            vec3 computedPosition = position;
			#ifdef USE_COLOR

				vColor.xyz = ( computedPosition.y < 0.5 ) ? instanceColorStart.xyz : instanceColorEnd.xyz;

			#endif

			#ifdef USE_DASH

				vLineDistance = ( computedPosition.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;
				vUv = uv;

			#endif

			float aspect = resolution.x / resolution.y;

			// camera space
            #ifdef USE_RTE
			/** Source https://github.com/virtualglobebook/OpenGlobe/blob/master/Source/Examples/Chapter05/Jitter/GPURelativeToEyeDSFUN90/Shaders/VS.glsl */
				// vec3 t1 = instanceStartLow.xyz - uViewer_low;
				// vec3 e = t1 - instanceStartLow.xyz;
				// vec3 t2 = ((-uViewer_low - e) + (instanceStartLow.xyz - (t1 - e))) + instanceStart.xyz - uViewer_high;
				// vec3 highDifference = t1 + t2;
				// vec3 lowDifference = t2 - (highDifference - t1);
				// vec4 start = modelViewMatrix * vec4(highDifference.xyz + lowDifference.xyz , 1.);
				vec4 start = modelViewMatrix * computeRelativePositionSeparate(instanceStartLow.xyz, instanceStart.xyz, uViewer_low, uViewer_high);
				
				// t1 = instanceEndLow.xyz - uViewer_low;
				// e = t1 - instanceEndLow.xyz;
				// t2 = ((-uViewer_low - e) + (instanceEndLow.xyz - (t1 - e))) + instanceEnd.xyz - uViewer_high;
				// highDifference = t1 + t2;
				// lowDifference = t2 - (highDifference - t1);
				// vec4 end = modelViewMatrix * vec4(highDifference.xyz + lowDifference.xyz , 1.);
				vec4 end = modelViewMatrix * computeRelativePositionSeparate(instanceEndLow.xyz, instanceEnd.xyz, uViewer_low, uViewer_high);
            #else
                vec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );
                vec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );
            #endif

			#ifdef WORLD_UNITS

				worldStart = start.xyz;
				worldEnd = end.xyz;

			#else

				vUv = uv;

			#endif

			// special case for perspective projection, and segments that terminate either in, or behind, the camera plane
			// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space
			// but we need to perform ndc-space calculations in the shader, so we must address this issue directly
			// perhaps there is a more elegant solution -- WestLangley

			bool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column

			if ( perspective ) {

				if ( start.z < 0.0 && end.z >= 0.0 ) {

					trimSegment( start, end );

				} else if ( end.z < 0.0 && start.z >= 0.0 ) {

					trimSegment( end, start );

				}

			}

			// clip space
			vec4 clipStart = projectionMatrix * start;
			vec4 clipEnd = projectionMatrix * end;

			// ndc space
			vec3 ndcStart = clipStart.xyz / clipStart.w;
			vec3 ndcEnd = clipEnd.xyz / clipEnd.w;

			// direction
			vec2 dir = ndcEnd.xy - ndcStart.xy;

			// account for clip-space aspect ratio
			dir.x *= aspect;
			dir = normalize( dir );

			#ifdef WORLD_UNITS

				// get the offset direction as perpendicular to the view vector
				vec3 worldDir = normalize( end.xyz - start.xyz );
				vec3 offset;
				if ( computedPosition.y < 0.5 ) {

					offset = normalize( cross( start.xyz, worldDir ) );

				} else {

					offset = normalize( cross( end.xyz, worldDir ) );

				}

				// sign flip
				if ( computedPosition.x < 0.0 ) offset *= - 1.0;

				float forwardOffset = dot( worldDir, vec3( 0.0, 0.0, 1.0 ) );

				// don't extend the line if we're rendering dashes because we
				// won't be rendering the endcaps
				#ifndef USE_DASH

					// extend the line bounds to encompass  endcaps
					start.xyz += - worldDir * linewidth * 0.5;
					end.xyz += worldDir * linewidth * 0.5;

					// shift the position of the quad so it hugs the forward edge of the line
					offset.xy -= dir * forwardOffset;
					offset.z += 0.5;

				#endif

				// endcaps
				if ( computedPosition.y > 1.0 || computedPosition.y < 0.0 ) {

					offset.xy += dir * 2.0 * forwardOffset;

				}

				// debugColor = vec3(0., 0., 1.);
				correctedLineWidth = linewidth;
				vec3 cOffset = offset;
				
				// adjust for linewidth
				offset *= linewidth * 0.5;

				// set the world position
				worldPos = ( computedPosition.y < 0.5 ) ? start : end;

				/*
				Not great, not terrible
				*/
				float pixelSize = length(vec2(pixelThreshold/resolution.x + pixelThreshold/resolution.y));
				float offsetStep = linewidth;
				float d = screenSpaceDistance(worldPos, worldPos + vec4(cOffset * offsetStep, 0.));
				/* We're trying to start off with a step closer to the initial difference between SS distance and the pixel size we want
				*/
				// offsetStep += pixelSize - d;
				vec3 move = offset;
				
				for(int i = 0; i < SEARCH_STEPS; i++){
					move = cOffset * offsetStep;
					d = screenSpaceDistance(worldPos, worldPos + vec4(move, 0.));
					if(d > pixelSize) {
						correctedLineWidth = offsetStep;
						break;
					}
					offsetStep += offsetStep;
				}

				worldPos.xyz += move;

				// project the worldpos
				vec4 clip = projectionMatrix * worldPos;

				// shift the depth of the projected points so the line
				// segments overlap neatly
				vec3 clipPose = ( computedPosition.y < 0.5 ) ? ndcStart : ndcEnd;
				clip.z = clipPose.z * clip.w;

			#else

				vec2 offset = vec2( dir.y, - dir.x );
				// undo aspect ratio adjustment
				dir.x /= aspect;
				offset.x /= aspect;

				// sign flip
				if ( computedPosition.x < 0.0 ) offset *= - 1.0;

				// endcaps
				if ( computedPosition.y < 0.0 ) {

					offset += - dir;

				} else if ( computedPosition.y > 1.0 ) {

					offset += dir;

				}

				// adjust for linewidth
				offset *= linewidth;

				// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...
				offset /= resolution.y;

				// select end
				vec4 clip = ( computedPosition.y < 0.5 ) ? clipStart : clipEnd;

				// back to clip space
				offset *= clip.w;

				clip.xy += offset;

			#endif

			gl_Position = clip;

			vec4 mvPosition = ( computedPosition.y < 0.5 ) ? start : end; // this is an approximation

			#include <logdepthbuf_vertex>
			#include <clipping_planes_vertex>
			#include <fog_vertex>

		}
		`, this.fragProgram = `
		uniform vec3 diffuse;
		uniform float opacity;
		uniform float linewidth;
		// varying vec3 debugColor;

		#ifdef USE_DASH

			uniform float dashOffset;
			uniform float dashSize;
			uniform float gapSize;

		#endif

		varying float vLineDistance;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;
			varying float correctedLineWidth;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#include <common>
		#include <color_pars_fragment>
		#include <fog_pars_fragment>
		#include <logdepthbuf_pars_fragment>
		#include <clipping_planes_pars_fragment>

		vec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {

			float mua;
			float mub;

			vec3 p13 = p1 - p3;
			vec3 p43 = p4 - p3;

			vec3 p21 = p2 - p1;

			float d1343 = dot( p13, p43 );
			float d4321 = dot( p43, p21 );
			float d1321 = dot( p13, p21 );
			float d4343 = dot( p43, p43 );
			float d2121 = dot( p21, p21 );

			float denom = d2121 * d4343 - d4321 * d4321;

			float numer = d1343 * d4321 - d1321 * d4343;

			mua = numer / denom;
			mua = clamp( mua, 0.0, 1.0 );
			mub = ( d1343 + d4321 * ( mua ) ) / d4343;
			mub = clamp( mub, 0.0, 1.0 );

			return vec2( mua, mub );

		}

		void main() {

			#include <clipping_planes_fragment>

			#ifdef USE_DASH

				if ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps

				if ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX

			#endif

			float alpha = opacity;

			#ifdef WORLD_UNITS

				// Find the closest points on the view ray and the line segment
				vec3 rayEnd = normalize( worldPos.xyz ) * 1e5;
				vec3 lineDir = worldEnd - worldStart;
				vec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );

				vec3 p1 = worldStart + lineDir * params.x;
				vec3 p2 = rayEnd * params.y;
				vec3 delta = p1 - p2;
				float len = length( delta );
				float norm = len / correctedLineWidth;

				#ifndef USE_DASH

					#ifdef USE_ALPHA_TO_COVERAGE

						float dnorm = fwidth( norm );
						alpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );

					#else

						if ( norm > 0.5 ) {

							discard;

						}

					#endif

				#endif

			#else

				#ifdef USE_ALPHA_TO_COVERAGE

					// artifacts appear on some hardware if a derivative is taken within a conditional
					float a = vUv.x;
					float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
					float len2 = a * a + b * b;
					float dlen = fwidth( len2 );

					if ( abs( vUv.y ) > 1.0 ) {

						alpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );

					}

				#else

					if ( abs( vUv.y ) > 1.0 ) {

						float a = vUv.x;
						float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
						float len2 = a * a + b * b;

						if ( len2 > 1.0 ) discard;

					}

				#endif

			#endif

			vec4 diffuseColor = vec4( diffuse, alpha );

			#include <logdepthbuf_fragment>
			// #include <color_fragment> COMMENTED CHUNK
			#if defined( USE_COLOR_ALPHA )
				diffuseColor *= vColor;
			#elif defined( USE_COLOR )
				diffuseColor.rgb = vColor;
			#endif

			gl_FragColor = vec4( diffuseColor.rgb, alpha );

			#include <tonemapping_fragment>
			#include <encodings_fragment>
			#include <fog_fragment>
			#include <premultiplied_alpha_fragment>

		}
		`, this.uniforms = Jn.merge([Pn.line.uniforms, { uViewer_high: { value: this.userData.uViewer_high.value }, uViewer_low: { value: this.userData.uViewer_low.value }, pixelThreshold: { value: this.userData.pixelThreshold } }]), this.onBeforeCompile = function(n) {
      n.uniforms.uViewer_high = this.userData.uViewer_high, n.uniforms.uViewer_low = this.userData.uViewer_low, n.uniforms.pixelThreshold = this.userData.pixelThreshold, n.vertexShader = this.vertProgram, n.fragmentShader = this.fragProgram;
    };
    for (let n = 0; n < e.length; n++)
      this.defines[e[n]] = "";
    this.defines.USE_RTE = " ";
  }
  copy(t) {
    return super.copy(t), this.userData = {}, this.userData.uViewer_high = { value: new D() }, this.userData.uViewer_low = { value: new D() }, this.userData.pixelThreshold = { value: t.userData.pixelThreshold.value }, this;
  }
  onBeforeRender(t, e, n, r, s, a) {
    wr.matBuff.copy(n.matrixWorldInverse), wr.matBuff.elements[12] = 0, wr.matBuff.elements[13] = 0, wr.matBuff.elements[14] = 0, wr.matBuff.multiply(s.matrixWorld), s.modelViewMatrix.copy(wr.matBuff), wr.vecBuff0.set(n.matrixWorld.elements[12], n.matrixWorld.elements[13], n.matrixWorld.elements[14]), Nn.DoubleToHighLowVector(wr.vecBuff0, wr.vecBuff1, wr.vecBuff2), this.userData.uViewer_low.value.copy(wr.vecBuff1), this.userData.uViewer_high.value.copy(wr.vecBuff2), this.needsUpdate = !0;
  }
};
U(wr, "matBuff", new Vt()), U(wr, "vecBuff0", new D()), U(wr, "vecBuff1", new D()), U(wr, "vecBuff2", new D());
let Ss = wr;
const xr = class xr extends Ds {
  constructor(t, e = []) {
    super(t), this.flatShading = !1, this.userData.uViewer_high = { value: new D() }, this.userData.uViewer_low = { value: new D() }, this.userData.rteShadowMatrix = { value: new Vt() }, this.userData.uShadowViewer_high = { value: new D() }, this.userData.uShadowViewer_low = { value: new D() }, this.vertProgram = `
#define STANDARD
#ifdef USE_RTE
    // The high component is stored as the default 'position' attribute buffer
    attribute vec3 position_low;
    uniform vec3 uViewer_high;
    uniform vec3 uViewer_low;
    uniform mat4 rteShadowMatrix;
    uniform vec3 uShadowViewer_high;
    uniform vec3 uShadowViewer_low;
#endif

varying vec3 vViewPosition;

#ifdef USE_TRANSMISSION

    varying vec3 vWorldPosition;

#endif

#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

vec4 computeRelativePositionSeparate(in vec3 position_low, in vec3 position_high, in vec3 relativeTo_low, in vec3 relativeTo_high){
    /* 
    Vector calculation for the high and low differences works on everything 
    *BESIDES* Apple Silicon (or whatever they call it) GPUs

    It would seem that when this code gets compiled, vector types get a lower precision(?)
    which completely brakes the 2 float -> double reconstructio. Doing it separately for each 
    vector component using floats works fine.
    */
    vec3 highDifference;
    vec3 lowDifference;
    float t1 = position_low.x - relativeTo_low.x;
    float e = t1 - position_low.x;
    float t2 = ((-relativeTo_low.x - e) + (position_low.x - (t1 - e))) + position_high.x - relativeTo_high.x;
    highDifference.x = t1 + t2;
    lowDifference.x = t2 - (highDifference.x - t1);

    t1 = position_low.y - relativeTo_low.y;
    e = t1 - position_low.y;
    t2 = ((-relativeTo_low.y - e) + (position_low.y - (t1 - e))) + position_high.y - relativeTo_high.y;
    highDifference.y = t1 + t2;
    lowDifference.y = t2 - (highDifference.y - t1);

    t1 = position_low.z - relativeTo_low.z;
    e = t1 - position_low.z;
    t2 = ((-relativeTo_low.z - e) + (position_low.z - (t1 - e))) + position_high.z - relativeTo_high.z;
    highDifference.z = t1 + t2;
    lowDifference.z = t2 - (highDifference.z - t1);

    vec3 position = highDifference.xyz + lowDifference.xyz;
    return vec4(position, 1.);
}

vec4 computeRelativePosition(in vec3 position_low, in vec3 position_high, in vec3 relativeTo_low, in vec3 relativeTo_high){
    /* 
    Source https://github.com/virtualglobebook/OpenGlobe/blob/master/Source/Examples/Chapter05/Jitter/GPURelativeToEyeDSFUN90/Shaders/VS.glsl 
    Note here, we're storing the high part of the position encoding inside three's default 'position' attribute buffer so we avoid redundancy 
    */
    vec3 t1 = position_low.xyz - relativeTo_low;
    vec3 e = t1 - position_low.xyz;
    vec3 t2 = ((-relativeTo_low - e) + (position_low.xyz - (t1 - e))) + position_high.xyz - relativeTo_high;
    vec3 highDifference = t1 + t2;
    vec3 lowDifference = t2 - (highDifference - t1);
    
    vec3 position = highDifference.xyz + lowDifference.xyz;
    return vec4(position, 1.);
}

void main() {

    #include <uv_vertex>
    #include <uv2_vertex>
    #include <color_vertex>
    #include <morphcolor_vertex>
    #include <beginnormal_vertex>
    #include <morphnormal_vertex>
    #include <skinbase_vertex>
    #include <skinnormal_vertex>
    #include <defaultnormal_vertex>
    #include <normal_vertex>

    #include <begin_vertex>
    #include <morphtarget_vertex>
    #include <skinning_vertex>
    #include <displacementmap_vertex>
    //#include <project_vertex> // EDITED CHUNK
    #ifdef USE_RTE
        vec4 mvPosition = computeRelativePositionSeparate(position_low.xyz, position.xyz, uViewer_low, uViewer_high);
    #else
        vec4 mvPosition = vec4( transformed, 1.0 );
    #endif
    
    #ifdef USE_INSTANCING

        mvPosition = instanceMatrix * mvPosition;

    #endif
    mvPosition = modelViewMatrix * mvPosition;

    gl_Position = projectionMatrix * mvPosition;


    #include <logdepthbuf_vertex>
    #include <clipping_planes_vertex>

    vViewPosition = - mvPosition.xyz;

    #include <worldpos_vertex>
    // #include <shadowmap_vertex> COMMENTED CHUNK!!!
    #ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0
		// Offsetting the position used for querying occlusion along the world normal can be used to reduce shadow acne.
		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		vec4 shadowWorldPosition;
	#endif
	#if NUM_DIR_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
        #ifdef USE_RTE
            vec4 shadowPosition = computeRelativePositionSeparate(position_low.xyz, position.xyz, uShadowViewer_low, uShadowViewer_high);
            shadowWorldPosition = modelMatrix * shadowPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
            vDirectionalShadowCoord[ i ] = rteShadowMatrix * shadowWorldPosition;
        #else
            shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
            vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
        #endif
        
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );
		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	/*
	#if NUM_RECT_AREA_LIGHTS > 0
		// TODO (abelnation): update vAreaShadowCoord with area light info
	#endif
	*/
    #endif

    #include <fog_vertex>

#ifdef USE_TRANSMISSION

    vWorldPosition = worldPosition.xyz;

#endif
}
`, this.fragProgram = `
#define STANDARD

#ifdef PHYSICAL
    #define IOR
    #define SPECULAR
#endif

uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;

#ifdef IOR
    uniform float ior;
#endif

#ifdef SPECULAR
    uniform float specularIntensity;
    uniform vec3 specularColor;

    #ifdef USE_SPECULARINTENSITYMAP
        uniform sampler2D specularIntensityMap;
    #endif

    #ifdef USE_SPECULARCOLORMAP
        uniform sampler2D specularColorMap;
    #endif
#endif

#ifdef USE_CLEARCOAT
    uniform float clearcoat;
    uniform float clearcoatRoughness;
#endif

#ifdef USE_SHEEN
    uniform vec3 sheenColor;
    uniform float sheenRoughness;

    #ifdef USE_SHEENCOLORMAP
        uniform sampler2D sheenColorMap;
    #endif

    #ifdef USE_SHEENROUGHNESSMAP
        uniform sampler2D sheenRoughnessMap;
    #endif
#endif

varying vec3 vViewPosition;

#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <bsdfs>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

    #include <clipping_planes_fragment>

    vec4 diffuseColor = vec4( diffuse, opacity );
    ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
    vec3 totalEmissiveRadiance = emissive;

    #include <logdepthbuf_fragment>
    #include <map_fragment>
    #include <color_fragment>
    #include <alphamap_fragment>
    #include <alphatest_fragment>
    #include <roughnessmap_fragment>
    #include <metalnessmap_fragment>
    #include <normal_fragment_begin>
    #include <normal_fragment_maps>
    #include <clearcoat_normal_fragment_begin>
    #include <clearcoat_normal_fragment_maps>
    #include <emissivemap_fragment>

    // accumulation
    #include <lights_physical_fragment>
    #include <lights_fragment_begin>
    #include <lights_fragment_maps>
    #include <lights_fragment_end>

    // modulation
    #include <aomap_fragment>

    vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
    vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;

    #include <transmission_fragment>

    vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;

    #ifdef USE_SHEEN

        // Sheen energy compensation approximation calculation can be found at the end of
        // https://drive.google.com/file/d/1T0D1VSyR4AllqIJTQAraEIzjlb5h4FKH/view?usp=sharing
        float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );

        outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;

    #endif

    #ifdef USE_CLEARCOAT

        float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );

        vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );

        outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;

    #endif

    #include <output_fragment>
    #include <tonemapping_fragment>
    #include <encodings_fragment>
    #include <fog_fragment>
    #include <premultiplied_alpha_fragment>
    #include <dithering_fragment>

}
`, this.uniforms = Jn.merge([Pn.standard.uniforms, { uViewer_high: { value: this.userData.uViewer_high.value }, uViewer_low: { value: this.userData.uViewer_low.value }, rteShadowMatrix: { value: this.userData.rteShadowMatrix.value }, uShdowViewer_high: { value: this.userData.uShadowViewer_high.value }, uShadowViewer_low: { value: this.userData.uShadowViewer_low.value } }]), this.onBeforeCompile = function(n) {
      n.uniforms.uViewer_high = this.userData.uViewer_high, n.uniforms.uViewer_low = this.userData.uViewer_low, n.uniforms.rteShadowMatrix = this.userData.rteShadowMatrix, n.uniforms.uShadowViewer_high = this.userData.uShadowViewer_high, n.uniforms.uShadowViewer_low = this.userData.uShadowViewer_low, n.vertexShader = this.vertProgram, n.fragmentShader = this.fragProgram;
    }, e && (this.defines = {});
    for (let n = 0; n < e.length; n++)
      this.defines[e[n]] = " ";
  }
  copy(t) {
    return super.copy(t), this.userData = {}, this.userData.uViewer_high = { value: new D() }, this.userData.uViewer_low = { value: new D() }, this.userData.rteShadowMatrix = { value: new Vt() }, this.userData.uShadowViewer_high = { value: new D() }, this.userData.uShadowViewer_low = { value: new D() }, this.defines.USE_RTE = " ", this;
  }
  onBeforeRender(t, e, n, r, s, a) {
    xr.matBuff.copy(n.matrixWorldInverse), xr.matBuff.elements[12] = 0, xr.matBuff.elements[13] = 0, xr.matBuff.elements[14] = 0, xr.matBuff.multiply(s.matrixWorld), s.modelViewMatrix.copy(xr.matBuff), xr.vecBuff0.set(n.matrixWorld.elements[12], n.matrixWorld.elements[13], n.matrixWorld.elements[14]), Nn.DoubleToHighLowVector(xr.vecBuff0, xr.vecBuff1, xr.vecBuff2), this.userData.uViewer_low.value.copy(xr.vecBuff1), this.userData.uViewer_high.value.copy(xr.vecBuff2), this.needsUpdate = !0;
  }
};
U(xr, "matBuff", new Vt()), U(xr, "vecBuff0", new D()), U(xr, "vecBuff1", new D()), U(xr, "vecBuff2", new D());
let rs = xr;
const br = class br extends i0 {
  constructor(t, e = []) {
    super(t), this.userData.uViewer_high = { value: new D() }, this.userData.uViewer_low = { value: new D() }, this.vertProgram = `
uniform float size;
uniform float scale;

#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

#ifdef USE_RTE
    // The high component is stored as the default 'position' attribute buffer
    attribute vec3 position_low;
    uniform vec3 uViewer_high;
    uniform vec3 uViewer_low;
#endif

vec4 computeRelativePositionSeparate(in vec3 position_low, in vec3 position_high, in vec3 relativeTo_low, in vec3 relativeTo_high){
    /* 
    Vector calculation for the high and low differences works on everything 
    *BESIDES* Apple Silicon (or whatever they call it) GPUs

    It would seem that when this code gets compiled, vector types get a lower precision(?)
    which completely brakes the 2 float -> double reconstructio. Doing it separately for each 
    vector component using floats works fine.
    */
    vec3 highDifference;
    vec3 lowDifference;
    float t1 = position_low.x - relativeTo_low.x;
    float e = t1 - position_low.x;
    float t2 = ((-relativeTo_low.x - e) + (position_low.x - (t1 - e))) + position_high.x - relativeTo_high.x;
    highDifference.x = t1 + t2;
    lowDifference.x = t2 - (highDifference.x - t1);

    t1 = position_low.y - relativeTo_low.y;
    e = t1 - position_low.y;
    t2 = ((-relativeTo_low.y - e) + (position_low.y - (t1 - e))) + position_high.y - relativeTo_high.y;
    highDifference.y = t1 + t2;
    lowDifference.y = t2 - (highDifference.y - t1);

    t1 = position_low.z - relativeTo_low.z;
    e = t1 - position_low.z;
    t2 = ((-relativeTo_low.z - e) + (position_low.z - (t1 - e))) + position_high.z - relativeTo_high.z;
    highDifference.z = t1 + t2;
    lowDifference.z = t2 - (highDifference.z - t1);

    vec3 position = highDifference.xyz + lowDifference.xyz;
    return vec4(position, 1.);
}

vec4 computeRelativePosition(in vec3 position_low, in vec3 position_high, in vec3 relativeTo_low, in vec3 relativeTo_high){
    /* 
    Source https://github.com/virtualglobebook/OpenGlobe/blob/master/Source/Examples/Chapter05/Jitter/GPURelativeToEyeDSFUN90/Shaders/VS.glsl 
    Note here, we're storing the high part of the position encoding inside three's default 'position' attribute buffer so we avoid redundancy 
    */
    vec3 t1 = position_low.xyz - relativeTo_low;
    vec3 e = t1 - position_low.xyz;
    vec3 t2 = ((-relativeTo_low - e) + (position_low.xyz - (t1 - e))) + position_high.xyz - relativeTo_high;
    vec3 highDifference = t1 + t2;
    vec3 lowDifference = t2 - (highDifference - t1);
    
    vec3 position = highDifference.xyz + lowDifference.xyz;
    return vec4(position, 1.);
}

void main() {

	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	// #include <project_vertex> COMMENTED CHUNK
	#ifdef USE_RTE
        vec4 mvPosition = computeRelativePositionSeparate(position_low.xyz, position.xyz, uViewer_low, uViewer_high);
    #else
        vec4 mvPosition = vec4( transformed, 1.0 );
    #endif
    
    #ifdef USE_INSTANCING

        mvPosition = instanceMatrix * mvPosition;

    #endif
    mvPosition = modelViewMatrix * mvPosition;

    gl_Position = projectionMatrix * mvPosition;

	gl_PointSize = size;

	#ifdef USE_SIZEATTENUATION

		bool isPerspective = isPerspectiveMatrix( projectionMatrix );

		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );

	#endif

	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>

}
`, this.fragProgram = `
uniform vec3 diffuse;
uniform float opacity;

#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>

	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );

	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>

	outgoingLight = diffuseColor.rgb;

	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>

}
`, this.uniforms = Jn.merge([Pn.standard.uniforms, { uViewer_high: { value: this.userData.uViewer_high.value }, uViewer_low: { value: this.userData.uViewer_low.value } }]), this.onBeforeCompile = function(n) {
      n.uniforms.uViewer_high = this.userData.uViewer_high, n.uniforms.uViewer_low = this.userData.uViewer_low, n.vertexShader = this.vertProgram, n.fragmentShader = this.fragProgram;
    }, e && (this.defines = {});
    for (let n = 0; n < e.length; n++)
      this.defines[e[n]] = " ";
  }
  copy(t) {
    return super.copy(t), this.userData = {}, this.userData.uViewer_high = { value: new D() }, this.userData.uViewer_low = { value: new D() }, this.defines.USE_RTE = " ", this;
  }
  onBeforeRender(t, e, n, r, s, a) {
    br.matBuff.copy(n.matrixWorldInverse), br.matBuff.elements[12] = 0, br.matBuff.elements[13] = 0, br.matBuff.elements[14] = 0, br.matBuff.multiply(s.matrixWorld), s.modelViewMatrix.copy(br.matBuff), br.vecBuff0.set(n.matrixWorld.elements[12], n.matrixWorld.elements[13], n.matrixWorld.elements[14]), Nn.DoubleToHighLowVector(br.vecBuff0, br.vecBuff1, br.vecBuff2), this.userData.uViewer_low.value.copy(br.vecBuff1), this.userData.uViewer_high.value.copy(br.vecBuff2), this.needsUpdate = !0;
  }
};
U(br, "matBuff", new Vt()), U(br, "vecBuff0", new D()), U(br, "vecBuff1", new D()), U(br, "vecBuff2", new D());
let Bi = br;
var FB = { exports: {} }, Hit = [{ value: "#B0171F", name: "indian red" }, { value: "#DC143C", css: !0, name: "crimson" }, { value: "#FFB6C1", css: !0, name: "lightpink" }, { value: "#FFAEB9", name: "lightpink 1" }, { value: "#EEA2AD", name: "lightpink 2" }, { value: "#CD8C95", name: "lightpink 3" }, { value: "#8B5F65", name: "lightpink 4" }, { value: "#FFC0CB", css: !0, name: "pink" }, { value: "#FFB5C5", name: "pink 1" }, { value: "#EEA9B8", name: "pink 2" }, { value: "#CD919E", name: "pink 3" }, { value: "#8B636C", name: "pink 4" }, { value: "#DB7093", css: !0, name: "palevioletred" }, { value: "#FF82AB", name: "palevioletred 1" }, { value: "#EE799F", name: "palevioletred 2" }, { value: "#CD6889", name: "palevioletred 3" }, { value: "#8B475D", name: "palevioletred 4" }, { value: "#FFF0F5", name: "lavenderblush 1" }, { value: "#FFF0F5", css: !0, name: "lavenderblush" }, { value: "#EEE0E5", name: "lavenderblush 2" }, { value: "#CDC1C5", name: "lavenderblush 3" }, { value: "#8B8386", name: "lavenderblush 4" }, { value: "#FF3E96", name: "violetred 1" }, { value: "#EE3A8C", name: "violetred 2" }, { value: "#CD3278", name: "violetred 3" }, { value: "#8B2252", name: "violetred 4" }, { value: "#FF69B4", css: !0, name: "hotpink" }, { value: "#FF6EB4", name: "hotpink 1" }, { value: "#EE6AA7", name: "hotpink 2" }, { value: "#CD6090", name: "hotpink 3" }, { value: "#8B3A62", name: "hotpink 4" }, { value: "#872657", name: "raspberry" }, { value: "#FF1493", name: "deeppink 1" }, { value: "#FF1493", css: !0, name: "deeppink" }, { value: "#EE1289", name: "deeppink 2" }, { value: "#CD1076", name: "deeppink 3" }, { value: "#8B0A50", name: "deeppink 4" }, { value: "#FF34B3", name: "maroon 1" }, { value: "#EE30A7", name: "maroon 2" }, { value: "#CD2990", name: "maroon 3" }, { value: "#8B1C62", name: "maroon 4" }, { value: "#C71585", css: !0, name: "mediumvioletred" }, { value: "#D02090", name: "violetred" }, { value: "#DA70D6", css: !0, name: "orchid" }, { value: "#FF83FA", name: "orchid 1" }, { value: "#EE7AE9", name: "orchid 2" }, { value: "#CD69C9", name: "orchid 3" }, { value: "#8B4789", name: "orchid 4" }, { value: "#D8BFD8", css: !0, name: "thistle" }, { value: "#FFE1FF", name: "thistle 1" }, { value: "#EED2EE", name: "thistle 2" }, { value: "#CDB5CD", name: "thistle 3" }, { value: "#8B7B8B", name: "thistle 4" }, { value: "#FFBBFF", name: "plum 1" }, { value: "#EEAEEE", name: "plum 2" }, { value: "#CD96CD", name: "plum 3" }, { value: "#8B668B", name: "plum 4" }, { value: "#DDA0DD", css: !0, name: "plum" }, { value: "#EE82EE", css: !0, name: "violet" }, { value: "#FF00FF", vga: !0, name: "magenta" }, { value: "#FF00FF", vga: !0, css: !0, name: "fuchsia" }, { value: "#EE00EE", name: "magenta 2" }, { value: "#CD00CD", name: "magenta 3" }, { value: "#8B008B", name: "magenta 4" }, { value: "#8B008B", css: !0, name: "darkmagenta" }, { value: "#800080", vga: !0, css: !0, name: "purple" }, { value: "#BA55D3", css: !0, name: "mediumorchid" }, { value: "#E066FF", name: "mediumorchid 1" }, { value: "#D15FEE", name: "mediumorchid 2" }, { value: "#B452CD", name: "mediumorchid 3" }, { value: "#7A378B", name: "mediumorchid 4" }, { value: "#9400D3", css: !0, name: "darkviolet" }, { value: "#9932CC", css: !0, name: "darkorchid" }, { value: "#BF3EFF", name: "darkorchid 1" }, { value: "#B23AEE", name: "darkorchid 2" }, { value: "#9A32CD", name: "darkorchid 3" }, { value: "#68228B", name: "darkorchid 4" }, { value: "#4B0082", css: !0, name: "indigo" }, { value: "#8A2BE2", css: !0, name: "blueviolet" }, { value: "#9B30FF", name: "purple 1" }, { value: "#912CEE", name: "purple 2" }, { value: "#7D26CD", name: "purple 3" }, { value: "#551A8B", name: "purple 4" }, { value: "#9370DB", css: !0, name: "mediumpurple" }, { value: "#AB82FF", name: "mediumpurple 1" }, { value: "#9F79EE", name: "mediumpurple 2" }, { value: "#8968CD", name: "mediumpurple 3" }, { value: "#5D478B", name: "mediumpurple 4" }, { value: "#483D8B", css: !0, name: "darkslateblue" }, { value: "#8470FF", name: "lightslateblue" }, { value: "#7B68EE", css: !0, name: "mediumslateblue" }, { value: "#6A5ACD", css: !0, name: "slateblue" }, { value: "#836FFF", name: "slateblue 1" }, { value: "#7A67EE", name: "slateblue 2" }, { value: "#6959CD", name: "slateblue 3" }, { value: "#473C8B", name: "slateblue 4" }, { value: "#F8F8FF", css: !0, name: "ghostwhite" }, { value: "#E6E6FA", css: !0, name: "lavender" }, { value: "#0000FF", vga: !0, css: !0, name: "blue" }, { value: "#0000EE", name: "blue 2" }, { value: "#0000CD", name: "blue 3" }, { value: "#0000CD", css: !0, name: "mediumblue" }, { value: "#00008B", name: "blue 4" }, { value: "#00008B", css: !0, name: "darkblue" }, { value: "#000080", vga: !0, css: !0, name: "navy" }, { value: "#191970", css: !0, name: "midnightblue" }, { value: "#3D59AB", name: "cobalt" }, { value: "#4169E1", css: !0, name: "royalblue" }, { value: "#4876FF", name: "royalblue 1" }, { value: "#436EEE", name: "royalblue 2" }, { value: "#3A5FCD", name: "royalblue 3" }, { value: "#27408B", name: "royalblue 4" }, { value: "#6495ED", css: !0, name: "cornflowerblue" }, { value: "#B0C4DE", css: !0, name: "lightsteelblue" }, { value: "#CAE1FF", name: "lightsteelblue 1" }, { value: "#BCD2EE", name: "lightsteelblue 2" }, { value: "#A2B5CD", name: "lightsteelblue 3" }, { value: "#6E7B8B", name: "lightsteelblue 4" }, { value: "#778899", css: !0, name: "lightslategray" }, { value: "#708090", css: !0, name: "slategray" }, { value: "#C6E2FF", name: "slategray 1" }, { value: "#B9D3EE", name: "slategray 2" }, { value: "#9FB6CD", name: "slategray 3" }, { value: "#6C7B8B", name: "slategray 4" }, { value: "#1E90FF", name: "dodgerblue 1" }, { value: "#1E90FF", css: !0, name: "dodgerblue" }, { value: "#1C86EE", name: "dodgerblue 2" }, { value: "#1874CD", name: "dodgerblue 3" }, { value: "#104E8B", name: "dodgerblue 4" }, { value: "#F0F8FF", css: !0, name: "aliceblue" }, { value: "#4682B4", css: !0, name: "steelblue" }, { value: "#63B8FF", name: "steelblue 1" }, { value: "#5CACEE", name: "steelblue 2" }, { value: "#4F94CD", name: "steelblue 3" }, { value: "#36648B", name: "steelblue 4" }, { value: "#87CEFA", css: !0, name: "lightskyblue" }, { value: "#B0E2FF", name: "lightskyblue 1" }, { value: "#A4D3EE", name: "lightskyblue 2" }, { value: "#8DB6CD", name: "lightskyblue 3" }, { value: "#607B8B", name: "lightskyblue 4" }, { value: "#87CEFF", name: "skyblue 1" }, { value: "#7EC0EE", name: "skyblue 2" }, { value: "#6CA6CD", name: "skyblue 3" }, { value: "#4A708B", name: "skyblue 4" }, { value: "#87CEEB", css: !0, name: "skyblue" }, { value: "#00BFFF", name: "deepskyblue 1" }, { value: "#00BFFF", css: !0, name: "deepskyblue" }, { value: "#00B2EE", name: "deepskyblue 2" }, { value: "#009ACD", name: "deepskyblue 3" }, { value: "#00688B", name: "deepskyblue 4" }, { value: "#33A1C9", name: "peacock" }, { value: "#ADD8E6", css: !0, name: "lightblue" }, { value: "#BFEFFF", name: "lightblue 1" }, { value: "#B2DFEE", name: "lightblue 2" }, { value: "#9AC0CD", name: "lightblue 3" }, { value: "#68838B", name: "lightblue 4" }, { value: "#B0E0E6", css: !0, name: "powderblue" }, { value: "#98F5FF", name: "cadetblue 1" }, { value: "#8EE5EE", name: "cadetblue 2" }, { value: "#7AC5CD", name: "cadetblue 3" }, { value: "#53868B", name: "cadetblue 4" }, { value: "#00F5FF", name: "turquoise 1" }, { value: "#00E5EE", name: "turquoise 2" }, { value: "#00C5CD", name: "turquoise 3" }, { value: "#00868B", name: "turquoise 4" }, { value: "#5F9EA0", css: !0, name: "cadetblue" }, { value: "#00CED1", css: !0, name: "darkturquoise" }, { value: "#F0FFFF", name: "azure 1" }, { value: "#F0FFFF", css: !0, name: "azure" }, { value: "#E0EEEE", name: "azure 2" }, { value: "#C1CDCD", name: "azure 3" }, { value: "#838B8B", name: "azure 4" }, { value: "#E0FFFF", name: "lightcyan 1" }, { value: "#E0FFFF", css: !0, name: "lightcyan" }, { value: "#D1EEEE", name: "lightcyan 2" }, { value: "#B4CDCD", name: "lightcyan 3" }, { value: "#7A8B8B", name: "lightcyan 4" }, { value: "#BBFFFF", name: "paleturquoise 1" }, { value: "#AEEEEE", name: "paleturquoise 2" }, { value: "#AEEEEE", css: !0, name: "paleturquoise" }, { value: "#96CDCD", name: "paleturquoise 3" }, { value: "#668B8B", name: "paleturquoise 4" }, { value: "#2F4F4F", css: !0, name: "darkslategray" }, { value: "#97FFFF", name: "darkslategray 1" }, { value: "#8DEEEE", name: "darkslategray 2" }, { value: "#79CDCD", name: "darkslategray 3" }, { value: "#528B8B", name: "darkslategray 4" }, { value: "#00FFFF", name: "cyan" }, { value: "#00FFFF", css: !0, name: "aqua" }, { value: "#00EEEE", name: "cyan 2" }, { value: "#00CDCD", name: "cyan 3" }, { value: "#008B8B", name: "cyan 4" }, { value: "#008B8B", css: !0, name: "darkcyan" }, { value: "#008080", vga: !0, css: !0, name: "teal" }, { value: "#48D1CC", css: !0, name: "mediumturquoise" }, { value: "#20B2AA", css: !0, name: "lightseagreen" }, { value: "#03A89E", name: "manganeseblue" }, { value: "#40E0D0", css: !0, name: "turquoise" }, { value: "#808A87", name: "coldgrey" }, { value: "#00C78C", name: "turquoiseblue" }, { value: "#7FFFD4", name: "aquamarine 1" }, { value: "#7FFFD4", css: !0, name: "aquamarine" }, { value: "#76EEC6", name: "aquamarine 2" }, { value: "#66CDAA", name: "aquamarine 3" }, { value: "#66CDAA", css: !0, name: "mediumaquamarine" }, { value: "#458B74", name: "aquamarine 4" }, { value: "#00FA9A", css: !0, name: "mediumspringgreen" }, { value: "#F5FFFA", css: !0, name: "mintcream" }, { value: "#00FF7F", css: !0, name: "springgreen" }, { value: "#00EE76", name: "springgreen 1" }, { value: "#00CD66", name: "springgreen 2" }, { value: "#008B45", name: "springgreen 3" }, { value: "#3CB371", css: !0, name: "mediumseagreen" }, { value: "#54FF9F", name: "seagreen 1" }, { value: "#4EEE94", name: "seagreen 2" }, { value: "#43CD80", name: "seagreen 3" }, { value: "#2E8B57", name: "seagreen 4" }, { value: "#2E8B57", css: !0, name: "seagreen" }, { value: "#00C957", name: "emeraldgreen" }, { value: "#BDFCC9", name: "mint" }, { value: "#3D9140", name: "cobaltgreen" }, { value: "#F0FFF0", name: "honeydew 1" }, { value: "#F0FFF0", css: !0, name: "honeydew" }, { value: "#E0EEE0", name: "honeydew 2" }, { value: "#C1CDC1", name: "honeydew 3" }, { value: "#838B83", name: "honeydew 4" }, { value: "#8FBC8F", css: !0, name: "darkseagreen" }, { value: "#C1FFC1", name: "darkseagreen 1" }, { value: "#B4EEB4", name: "darkseagreen 2" }, { value: "#9BCD9B", name: "darkseagreen 3" }, { value: "#698B69", name: "darkseagreen 4" }, { value: "#98FB98", css: !0, name: "palegreen" }, { value: "#9AFF9A", name: "palegreen 1" }, { value: "#90EE90", name: "palegreen 2" }, { value: "#90EE90", css: !0, name: "lightgreen" }, { value: "#7CCD7C", name: "palegreen 3" }, { value: "#548B54", name: "palegreen 4" }, { value: "#32CD32", css: !0, name: "limegreen" }, { value: "#228B22", css: !0, name: "forestgreen" }, { value: "#00FF00", vga: !0, name: "green 1" }, { value: "#00FF00", vga: !0, css: !0, name: "lime" }, { value: "#00EE00", name: "green 2" }, { value: "#00CD00", name: "green 3" }, { value: "#008B00", name: "green 4" }, { value: "#008000", vga: !0, css: !0, name: "green" }, { value: "#006400", css: !0, name: "darkgreen" }, { value: "#308014", name: "sapgreen" }, { value: "#7CFC00", css: !0, name: "lawngreen" }, { value: "#7FFF00", name: "chartreuse 1" }, { value: "#7FFF00", css: !0, name: "chartreuse" }, { value: "#76EE00", name: "chartreuse 2" }, { value: "#66CD00", name: "chartreuse 3" }, { value: "#458B00", name: "chartreuse 4" }, { value: "#ADFF2F", css: !0, name: "greenyellow" }, { value: "#CAFF70", name: "darkolivegreen 1" }, { value: "#BCEE68", name: "darkolivegreen 2" }, { value: "#A2CD5A", name: "darkolivegreen 3" }, { value: "#6E8B3D", name: "darkolivegreen 4" }, { value: "#556B2F", css: !0, name: "darkolivegreen" }, { value: "#6B8E23", css: !0, name: "olivedrab" }, { value: "#C0FF3E", name: "olivedrab 1" }, { value: "#B3EE3A", name: "olivedrab 2" }, { value: "#9ACD32", name: "olivedrab 3" }, { value: "#9ACD32", css: !0, name: "yellowgreen" }, { value: "#698B22", name: "olivedrab 4" }, { value: "#FFFFF0", name: "ivory 1" }, { value: "#FFFFF0", css: !0, name: "ivory" }, { value: "#EEEEE0", name: "ivory 2" }, { value: "#CDCDC1", name: "ivory 3" }, { value: "#8B8B83", name: "ivory 4" }, { value: "#F5F5DC", css: !0, name: "beige" }, { value: "#FFFFE0", name: "lightyellow 1" }, { value: "#FFFFE0", css: !0, name: "lightyellow" }, { value: "#EEEED1", name: "lightyellow 2" }, { value: "#CDCDB4", name: "lightyellow 3" }, { value: "#8B8B7A", name: "lightyellow 4" }, { value: "#FAFAD2", css: !0, name: "lightgoldenrodyellow" }, { value: "#FFFF00", vga: !0, name: "yellow 1" }, { value: "#FFFF00", vga: !0, css: !0, name: "yellow" }, { value: "#EEEE00", name: "yellow 2" }, { value: "#CDCD00", name: "yellow 3" }, { value: "#8B8B00", name: "yellow 4" }, { value: "#808069", name: "warmgrey" }, { value: "#808000", vga: !0, css: !0, name: "olive" }, { value: "#BDB76B", css: !0, name: "darkkhaki" }, { value: "#FFF68F", name: "khaki 1" }, { value: "#EEE685", name: "khaki 2" }, { value: "#CDC673", name: "khaki 3" }, { value: "#8B864E", name: "khaki 4" }, { value: "#F0E68C", css: !0, name: "khaki" }, { value: "#EEE8AA", css: !0, name: "palegoldenrod" }, { value: "#FFFACD", name: "lemonchiffon 1" }, { value: "#FFFACD", css: !0, name: "lemonchiffon" }, { value: "#EEE9BF", name: "lemonchiffon 2" }, { value: "#CDC9A5", name: "lemonchiffon 3" }, { value: "#8B8970", name: "lemonchiffon 4" }, { value: "#FFEC8B", name: "lightgoldenrod 1" }, { value: "#EEDC82", name: "lightgoldenrod 2" }, { value: "#CDBE70", name: "lightgoldenrod 3" }, { value: "#8B814C", name: "lightgoldenrod 4" }, { value: "#E3CF57", name: "banana" }, { value: "#FFD700", name: "gold 1" }, { value: "#FFD700", css: !0, name: "gold" }, { value: "#EEC900", name: "gold 2" }, { value: "#CDAD00", name: "gold 3" }, { value: "#8B7500", name: "gold 4" }, { value: "#FFF8DC", name: "cornsilk 1" }, { value: "#FFF8DC", css: !0, name: "cornsilk" }, { value: "#EEE8CD", name: "cornsilk 2" }, { value: "#CDC8B1", name: "cornsilk 3" }, { value: "#8B8878", name: "cornsilk 4" }, { value: "#DAA520", css: !0, name: "goldenrod" }, { value: "#FFC125", name: "goldenrod 1" }, { value: "#EEB422", name: "goldenrod 2" }, { value: "#CD9B1D", name: "goldenrod 3" }, { value: "#8B6914", name: "goldenrod 4" }, { value: "#B8860B", css: !0, name: "darkgoldenrod" }, { value: "#FFB90F", name: "darkgoldenrod 1" }, { value: "#EEAD0E", name: "darkgoldenrod 2" }, { value: "#CD950C", name: "darkgoldenrod 3" }, { value: "#8B6508", name: "darkgoldenrod 4" }, { value: "#FFA500", name: "orange 1" }, { value: "#FF8000", css: !0, name: "orange" }, { value: "#EE9A00", name: "orange 2" }, { value: "#CD8500", name: "orange 3" }, { value: "#8B5A00", name: "orange 4" }, { value: "#FFFAF0", css: !0, name: "floralwhite" }, { value: "#FDF5E6", css: !0, name: "oldlace" }, { value: "#F5DEB3", css: !0, name: "wheat" }, { value: "#FFE7BA", name: "wheat 1" }, { value: "#EED8AE", name: "wheat 2" }, { value: "#CDBA96", name: "wheat 3" }, { value: "#8B7E66", name: "wheat 4" }, { value: "#FFE4B5", css: !0, name: "moccasin" }, { value: "#FFEFD5", css: !0, name: "papayawhip" }, { value: "#FFEBCD", css: !0, name: "blanchedalmond" }, { value: "#FFDEAD", name: "navajowhite 1" }, { value: "#FFDEAD", css: !0, name: "navajowhite" }, { value: "#EECFA1", name: "navajowhite 2" }, { value: "#CDB38B", name: "navajowhite 3" }, { value: "#8B795E", name: "navajowhite 4" }, { value: "#FCE6C9", name: "eggshell" }, { value: "#D2B48C", css: !0, name: "tan" }, { value: "#9C661F", name: "brick" }, { value: "#FF9912", name: "cadmiumyellow" }, { value: "#FAEBD7", css: !0, name: "antiquewhite" }, { value: "#FFEFDB", name: "antiquewhite 1" }, { value: "#EEDFCC", name: "antiquewhite 2" }, { value: "#CDC0B0", name: "antiquewhite 3" }, { value: "#8B8378", name: "antiquewhite 4" }, { value: "#DEB887", css: !0, name: "burlywood" }, { value: "#FFD39B", name: "burlywood 1" }, { value: "#EEC591", name: "burlywood 2" }, { value: "#CDAA7D", name: "burlywood 3" }, { value: "#8B7355", name: "burlywood 4" }, { value: "#FFE4C4", name: "bisque 1" }, { value: "#FFE4C4", css: !0, name: "bisque" }, { value: "#EED5B7", name: "bisque 2" }, { value: "#CDB79E", name: "bisque 3" }, { value: "#8B7D6B", name: "bisque 4" }, { value: "#E3A869", name: "melon" }, { value: "#ED9121", name: "carrot" }, { value: "#FF8C00", css: !0, name: "darkorange" }, { value: "#FF7F00", name: "darkorange 1" }, { value: "#EE7600", name: "darkorange 2" }, { value: "#CD6600", name: "darkorange 3" }, { value: "#8B4500", name: "darkorange 4" }, { value: "#FFA54F", name: "tan 1" }, { value: "#EE9A49", name: "tan 2" }, { value: "#CD853F", name: "tan 3" }, { value: "#CD853F", css: !0, name: "peru" }, { value: "#8B5A2B", name: "tan 4" }, { value: "#FAF0E6", css: !0, name: "linen" }, { value: "#FFDAB9", name: "peachpuff 1" }, { value: "#FFDAB9", css: !0, name: "peachpuff" }, { value: "#EECBAD", name: "peachpuff 2" }, { value: "#CDAF95", name: "peachpuff 3" }, { value: "#8B7765", name: "peachpuff 4" }, { value: "#FFF5EE", name: "seashell 1" }, { value: "#FFF5EE", css: !0, name: "seashell" }, { value: "#EEE5DE", name: "seashell 2" }, { value: "#CDC5BF", name: "seashell 3" }, { value: "#8B8682", name: "seashell 4" }, { value: "#F4A460", css: !0, name: "sandybrown" }, { value: "#C76114", name: "rawsienna" }, { value: "#D2691E", css: !0, name: "chocolate" }, { value: "#FF7F24", name: "chocolate 1" }, { value: "#EE7621", name: "chocolate 2" }, { value: "#CD661D", name: "chocolate 3" }, { value: "#8B4513", name: "chocolate 4" }, { value: "#8B4513", css: !0, name: "saddlebrown" }, { value: "#292421", name: "ivoryblack" }, { value: "#FF7D40", name: "flesh" }, { value: "#FF6103", name: "cadmiumorange" }, { value: "#8A360F", name: "burntsienna" }, { value: "#A0522D", css: !0, name: "sienna" }, { value: "#FF8247", name: "sienna 1" }, { value: "#EE7942", name: "sienna 2" }, { value: "#CD6839", name: "sienna 3" }, { value: "#8B4726", name: "sienna 4" }, { value: "#FFA07A", name: "lightsalmon 1" }, { value: "#FFA07A", css: !0, name: "lightsalmon" }, { value: "#EE9572", name: "lightsalmon 2" }, { value: "#CD8162", name: "lightsalmon 3" }, { value: "#8B5742", name: "lightsalmon 4" }, { value: "#FF7F50", css: !0, name: "coral" }, { value: "#FF4500", name: "orangered 1" }, { value: "#FF4500", css: !0, name: "orangered" }, { value: "#EE4000", name: "orangered 2" }, { value: "#CD3700", name: "orangered 3" }, { value: "#8B2500", name: "orangered 4" }, { value: "#5E2612", name: "sepia" }, { value: "#E9967A", css: !0, name: "darksalmon" }, { value: "#FF8C69", name: "salmon 1" }, { value: "#EE8262", name: "salmon 2" }, { value: "#CD7054", name: "salmon 3" }, { value: "#8B4C39", name: "salmon 4" }, { value: "#FF7256", name: "coral 1" }, { value: "#EE6A50", name: "coral 2" }, { value: "#CD5B45", name: "coral 3" }, { value: "#8B3E2F", name: "coral 4" }, { value: "#8A3324", name: "burntumber" }, { value: "#FF6347", name: "tomato 1" }, { value: "#FF6347", css: !0, name: "tomato" }, { value: "#EE5C42", name: "tomato 2" }, { value: "#CD4F39", name: "tomato 3" }, { value: "#8B3626", name: "tomato 4" }, { value: "#FA8072", css: !0, name: "salmon" }, { value: "#FFE4E1", name: "mistyrose 1" }, { value: "#FFE4E1", css: !0, name: "mistyrose" }, { value: "#EED5D2", name: "mistyrose 2" }, { value: "#CDB7B5", name: "mistyrose 3" }, { value: "#8B7D7B", name: "mistyrose 4" }, { value: "#FFFAFA", name: "snow 1" }, { value: "#FFFAFA", css: !0, name: "snow" }, { value: "#EEE9E9", name: "snow 2" }, { value: "#CDC9C9", name: "snow 3" }, { value: "#8B8989", name: "snow 4" }, { value: "#BC8F8F", css: !0, name: "rosybrown" }, { value: "#FFC1C1", name: "rosybrown 1" }, { value: "#EEB4B4", name: "rosybrown 2" }, { value: "#CD9B9B", name: "rosybrown 3" }, { value: "#8B6969", name: "rosybrown 4" }, { value: "#F08080", css: !0, name: "lightcoral" }, { value: "#CD5C5C", css: !0, name: "indianred" }, { value: "#FF6A6A", name: "indianred 1" }, { value: "#EE6363", name: "indianred 2" }, { value: "#8B3A3A", name: "indianred 4" }, { value: "#CD5555", name: "indianred 3" }, { value: "#A52A2A", css: !0, name: "brown" }, { value: "#FF4040", name: "brown 1" }, { value: "#EE3B3B", name: "brown 2" }, { value: "#CD3333", name: "brown 3" }, { value: "#8B2323", name: "brown 4" }, { value: "#B22222", css: !0, name: "firebrick" }, { value: "#FF3030", name: "firebrick 1" }, { value: "#EE2C2C", name: "firebrick 2" }, { value: "#CD2626", name: "firebrick 3" }, { value: "#8B1A1A", name: "firebrick 4" }, { value: "#FF0000", vga: !0, name: "red 1" }, { value: "#FF0000", vga: !0, css: !0, name: "red" }, { value: "#EE0000", name: "red 2" }, { value: "#CD0000", name: "red 3" }, { value: "#8B0000", name: "red 4" }, { value: "#8B0000", css: !0, name: "darkred" }, { value: "#800000", vga: !0, css: !0, name: "maroon" }, { value: "#8E388E", name: "sgi beet" }, { value: "#7171C6", name: "sgi slateblue" }, { value: "#7D9EC0", name: "sgi lightblue" }, { value: "#388E8E", name: "sgi teal" }, { value: "#71C671", name: "sgi chartreuse" }, { value: "#8E8E38", name: "sgi olivedrab" }, { value: "#C5C1AA", name: "sgi brightgray" }, { value: "#C67171", name: "sgi salmon" }, { value: "#555555", name: "sgi darkgray" }, { value: "#1E1E1E", name: "sgi gray 12" }, { value: "#282828", name: "sgi gray 16" }, { value: "#515151", name: "sgi gray 32" }, { value: "#5B5B5B", name: "sgi gray 36" }, { value: "#848484", name: "sgi gray 52" }, { value: "#8E8E8E", name: "sgi gray 56" }, { value: "#AAAAAA", name: "sgi lightgray" }, { value: "#B7B7B7", name: "sgi gray 72" }, { value: "#C1C1C1", name: "sgi gray 76" }, { value: "#EAEAEA", name: "sgi gray 92" }, { value: "#F4F4F4", name: "sgi gray 96" }, { value: "#FFFFFF", vga: !0, css: !0, name: "white" }, { value: "#F5F5F5", name: "white smoke" }, { value: "#F5F5F5", name: "gray 96" }, { value: "#DCDCDC", css: !0, name: "gainsboro" }, { value: "#D3D3D3", css: !0, name: "lightgrey" }, { value: "#C0C0C0", vga: !0, css: !0, name: "silver" }, { value: "#A9A9A9", css: !0, name: "darkgray" }, { value: "#808080", vga: !0, css: !0, name: "gray" }, { value: "#696969", css: !0, name: "dimgray" }, { value: "#696969", name: "gray 42" }, { value: "#000000", vga: !0, css: !0, name: "black" }, { value: "#FCFCFC", name: "gray 99" }, { value: "#FAFAFA", name: "gray 98" }, { value: "#F7F7F7", name: "gray 97" }, { value: "#F2F2F2", name: "gray 95" }, { value: "#F0F0F0", name: "gray 94" }, { value: "#EDEDED", name: "gray 93" }, { value: "#EBEBEB", name: "gray 92" }, { value: "#E8E8E8", name: "gray 91" }, { value: "#E5E5E5", name: "gray 90" }, { value: "#E3E3E3", name: "gray 89" }, { value: "#E0E0E0", name: "gray 88" }, { value: "#DEDEDE", name: "gray 87" }, { value: "#DBDBDB", name: "gray 86" }, { value: "#D9D9D9", name: "gray 85" }, { value: "#D6D6D6", name: "gray 84" }, { value: "#D4D4D4", name: "gray 83" }, { value: "#D1D1D1", name: "gray 82" }, { value: "#CFCFCF", name: "gray 81" }, { value: "#CCCCCC", name: "gray 80" }, { value: "#C9C9C9", name: "gray 79" }, { value: "#C7C7C7", name: "gray 78" }, { value: "#C4C4C4", name: "gray 77" }, { value: "#C2C2C2", name: "gray 76" }, { value: "#BFBFBF", name: "gray 75" }, { value: "#BDBDBD", name: "gray 74" }, { value: "#BABABA", name: "gray 73" }, { value: "#B8B8B8", name: "gray 72" }, { value: "#B5B5B5", name: "gray 71" }, { value: "#B3B3B3", name: "gray 70" }, { value: "#B0B0B0", name: "gray 69" }, { value: "#ADADAD", name: "gray 68" }, { value: "#ABABAB", name: "gray 67" }, { value: "#A8A8A8", name: "gray 66" }, { value: "#A6A6A6", name: "gray 65" }, { value: "#A3A3A3", name: "gray 64" }, { value: "#A1A1A1", name: "gray 63" }, { value: "#9E9E9E", name: "gray 62" }, { value: "#9C9C9C", name: "gray 61" }, { value: "#999999", name: "gray 60" }, { value: "#969696", name: "gray 59" }, { value: "#949494", name: "gray 58" }, { value: "#919191", name: "gray 57" }, { value: "#8F8F8F", name: "gray 56" }, { value: "#8C8C8C", name: "gray 55" }, { value: "#8A8A8A", name: "gray 54" }, { value: "#878787", name: "gray 53" }, { value: "#858585", name: "gray 52" }, { value: "#828282", name: "gray 51" }, { value: "#7F7F7F", name: "gray 50" }, { value: "#7D7D7D", name: "gray 49" }, { value: "#7A7A7A", name: "gray 48" }, { value: "#787878", name: "gray 47" }, { value: "#757575", name: "gray 46" }, { value: "#737373", name: "gray 45" }, { value: "#707070", name: "gray 44" }, { value: "#6E6E6E", name: "gray 43" }, { value: "#666666", name: "gray 40" }, { value: "#636363", name: "gray 39" }, { value: "#616161", name: "gray 38" }, { value: "#5E5E5E", name: "gray 37" }, { value: "#5C5C5C", name: "gray 36" }, { value: "#595959", name: "gray 35" }, { value: "#575757", name: "gray 34" }, { value: "#545454", name: "gray 33" }, { value: "#525252", name: "gray 32" }, { value: "#4F4F4F", name: "gray 31" }, { value: "#4D4D4D", name: "gray 30" }, { value: "#4A4A4A", name: "gray 29" }, { value: "#474747", name: "gray 28" }, { value: "#454545", name: "gray 27" }, { value: "#424242", name: "gray 26" }, { value: "#404040", name: "gray 25" }, { value: "#3D3D3D", name: "gray 24" }, { value: "#3B3B3B", name: "gray 23" }, { value: "#383838", name: "gray 22" }, { value: "#363636", name: "gray 21" }, { value: "#333333", name: "gray 20" }, { value: "#303030", name: "gray 19" }, { value: "#2E2E2E", name: "gray 18" }, { value: "#2B2B2B", name: "gray 17" }, { value: "#292929", name: "gray 16" }, { value: "#262626", name: "gray 15" }, { value: "#242424", name: "gray 14" }, { value: "#212121", name: "gray 13" }, { value: "#1F1F1F", name: "gray 12" }, { value: "#1C1C1C", name: "gray 11" }, { value: "#1A1A1A", name: "gray 10" }, { value: "#171717", name: "gray 9" }, { value: "#141414", name: "gray 8" }, { value: "#121212", name: "gray 7" }, { value: "#0F0F0F", name: "gray 6" }, { value: "#0D0D0D", name: "gray 5" }, { value: "#0A0A0A", name: "gray 4" }, { value: "#080808", name: "gray 3" }, { value: "#050505", name: "gray 2" }, { value: "#030303", name: "gray 1" }, { value: "#F5F5F5", css: !0, name: "whitesmoke" }];
(function(i) {
  var t = Hit, e = t.filter(function(r) {
    return !!r.css;
  }), n = t.filter(function(r) {
    return !!r.vga;
  });
  i.exports = function(r) {
    var s = i.exports.get(r);
    return s && s.value;
  }, i.exports.get = function(r) {
    return r = (r = r || "").trim().toLowerCase(), t.filter(function(s) {
      return s.name.toLowerCase() === r;
    }).pop();
  }, i.exports.all = i.exports.get.all = function() {
    return t;
  }, i.exports.get.css = function(r) {
    return r ? (r = (r = r || "").trim().toLowerCase(), e.filter(function(s) {
      return s.name.toLowerCase() === r;
    }).pop()) : e;
  }, i.exports.get.vga = function(r) {
    return r ? (r = (r = r || "").trim().toLowerCase(), n.filter(function(s) {
      return s.name.toLowerCase() === r;
    }).pop()) : n;
  };
})(FB);
var jit = FB.exports, Git = 1 / 0, Wit = "[object Symbol]", Zit = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g, UB = "\\ud800-\\udfff", VB = "\\u2700-\\u27bf", HB = "a-z\\xdf-\\xf6\\xf8-\\xff", jB = "A-Z\\xc0-\\xd6\\xd8-\\xde", GB = "\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", ND = "[" + GB + "]", WB = "\\d+", qit = "[" + VB + "]", ZB = "[" + HB + "]", qB = "[^" + UB + GB + WB + VB + HB + jB + "]", XB = "(?:\\ud83c[\\udde6-\\uddff]){2}", YB = "[\\ud800-\\udbff][\\udc00-\\udfff]", mh = "[" + jB + "]", FD = "(?:" + ZB + "|" + qB + ")", Xit = "(?:" + mh + "|" + qB + ")", UD = "(?:['’](?:d|ll|m|re|s|t|ve))?", VD = "(?:['’](?:D|LL|M|RE|S|T|VE))?", HD = "(?:[\\u0300-\\u036f\\ufe20-\\ufe23\\u20d0-\\u20f0]|\\ud83c[\\udffb-\\udfff])?", jD = "[\\ufe0e\\ufe0f]?", Yit = jD + HD + ("(?:\\u200d(?:" + ["[^" + UB + "]", XB, YB].join("|") + ")" + jD + HD + ")*"), Jit = "(?:" + [qit, XB, YB].join("|") + ")" + Yit, Kit = RegExp([mh + "?" + ZB + "+" + UD + "(?=" + [ND, mh, "$"].join("|") + ")", Xit + "+" + VD + "(?=" + [ND, mh + FD, "$"].join("|") + ")", mh + "?" + FD + "+" + UD, mh + "+" + VD, WB, Jit].join("|"), "g"), $it = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/, Qit = typeof bn == "object" && bn && bn.Object === Object && bn, tst = typeof self == "object" && self && self.Object === Object && self, est = Qit || tst || Function("return this")(), nst = Object.prototype.toString, GD = est.Symbol, WD = GD ? GD.prototype : void 0, ZD = WD ? WD.toString : void 0;
function rst(i) {
  if (typeof i == "string")
    return i;
  if (function(e) {
    return typeof e == "symbol" || function(n) {
      return !!n && typeof n == "object";
    }(e) && nst.call(e) == Wit;
  }(i))
    return ZD ? ZD.call(i) : "";
  var t = i + "";
  return t == "0" && 1 / i == -Git ? "-0" : t;
}
var ist = function(i, t, e) {
  var n;
  return i = (n = i) == null ? "" : rst(n), (t = e ? void 0 : t) === void 0 ? function(r) {
    return $it.test(r);
  }(i) ? function(r) {
    return r.match(Kit) || [];
  }(i) : function(r) {
    return r.match(Zit) || [];
  }(i) : i.match(t) || [];
}, sst = 1 / 0, ast = "[object Symbol]", ost = /^\s+/, lM = "\\ud800-\\udfff", JB = "\\u0300-\\u036f\\ufe20-\\ufe23", KB = "\\u20d0-\\u20f0", $B = "\\ufe0e\\ufe0f", lst = "[" + lM + "]", pb = "[" + JB + KB + "]", fb = "\\ud83c[\\udffb-\\udfff]", QB = "[^" + lM + "]", tz = "(?:\\ud83c[\\udde6-\\uddff]){2}", ez = "[\\ud800-\\udbff][\\udc00-\\udfff]", nz = "\\u200d", qD = "(?:" + pb + "|" + fb + ")?", XD = "[" + $B + "]?", cst = XD + qD + ("(?:" + nz + "(?:" + [QB, tz, ez].join("|") + ")" + XD + qD + ")*"), hst = "(?:" + [QB + pb + "?", pb, tz, ez, lst].join("|") + ")", ust = RegExp(fb + "(?=" + fb + ")|" + hst + cst, "g"), dst = RegExp("[" + nz + lM + JB + KB + $B + "]"), pst = typeof bn == "object" && bn && bn.Object === Object && bn, fst = typeof self == "object" && self && self.Object === Object && self, mst = pst || fst || Function("return this")();
function gst(i, t, e) {
  if (t != t)
    return function(s, a, o, l) {
      for (var c = s.length, u = o + (l ? 1 : -1); l ? u-- : ++u < c; )
        if (a(s[u], u, s))
          return u;
      return -1;
    }(i, vst, e);
  for (var n = e - 1, r = i.length; ++n < r; )
    if (i[n] === t)
      return n;
  return -1;
}
function vst(i) {
  return i != i;
}
function YD(i) {
  return function(t) {
    return dst.test(t);
  }(i) ? function(t) {
    return t.match(ust) || [];
  }(i) : function(t) {
    return t.split("");
  }(i);
}
var yst = Object.prototype.toString, JD = mst.Symbol, KD = JD ? JD.prototype : void 0, $D = KD ? KD.toString : void 0;
function QD(i) {
  if (typeof i == "string")
    return i;
  if (function(e) {
    return typeof e == "symbol" || function(n) {
      return !!n && typeof n == "object";
    }(e) && yst.call(e) == ast;
  }(i))
    return $D ? $D.call(i) : "";
  var t = i + "";
  return t == "0" && 1 / i == -sst ? "-0" : t;
}
function _st(i, t, e) {
  var n = i.length;
  return e = e === void 0 ? n : e, !t && e >= n ? i : function(r, s, a) {
    var o = -1, l = r.length;
    s < 0 && (s = -s > l ? 0 : l + s), (a = a > l ? l : a) < 0 && (a += l), l = s > a ? 0 : a - s >>> 0, s >>>= 0;
    for (var c = Array(l); ++o < l; )
      c[o] = r[o + s];
    return c;
  }(i, t, e);
}
var tR, wst = function(i, t, e) {
  var n;
  if ((i = (n = i) == null ? "" : QD(n)) && (e || t === void 0))
    return i.replace(ost, "");
  if (!i || !(t = QD(t)))
    return i;
  var r = YD(i), s = function(a, o) {
    for (var l = -1, c = a.length; ++l < c && gst(o, a[l], 0) > -1; )
      ;
    return l;
  }(r, YD(t));
  return _st(r, s).join("");
}, mb = 1 / 0, xst = 9007199254740991, bst = 17976931348623157e292, eR = NaN, Sst = "[object Symbol]", Mst = /^\s+|\s+$/g, Tst = /^[-+]0x[0-9a-f]+$/i, Est = /^0b[01]+$/i, Ast = /^0o[0-7]+$/i, cM = "\\ud800-\\udfff", rz = "\\u0300-\\u036f\\ufe20-\\ufe23", iz = "\\u20d0-\\u20f0", sz = "\\ufe0e\\ufe0f", Cst = "[" + cM + "]", gb = "[" + rz + iz + "]", vb = "\\ud83c[\\udffb-\\udfff]", az = "[^" + cM + "]", oz = "(?:\\ud83c[\\udde6-\\uddff]){2}", lz = "[\\ud800-\\udbff][\\udc00-\\udfff]", cz = "\\u200d", nR = "(?:" + gb + "|" + vb + ")?", rR = "[" + sz + "]?", Pst = rR + nR + ("(?:" + cz + "(?:" + [az, oz, lz].join("|") + ")" + rR + nR + ")*"), Dst = "(?:" + [az + gb + "?", gb, oz, lz, Cst].join("|") + ")", yb = RegExp(vb + "(?=" + vb + ")|" + Dst + Pst, "g"), Rst = RegExp("[" + cz + cM + rz + iz + sz + "]"), Ist = parseInt, Ost = typeof bn == "object" && bn && bn.Object === Object && bn, Lst = typeof self == "object" && self && self.Object === Object && self, Bst = Ost || Lst || Function("return this")(), zst = (tR = "length", function(i) {
  return i == null ? void 0 : i[tR];
});
function hM(i) {
  return Rst.test(i);
}
function iR(i) {
  return hM(i) ? function(t) {
    for (var e = yb.lastIndex = 0; yb.test(t); )
      e++;
    return e;
  }(i) : zst(i);
}
function kst(i) {
  return hM(i) ? function(t) {
    return t.match(yb) || [];
  }(i) : function(t) {
    return t.split("");
  }(i);
}
var Nst = Object.prototype.toString, sR = Bst.Symbol, Fst = Math.ceil, Ust = Math.floor, aR = sR ? sR.prototype : void 0, oR = aR ? aR.toString : void 0;
function lR(i, t) {
  var e = "";
  if (!i || t < 1 || t > xst)
    return e;
  do
    t % 2 && (e += i), (t = Ust(t / 2)) && (i += i);
  while (t);
  return e;
}
function cR(i) {
  if (typeof i == "string")
    return i;
  if (hz(i))
    return oR ? oR.call(i) : "";
  var t = i + "";
  return t == "0" && 1 / i == -mb ? "-0" : t;
}
function Vst(i, t, e) {
  var n = i.length;
  return e = e === void 0 ? n : e, !t && e >= n ? i : function(r, s, a) {
    var o = -1, l = r.length;
    s < 0 && (s = -s > l ? 0 : l + s), (a = a > l ? l : a) < 0 && (a += l), l = s > a ? 0 : a - s >>> 0, s >>>= 0;
    for (var c = Array(l); ++o < l; )
      c[o] = r[o + s];
    return c;
  }(i, t, e);
}
function hR(i) {
  var t = typeof i;
  return !!i && (t == "object" || t == "function");
}
function hz(i) {
  return typeof i == "symbol" || function(t) {
    return !!t && typeof t == "object";
  }(i) && Nst.call(i) == Sst;
}
function Hst(i) {
  return i ? (i = function(t) {
    if (typeof t == "number")
      return t;
    if (hz(t))
      return eR;
    if (hR(t)) {
      var e = typeof t.valueOf == "function" ? t.valueOf() : t;
      t = hR(e) ? e + "" : e;
    }
    if (typeof t != "string")
      return t === 0 ? t : +t;
    t = t.replace(Mst, "");
    var n = Est.test(t);
    return n || Ast.test(t) ? Ist(t.slice(2), n ? 2 : 8) : Tst.test(t) ? eR : +t;
  }(i)) === mb || i === -mb ? (i < 0 ? -1 : 1) * bst : i == i ? i : 0 : i === 0 ? i : 0;
}
var jst = function(i, t, e) {
  var n;
  i = (n = i) == null ? "" : cR(n);
  var r = (t = function(s) {
    var a = Hst(s), o = a % 1;
    return a == a ? o ? a - o : a : 0;
  }(t)) ? iR(i) : 0;
  return t && r < t ? i + function(s, a) {
    var o = (a = a === void 0 ? " " : cR(a)).length;
    if (o < 2)
      return o ? lR(a, s) : a;
    var l = lR(a, Fst(s / iR(a)));
    return hM(a) ? Vst(kst(l), 0, s).join("") : l.slice(0, s);
  }(t - r, e) : i;
};
const _p = "a-f\\d", Gst = `#?[${_p}]{3}[${_p}]?`, Wst = `#?[${_p}]{6}([${_p}]{2})?`, Zst = new RegExp(`[^#${_p}]`, "gi"), qst = new RegExp(`^${Gst}$|^${Wst}$`, "i");
var Xst = jit, Yst = ist, Jst = wst, Kst = jst, $st = (i, t, e, n) => {
  const r = (i + (n || "")).toString().includes("%");
  if (typeof i == "string" ? [i, t, e, n] = i.match(/(0?\.?\d{1,3})%?\b/g).map(Number) : n !== void 0 && (n = parseFloat(n)), typeof i != "number" || typeof t != "number" || typeof e != "number" || i > 255 || t > 255 || e > 255)
    throw new TypeError("Expected three numbers below 256");
  if (typeof n == "number") {
    if (!r && n >= 0 && n <= 1)
      n = Math.round(255 * n);
    else {
      if (!(r && n >= 0 && n <= 100))
        throw new TypeError(`Expected alpha value (${n}) as a fraction or percentage`);
      n = Math.round(255 * n / 100);
    }
    n = (256 | n).toString(16).slice(1);
  } else
    n = "";
  return (e | t << 8 | i << 16 | 1 << 24).toString(16).slice(1) + n;
}, uR = (i, t = {}) => {
  if (typeof i != "string" || Zst.test(i) || !qst.test(i))
    throw new TypeError("Expected a valid hex string");
  let e = 1;
  (i = i.replace(/^#/, "")).length === 8 && (e = Number.parseInt(i.slice(6, 8), 16) / 255, i = i.slice(0, 6)), i.length === 4 && (e = Number.parseInt(i.slice(3, 4).repeat(2), 16) / 255, i = i.slice(0, 3)), i.length === 3 && (i = i[0] + i[0] + i[1] + i[1] + i[2] + i[2]);
  const n = Number.parseInt(i, 16), r = n >> 16, s = n >> 8 & 255, a = 255 & n, o = typeof t.alpha == "number" ? t.alpha : e;
  return t.format === "array" ? [r, s, a, o] : t.format === "css" ? `rgb(${r} ${s} ${a}${o === 1 ? "" : ` / ${Number((100 * o).toFixed(2))}%`})` : { red: r, green: s, blue: a, alpha: o };
};
const _w = 0.75, ww = 0.25, xw = 16777215, Qst = 49979693;
var tat = function(i) {
  return "#" + function(t) {
    var e, n = function(u) {
      var h = Yst(u), p = [];
      return h.forEach(function(f) {
        var v = Xst(f);
        v && p.push(uR(Jst(v, "#"), { format: "array" }));
      }), p;
    }(t);
    n.length > 0 && (e = function(u) {
      var h = [0, 0, 0];
      return u.forEach(function(p) {
        for (var f = 0; f < 3; f++)
          h[f] += p[f];
      }), [h[0] / u.length, h[1] / u.length, h[2] / u.length];
    }(n));
    var r = 1, s = 0, a = 1;
    if (t.length > 0)
      for (var o = 0; o < t.length; o++)
        t[o].charCodeAt(0) > s && (s = t[o].charCodeAt(0)), a = parseInt(xw / s), r = (r + t[o].charCodeAt(0) * a * Qst) % xw;
    var l = (r * t.length % xw).toString(16);
    l = Kst(l, 6, l);
    var c = uR(l, { format: "array" });
    return e ? $st(ww * c[0] + _w * e[0], ww * c[1] + _w * e[1], ww * c[2] + _w * e[2]) : l;
  }(String(JSON.stringify(i)));
};
const eat = Mp(tat);
/*!
fflate - fast JavaScript compression/decompression
<https://101arrowz.github.io/fflate>
Licensed under MIT. https://github.com/101arrowz/fflate/blob/master/LICENSE
version 0.6.9
*/
var dR = function(i) {
  return URL.createObjectURL(new Blob([i], { type: "text/javascript" }));
};
try {
  URL.revokeObjectURL(dR(""));
} catch {
  dR = function(t) {
    return "data:application/javascript;charset=UTF-8," + encodeURI(t);
  };
}
var as = Uint8Array, Lo = Uint16Array, _b = Uint32Array, uz = new as([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]), dz = new as([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]), nat = new as([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), pz = function(i, t) {
  for (var e = new Lo(31), n = 0; n < 31; ++n)
    e[n] = t += 1 << i[n - 1];
  var r = new _b(e[30]);
  for (n = 1; n < 30; ++n)
    for (var s = e[n]; s < e[n + 1]; ++s)
      r[s] = s - e[n] << 5 | n;
  return [e, r];
}, fz = pz(uz, 2), mz = fz[0], rat = fz[1];
mz[28] = 258, rat[258] = 28;
for (var iat = pz(dz, 0)[0], wb = new Lo(32768), Dn = 0; Dn < 32768; ++Dn) {
  var xl = (43690 & Dn) >>> 1 | (21845 & Dn) << 1;
  xl = (61680 & (xl = (52428 & xl) >>> 2 | (13107 & xl) << 2)) >>> 4 | (3855 & xl) << 4, wb[Dn] = ((65280 & xl) >>> 8 | (255 & xl) << 8) >>> 1;
}
var Hd = function(i, t, e) {
  for (var n = i.length, r = 0, s = new Lo(t); r < n; ++r)
    ++s[i[r] - 1];
  var a, o = new Lo(t);
  for (r = 0; r < t; ++r)
    o[r] = o[r - 1] + s[r - 1] << 1;
  if (e) {
    a = new Lo(1 << t);
    var l = 15 - t;
    for (r = 0; r < n; ++r)
      if (i[r])
        for (var c = r << 4 | i[r], u = t - i[r], h = o[i[r] - 1]++ << u, p = h | (1 << u) - 1; h <= p; ++h)
          a[wb[h] >>> l] = c;
  } else
    for (a = new Lo(n), r = 0; r < n; ++r)
      i[r] && (a[r] = wb[o[i[r] - 1]++] >>> 15 - i[r]);
  return a;
}, Hp = new as(288);
for (Dn = 0; Dn < 144; ++Dn)
  Hp[Dn] = 8;
for (Dn = 144; Dn < 256; ++Dn)
  Hp[Dn] = 9;
for (Dn = 256; Dn < 280; ++Dn)
  Hp[Dn] = 7;
for (Dn = 280; Dn < 288; ++Dn)
  Hp[Dn] = 8;
var gz = new as(32);
for (Dn = 0; Dn < 32; ++Dn)
  gz[Dn] = 5;
var sat = Hd(Hp, 9, 1), aat = Hd(gz, 5, 1), bw = function(i) {
  for (var t = i[0], e = 1; e < i.length; ++e)
    i[e] > t && (t = i[e]);
  return t;
}, _s = function(i, t, e) {
  var n = t / 8 | 0;
  return (i[n] | i[n + 1] << 8) >> (7 & t) & e;
}, Sw = function(i, t) {
  var e = t / 8 | 0;
  return (i[e] | i[e + 1] << 8 | i[e + 2] << 16) >> (7 & t);
}, oat = function(i, t, e) {
  var n = i.length;
  if (!n || e && !e.l && n < 5)
    return t || new as(0);
  var r = !t || e, s = !e || e.i;
  e || (e = {}), t || (t = new as(3 * n));
  var a, o = function(N) {
    var st = t.length;
    if (N > st) {
      var et = new as(Math.max(2 * st, N));
      et.set(t), t = et;
    }
  }, l = e.f || 0, c = e.p || 0, u = e.b || 0, h = e.l, p = e.d, f = e.m, v = e.n, m = 8 * n;
  do {
    if (!h) {
      e.f = l = _s(i, c, 1);
      var y = _s(i, c + 1, 3);
      if (c += 3, !y) {
        var _ = i[(E = ((a = c) / 8 | 0) + (7 & a && 1) + 4) - 4] | i[E - 3] << 8, w = E + _;
        if (w > n) {
          if (s)
            throw "unexpected EOF";
          break;
        }
        r && o(u + _), t.set(i.subarray(E, w), u), e.b = u += _, e.p = c = 8 * w;
        continue;
      }
      if (y == 1)
        h = sat, p = aat, f = 9, v = 5;
      else {
        if (y != 2)
          throw "invalid block type";
        var b = _s(i, c, 31) + 257, T = _s(i, c + 10, 15) + 4, M = b + _s(i, c + 5, 31) + 1;
        c += 14;
        for (var A = new as(M), C = new as(19), I = 0; I < T; ++I)
          C[nat[I]] = _s(i, c + 3 * I, 7);
        c += 3 * T;
        var k = bw(C), R = (1 << k) - 1, L = Hd(C, k, 1);
        for (I = 0; I < M; ) {
          var E, q = L[_s(i, c, R)];
          if (c += 15 & q, (E = q >>> 4) < 16)
            A[I++] = E;
          else {
            var it = 0, rt = 0;
            for (E == 16 ? (rt = 3 + _s(i, c, 3), c += 2, it = A[I - 1]) : E == 17 ? (rt = 3 + _s(i, c, 7), c += 3) : E == 18 && (rt = 11 + _s(i, c, 127), c += 7); rt--; )
              A[I++] = it;
          }
        }
        var ft = A.subarray(0, b), nt = A.subarray(b);
        f = bw(ft), v = bw(nt), h = Hd(ft, f, 1), p = Hd(nt, v, 1);
      }
      if (c > m) {
        if (s)
          throw "unexpected EOF";
        break;
      }
    }
    r && o(u + 131072);
    for (var vt = (1 << f) - 1, $ = (1 << v) - 1, W = c; ; W = c) {
      var ct = (it = h[Sw(i, c) & vt]) >>> 4;
      if ((c += 15 & it) > m) {
        if (s)
          throw "unexpected EOF";
        break;
      }
      if (!it)
        throw "invalid length/literal";
      if (ct < 256)
        t[u++] = ct;
      else {
        if (ct == 256) {
          W = c, h = null;
          break;
        }
        var mt = ct - 254;
        if (ct > 264) {
          var dt = uz[I = ct - 257];
          mt = _s(i, c, (1 << dt) - 1) + mz[I], c += dt;
        }
        var Mt = p[Sw(i, c) & $], At = Mt >>> 4;
        if (!Mt)
          throw "invalid distance";
        if (c += 15 & Mt, nt = iat[At], At > 3 && (dt = dz[At], nt += Sw(i, c) & (1 << dt) - 1, c += dt), c > m) {
          if (s)
            throw "unexpected EOF";
          break;
        }
        r && o(u + 131072);
        for (var H = u + mt; u < H; u += 4)
          t[u] = t[u - nt], t[u + 1] = t[u + 1 - nt], t[u + 2] = t[u + 2 - nt], t[u + 3] = t[u + 3 - nt];
        u = H;
      }
    }
    e.l = h, e.p = W, e.b = u, h && (l = 1, e.m = f, e.d = p, e.n = v);
  } while (!l);
  return u == t.length ? t : function(N, st, et) {
    (st == null || st < 0) && (st = 0), (et == null || et > N.length) && (et = N.length);
    var J = new (N instanceof Lo ? Lo : N instanceof _b ? _b : as)(et - st);
    return J.set(N.subarray(st, et)), J;
  }(t, 0, u);
}, lat = new as(0);
function Cg(i, t) {
  return oat((function(e) {
    if ((15 & e[0]) != 8 || e[0] >>> 4 > 7 || (e[0] << 8 | e[1]) % 31)
      throw "invalid zlib data";
    if (32 & e[1])
      throw "invalid zlib data: preset dictionaries not supported";
  }(i), i.subarray(2, -4)), t);
}
var cat = typeof TextDecoder < "u" && new TextDecoder();
try {
  cat.decode(lat, { stream: !0 });
} catch {
}
class hat extends eS {
  constructor(t) {
    super(t), this.type = 1016;
  }
  parse(t) {
    const a = Math.pow(2.7182818, 2.2), o = { l: 0, c: 0, lc: 0 };
    function l(O, V, tt, gt, Tt) {
      for (; tt < O; )
        V = V << 8 | H(gt, Tt), tt += 8;
      tt -= O, o.l = V >> tt & (1 << O) - 1, o.c = V, o.lc = tt;
    }
    const c = new Array(59);
    function u(O, V, tt, gt, Tt, ot) {
      const St = V;
      let It = 0, xt = 0;
      for (; gt <= Tt; gt++) {
        if (St.value - V.value > tt)
          return !1;
        l(6, It, xt, O, St);
        const Ft = o.l;
        if (It = o.c, xt = o.lc, ot[gt] = Ft, Ft == 63) {
          if (St.value - V.value > tt)
            throw new Error("Something wrong with hufUnpackEncTable");
          l(8, It, xt, O, St);
          let Kt = o.l + 6;
          if (It = o.c, xt = o.lc, gt + Kt > Tt + 1)
            throw new Error("Something wrong with hufUnpackEncTable");
          for (; Kt--; )
            ot[gt++] = 0;
          gt--;
        } else if (Ft >= 59) {
          let Kt = Ft - 59 + 2;
          if (gt + Kt > Tt + 1)
            throw new Error("Something wrong with hufUnpackEncTable");
          for (; Kt--; )
            ot[gt++] = 0;
          gt--;
        }
      }
      (function(Ft) {
        for (let jt = 0; jt <= 58; ++jt)
          c[jt] = 0;
        for (let jt = 0; jt < 65537; ++jt)
          c[Ft[jt]] += 1;
        let Kt = 0;
        for (let jt = 58; jt > 0; --jt) {
          const qt = Kt + c[jt] >> 1;
          c[jt] = Kt, Kt = qt;
        }
        for (let jt = 0; jt < 65537; ++jt) {
          const qt = Ft[jt];
          qt > 0 && (Ft[jt] = qt | c[qt]++ << 6);
        }
      })(ot);
    }
    function h(O) {
      return 63 & O;
    }
    function p(O) {
      return O >> 6;
    }
    const f = { c: 0, lc: 0 };
    function v(O, V, tt, gt) {
      O = O << 8 | H(tt, gt), V += 8, f.c = O, f.lc = V;
    }
    const m = { c: 0, lc: 0 };
    function y(O, V, tt, gt, Tt, ot, St, It, xt) {
      if (O == V) {
        gt < 8 && (v(tt, gt, Tt, ot), tt = f.c, gt = f.lc);
        let Ft = tt >> (gt -= 8);
        if (Ft = new Uint8Array([Ft])[0], It.value + Ft > xt)
          return !1;
        const Kt = St[It.value - 1];
        for (; Ft-- > 0; )
          St[It.value++] = Kt;
      } else {
        if (!(It.value < xt))
          return !1;
        St[It.value++] = O;
      }
      m.c = tt, m.lc = gt;
    }
    function _(O) {
      return 65535 & O;
    }
    function w(O) {
      const V = _(O);
      return V > 32767 ? V - 65536 : V;
    }
    const b = { a: 0, b: 0 };
    function T(O, V) {
      const tt = w(O), gt = w(V), Tt = tt + (1 & gt) + (gt >> 1), ot = Tt, St = Tt - gt;
      b.a = ot, b.b = St;
    }
    function M(O, V) {
      const tt = _(O), gt = _(V), Tt = tt - (gt >> 1) & 65535, ot = gt + Tt - 32768 & 65535;
      b.a = ot, b.b = Tt;
    }
    function A(O, V, tt, gt, Tt, ot, St) {
      const It = St < 16384, xt = tt > Tt ? Tt : tt;
      let Ft, Kt, jt = 1;
      for (; jt <= xt; )
        jt <<= 1;
      for (jt >>= 1, Ft = jt, jt >>= 1; jt >= 1; ) {
        Kt = 0;
        const qt = Kt + ot * (Tt - Ft), $t = ot * jt, fe = ot * Ft, Yt = gt * jt, te = gt * Ft;
        let oe, ce, Ve, sn;
        for (; Kt <= qt; Kt += fe) {
          let he = Kt;
          const Te = Kt + gt * (tt - Ft);
          for (; he <= Te; he += te) {
            const Tn = he + Yt, Kn = he + $t, cr = Kn + Yt;
            It ? (T(O[he + V], O[Kn + V]), oe = b.a, Ve = b.b, T(O[Tn + V], O[cr + V]), ce = b.a, sn = b.b, T(oe, ce), O[he + V] = b.a, O[Tn + V] = b.b, T(Ve, sn), O[Kn + V] = b.a, O[cr + V] = b.b) : (M(O[he + V], O[Kn + V]), oe = b.a, Ve = b.b, M(O[Tn + V], O[cr + V]), ce = b.a, sn = b.b, M(oe, ce), O[he + V] = b.a, O[Tn + V] = b.b, M(Ve, sn), O[Kn + V] = b.a, O[cr + V] = b.b);
          }
          if (tt & jt) {
            const Tn = he + $t;
            It ? T(O[he + V], O[Tn + V]) : M(O[he + V], O[Tn + V]), oe = b.a, O[Tn + V] = b.b, O[he + V] = oe;
          }
        }
        if (Tt & jt) {
          let he = Kt;
          const Te = Kt + gt * (tt - Ft);
          for (; he <= Te; he += te) {
            const Tn = he + Yt;
            It ? T(O[he + V], O[Tn + V]) : M(O[he + V], O[Tn + V]), oe = b.a, O[Tn + V] = b.b, O[he + V] = oe;
          }
        }
        Ft = jt, jt >>= 1;
      }
      return Kt;
    }
    function C(O, V, tt, gt, Tt, ot) {
      const St = tt.value, It = At(V, tt), xt = At(V, tt);
      tt.value += 4;
      const Ft = At(V, tt);
      if (tt.value += 4, It < 0 || It >= 65537 || xt < 0 || xt >= 65537)
        throw new Error("Something wrong with HUF_ENCSIZE");
      const Kt = new Array(65537), jt = new Array(16384);
      if (function(qt) {
        for (let $t = 0; $t < 16384; $t++)
          qt[$t] = {}, qt[$t].len = 0, qt[$t].lit = 0, qt[$t].p = null;
      }(jt), u(O, tt, gt - (tt.value - St), It, xt, Kt), Ft > 8 * (gt - (tt.value - St)))
        throw new Error("Something wrong with hufUncompress");
      (function(qt, $t, fe, Yt) {
        for (; $t <= fe; $t++) {
          const te = p(qt[$t]), oe = h(qt[$t]);
          if (te >> oe)
            throw new Error("Invalid table entry");
          if (oe > 14) {
            const ce = Yt[te >> oe - 14];
            if (ce.len)
              throw new Error("Invalid table entry");
            if (ce.lit++, ce.p) {
              const Ve = ce.p;
              ce.p = new Array(ce.lit);
              for (let sn = 0; sn < ce.lit - 1; ++sn)
                ce.p[sn] = Ve[sn];
            } else
              ce.p = new Array(1);
            ce.p[ce.lit - 1] = $t;
          } else if (oe) {
            let ce = 0;
            for (let Ve = 1 << 14 - oe; Ve > 0; Ve--) {
              const sn = Yt[(te << 14 - oe) + ce];
              if (sn.len || sn.p)
                throw new Error("Invalid table entry");
              sn.len = oe, sn.lit = $t, ce++;
            }
          }
        }
      })(Kt, It, xt, jt), function(qt, $t, fe, Yt, te, oe, ce, Ve, sn) {
        let he = 0, Te = 0;
        const Tn = ce, Kn = Math.trunc(Yt.value + (te + 7) / 8);
        for (; Yt.value < Kn; )
          for (v(he, Te, fe, Yt), he = f.c, Te = f.lc; Te >= 14; ) {
            const Q = $t[he >> Te - 14 & 16383];
            if (Q.len)
              Te -= Q.len, y(Q.lit, oe, he, Te, fe, Yt, Ve, sn, Tn), he = m.c, Te = m.lc;
            else {
              if (!Q.p)
                throw new Error("hufDecode issues");
              let Et;
              for (Et = 0; Et < Q.lit; Et++) {
                const Pt = h(qt[Q.p[Et]]);
                for (; Te < Pt && Yt.value < Kn; )
                  v(he, Te, fe, Yt), he = f.c, Te = f.lc;
                if (Te >= Pt && p(qt[Q.p[Et]]) == (he >> Te - Pt & (1 << Pt) - 1)) {
                  Te -= Pt, y(Q.p[Et], oe, he, Te, fe, Yt, Ve, sn, Tn), he = m.c, Te = m.lc;
                  break;
                }
              }
              if (Et == Q.lit)
                throw new Error("hufDecode issues");
            }
          }
        const cr = 8 - te & 7;
        for (he >>= cr, Te -= cr; Te > 0; ) {
          const Q = $t[he << 14 - Te & 16383];
          if (!Q.len)
            throw new Error("hufDecode issues");
          Te -= Q.len, y(Q.lit, oe, he, Te, fe, Yt, Ve, sn, Tn), he = m.c, Te = m.lc;
        }
      }(Kt, jt, O, tt, Ft, xt, ot, Tt, { value: 0 });
    }
    function I(O) {
      for (let V = 1; V < O.length; V++) {
        const tt = O[V - 1] + O[V] - 128;
        O[V] = tt;
      }
    }
    function k(O, V) {
      let tt = 0, gt = Math.floor((O.length + 1) / 2), Tt = 0;
      const ot = O.length - 1;
      for (; !(Tt > ot || (V[Tt++] = O[tt++], Tt > ot)); )
        V[Tt++] = O[gt++];
    }
    function R(O) {
      let V = O.byteLength;
      const tt = new Array();
      let gt = 0;
      const Tt = new DataView(O);
      for (; V > 0; ) {
        const ot = Tt.getInt8(gt++);
        if (ot < 0) {
          const St = -ot;
          V -= St + 1;
          for (let It = 0; It < St; It++)
            tt.push(Tt.getUint8(gt++));
        } else {
          const St = ot;
          V -= 2;
          const It = Tt.getUint8(gt++);
          for (let xt = 0; xt < St + 1; xt++)
            tt.push(It);
        }
      }
      return tt;
    }
    function L(O, V, tt) {
      let gt, Tt = 1;
      for (; Tt < 64; )
        gt = V[O.value], gt == 65280 ? Tt = 64 : gt >> 8 == 255 ? Tt += 255 & gt : (tt[Tt] = gt, Tt++), O.value++;
    }
    function E(O, V) {
      V[0] = K(O[0]), V[1] = K(O[1]), V[2] = K(O[5]), V[3] = K(O[6]), V[4] = K(O[14]), V[5] = K(O[15]), V[6] = K(O[27]), V[7] = K(O[28]), V[8] = K(O[2]), V[9] = K(O[4]), V[10] = K(O[7]), V[11] = K(O[13]), V[12] = K(O[16]), V[13] = K(O[26]), V[14] = K(O[29]), V[15] = K(O[42]), V[16] = K(O[3]), V[17] = K(O[8]), V[18] = K(O[12]), V[19] = K(O[17]), V[20] = K(O[25]), V[21] = K(O[30]), V[22] = K(O[41]), V[23] = K(O[43]), V[24] = K(O[9]), V[25] = K(O[11]), V[26] = K(O[18]), V[27] = K(O[24]), V[28] = K(O[31]), V[29] = K(O[40]), V[30] = K(O[44]), V[31] = K(O[53]), V[32] = K(O[10]), V[33] = K(O[19]), V[34] = K(O[23]), V[35] = K(O[32]), V[36] = K(O[39]), V[37] = K(O[45]), V[38] = K(O[52]), V[39] = K(O[54]), V[40] = K(O[20]), V[41] = K(O[22]), V[42] = K(O[33]), V[43] = K(O[38]), V[44] = K(O[46]), V[45] = K(O[51]), V[46] = K(O[55]), V[47] = K(O[60]), V[48] = K(O[21]), V[49] = K(O[34]), V[50] = K(O[37]), V[51] = K(O[47]), V[52] = K(O[50]), V[53] = K(O[56]), V[54] = K(O[59]), V[55] = K(O[61]), V[56] = K(O[35]), V[57] = K(O[36]), V[58] = K(O[48]), V[59] = K(O[49]), V[60] = K(O[57]), V[61] = K(O[58]), V[62] = K(O[62]), V[63] = K(O[63]);
    }
    function q(O) {
      const V = 0.5 * Math.cos(0.7853975), tt = 0.5 * Math.cos(3.14159 / 16), gt = 0.5 * Math.cos(3.14159 / 8), Tt = 0.5 * Math.cos(3 * 3.14159 / 16), ot = 0.5 * Math.cos(0.981746875), St = 0.5 * Math.cos(3 * 3.14159 / 8), It = 0.5 * Math.cos(1.374445625), xt = new Array(4), Ft = new Array(4), Kt = new Array(4), jt = new Array(4);
      for (let qt = 0; qt < 8; ++qt) {
        const $t = 8 * qt;
        xt[0] = gt * O[$t + 2], xt[1] = St * O[$t + 2], xt[2] = gt * O[$t + 6], xt[3] = St * O[$t + 6], Ft[0] = tt * O[$t + 1] + Tt * O[$t + 3] + ot * O[$t + 5] + It * O[$t + 7], Ft[1] = Tt * O[$t + 1] - It * O[$t + 3] - tt * O[$t + 5] - ot * O[$t + 7], Ft[2] = ot * O[$t + 1] - tt * O[$t + 3] + It * O[$t + 5] + Tt * O[$t + 7], Ft[3] = It * O[$t + 1] - ot * O[$t + 3] + Tt * O[$t + 5] - tt * O[$t + 7], Kt[0] = V * (O[$t + 0] + O[$t + 4]), Kt[3] = V * (O[$t + 0] - O[$t + 4]), Kt[1] = xt[0] + xt[3], Kt[2] = xt[1] - xt[2], jt[0] = Kt[0] + Kt[1], jt[1] = Kt[3] + Kt[2], jt[2] = Kt[3] - Kt[2], jt[3] = Kt[0] - Kt[1], O[$t + 0] = jt[0] + Ft[0], O[$t + 1] = jt[1] + Ft[1], O[$t + 2] = jt[2] + Ft[2], O[$t + 3] = jt[3] + Ft[3], O[$t + 4] = jt[3] - Ft[3], O[$t + 5] = jt[2] - Ft[2], O[$t + 6] = jt[1] - Ft[1], O[$t + 7] = jt[0] - Ft[0];
      }
      for (let qt = 0; qt < 8; ++qt)
        xt[0] = gt * O[16 + qt], xt[1] = St * O[16 + qt], xt[2] = gt * O[48 + qt], xt[3] = St * O[48 + qt], Ft[0] = tt * O[8 + qt] + Tt * O[24 + qt] + ot * O[40 + qt] + It * O[56 + qt], Ft[1] = Tt * O[8 + qt] - It * O[24 + qt] - tt * O[40 + qt] - ot * O[56 + qt], Ft[2] = ot * O[8 + qt] - tt * O[24 + qt] + It * O[40 + qt] + Tt * O[56 + qt], Ft[3] = It * O[8 + qt] - ot * O[24 + qt] + Tt * O[40 + qt] - tt * O[56 + qt], Kt[0] = V * (O[qt] + O[32 + qt]), Kt[3] = V * (O[qt] - O[32 + qt]), Kt[1] = xt[0] + xt[3], Kt[2] = xt[1] - xt[2], jt[0] = Kt[0] + Kt[1], jt[1] = Kt[3] + Kt[2], jt[2] = Kt[3] - Kt[2], jt[3] = Kt[0] - Kt[1], O[0 + qt] = jt[0] + Ft[0], O[8 + qt] = jt[1] + Ft[1], O[16 + qt] = jt[2] + Ft[2], O[24 + qt] = jt[3] + Ft[3], O[32 + qt] = jt[3] - Ft[3], O[40 + qt] = jt[2] - Ft[2], O[48 + qt] = jt[1] - Ft[1], O[56 + qt] = jt[0] - Ft[0];
    }
    function it(O) {
      for (let V = 0; V < 64; ++V) {
        const tt = O[0][V], gt = O[1][V], Tt = O[2][V];
        O[0][V] = tt + 1.5747 * Tt, O[1][V] = tt - 0.1873 * gt - 0.4682 * Tt, O[2][V] = tt + 1.8556 * gt;
      }
    }
    function rt(O, V, tt) {
      for (let gt = 0; gt < 64; ++gt)
        V[tt + gt] = kl.toHalfFloat(ft(O[gt]));
    }
    function ft(O) {
      return O <= 1 ? Math.sign(O) * Math.pow(Math.abs(O), 2.2) : Math.sign(O) * Math.pow(a, Math.abs(O) - 1);
    }
    function nt(O) {
      return new DataView(O.array.buffer, O.offset.value, O.size);
    }
    function vt(O) {
      const V = O.viewer.buffer.slice(O.offset.value, O.offset.value + O.size), tt = new Uint8Array(R(V)), gt = new Uint8Array(tt.length);
      return I(tt), k(tt, gt), new DataView(gt.buffer);
    }
    function $(O) {
      const V = Cg(O.array.slice(O.offset.value, O.offset.value + O.size)), tt = new Uint8Array(V.length);
      return I(V), k(V, tt), new DataView(tt.buffer);
    }
    function W(O) {
      const V = O.viewer, tt = { value: O.offset.value }, gt = new Uint16Array(O.width * O.scanlineBlockSize * (O.channels * O.type)), Tt = new Uint8Array(8192);
      let ot = 0;
      const St = new Array(O.channels);
      for (let fe = 0; fe < O.channels; fe++)
        St[fe] = {}, St[fe].start = ot, St[fe].end = St[fe].start, St[fe].nx = O.width, St[fe].ny = O.lines, St[fe].size = O.type, ot += St[fe].nx * St[fe].ny * St[fe].size;
      const It = S(V, tt), xt = S(V, tt);
      if (xt >= 8192)
        throw new Error("Something is wrong with PIZ_COMPRESSION BITMAP_SIZE");
      if (It <= xt)
        for (let fe = 0; fe < xt - It + 1; fe++)
          Tt[fe + It] = N(V, tt);
      const Ft = new Uint16Array(65536), Kt = function(fe, Yt) {
        let te = 0;
        for (let ce = 0; ce < 65536; ++ce)
          (ce == 0 || fe[ce >> 3] & 1 << (7 & ce)) && (Yt[te++] = ce);
        const oe = te - 1;
        for (; te < 65536; )
          Yt[te++] = 0;
        return oe;
      }(Tt, Ft), jt = At(V, tt);
      C(O.array, V, tt, jt, gt, ot);
      for (let fe = 0; fe < O.channels; ++fe) {
        const Yt = St[fe];
        for (let te = 0; te < St[fe].size; ++te)
          A(gt, Yt.start + te, Yt.nx, Yt.size, Yt.ny, Yt.nx * Yt.size, Kt);
      }
      (function(fe, Yt, te) {
        for (let oe = 0; oe < te; ++oe)
          Yt[oe] = fe[Yt[oe]];
      })(Ft, gt, ot);
      let qt = 0;
      const $t = new Uint8Array(gt.buffer.byteLength);
      for (let fe = 0; fe < O.lines; fe++)
        for (let Yt = 0; Yt < O.channels; Yt++) {
          const te = St[Yt], oe = te.nx * te.size, ce = new Uint8Array(gt.buffer, 2 * te.end, 2 * oe);
          $t.set(ce, qt), qt += 2 * oe, te.end += oe;
        }
      return new DataView($t.buffer);
    }
    function ct(O) {
      const V = Cg(O.array.slice(O.offset.value, O.offset.value + O.size)), tt = O.lines * O.channels * O.width, gt = O.type == 1 ? new Uint16Array(tt) : new Uint32Array(tt);
      let Tt = 0, ot = 0;
      const St = new Array(4);
      for (let It = 0; It < O.lines; It++)
        for (let xt = 0; xt < O.channels; xt++) {
          let Ft = 0;
          switch (O.type) {
            case 1:
              St[0] = Tt, St[1] = St[0] + O.width, Tt = St[1] + O.width;
              for (let Kt = 0; Kt < O.width; ++Kt)
                Ft += V[St[0]++] << 8 | V[St[1]++], gt[ot] = Ft, ot++;
              break;
            case 2:
              St[0] = Tt, St[1] = St[0] + O.width, St[2] = St[1] + O.width, Tt = St[2] + O.width;
              for (let Kt = 0; Kt < O.width; ++Kt)
                Ft += V[St[0]++] << 24 | V[St[1]++] << 16 | V[St[2]++] << 8, gt[ot] = Ft, ot++;
          }
        }
      return new DataView(gt.buffer);
    }
    function mt(O) {
      const V = O.viewer, tt = { value: O.offset.value }, gt = new Uint8Array(O.width * O.lines * (O.channels * O.type * 2)), Tt = { version: st(V, tt), unknownUncompressedSize: st(V, tt), unknownCompressedSize: st(V, tt), acCompressedSize: st(V, tt), dcCompressedSize: st(V, tt), rleCompressedSize: st(V, tt), rleUncompressedSize: st(V, tt), rleRawSize: st(V, tt), totalAcUncompressedCount: st(V, tt), totalDcUncompressedCount: st(V, tt), acCompression: st(V, tt) };
      if (Tt.version < 2)
        throw new Error("EXRLoader.parse: " + pt.compression + " version " + Tt.version + " is unsupported");
      const ot = new Array();
      let St = S(V, tt) - 2;
      for (; St > 0; ) {
        const Yt = dt(V.buffer, tt), te = N(V, tt), oe = te >> 2 & 3, ce = new Int8Array([(te >> 4) - 1])[0], Ve = N(V, tt);
        ot.push({ name: Yt, index: ce, type: Ve, compression: oe }), St -= Yt.length + 3;
      }
      const It = pt.channels, xt = new Array(O.channels);
      for (let Yt = 0; Yt < O.channels; ++Yt) {
        const te = xt[Yt] = {}, oe = It[Yt];
        te.name = oe.name, te.compression = 0, te.decoded = !1, te.type = oe.pixelType, te.pLinear = oe.pLinear, te.width = O.width, te.height = O.lines;
      }
      const Ft = { idx: new Array(3) };
      for (let Yt = 0; Yt < O.channels; ++Yt) {
        const te = xt[Yt];
        for (let oe = 0; oe < ot.length; ++oe) {
          const ce = ot[oe];
          te.name == ce.name && (te.compression = ce.compression, ce.index >= 0 && (Ft.idx[ce.index] = Yt), te.offset = Yt);
        }
      }
      let Kt, jt, qt;
      if (Tt.acCompressedSize > 0)
        switch (Tt.acCompression) {
          case 0:
            Kt = new Uint16Array(Tt.totalAcUncompressedCount), C(O.array, V, tt, Tt.acCompressedSize, Kt, Tt.totalAcUncompressedCount);
            break;
          case 1:
            const Yt = Cg(O.array.slice(tt.value, tt.value + Tt.totalAcUncompressedCount));
            Kt = new Uint16Array(Yt.buffer), tt.value += Tt.totalAcUncompressedCount;
        }
      if (Tt.dcCompressedSize > 0) {
        const Yt = { array: O.array, offset: tt, size: Tt.dcCompressedSize };
        jt = new Uint16Array($(Yt).buffer), tt.value += Tt.dcCompressedSize;
      }
      Tt.rleRawSize > 0 && (qt = R(Cg(O.array.slice(tt.value, tt.value + Tt.rleCompressedSize)).buffer), tt.value += Tt.rleCompressedSize);
      let $t = 0;
      const fe = new Array(xt.length);
      for (let Yt = 0; Yt < fe.length; ++Yt)
        fe[Yt] = new Array();
      for (let Yt = 0; Yt < O.lines; ++Yt)
        for (let te = 0; te < xt.length; ++te)
          fe[te].push($t), $t += xt[te].width * O.type * 2;
      (function(Yt, te, oe, ce, Ve, sn) {
        let he = new DataView(sn.buffer);
        const Te = oe[Yt.idx[0]].width, Tn = oe[Yt.idx[0]].height, Kn = Math.floor(Te / 8), cr = Math.ceil(Te / 8), Q = Math.ceil(Tn / 8), Et = Te - 8 * (cr - 1), Pt = Tn - 8 * (Q - 1), Dt = { value: 0 }, kt = new Array(3), re = new Array(3), we = new Array(3), de = new Array(3), Re = new Array(3);
        for (let ie = 0; ie < 3; ++ie)
          Re[ie] = te[Yt.idx[ie]], kt[ie] = ie < 1 ? 0 : kt[ie - 1] + cr * Q, re[ie] = new Float32Array(64), we[ie] = new Uint16Array(64), de[ie] = new Uint16Array(64 * cr);
        for (let ie = 0; ie < Q; ++ie) {
          let xe = 8;
          ie == Q - 1 && (xe = Pt);
          let _n = 8;
          for (let be = 0; be < cr; ++be) {
            be == cr - 1 && (_n = Et);
            for (let We = 0; We < 3; ++We)
              we[We].fill(0), we[We][0] = Ve[kt[We]++], L(Dt, ce, we[We]), E(we[We], re[We]), q(re[We]);
            it(re);
            for (let We = 0; We < 3; ++We)
              rt(re[We], de[We], 64 * be);
          }
          let cn = 0;
          for (let be = 0; be < 3; ++be) {
            const We = oe[Yt.idx[be]].type;
            for (let Qe = 8 * ie; Qe < 8 * ie + xe; ++Qe) {
              cn = Re[be][Qe];
              for (let wn = 0; wn < Kn; ++wn) {
                const $n = 64 * wn + 8 * (7 & Qe);
                he.setUint16(cn + 0 * We, de[be][$n + 0], !0), he.setUint16(cn + 2 * We, de[be][$n + 1], !0), he.setUint16(cn + 4 * We, de[be][$n + 2], !0), he.setUint16(cn + 6 * We, de[be][$n + 3], !0), he.setUint16(cn + 8 * We, de[be][$n + 4], !0), he.setUint16(cn + 10 * We, de[be][$n + 5], !0), he.setUint16(cn + 12 * We, de[be][$n + 6], !0), he.setUint16(cn + 14 * We, de[be][$n + 7], !0), cn += 16 * We;
              }
            }
            if (Kn != cr)
              for (let Qe = 8 * ie; Qe < 8 * ie + xe; ++Qe) {
                const wn = Re[be][Qe] + 8 * Kn * 2 * We, $n = 64 * Kn + 8 * (7 & Qe);
                for (let hr = 0; hr < _n; ++hr)
                  he.setUint16(wn + 2 * hr * We, de[be][$n + hr], !0);
              }
          }
        }
        const Ge = new Uint16Array(Te);
        he = new DataView(sn.buffer);
        for (let ie = 0; ie < 3; ++ie) {
          oe[Yt.idx[ie]].decoded = !0;
          const xe = oe[Yt.idx[ie]].type;
          if (oe[ie].type == 2)
            for (let _n = 0; _n < Tn; ++_n) {
              const cn = Re[ie][_n];
              for (let be = 0; be < Te; ++be)
                Ge[be] = he.getUint16(cn + 2 * be * xe, !0);
              for (let be = 0; be < Te; ++be)
                he.setFloat32(cn + 2 * be * xe, K(Ge[be]), !0);
            }
        }
      })(Ft, fe, xt, Kt, jt, gt);
      for (let Yt = 0; Yt < xt.length; ++Yt) {
        const te = xt[Yt];
        if (!te.decoded) {
          if (te.compression !== 2)
            throw new Error("EXRLoader.parse: unsupported channel compression");
          {
            let oe = 0, ce = 0;
            for (let Ve = 0; Ve < O.lines; ++Ve) {
              let sn = fe[Yt][oe];
              for (let he = 0; he < te.width; ++he) {
                for (let Te = 0; Te < 2 * te.type; ++Te)
                  gt[sn++] = qt[ce + Te * te.width * te.height];
                ce++;
              }
              oe++;
            }
          }
        }
      }
      return new DataView(gt.buffer);
    }
    function dt(O, V) {
      const tt = new Uint8Array(O);
      let gt = 0;
      for (; tt[V.value + gt] != 0; )
        gt += 1;
      const Tt = new TextDecoder().decode(tt.slice(V.value, V.value + gt));
      return V.value = V.value + gt + 1, Tt;
    }
    function Mt(O, V) {
      const tt = O.getInt32(V.value, !0);
      return V.value = V.value + 4, tt;
    }
    function At(O, V) {
      const tt = O.getUint32(V.value, !0);
      return V.value = V.value + 4, tt;
    }
    function H(O, V) {
      const tt = O[V.value];
      return V.value = V.value + 1, tt;
    }
    function N(O, V) {
      const tt = O.getUint8(V.value);
      return V.value = V.value + 1, tt;
    }
    const st = function(O, V) {
      const tt = Number(O.getBigInt64(V.value, !0));
      return V.value += 8, tt;
    };
    function et(O, V) {
      const tt = O.getFloat32(V.value, !0);
      return V.value += 4, tt;
    }
    function J(O, V) {
      return kl.toHalfFloat(et(O, V));
    }
    function K(O) {
      const V = (31744 & O) >> 10, tt = 1023 & O;
      return (O >> 15 ? -1 : 1) * (V ? V === 31 ? tt ? NaN : 1 / 0 : Math.pow(2, V - 15) * (1 + tt / 1024) : tt / 1024 * 6103515625e-14);
    }
    function S(O, V) {
      const tt = O.getUint16(V.value, !0);
      return V.value += 2, tt;
    }
    function Z(O, V) {
      return K(S(O, V));
    }
    function G(O, V, tt, gt, Tt) {
      return gt === "string" || gt === "stringvector" || gt === "iccProfile" ? function(ot, St, It) {
        const xt = new TextDecoder().decode(new Uint8Array(ot).slice(St.value, St.value + It));
        return St.value = St.value + It, xt;
      }(V, tt, Tt) : gt === "chlist" ? function(ot, St, It, xt) {
        const Ft = It.value, Kt = [];
        for (; It.value < Ft + xt - 1; ) {
          const jt = dt(St, It), qt = Mt(ot, It), $t = N(ot, It);
          It.value += 3;
          const fe = Mt(ot, It), Yt = Mt(ot, It);
          Kt.push({ name: jt, pixelType: qt, pLinear: $t, xSampling: fe, ySampling: Yt });
        }
        return It.value += 1, Kt;
      }(O, V, tt, Tt) : gt === "chromaticities" ? function(ot, St) {
        return { redX: et(ot, St), redY: et(ot, St), greenX: et(ot, St), greenY: et(ot, St), blueX: et(ot, St), blueY: et(ot, St), whiteX: et(ot, St), whiteY: et(ot, St) };
      }(O, tt) : gt === "compression" ? function(ot, St) {
        return ["NO_COMPRESSION", "RLE_COMPRESSION", "ZIPS_COMPRESSION", "ZIP_COMPRESSION", "PIZ_COMPRESSION", "PXR24_COMPRESSION", "B44_COMPRESSION", "B44A_COMPRESSION", "DWAA_COMPRESSION", "DWAB_COMPRESSION"][N(ot, St)];
      }(O, tt) : gt === "box2i" ? function(ot, St) {
        return { xMin: At(ot, St), yMin: At(ot, St), xMax: At(ot, St), yMax: At(ot, St) };
      }(O, tt) : gt === "lineOrder" ? function(ot, St) {
        return ["INCREASING_Y"][N(ot, St)];
      }(O, tt) : gt === "float" ? et(O, tt) : gt === "v2f" ? function(ot, St) {
        return [et(ot, St), et(ot, St)];
      }(O, tt) : gt === "v3f" ? function(ot, St) {
        return [et(ot, St), et(ot, St), et(ot, St)];
      }(O, tt) : gt === "int" ? Mt(O, tt) : gt === "rational" ? function(ot, St) {
        return [Mt(ot, St), At(ot, St)];
      }(O, tt) : gt === "timecode" ? function(ot, St) {
        return [At(ot, St), At(ot, St)];
      }(O, tt) : gt === "preview" ? (tt.value += Tt, "skipped") : void (tt.value += Tt);
    }
    const F = new DataView(t), z = new Uint8Array(t), Y = { value: 0 }, pt = function(O, V, tt) {
      const gt = {};
      if (O.getUint32(0, !0) != 20000630)
        throw new Error("THREE.EXRLoader: provided file doesn't appear to be in OpenEXR format.");
      gt.version = O.getUint8(4);
      const Tt = O.getUint8(5);
      gt.spec = { singleTile: !!(2 & Tt), longName: !!(4 & Tt), deepFormat: !!(8 & Tt), multiPart: !!(16 & Tt) }, tt.value = 8;
      let ot = !0;
      for (; ot; ) {
        const St = dt(V, tt);
        if (St == 0)
          ot = !1;
        else {
          const It = dt(V, tt), xt = G(O, V, tt, It, At(O, tt));
          xt === void 0 ? console.warn(`EXRLoader.parse: skipped unknown header attribute type '${It}'.`) : gt[St] = xt;
        }
      }
      if (-5 & Tt)
        throw console.error("EXRHeader:", gt), new Error("THREE.EXRLoader: provided file is currently unsupported.");
      return gt;
    }(F, t, Y), ht = function(O, V, tt, gt, Tt) {
      const ot = { size: 0, viewer: V, array: tt, offset: gt, width: O.dataWindow.xMax - O.dataWindow.xMin + 1, height: O.dataWindow.yMax - O.dataWindow.yMin + 1, channels: O.channels.length, bytesPerLine: null, lines: null, inputSize: null, type: O.channels[0].pixelType, uncompress: null, getter: null, format: null, encoding: null };
      switch (O.compression) {
        case "NO_COMPRESSION":
          ot.lines = 1, ot.uncompress = nt;
          break;
        case "RLE_COMPRESSION":
          ot.lines = 1, ot.uncompress = vt;
          break;
        case "ZIPS_COMPRESSION":
          ot.lines = 1, ot.uncompress = $;
          break;
        case "ZIP_COMPRESSION":
          ot.lines = 16, ot.uncompress = $;
          break;
        case "PIZ_COMPRESSION":
          ot.lines = 32, ot.uncompress = W;
          break;
        case "PXR24_COMPRESSION":
          ot.lines = 16, ot.uncompress = ct;
          break;
        case "DWAA_COMPRESSION":
          ot.lines = 32, ot.uncompress = mt;
          break;
        case "DWAB_COMPRESSION":
          ot.lines = 256, ot.uncompress = mt;
          break;
        default:
          throw new Error("EXRLoader.parse: " + O.compression + " is unsupported");
      }
      if (ot.scanlineBlockSize = ot.lines, ot.type == 1)
        switch (Tt) {
          case 1015:
            ot.getter = Z, ot.inputSize = 2;
            break;
          case 1016:
            ot.getter = S, ot.inputSize = 2;
        }
      else {
        if (ot.type != 2)
          throw new Error("EXRLoader.parse: unsupported pixelType " + ot.type + " for " + O.compression + ".");
        switch (Tt) {
          case 1015:
            ot.getter = et, ot.inputSize = 4;
            break;
          case 1016:
            ot.getter = J, ot.inputSize = 4;
        }
      }
      ot.blockCount = (O.dataWindow.yMax + 1) / ot.scanlineBlockSize;
      for (let It = 0; It < ot.blockCount; It++)
        st(V, gt);
      ot.outputChannels = ot.channels == 3 ? 4 : ot.channels;
      const St = ot.width * ot.height * ot.outputChannels;
      switch (Tt) {
        case 1015:
          ot.byteArray = new Float32Array(St), ot.channels < ot.outputChannels && ot.byteArray.fill(1, 0, St);
          break;
        case 1016:
          ot.byteArray = new Uint16Array(St), ot.channels < ot.outputChannels && ot.byteArray.fill(15360, 0, St);
          break;
        default:
          console.error("THREE.EXRLoader: unsupported type: ", Tt);
      }
      return ot.bytesPerLine = ot.width * ot.inputSize * ot.channels, ot.outputChannels == 4 ? (ot.format = 1023, ot.encoding = 3e3) : (ot.format = 1028, ot.encoding = 3e3), ot;
    }(pt, F, z, Y, this.type), lt = { value: 0 }, yt = { R: 0, G: 1, B: 2, A: 3, Y: 0 };
    for (let O = 0; O < ht.height / ht.scanlineBlockSize; O++) {
      const V = At(F, Y);
      ht.size = At(F, Y), ht.lines = V + ht.scanlineBlockSize > ht.height ? ht.height - V : ht.scanlineBlockSize;
      const tt = ht.size < ht.lines * ht.bytesPerLine ? ht.uncompress(ht) : nt(ht);
      Y.value += ht.size;
      for (let gt = 0; gt < ht.scanlineBlockSize; gt++) {
        const Tt = gt + O * ht.scanlineBlockSize;
        if (Tt >= ht.height)
          break;
        for (let ot = 0; ot < ht.channels; ot++) {
          const St = yt[pt.channels[ot].name];
          for (let It = 0; It < ht.width; It++) {
            lt.value = (gt * (ht.channels * ht.width) + ot * ht.width + It) * ht.inputSize;
            const xt = (ht.height - 1 - Tt) * (ht.width * ht.outputChannels) + It * ht.outputChannels + St;
            ht.byteArray[xt] = ht.getter(tt, lt);
          }
        }
      }
    }
    return { header: pt, width: ht.width, height: ht.height, data: ht.byteArray, format: ht.format, encoding: ht.encoding, type: this.type };
  }
  setDataType(t) {
    return this.type = t, this;
  }
  load(t, e, n, r) {
    return super.load(t, function(s, a) {
      s.encoding = a.encoding, s.minFilter = 1006, s.magFilter = 1006, s.generateMipmaps = !1, s.flipY = !1, e && e(s, a);
    }, n, r);
  }
}
class uat extends eS {
  constructor(t) {
    super(t), this.type = 1016;
  }
  parse(t) {
    const e = function(l, c) {
      switch (l) {
        case 1:
          console.error("THREE.RGBELoader Read Error: " + (c || ""));
          break;
        case 2:
          console.error("THREE.RGBELoader Write Error: " + (c || ""));
          break;
        case 3:
          console.error("THREE.RGBELoader Bad File Format: " + (c || ""));
          break;
        default:
          console.error("THREE.RGBELoader: Error: " + (c || ""));
      }
      return -1;
    }, n = function(l, c, u) {
      c = c || 1024;
      let h = l.pos, p = -1, f = 0, v = "", m = String.fromCharCode.apply(null, new Uint16Array(l.subarray(h, h + 128)));
      for (; 0 > (p = m.indexOf(`
`)) && f < c && h < l.byteLength; )
        v += m, f += m.length, h += 128, m += String.fromCharCode.apply(null, new Uint16Array(l.subarray(h, h + 128)));
      return -1 < p && (u !== !1 && (l.pos += f + p + 1), v + m.slice(0, p));
    }, r = function(l, c, u, h) {
      const p = l[c + 3], f = Math.pow(2, p - 128) / 255;
      u[h + 0] = l[c + 0] * f, u[h + 1] = l[c + 1] * f, u[h + 2] = l[c + 2] * f, u[h + 3] = 1;
    }, s = function(l, c, u, h) {
      const p = l[c + 3], f = Math.pow(2, p - 128) / 255;
      u[h + 0] = kl.toHalfFloat(Math.min(l[c + 0] * f, 65504)), u[h + 1] = kl.toHalfFloat(Math.min(l[c + 1] * f, 65504)), u[h + 2] = kl.toHalfFloat(Math.min(l[c + 2] * f, 65504)), u[h + 3] = kl.toHalfFloat(1);
    }, a = new Uint8Array(t);
    a.pos = 0;
    const o = function(l) {
      const c = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/, u = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/, h = /^\s*FORMAT=(\S+)\s*$/, p = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/, f = { valid: 0, string: "", comments: "", programtype: "RGBE", format: "", gamma: 1, exposure: 1, width: 0, height: 0 };
      let v, m;
      if (l.pos >= l.byteLength || !(v = n(l)))
        return e(1, "no header found");
      if (!(m = v.match(/^#\?(\S+)/)))
        return e(3, "bad initial token");
      for (f.valid |= 1, f.programtype = m[1], f.string += v + `
`; v = n(l), v !== !1; )
        if (f.string += v + `
`, v.charAt(0) !== "#") {
          if ((m = v.match(c)) && (f.gamma = parseFloat(m[1])), (m = v.match(u)) && (f.exposure = parseFloat(m[1])), (m = v.match(h)) && (f.valid |= 2, f.format = m[1]), (m = v.match(p)) && (f.valid |= 4, f.height = parseInt(m[1], 10), f.width = parseInt(m[2], 10)), 2 & f.valid && 4 & f.valid)
            break;
        } else
          f.comments += v + `
`;
      return 2 & f.valid ? 4 & f.valid ? f : e(3, "missing image size specifier") : e(3, "missing format specifier");
    }(a);
    if (o !== -1) {
      const l = o.width, c = o.height, u = function(h, p, f) {
        const v = p;
        if (v < 8 || v > 32767 || h[0] !== 2 || h[1] !== 2 || 128 & h[2])
          return new Uint8Array(h);
        if (v !== (h[2] << 8 | h[3]))
          return e(3, "wrong scanline width");
        const m = new Uint8Array(4 * p * f);
        if (!m.length)
          return e(4, "unable to allocate buffer space");
        let y = 0, _ = 0;
        const w = 4 * v, b = new Uint8Array(4), T = new Uint8Array(w);
        let M = f;
        for (; M > 0 && _ < h.byteLength; ) {
          if (_ + 4 > h.byteLength)
            return e(1);
          if (b[0] = h[_++], b[1] = h[_++], b[2] = h[_++], b[3] = h[_++], b[0] != 2 || b[1] != 2 || (b[2] << 8 | b[3]) != v)
            return e(3, "bad rgbe scanline format");
          let A, C = 0;
          for (; C < w && _ < h.byteLength; ) {
            A = h[_++];
            const k = A > 128;
            if (k && (A -= 128), A === 0 || C + A > w)
              return e(3, "bad scanline data");
            if (k) {
              const R = h[_++];
              for (let L = 0; L < A; L++)
                T[C++] = R;
            } else
              T.set(h.subarray(_, _ + A), C), C += A, _ += A;
          }
          const I = v;
          for (let k = 0; k < I; k++) {
            let R = 0;
            m[y] = T[k + R], R += v, m[y + 1] = T[k + R], R += v, m[y + 2] = T[k + R], R += v, m[y + 3] = T[k + R], y += 4;
          }
          M--;
        }
        return m;
      }(a.subarray(a.pos), l, c);
      if (u !== -1) {
        let h, p, f;
        switch (this.type) {
          case 1015:
            f = u.length / 4;
            const v = new Float32Array(4 * f);
            for (let y = 0; y < f; y++)
              r(u, 4 * y, v, 4 * y);
            h = v, p = 1015;
            break;
          case 1016:
            f = u.length / 4;
            const m = new Uint16Array(4 * f);
            for (let y = 0; y < f; y++)
              s(u, 4 * y, m, 4 * y);
            h = m, p = 1016;
            break;
          default:
            console.error("THREE.RGBELoader: unsupported type: ", this.type);
        }
        return { width: l, height: c, data: h, header: o.string, gamma: o.gamma, exposure: o.exposure, type: p };
      }
    }
    return null;
  }
  setDataType(t) {
    return this.type = t, this;
  }
  load(t, e, n, r) {
    return super.load(t, function(s, a) {
      switch (s.type) {
        case 1015:
        case 1016:
          s.encoding = 3e3, s.minFilter = 1006, s.magFilter = 1006, s.generateMipmaps = !1, s.flipY = !0;
      }
      e && e(s, a);
    }, n, r);
  }
}
const Po = class Po {
  constructor(t) {
    Po.pmremGenerator = new Yd(t), Po.pmremGenerator.compileEquirectangularShader();
  }
  static getLoader(t, e) {
    if (e === void 0 && (e = t.split(".").pop()), !Object.values(Td).includes(e))
      return De.warn(`Asset ${t} could not be loaded. Unknown type`), null;
    switch (e) {
      case Td.TEXTURE_EXR:
        return new hat();
      case Td.TEXTURE_HDR:
        return new uat();
      case Td.TEXTURE_8BPP:
        return new o0();
    }
  }
  static getEnvironment(t) {
    let e, n = null;
    return t.src ? (n = t.src, e = t.type) : n = t, new Promise((r, s) => {
      const a = Po.getLoader(n, e);
      a ? a.load(n, (o) => {
        const l = this.pmremGenerator.fromEquirectangular(o);
        this._cache[n] = l.texture, o.dispose(), r(l.texture);
      }, void 0, (o) => {
        s(`Loading asset ${n} failed ${o.message}`);
      }) : s(`Loading asset ${n} failed`);
    });
  }
  static getTexture(t) {
    let e, n = null;
    return t.src ? (n = t.src, e = t.type) : n = t, this._cache[n] ? Promise.resolve(this._cache[n]) : new Promise((r, s) => {
      if (n.includes("data:image")) {
        const a = new Image();
        a.src = n, a.onload = () => {
          const o = new Yn(a);
          o.needsUpdate = !0, this._cache[n] = o, r(o);
        }, a.onerror = (o) => {
          s(`Loading asset ${n} failed with ${o.toString()}`);
        };
      } else {
        const a = Po.getLoader(n, e);
        a ? a.load(n, (o) => {
          this._cache[n] = o, r(this._cache[n]);
        }, void 0, (o) => {
          s(`Loading asset ${n} failed ${o.message}`);
        }) : s(`Loading asset ${n} failed`);
      }
    });
  }
  static generateGradientRampTexture(t, e, n) {
  }
  static generateDiscreetRampTexture(t) {
    const e = t.length, n = new Uint8Array(4 * (1 * e));
    for (let s = 0; s < t.length; s++) {
      const a = 4 * s, o = new Ht(t[s]);
      o.convertSRGBToLinear(), n[a] = Math.floor(255 * o.r), n[a + 1] = Math.floor(255 * o.g), n[a + 2] = Math.floor(255 * o.b), n[a + 3] = 255;
    }
    const r = new Ro(n, e, 1);
    return r.needsUpdate = !0, r;
  }
};
U(Po, "_cache", {}), U(Po, "pmremGenerator");
let $l = Po;
var ki = ((i) => (i[i.SELECT = 0] = "SELECT", i[i.GHOST = 1] = "GHOST", i[i.GRADIENT = 2] = "GRADIENT", i[i.COLORED = 3] = "COLORED", i[i.OVERLAY = 4] = "OVERLAY", i[i.HIDDEN = 5] = "HIDDEN", i))(ki || {});
class dat {
  constructor(t) {
    U(this, "WTI");
    U(this, "Renderer");
    U(this, "StateKey", null);
    U(this, "VisibilityState", new pR());
    U(this, "ColorStringFilterState", null);
    U(this, "ColorNumericFilterState", null);
    U(this, "SelectionState", new rh());
    U(this, "HighlightState", new rh());
    U(this, "UserspaceColorState", new fR());
    U(this, "ColorStringFilterState2", null);
    U(this, "idCache", {});
    this.WTI = Qt.getInstance(), this.Renderer = t;
  }
  hideObjects(t, e = null, n = !1, r = !1) {
    return this.setVisibilityState(t, e, 10, n, r);
  }
  showObjects(t, e = null, n = !1) {
    return this.setVisibilityState(t, e, 11, n);
  }
  isolateObjects(t, e = null, n = !0, r = !0) {
    return this.setVisibilityState(t, e, 20, n, r);
  }
  unIsolateObjects(t, e = null, n = !0, r = !0) {
    return this.setVisibilityState(t, e, 21, n, r);
  }
  setVisibilityState(t, e = null, n, r = !1, s = !1) {
    if ((e !== this.StateKey || Math.abs(n - this.VisibilityState.command) > 1) && this.VisibilityState.reset(), this.StateKey = e, this.VisibilityState.rvs = [], this.VisibilityState.ghost = s, r && (t = [...t, ...this.getDescendantIds(t)]), n !== 11 && n !== 21 || (this.VisibilityState.ids = this.VisibilityState.ids.filter((o) => t.indexOf(o) === -1)), n !== 10 && n !== 20 || (this.VisibilityState.ids = [.../* @__PURE__ */ new Set([...t, ...this.VisibilityState.ids])]), this.VisibilityState.ids = this.VisibilityState.ids.filter((o) => o != null), this.VisibilityState.ids.length === 0)
      return this.VisibilityState.command = 30, this.setFilters();
    let a;
    return this.VisibilityState.command = n, n !== 10 && n !== 11 || (a = this.visibilityWalk), n !== 20 && n !== 21 || (a = this.isolationWalk), this.WTI.walk(a.bind(this)), this.setFilters();
  }
  visibilityWalk(t) {
    return !t.model.atomic || (this.VisibilityState.ids.indexOf(t.model.raw.id) !== -1 && this.VisibilityState.rvs.push(...Qt.getRenderTree().getRenderViewsForNode(t, t)), !0);
  }
  isolationWalk(t) {
    if (!t.model.atomic || t.model.id === "MOTHERSHIP")
      return !0;
    const e = Qt.getRenderTree().getRenderViewsForNode(t, t);
    return this.VisibilityState.ids.indexOf(t.model.raw.id) === -1 ? this.VisibilityState.rvs.push(...e) : this.VisibilityState.rvs = this.VisibilityState.rvs.filter((n) => !e.includes(n)), !0;
  }
  setColorFilter(t, e = !0) {
    return t.type === "number" ? (this.ColorStringFilterState = null, this.ColorNumericFilterState = new fat(), this.setNumericColorFilter(t, e)) : t.type === "string" ? (this.ColorNumericFilterState = null, this.ColorStringFilterState = new pat(), this.setStringColorFilter(t, e)) : void 0;
  }
  setNumericColorFilter(t, e) {
    this.ColorNumericFilterState.currentProp = t;
    const n = t.passMin || t.min, r = t.passMax || t.max, s = t.valueGroups.filter((c) => c.value >= n && c.value <= r).map((c) => c.id), a = t.valueGroups.filter((c) => c.value >= n && c.value <= r).map((c) => c.value), o = [], l = [];
    return Qt.getInstance().walk((c) => {
      if (!c.model.atomic || c.model.id === "MOTHERSHIP" || c.model.root)
        return !0;
      const u = Qt.getRenderTree().getRenderViewsForNode(c, c), h = s.indexOf(c.model.raw.id);
      h === -1 ? o.push(...u) : l.push({ rvs: u, value: (a[h] - n) / (r - n) });
    }), this.ColorNumericFilterState.colorGroups = l, this.ColorNumericFilterState.nonMatchingRvs = o, this.ColorNumericFilterState.ghost = e, this.ColorNumericFilterState.matchingIds = s, this.setFilters();
  }
  setStringColorFilter(t, e) {
    this.ColorStringFilterState.currentProp = t;
    const n = [];
    for (const a of t.valueGroups) {
      const o = eat(a.value);
      n.push({ ...a, color: new Ht(o), rvs: [] });
    }
    const r = $l.generateDiscreetRampTexture(n.map((a) => a.color.getHex())), s = [];
    return this.WTI.walk((a) => {
      if (!a.model.atomic || a.model.id === "MOTHERSHIP")
        return !0;
      const o = n.find((c) => c.ids.indexOf(a.model.raw.id) !== -1), l = Qt.getRenderTree().getRenderViewsForNode(a, a);
      return o ? (o.rvs.push(...l), !0) : (s.push(...l), !0);
    }), this.ColorStringFilterState.colorGroups = n, this.ColorStringFilterState.rampTexture = r, this.ColorStringFilterState.nonMatchingRvs = s, this.ColorStringFilterState.ghost = e, this.setFilters();
  }
  removeColorFilter() {
    return this.ColorStringFilterState = null, this.ColorNumericFilterState = null, this.setFilters();
  }
  selectObjects(t) {
    return this.populateGenericState(t, this.SelectionState);
  }
  highlightObjects(t, e = !1) {
    return this.HighlightState.ghost = e, this.populateGenericState(t, this.HighlightState);
  }
  setUserObjectColors(t) {
    this.UserspaceColorState = new fR(), this.ColorNumericFilterState = null, this.ColorStringFilterState = null;
    const e = t.map((r) => ({ ...r, nodes: [], rvs: [] }));
    Qt.getInstance().walk((r) => {
      var s, a;
      if (!((a = (s = r.model) == null ? void 0 : s.raw) != null && a.id))
        return !0;
      for (const o of e)
        if (o.objectIds.includes(r.model.raw.id)) {
          o.nodes.push(r);
          const l = Qt.getRenderTree().getRenderViewNodesForNode(r, r).map((c) => c.model.renderView);
          l && o.rvs.push(...l);
        }
      return !0;
    }), this.UserspaceColorState.groups = e;
    const n = $l.generateDiscreetRampTexture(t.map((r) => new Ht(r.color).getHex()));
    return this.UserspaceColorState.rampTexture = n, this.setFilters();
  }
  removeUserObjectColors() {
    return this.UserspaceColorState = null, this.setFilters();
  }
  populateGenericState(t, e) {
    let n = [...t, ...this.getDescendantIds(t)];
    n = [...Array.from(new Set(n.map((s) => s)))], e.rvs = [], e.ids = [];
    const r = [];
    if (n.length !== 0) {
      Qt.getInstance().walk((s) => (n.indexOf(s.model.raw.id) !== -1 && r.push(s), !0));
      for (let s = 0; s < r.length; s++) {
        const a = Qt.getRenderTree().getRenderViewNodesForNode(r[s], r[s]);
        a && (e.rvs.push(...a.map((o) => o.model.renderView)), e.ids.push(...a.map((o) => o.model.raw.id)));
      }
    }
    return this.setFilters();
  }
  resetSelection() {
    return this.SelectionState = new rh(), this.setFilters();
  }
  resetHighlight() {
    return this.HighlightState = new rh(), this.setFilters();
  }
  reset() {
    return this.Renderer.clearFilter(), this.VisibilityState = new pR(), this.ColorStringFilterState = null, this.ColorNumericFilterState = null, this.SelectionState = new rh(), this.HighlightState = new rh(), this.UserspaceColorState = null, this.StateKey = null, null;
  }
  setFilters() {
    var a, o;
    const t = {};
    if (this.Renderer.clearFilter(), this.Renderer.beginFilter(), this.ColorStringFilterState) {
      t.colorGroups = [];
      let l = -1;
      for (const c of this.ColorStringFilterState.colorGroups)
        l++, this.Renderer.applyFilter(c.rvs, { filterType: 3, rampIndex: l / this.ColorStringFilterState.colorGroups.length, rampIndexColor: c.color, rampTexture: this.ColorStringFilterState.rampTexture }), t.colorGroups.push({ value: c.value, color: c.color.getHexString(), ids: c.ids }), t.activePropFilterKey = this.ColorStringFilterState.currentProp.key;
    }
    if (this.ColorNumericFilterState) {
      for (const l of this.ColorNumericFilterState.colorGroups)
        this.Renderer.applyFilter(l.rvs, { filterType: 2, rampIndex: l.value });
      t.activePropFilterKey = this.ColorNumericFilterState.currentProp.key, t.passMin = this.ColorNumericFilterState.currentProp.passMin || this.ColorNumericFilterState.currentProp.min, t.passMax = this.ColorNumericFilterState.currentProp.passMax || this.ColorNumericFilterState.currentProp.max, t.isolatedObjects = this.ColorNumericFilterState.matchingIds;
    }
    const e = this.VisibilityState.command === 10 || this.VisibilityState.command === 11, n = this.VisibilityState.command === 20 || this.VisibilityState.command === 21;
    (e || n) && (this.Renderer.applyFilter(this.VisibilityState.rvs, { filterType: this.VisibilityState.ghost ? 1 : 5 }), e && (t.hiddenObjects = this.VisibilityState.ids), n && (t.isolatedObjects = this.VisibilityState.ids));
    const r = ((a = this.ColorStringFilterState) == null ? void 0 : a.nonMatchingRvs) || ((o = this.ColorNumericFilterState) == null ? void 0 : o.nonMatchingRvs);
    let s = !1;
    if (this.ColorStringFilterState && (s = this.ColorStringFilterState.ghost), this.ColorNumericFilterState && (s = this.ColorNumericFilterState.ghost), r && this.Renderer.applyFilter(r, { filterType: s ? 1 : 5 }), this.UserspaceColorState) {
      t.userColorGroups = [];
      let l = -1;
      for (const c of this.UserspaceColorState.groups)
        l++, this.Renderer.applyFilter(c.rvs, { filterType: 3, rampIndex: l / this.UserspaceColorState.groups.length, rampIndexColor: new Ht(c.color), rampTexture: this.UserspaceColorState.rampTexture }), t.userColorGroups.push({ ids: c.objectIds, color: c.color });
    }
    return this.HighlightState.rvs.length !== 0 && this.Renderer.applyFilter(this.HighlightState.rvs, { filterType: this.HighlightState.ghost ? 1 : 4 }), this.SelectionState.rvs.length !== 0 && this.Renderer.applyFilter(this.SelectionState.rvs, { filterType: 0 }), this.Renderer.endFilter(), this.Renderer.viewer.requestRender(), t;
  }
  getDescendantIds(t) {
    const e = [], n = t.join(",");
    return this.idCache[n] ? this.idCache[n] : (this.WTI.walk((r) => {
      if (t.includes(r.model.raw.id) && r.model.raw.__closure) {
        const s = Object.keys(r.model.raw.__closure);
        e.push(...s), this.idCache[r.model.raw.id] = s;
      }
      return !0;
    }), this.idCache[n] = e, e);
  }
}
class pR {
  constructor() {
    U(this, "command", 30);
    U(this, "ghost", !0);
    U(this, "ids", []);
    U(this, "rvs", []);
  }
  reset() {
    this.ghost = !0, this.ids = [], this.rvs = [];
  }
}
class pat {
  constructor() {
    U(this, "currentProp");
    U(this, "colorGroups");
    U(this, "nonMatchingRvs");
    U(this, "rampTexture");
    U(this, "ghost", !0);
  }
  reset() {
    this.currentProp = null, this.colorGroups = [], this.nonMatchingRvs = [], this.rampTexture = null;
  }
}
class fat {
  constructor() {
    U(this, "currentProp");
    U(this, "nonMatchingRvs");
    U(this, "colorGroups");
    U(this, "ghost", !0);
    U(this, "matchingIds");
  }
}
class rh {
  constructor() {
    U(this, "ids", []);
    U(this, "rvs", []);
    U(this, "ghost", !1);
  }
  reset() {
    this.rvs = [], this.ids = [];
  }
}
class fR {
  constructor() {
    U(this, "groups", []);
    U(this, "rampTexture");
  }
  reset() {
    this.groups = [];
  }
}
const Sr = class Sr extends Ds {
  constructor(t, e = []) {
    super(t), this.userData.uViewer_high = { value: new D() }, this.userData.uViewer_low = { value: new D() }, this.userData.gradientRamp = { value: null }, this.userData.rteShadowMatrix = { value: new Vt() }, this.userData.uShadowViewer_high = { value: new D() }, this.userData.uShadowViewer_low = { value: new D() }, this.vertProgram = `
#define STANDARD
#ifdef USE_RTE
    // The high component is stored as the default 'position' attribute buffer
    attribute vec3 position_low;
    uniform vec3 uViewer_high;
    uniform vec3 uViewer_low;
#endif

varying vec3 vViewPosition;

#ifdef USE_TRANSMISSION

    varying vec3 vWorldPosition;

#endif

#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

attribute float gradientIndex;
varying float vGradientIndex;

vec4 computeRelativePositionSeparate(in vec3 position_low, in vec3 position_high, in vec3 relativeTo_low, in vec3 relativeTo_high){
    /* 
    Vector calculation for the high and low differences works on everything 
    *BESIDES* Apple Silicon (or whatever they call it) GPUs

    It would seem that when this code gets compiled, vector types get a lower precision(?)
    which completely brakes the 2 float -> double reconstructio. Doing it separately for each 
    vector component using floats works fine.
    */
    vec3 highDifference;
    vec3 lowDifference;
    float t1 = position_low.x - relativeTo_low.x;
    float e = t1 - position_low.x;
    float t2 = ((-relativeTo_low.x - e) + (position_low.x - (t1 - e))) + position_high.x - relativeTo_high.x;
    highDifference.x = t1 + t2;
    lowDifference.x = t2 - (highDifference.x - t1);

    t1 = position_low.y - relativeTo_low.y;
    e = t1 - position_low.y;
    t2 = ((-relativeTo_low.y - e) + (position_low.y - (t1 - e))) + position_high.y - relativeTo_high.y;
    highDifference.y = t1 + t2;
    lowDifference.y = t2 - (highDifference.y - t1);

    t1 = position_low.z - relativeTo_low.z;
    e = t1 - position_low.z;
    t2 = ((-relativeTo_low.z - e) + (position_low.z - (t1 - e))) + position_high.z - relativeTo_high.z;
    highDifference.z = t1 + t2;
    lowDifference.z = t2 - (highDifference.z - t1);

    vec3 position = highDifference.xyz + lowDifference.xyz;
    return vec4(position, 1.);
}

vec4 computeRelativePosition(in vec3 position_low, in vec3 position_high, in vec3 relativeTo_low, in vec3 relativeTo_high){
    /* 
    Source https://github.com/virtualglobebook/OpenGlobe/blob/master/Source/Examples/Chapter05/Jitter/GPURelativeToEyeDSFUN90/Shaders/VS.glsl 
    Note here, we're storing the high part of the position encoding inside three's default 'position' attribute buffer so we avoid redundancy 
    */
    vec3 t1 = position_low.xyz - relativeTo_low;
    vec3 e = t1 - position_low.xyz;
    vec3 t2 = ((-relativeTo_low - e) + (position_low.xyz - (t1 - e))) + position_high.xyz - relativeTo_high;
    vec3 highDifference = t1 + t2;
    vec3 lowDifference = t2 - (highDifference - t1);
    
    vec3 position = highDifference.xyz + lowDifference.xyz;
    return vec4(position, 1.);
}

void main() {

    #include <uv_vertex>
    #include <uv2_vertex>
    #include <color_vertex>
    #include <morphcolor_vertex>
    #include <beginnormal_vertex>
    #include <morphnormal_vertex>
    #include <skinbase_vertex>
    #include <skinnormal_vertex>
    #include <defaultnormal_vertex>
    #include <normal_vertex>

    #include <begin_vertex>
    #include <morphtarget_vertex>
    #include <skinning_vertex>
    #include <displacementmap_vertex>
    //#include <project_vertex> // EDITED CHUNK
    #ifdef USE_RTE
        vec4 mvPosition = computeRelativePositionSeparate(position_low.xyz, position.xyz, uViewer_low, uViewer_high);
    #else
        vec4 mvPosition = vec4( transformed, 1.0 );
    #endif
    
    #ifdef USE_INSTANCING

        mvPosition = instanceMatrix * mvPosition;

    #endif
    mvPosition = modelViewMatrix * mvPosition;
    vGradientIndex = gradientIndex;
    gl_Position = projectionMatrix * mvPosition;


    #include <logdepthbuf_vertex>
    #include <clipping_planes_vertex>

    vViewPosition = - mvPosition.xyz;

    #include <worldpos_vertex>
    #include <shadowmap_vertex>
    #include <fog_vertex>

#ifdef USE_TRANSMISSION

    vWorldPosition = worldPosition.xyz;

#endif
}
`, this.fragProgram = `
#define STANDARD

#ifdef PHYSICAL
    #define IOR
    #define SPECULAR
#endif

uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;

#ifdef IOR
    uniform float ior;
#endif

#ifdef SPECULAR
    uniform float specularIntensity;
    uniform vec3 specularColor;

    #ifdef USE_SPECULARINTENSITYMAP
        uniform sampler2D specularIntensityMap;
    #endif

    #ifdef USE_SPECULARCOLORMAP
        uniform sampler2D specularColorMap;
    #endif
#endif

#ifdef USE_CLEARCOAT
    uniform float clearcoat;
    uniform float clearcoatRoughness;
#endif

#ifdef USE_SHEEN
    uniform vec3 sheenColor;
    uniform float sheenRoughness;

    #ifdef USE_SHEENCOLORMAP
        uniform sampler2D sheenColorMap;
    #endif

    #ifdef USE_SHEENROUGHNESSMAP
        uniform sampler2D sheenRoughnessMap;
    #endif
#endif

varying vec3 vViewPosition;

varying float vGradientIndex;
uniform sampler2D gradientRamp;

#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <bsdfs>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

    #include <clipping_planes_fragment>

    vec4 diffuseColor = vec4( texture2D(gradientRamp, vec2(vGradientIndex, 0.)).rgb, opacity );
    ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
    vec3 totalEmissiveRadiance = emissive;

    #include <logdepthbuf_fragment>
    #include <map_fragment>
    #include <color_fragment>
    #include <alphamap_fragment>
    #include <alphatest_fragment>
    #include <roughnessmap_fragment>
    #include <metalnessmap_fragment>
    #include <normal_fragment_begin>
    #include <normal_fragment_maps>
    #include <clearcoat_normal_fragment_begin>
    #include <clearcoat_normal_fragment_maps>
    #include <emissivemap_fragment>

    // accumulation
    #include <lights_physical_fragment>
    #include <lights_fragment_begin>
    #include <lights_fragment_maps>
    #include <lights_fragment_end>

    // modulation
    #include <aomap_fragment>

    vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
    vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;

    #include <transmission_fragment>

    vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;

    #ifdef USE_SHEEN

        // Sheen energy compensation approximation calculation can be found at the end of
        // https://drive.google.com/file/d/1T0D1VSyR4AllqIJTQAraEIzjlb5h4FKH/view?usp=sharing
        float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );

        outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;

    #endif

    #ifdef USE_CLEARCOAT

        float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );

        vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );

        outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;

    #endif

    #include <output_fragment>
    #include <tonemapping_fragment>
    #include <encodings_fragment>
    #include <fog_fragment>
    #include <premultiplied_alpha_fragment>
    #include <dithering_fragment>
}
`, this.uniforms = Jn.merge([Pn.standard.uniforms, { uViewer_high: { value: this.userData.uViewer_high.value }, uViewer_low: { value: this.userData.uViewer_low.value }, gradientRamp: { value: this.userData.gradientRamp }, rteShadowMatrix: { value: this.userData.rteShadowMatrix.value }, uShdowViewer_high: { value: this.userData.uShadowViewer_high.value }, uShadowViewer_low: { value: this.userData.uShadowViewer_low.value } }]), this.onBeforeCompile = function(n) {
      n.uniforms.uViewer_high = this.userData.uViewer_high, n.uniforms.uViewer_low = this.userData.uViewer_low, n.uniforms.gradientRamp = this.userData.gradientRamp, n.uniforms.rteShadowMatrix = this.userData.rteShadowMatrix, n.uniforms.uShadowViewer_high = this.userData.uShadowViewer_high, n.uniforms.uShadowViewer_low = this.userData.uShadowViewer_low, n.vertexShader = this.vertProgram, n.fragmentShader = this.fragProgram;
    }, e && (this.defines = {});
    for (let n = 0; n < e.length; n++)
      this.defines[e[n]] = " ";
  }
  copy(t) {
    return super.copy(t), this.userData = {}, this.userData.uViewer_high = { value: new D() }, this.userData.uViewer_low = { value: new D() }, this.userData.gradientRamp = { value: null }, this.userData.rteShadowMatrix = { value: new Vt() }, this.userData.uShadowViewer_high = { value: new D() }, this.userData.uShadowViewer_low = { value: new D() }, this.defines.USE_RTE = " ", this;
  }
  setGradientTexture(t) {
    this.userData.gradientRamp.value = t, this.userData.gradientRamp.value.generateMipmaps = !1, this.userData.gradientRamp.value.minFilter = 1003, this.userData.gradientRamp.value.magFilter = 1003, this.needsUpdate = !0;
  }
  onBeforeRender(t, e, n, r, s, a) {
    Sr.matBuff.copy(n.matrixWorldInverse), Sr.matBuff.elements[12] = 0, Sr.matBuff.elements[13] = 0, Sr.matBuff.elements[14] = 0, Sr.matBuff.multiply(s.matrixWorld), s.modelViewMatrix.copy(Sr.matBuff), Sr.vecBuff0.set(n.matrixWorld.elements[12], n.matrixWorld.elements[13], n.matrixWorld.elements[14]), Nn.DoubleToHighLowVector(Sr.vecBuff0, Sr.vecBuff1, Sr.vecBuff2), this.userData.uViewer_low.value.copy(Sr.vecBuff1), this.userData.uViewer_high.value.copy(Sr.vecBuff2), this.needsUpdate = !0;
  }
};
U(Sr, "matBuff", new Vt()), U(Sr, "vecBuff0", new D()), U(Sr, "vecBuff1", new D()), U(Sr, "vecBuff2", new D());
let Ch = Sr;
const mR = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAgAAAAABCAIAAAAn2YEhAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAHoSURBVDhPTZRRdoMwDAQx9//seaEzI5sXpwFptVqvMOm6/t7retd1Le8XAdF6+SMEYr03l2fF4GJprcfixl4+tyklG6ZvxeAKWGxBQsKDk9FIdD+pDUFiak9IDQEWMAM4dczEZmWSDOXPBuAQ1OCLYI4bc0S0bbnlFOR6Vgo2WwgraIvgbh8L2ZNxRH5T7QWKyKz9E7kNnUE+KTA3Oz6O3YIOkop+4juHoh1H+m3slByVm9vgOCOoXr7HvBJSjLdJRUHuSrbse+jDiZOPPt/jZIv8WPJeW+JVzYj2CIHc9GaEjmc/OhF3C+neQoBgW/KKZx2VuyxFKqDBNwfqA8NXa7p0781GBT6TPkSOozQPMPer4sBqTrvZUZgqSKP5oaCXXirJdZ4jqyRbtyE8amCkLLkzW9qik7Fx9mWE9pHEh9vMHsIawZSPcxut2DcDyjzeKinisypDwQoKnLU5WVLz7pGO/nbrIhC2MMOaGrj8PRLmfKpSJcT4NZn5wFgbKbVlCzia76HbQZMAjP72IyX94v189i7Ewfa2wcdMTfGOqekE2i/O9LZRi/T8qwFuuvknA3kW/YnLTMVO22OwUXg0OZ1IAdeqcEjXffH2jjEqNmSvRZbF43BLuUPsYsk5XPu3NqD3WKzr/QfN+6p+JpC7ZQAAAABJRU5ErkJggg==", Mr = class Mr extends ci {
  constructor(t, e = []) {
    super(t), this.userData.uViewer_high = { value: new D() }, this.userData.uViewer_low = { value: new D() }, this.vertProgram = `
#include <common>
#ifdef USE_RTE
    // The high component is stored as the default 'position' attribute buffer
    attribute vec3 position_low;
    uniform vec3 uViewer_high;
    uniform vec3 uViewer_low;
#endif
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

vec4 computeRelativePositionSeparate(in vec3 position_low, in vec3 position_high, in vec3 relativeTo_low, in vec3 relativeTo_high){
    /* 
    Vector calculation for the high and low differences works on everything 
    *BESIDES* Apple Silicon (or whatever they call it) GPUs

    It would seem that when this code gets compiled, vector types get a lower precision(?)
    which completely brakes the 2 float -> double reconstructio. Doing it separately for each 
    vector component using floats works fine.
    */
    vec3 highDifference;
    vec3 lowDifference;
    float t1 = position_low.x - relativeTo_low.x;
    float e = t1 - position_low.x;
    float t2 = ((-relativeTo_low.x - e) + (position_low.x - (t1 - e))) + position_high.x - relativeTo_high.x;
    highDifference.x = t1 + t2;
    lowDifference.x = t2 - (highDifference.x - t1);

    t1 = position_low.y - relativeTo_low.y;
    e = t1 - position_low.y;
    t2 = ((-relativeTo_low.y - e) + (position_low.y - (t1 - e))) + position_high.y - relativeTo_high.y;
    highDifference.y = t1 + t2;
    lowDifference.y = t2 - (highDifference.y - t1);

    t1 = position_low.z - relativeTo_low.z;
    e = t1 - position_low.z;
    t2 = ((-relativeTo_low.z - e) + (position_low.z - (t1 - e))) + position_high.z - relativeTo_high.z;
    highDifference.z = t1 + t2;
    lowDifference.z = t2 - (highDifference.z - t1);

    vec3 position = highDifference.xyz + lowDifference.xyz;
    return vec4(position, 1.);
}

vec4 computeRelativePosition(in vec3 position_low, in vec3 position_high, in vec3 relativeTo_low, in vec3 relativeTo_high){
    /* 
    Source https://github.com/virtualglobebook/OpenGlobe/blob/master/Source/Examples/Chapter05/Jitter/GPURelativeToEyeDSFUN90/Shaders/VS.glsl 
    Note here, we're storing the high part of the position encoding inside three's default 'position' attribute buffer so we avoid redundancy 
    */
    vec3 t1 = position_low.xyz - relativeTo_low;
    vec3 e = t1 - position_low.xyz;
    vec3 t2 = ((-relativeTo_low - e) + (position_low.xyz - (t1 - e))) + position_high.xyz - relativeTo_high;
    vec3 highDifference = t1 + t2;
    vec3 lowDifference = t2 - (highDifference - t1);
    
    vec3 position = highDifference.xyz + lowDifference.xyz;
    return vec4(position, 1.);
}

void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	// #include <project_vertex> COMMENTED CHUNK
    #ifdef USE_RTE
        vec4 mvPosition = computeRelativePositionSeparate(position_low.xyz, position.xyz, uViewer_low, uViewer_high);
    #else
        vec4 mvPosition = vec4( transformed, 1.0 );
    #endif
    
    #ifdef USE_INSTANCING

        mvPosition = instanceMatrix * mvPosition;

    #endif
    mvPosition = modelViewMatrix * mvPosition;

    gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}
`, this.fragProgram = `
uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	// accumulation (baked indirect lighting only)
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	// modulation
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}
`, this.uniforms = Jn.merge([Pn.standard.uniforms, { uViewer_high: { value: this.userData.uViewer_high.value }, uViewer_low: { value: this.userData.uViewer_low.value } }]), this.onBeforeCompile = function(n) {
      n.uniforms.uViewer_high = this.userData.uViewer_high, n.uniforms.uViewer_low = this.userData.uViewer_low, n.vertexShader = this.vertProgram, n.fragmentShader = this.fragProgram;
    }, e && (this.defines = {});
    for (let n = 0; n < e.length; n++)
      this.defines[e[n]] = " ";
  }
  copy(t) {
    return super.copy(t), this.userData = {}, this.userData.uViewer_high = { value: new D() }, this.userData.uViewer_low = { value: new D() }, this.defines.USE_RTE = " ", this;
  }
  onBeforeRender(t, e, n, r, s, a) {
    Mr.matBuff.copy(n.matrixWorldInverse), Mr.matBuff.elements[12] = 0, Mr.matBuff.elements[13] = 0, Mr.matBuff.elements[14] = 0, Mr.matBuff.multiply(s.matrixWorld), s.modelViewMatrix.copy(Mr.matBuff), Mr.vecBuff0.set(n.matrixWorld.elements[12], n.matrixWorld.elements[13], n.matrixWorld.elements[14]), Nn.DoubleToHighLowVector(Mr.vecBuff0, Mr.vecBuff1, Mr.vecBuff2), this.userData.uViewer_low.value.copy(Mr.vecBuff1), this.userData.uViewer_high.value.copy(Mr.vecBuff2), this.needsUpdate = !0;
  }
};
U(Mr, "matBuff", new Vt()), U(Mr, "vecBuff0", new D()), U(Mr, "vecBuff1", new D()), U(Mr, "vecBuff2", new D());
let Kh = Mr;
class vz extends Kh {
  constructor(t, e = []) {
    super(t), this.userData.uViewer_high = { value: new D() }, this.userData.uViewer_low = { value: new D() }, this.vertProgram = `
#include <common>
#ifdef USE_RTE
    // The high component is stored as the default 'position' attribute buffer
    attribute vec3 position_low;
    uniform vec3 uViewer_high;
    uniform vec3 uViewer_low;
#endif
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

vec4 computeRelativePositionSeparate(in vec3 position_low, in vec3 position_high, in vec3 relativeTo_low, in vec3 relativeTo_high){
    /* 
    Vector calculation for the high and low differences works on everything 
    *BESIDES* Apple Silicon (or whatever they call it) GPUs

    It would seem that when this code gets compiled, vector types get a lower precision(?)
    which completely brakes the 2 float -> double reconstructio. Doing it separately for each 
    vector component using floats works fine.
    */
    vec3 highDifference;
    vec3 lowDifference;
    float t1 = position_low.x - relativeTo_low.x;
    float e = t1 - position_low.x;
    float t2 = ((-relativeTo_low.x - e) + (position_low.x - (t1 - e))) + position_high.x - relativeTo_high.x;
    highDifference.x = t1 + t2;
    lowDifference.x = t2 - (highDifference.x - t1);

    t1 = position_low.y - relativeTo_low.y;
    e = t1 - position_low.y;
    t2 = ((-relativeTo_low.y - e) + (position_low.y - (t1 - e))) + position_high.y - relativeTo_high.y;
    highDifference.y = t1 + t2;
    lowDifference.y = t2 - (highDifference.y - t1);

    t1 = position_low.z - relativeTo_low.z;
    e = t1 - position_low.z;
    t2 = ((-relativeTo_low.z - e) + (position_low.z - (t1 - e))) + position_high.z - relativeTo_high.z;
    highDifference.z = t1 + t2;
    lowDifference.z = t2 - (highDifference.z - t1);

    vec3 position = highDifference.xyz + lowDifference.xyz;
    return vec4(position, 1.);
}

vec4 computeRelativePosition(in vec3 position_low, in vec3 position_high, in vec3 relativeTo_low, in vec3 relativeTo_high){
    /* 
    Source https://github.com/virtualglobebook/OpenGlobe/blob/master/Source/Examples/Chapter05/Jitter/GPURelativeToEyeDSFUN90/Shaders/VS.glsl 
    Note here, we're storing the high part of the position encoding inside three's default 'position' attribute buffer so we avoid redundancy 
    */
    vec3 t1 = position_low.xyz - relativeTo_low;
    vec3 e = t1 - position_low.xyz;
    vec3 t2 = ((-relativeTo_low - e) + (position_low.xyz - (t1 - e))) + position_high.xyz - relativeTo_high;
    vec3 highDifference = t1 + t2;
    vec3 lowDifference = t2 - (highDifference - t1);
    
    vec3 position = highDifference.xyz + lowDifference.xyz;
    return vec4(position, 1.);
}

void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	// #include <project_vertex> COMMENTED CHUNK
    #ifdef USE_RTE
        vec4 mvPosition = computeRelativePositionSeparate(position_low.xyz, position.xyz, uViewer_low, uViewer_high);
    #else
        vec4 mvPosition = vec4( transformed, 1.0 );
    #endif
    
    #ifdef USE_INSTANCING

        mvPosition = instanceMatrix * mvPosition;

    #endif
    mvPosition = modelViewMatrix * mvPosition;

    gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}
`, this.fragProgram = `
uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
    // We're disabling alpha testing because we need to use it for shadow rejection. Three.js gave me no choice
	// #include <alphatest_fragment> 
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	// accumulation (baked indirect lighting only)
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	// modulation
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}
`, this.uniforms = Jn.merge([Pn.standard.uniforms, { uViewer_high: { value: this.userData.uViewer_high.value }, uViewer_low: { value: this.userData.uViewer_low.value } }]), this.onBeforeCompile = function(n) {
      n.uniforms.uViewer_high = this.userData.uViewer_high, n.uniforms.uViewer_low = this.userData.uViewer_low, n.vertexShader = this.vertProgram, n.fragmentShader = this.fragProgram;
    }, e && (this.defines = {});
    for (let n = 0; n < e.length; n++)
      this.defines[e[n]] = " ";
  }
}
class xb {
  constructor() {
    U(this, "materialMap", {});
    U(this, "meshHighlightMaterial", null);
    U(this, "meshTransparentHighlightMaterial", null);
    U(this, "meshGhostMaterial", null);
    U(this, "meshGradientMaterial", null);
    U(this, "meshTransparentGradientMaterial", null);
    U(this, "meshColoredMaterial", null);
    U(this, "meshTransparentColoredMaterial", null);
    U(this, "meshHiddenMaterial", null);
    U(this, "meshOverlayMaterial", null);
    U(this, "meshTransparentOverlayMaterial", null);
    U(this, "lineHighlightMaterial", null);
    U(this, "lineGhostMaterial", null);
    U(this, "lineColoredMaterial", null);
    U(this, "lineHiddenMaterial", null);
    U(this, "lineOverlayMaterial", null);
    U(this, "pointCloudHighlightMaterial", null);
    U(this, "pointHighlightMaterial", null);
    U(this, "pointGhostMaterial", null);
    U(this, "pointOverlayMaterial", null);
    U(this, "pointCloudOverlayMaterial", null);
  }
  static renderMaterialFromNode(t) {
    var s, a;
    if (!t)
      return null;
    const e = (a = (s = t == null ? void 0 : t.model) == null ? void 0 : s.raw) == null ? void 0 : a.renderMaterial;
    if (!e)
      return null;
    const n = (o) => o ? { id: o.id, color: o.diffuse, roughness: o.roughness, metalness: o.metalness, vertexColors: t.model.raw.colors && t.model.raw.colors.length > 0, emissive: o.emissive, bumpScale: o.bumpScale, emissiveIntensity: o.emissiveIntensity, opacity: o.opacity !== void 0 ? o.opacity : 1, alphaTest: o.alphaTest, side: o.side, depthTest: o.depthTest, depthWrite: o.depthWrite, transparent: o.transparent, toneMapped: o.toneMapped, userData: { blobIds: o.blobIds, aoBlobIds: o.aoBlobIds, normalBlobIds: o.normalBlobIds, metalnessBlobIds: o.metalnessBlobIds, roughnessBlobIds: o.roughnessBlobIds, emissiveBlobIds: o.emissiveBlobIds, alphaBlobIds: o.alphaBlobIds, bumpBlobIds: o.bumpBlobIds, emissiveIntensity: o.emissiveIntensity, opacity: o.opacity !== void 0 ? o.opacity : 1, alphaTest: o.alphaTest, side: o.side, depthTest: o.depthTest, depthWrite: o.depthWrite, transparent: o.transparent, toneMapped: o.toneMapped } } : null;
    if (!Array.isArray(e))
      return n(e);
    const r = [];
    for (let o = 0; o < e.length; o++)
      r.push(n(e[o]));
    return r;
  }
  static displayStyleFromNode(t) {
    if (!t)
      return null;
    let e = null;
    if (t.model.raw.displayStyle) {
      let n = t.model.raw.displayStyle.lineweight || 0;
      const r = t.model.raw.displayStyle.units;
      n = r ? n * Li(r) : 0, n = n < 1e-3 ? 0 : n, e = { id: t.model.raw.displayStyle.id, color: t.model.raw.displayStyle.diffuse || t.model.raw.displayStyle.color, lineWeight: n };
    } else
      t.model.raw.renderMaterial && (e = { id: t.model.raw.renderMaterial.id, color: t.model.raw.renderMaterial.diffuse, lineWeight: 0, pattern: t.model.raw.renderMaterial.pattern });
    return e;
  }
  async createDefaultMeshMaterials() {
    this.meshHighlightMaterial = new rs({ color: 294651, emissive: 0, roughness: 1, metalness: 0, side: 2 }, ["USE_RTE"]), this.meshHighlightMaterial.clipShadows = !0, this.meshHighlightMaterial.stencilWrite = !0, this.meshHighlightMaterial.stencilWriteMask = 255, this.meshHighlightMaterial.stencilRef = 0, this.meshHighlightMaterial.stencilFunc = 519, this.meshHighlightMaterial.stencilZFail = 7681, this.meshHighlightMaterial.stencilZPass = 7681, this.meshHighlightMaterial.stencilFail = 7681, this.meshTransparentHighlightMaterial = new rs({ color: 294651, emissive: 0, roughness: 1, metalness: 0, side: 2, transparent: !0, opacity: 0.5 }, ["USE_RTE"]), this.meshTransparentHighlightMaterial.clipShadows = !0, this.meshTransparentHighlightMaterial.stencilWrite = !0, this.meshTransparentHighlightMaterial.stencilWriteMask = 255, this.meshTransparentHighlightMaterial.stencilRef = 0, this.meshTransparentHighlightMaterial.stencilFunc = 519, this.meshTransparentHighlightMaterial.stencilZFail = 7681, this.meshTransparentHighlightMaterial.stencilZPass = 7681, this.meshTransparentHighlightMaterial.stencilFail = 7681, this.meshGhostMaterial = new vz({ color: 16777215, side: 0, transparent: !0, opacity: 0.1 }, ["USE_RTE"]), this.meshGhostMaterial.depthWrite = !1, this.meshGhostMaterial.alphaTest = 1, this.meshGradientMaterial = new Ch({ side: 2, transparent: !1, opacity: 1 }, ["USE_RTE"]), this.meshGradientMaterial.setGradientTexture(await $l.getTexture(mR)), this.meshGradientMaterial.clipShadows = !0, this.meshTransparentGradientMaterial = new Ch({ side: 2, transparent: !0, opacity: 0.5 }, ["USE_RTE"]), this.meshTransparentGradientMaterial.setGradientTexture(await $l.getTexture(mR)), this.meshTransparentGradientMaterial.clipShadows = !0, this.meshColoredMaterial = new Ch({ side: 2, transparent: !1, opacity: 1, wireframe: !1 }, ["USE_RTE"]), this.meshColoredMaterial.clipShadows = !0, this.meshTransparentColoredMaterial = new Ch({ side: 2, transparent: !0, opacity: 0.5 }, ["USE_RTE"]), this.meshHiddenMaterial = new rs({ side: 2, transparent: !1, opacity: 1, wireframe: !1 }, ["USE_RTE"]), this.meshHiddenMaterial.visible = !1, this.meshOverlayMaterial = new rs({ color: 314363, emissive: 0, roughness: 1, metalness: 0, side: 2 }, ["USE_RTE"]), this.meshOverlayMaterial.clipShadows = !0, this.meshTransparentOverlayMaterial = new rs({ color: 314363, emissive: 0, roughness: 1, metalness: 0, side: 2, transparent: !0, opacity: 0.5 }, ["USE_RTE"]), this.meshTransparentHighlightMaterial.color.convertSRGBToLinear(), this.meshHighlightMaterial.color.convertSRGBToLinear(), this.meshOverlayMaterial.color.convertSRGBToLinear(), this.meshTransparentOverlayMaterial.color.convertSRGBToLinear();
  }
  async createLineDefaultMaterials() {
    this.lineHighlightMaterial = new Ss({ color: 294651, linewidth: 1, worldUnits: !1, vertexColors: !0, alphaToCoverage: !1, resolution: new wt() }), this.lineHighlightMaterial.color = new Ht(294651), this.lineHighlightMaterial.linewidth = 1, this.lineHighlightMaterial.worldUnits = !1, this.lineHighlightMaterial.vertexColors = !0, this.lineHighlightMaterial.pixelThreshold = 0.5, this.lineHighlightMaterial.resolution = new wt(), this.lineGhostMaterial = new Ss({ color: 16777215, linewidth: 1, worldUnits: !1, vertexColors: !0, alphaToCoverage: !1, resolution: new wt() }), this.lineGhostMaterial.color = new Ht(16777215), this.lineGhostMaterial.linewidth = 1, this.lineGhostMaterial.worldUnits = !0, this.lineGhostMaterial.vertexColors = !0, this.lineGhostMaterial.pixelThreshold = 0.5, this.lineGhostMaterial.resolution = new wt(), this.lineColoredMaterial = new Ss({ color: 16777215, linewidth: 1, worldUnits: !1, vertexColors: !0, alphaToCoverage: !1, resolution: new wt() }), this.lineColoredMaterial.color = new Ht(16777215), this.lineColoredMaterial.linewidth = 1, this.lineColoredMaterial.worldUnits = !1, this.lineColoredMaterial.vertexColors = !0, this.lineColoredMaterial.pixelThreshold = 0.5, this.lineColoredMaterial.resolution = new wt(), this.lineHiddenMaterial = new Ss({ color: 16777215, linewidth: 1, worldUnits: !1, vertexColors: !0, alphaToCoverage: !1, resolution: new wt() }), this.lineHiddenMaterial.color = new Ht(16711680), this.lineHiddenMaterial.linewidth = 1, this.lineHiddenMaterial.worldUnits = !1, this.lineHiddenMaterial.vertexColors = !0, this.lineHiddenMaterial.pixelThreshold = 0.5, this.lineHiddenMaterial.resolution = new wt(), this.lineHiddenMaterial.visible = !1, this.lineOverlayMaterial = new Ss({ color: 314363, linewidth: 1, worldUnits: !1, vertexColors: !0, alphaToCoverage: !1, resolution: new wt() }), this.lineHighlightMaterial.color = new Ht(314363), this.lineHighlightMaterial.linewidth = 1, this.lineHighlightMaterial.worldUnits = !1, this.lineHighlightMaterial.vertexColors = !0, this.lineHighlightMaterial.pixelThreshold = 0.5, this.lineHighlightMaterial.resolution = new wt(), this.lineHighlightMaterial.color.convertSRGBToLinear(), this.lineOverlayMaterial.color.convertSRGBToLinear();
  }
  async createDefaultPointMaterials() {
    this.pointCloudHighlightMaterial = new Bi({ color: 294651, vertexColors: !0, size: 2, sizeAttenuation: !1 }, ["USE_RTE"]), this.pointHighlightMaterial = new Bi({ color: 294651, vertexColors: !1, size: 2, sizeAttenuation: !1 }, ["USE_RTE"]), this.pointGhostMaterial = new Bi({ color: 16777215, vertexColors: !1, size: 2, opacity: 0.01, sizeAttenuation: !1 }, ["USE_RTE"]), this.pointCloudOverlayMaterial = new Bi({ color: 314363, vertexColors: !0, size: 2, sizeAttenuation: !1 }, ["USE_RTE"]), this.pointOverlayMaterial = new Bi({ color: 314363, vertexColors: !1, size: 2, sizeAttenuation: !1 }, ["USE_RTE"]), this.pointCloudHighlightMaterial.color.convertSRGBToLinear(), this.pointCloudHighlightMaterial.toneMapped = !1, this.pointHighlightMaterial.color.convertSRGBToLinear(), this.pointHighlightMaterial.toneMapped = !1, this.pointOverlayMaterial.color.convertSRGBToLinear(), this.pointOverlayMaterial.toneMapped = !1, this.pointCloudOverlayMaterial.color.convertSRGBToLinear(), this.pointCloudOverlayMaterial.toneMapped = !1, this.pointGhostMaterial.toneMapped = !1;
  }
  async createDefaultNullMaterials() {
    this.materialMap[zi.NullRenderMaterialHash] = new rs({ color: 8355711, emissive: 0, roughness: 1, metalness: 0, side: 2 }, ["USE_RTE"]), this.materialMap[zi.NullRenderMaterialHash].color.convertSRGBToLinear(), this.materialMap[zi.NullRenderMaterialVertexColorsHash] = new rs({ color: 8355711, emissive: 0, roughness: 1, metalness: 0, side: 2, vertexColors: !0 }, ["USE_RTE"]), this.materialMap[zi.NullRenderMaterialVertexColorsHash].color.convertSRGBToLinear();
    const t = zi.NullDisplayStyleHash;
    this.materialMap[t] = new Ss({ color: 8355711, linewidth: 1, worldUnits: !1, vertexColors: !0, alphaToCoverage: !1, resolution: new wt() }), this.materialMap[t].color = new Ht(8355711), this.materialMap[t].color.convertSRGBToLinear(), this.materialMap[t].linewidth = 1, this.materialMap[t].worldUnits = !1, this.materialMap[t].vertexColors = !0, this.materialMap[t].pixelThreshold = 0.5, this.materialMap[t].resolution = new wt(), this.materialMap[zi.NullPointMaterialHash] = new Bi({ color: 8355711, vertexColors: !1, size: 2, sizeAttenuation: !1 }, ["USE_RTE"]), this.materialMap[zi.NullPointMaterialHash].color.convertSRGBToLinear(), this.materialMap[zi.NullPointCloudVertexColorsMaterialHash] = new Bi({ color: 16777215, vertexColors: !0, size: 2, sizeAttenuation: !1 }, ["USE_RTE"]), this.materialMap[zi.NullPointCloudMaterialHash] = new Bi({ color: 16777215, vertexColors: !1, size: 2, sizeAttenuation: !1 }, ["USE_RTE"]);
  }
  async createDefaultMaterials() {
    await this.createDefaultMeshMaterials(), await this.createLineDefaultMaterials(), await this.createDefaultPointMaterials(), await this.createDefaultNullMaterials();
  }
  makeMeshMaterial(t) {
    var r, s;
    console.log("mesh color :", t.color);
    const e = { color: t.color, emissive: t.emissive, roughness: t.roughness, metalness: t.metalness, opacity: t.opacity, bumpScale: t.bumpScale || 0.01, side: ((r = t == null ? void 0 : t.userData) == null ? void 0 : r.side) !== void 0 ? (s = t == null ? void 0 : t.userData) == null ? void 0 : s.side : 2, depthTest: t.depthTest, depthWrite: t.depthWrite, alphaTest: t.alphaTest }, n = t.existMorphAttributes ? new Ds(e) : new rs(e, ["USE_RTE"]);
    return n.vertexColors = t.vertexColors, n.clipShadows = !0, t.haveUv || n.color.convertSRGBToLinear(), n.transparent = t.transparent === !0 || n.opacity < 1, t.toneMapped === !1 && (n.toneMapped = !1), n;
  }
  makeLineMaterial(t) {
    let e, n, r, s;
    if (t.pattern && Array.isArray(t.pattern) && t.pattern.some((o) => o < 0)) {
      const o = t.pattern;
      e = !0, r = Math.abs(o[o.length - 2]), s = Math.abs(o.find((l) => l < 0)), n = o.filter((l) => l < 0).reduce((l, c) => l += Math.abs(c), 0) / r;
    }
    console.log("line color :", t.color);
    const a = new Ss({ color: t.color, linewidth: t.lineWeight > 0 ? t.lineWeight : 1, worldUnits: t.lineWeight > 0, vertexColors: !0, alphaToCoverage: !1, resolution: new wt() });
    return a.color = new Ht(t.color), a.color.convertSRGBToLinear(), a.linewidth = t.lineWeight > 0 ? t.lineWeight : 1, a.worldUnits = t.lineWeight > 0, a.vertexColors = !0, a.pixelThreshold = 0.5, a.resolution = new wt(), a.dashed = e, a.dashScale = n, a.dashSize = r, a.gapSize = s, a.toneMapped = !1, a;
  }
  makePointMaterial(t) {
    const e = t.color === -16777216, n = t.vertexColors && e ? 16777215 : t.color, r = new Bi({ color: n, opacity: t.opacity, vertexColors: t.vertexColors, size: 2, sizeAttenuation: !1 }, ["USE_RTE"]);
    return r.transparent = r.opacity < 1, r.depthWrite = !r.transparent, r.toneMapped = !1, r.color.convertSRGBToLinear(), r;
  }
  updateMaterialMap(t, e, n) {
    if (this.materialMap[t])
      return this.materialMap[t];
    if (e) {
      const r = (s, a) => {
        if (!Array.isArray(s))
          return a(s);
        const o = [];
        for (let l = 0; l < s.length; l++)
          o.push(a(s[l]));
        return o;
      };
      switch (n) {
        case ae.MESH:
          this.materialMap[t] = r(e, this.makeMeshMaterial);
          break;
        case ae.LINE:
          this.materialMap[t] = r(e, this.makeLineMaterial);
          break;
        case ae.POINT:
        case ae.POINT_CLOUD:
          this.materialMap[t] = r(e, this.makePointMaterial);
      }
    }
    return this.materialMap[t].clippingPlanes = [], this.materialMap[t];
  }
  getHighlightMaterial(t) {
    switch (t.geometryType) {
      case ae.MESH:
        return t.transparent ? this.meshTransparentHighlightMaterial : this.meshHighlightMaterial;
      case ae.LINE:
        return this.lineHighlightMaterial;
      case ae.POINT:
        return this.pointHighlightMaterial;
      case ae.POINT_CLOUD:
        return this.pointCloudHighlightMaterial;
    }
  }
  getGhostMaterial(t) {
    switch (t.geometryType) {
      case ae.MESH:
        return this.meshGhostMaterial;
      case ae.LINE:
        return this.lineGhostMaterial;
      case ae.POINT:
      case ae.POINT_CLOUD:
        return this.pointGhostMaterial;
    }
  }
  getGradientMaterial(t) {
    switch (t.geometryType) {
      case ae.MESH:
        return t.transparent ? this.meshTransparentGradientMaterial : this.meshGradientMaterial;
      case ae.LINE:
        return this.lineGhostMaterial;
      case ae.POINT:
      case ae.POINT_CLOUD:
        return this.pointGhostMaterial;
    }
  }
  getColoredMaterial(t) {
    switch (t.geometryType) {
      case ae.MESH:
        return t.transparent ? this.meshTransparentColoredMaterial : this.meshColoredMaterial;
      case ae.LINE:
        return this.lineColoredMaterial;
      case ae.POINT:
      case ae.POINT_CLOUD:
        return this.pointGhostMaterial;
    }
  }
  getOverlayMaterial(t) {
    switch (t.geometryType) {
      case ae.MESH:
        return t.transparent ? this.meshTransparentOverlayMaterial : this.meshOverlayMaterial;
      case ae.LINE:
        return this.lineOverlayMaterial;
      case ae.POINT:
        return this.pointOverlayMaterial;
      case ae.POINT_CLOUD:
        return this.pointCloudOverlayMaterial;
    }
  }
  getHiddenMaterial(t) {
    switch (t.geometryType) {
      case ae.MESH:
        return this.meshHiddenMaterial;
      case ae.LINE:
        return this.lineHiddenMaterial;
      case ae.POINT:
      case ae.POINT_CLOUD:
        return this.meshHiddenMaterial;
    }
  }
  getDebugBatchMaterial(t) {
    const e = new Ht(Hl.randInt(0, 16777215));
    switch (e.convertSRGBToLinear(), t.geometryType) {
      case ae.MESH:
        return new rs({ color: e, emissive: 0, roughness: 1, metalness: 0, opacity: 1, side: 2 }, ["USE_RTE"]);
      case ae.LINE: {
        const n = new Ss({ color: e, linewidth: 1, worldUnits: !1, vertexColors: !0, alphaToCoverage: !1, resolution: new wt() });
        return n.color = e, n.linewidth = 1, n.worldUnits = !1, n.vertexColors = !0, n.pixelThreshold = 0.5, n.resolution = new wt(), n;
      }
      case ae.POINT:
        return new Bi({ color: e, vertexColors: !1, size: 2, sizeAttenuation: !1 }, ["USE_RTE"]);
      case ae.POINT_CLOUD:
        return new Bi({ color: e, vertexColors: !0, size: 2, sizeAttenuation: !1 }, ["USE_RTE"]);
    }
  }
  getFilterMaterial(t, e) {
    let n;
    switch (e) {
      case ki.SELECT:
        n = this.getHighlightMaterial(t);
        break;
      case ki.GHOST:
        n = this.getGhostMaterial(t);
        break;
      case ki.GRADIENT:
        n = this.getGradientMaterial(t);
        break;
      case ki.COLORED:
        n = this.getColoredMaterial(t);
        break;
      case ki.OVERLAY:
        n = this.getOverlayMaterial(t);
        break;
      case ki.HIDDEN:
        n = this.getHiddenMaterial(t);
    }
    return n.clippingPlanes = [], n;
  }
  getFilterMaterialOptions(t) {
    switch (t.filterType) {
      case ki.COLORED:
        return { rampIndex: t.rampIndex !== void 0 ? t.rampIndex : void 0, rampIndexColor: t.rampIndexColor, rampTexture: t.rampTexture ? t.rampTexture : void 0, rampWidth: t.rampTexture ? t.rampTexture.image.width : void 0 };
      case ki.GRADIENT:
        return { rampIndex: t.rampIndex !== void 0 ? t.rampIndex : void 0, rampTexture: t.rampTexture ? t.rampTexture : this.meshGradientMaterial.userData.gradientRamp.value, rampWidth: t.rampTexture ? t.rampTexture.image.width : this.meshGradientMaterial.userData.gradientRamp.value.image.width };
    }
  }
  purge() {
  }
}
const yz = typeof global == "object" && global && global.Object === Object && global;
var mat = typeof self == "object" && self && self.Object === Object && self;
const aa = yz || mat || Function("return this")(), $h = aa.Symbol;
var _z = Object.prototype, gat = _z.hasOwnProperty, vat = _z.toString, dd = $h ? $h.toStringTag : void 0, yat = Object.prototype.toString, _at = "[object Null]", wat = "[object Undefined]", gR = $h ? $h.toStringTag : void 0;
function jp(i) {
  return i == null ? i === void 0 ? wat : _at : gR && gR in Object(i) ? function(t) {
    var e = gat.call(t, dd), n = t[dd];
    try {
      t[dd] = void 0;
      var r = !0;
    } catch {
    }
    var s = vat.call(t);
    return r && (e ? t[dd] = n : delete t[dd]), s;
  }(i) : function(t) {
    return yat.call(t);
  }(i);
}
function Gp(i) {
  return i != null && typeof i == "object";
}
const uM = Array.isArray;
function Wp(i) {
  var t = typeof i;
  return i != null && (t == "object" || t == "function");
}
var xat = "[object AsyncFunction]", bat = "[object Function]", Sat = "[object GeneratorFunction]", Mat = "[object Proxy]";
function wz(i) {
  if (!Wp(i))
    return !1;
  var t = jp(i);
  return t == bat || t == Sat || t == xat || t == Mat;
}
const Mw = aa["__core-js_shared__"];
var vR = function() {
  var i = /[^.]+$/.exec(Mw && Mw.keys && Mw.keys.IE_PROTO || "");
  return i ? "Symbol(src)_1." + i : "";
}(), Tat = Function.prototype.toString;
function sc(i) {
  if (i != null) {
    try {
      return Tat.call(i);
    } catch {
    }
    try {
      return i + "";
    } catch {
    }
  }
  return "";
}
var Eat = /^\[object .+?Constructor\]$/, Aat = Function.prototype, Cat = Object.prototype, Pat = Aat.toString, Dat = Cat.hasOwnProperty, Rat = RegExp("^" + Pat.call(Dat).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
function Iat(i) {
  return !(!Wp(i) || (t = i, vR && vR in t)) && (wz(i) ? Rat : Eat).test(sc(i));
  var t;
}
function ac(i, t) {
  var e = function(n, r) {
    return n == null ? void 0 : n[r];
  }(i, t);
  return Iat(e) ? e : void 0;
}
const bb = ac(aa, "WeakMap");
var yR = Object.create;
const Oat = function() {
  function i() {
  }
  return function(t) {
    if (!Wp(t))
      return {};
    if (yR)
      return yR(t);
    i.prototype = t;
    var e = new i();
    return i.prototype = void 0, e;
  };
}(), _R = function() {
  try {
    var i = ac(Object, "defineProperty");
    return i({}, "", {}), i;
  } catch {
  }
}();
var Lat = 9007199254740991, Bat = /^(?:0|[1-9]\d*)$/;
function zat(i, t) {
  var e = typeof i;
  return !!(t = t ?? Lat) && (e == "number" || e != "symbol" && Bat.test(i)) && i > -1 && i % 1 == 0 && i < t;
}
function xz(i, t, e) {
  t == "__proto__" && _R ? _R(i, t, { configurable: !0, enumerable: !0, value: e, writable: !0 }) : i[t] = e;
}
function bz(i, t) {
  return i === t || i != i && t != t;
}
var kat = Object.prototype.hasOwnProperty;
function Sz(i, t, e) {
  var n = i[t];
  kat.call(i, t) && bz(n, e) && (e !== void 0 || t in i) || xz(i, t, e);
}
function Pg(i, t, e, n) {
  var r = !e;
  e || (e = {});
  for (var s = -1, a = t.length; ++s < a; ) {
    var o = t[s], l = n ? n(e[o], i[o], o, e, i) : void 0;
    l === void 0 && (l = i[o]), r ? xz(e, o, l) : Sz(e, o, l);
  }
  return e;
}
var Nat = 9007199254740991;
function Mz(i) {
  return typeof i == "number" && i > -1 && i % 1 == 0 && i <= Nat;
}
function Tz(i) {
  return i != null && Mz(i.length) && !wz(i);
}
var Fat = Object.prototype;
function dM(i) {
  var t = i && i.constructor;
  return i === (typeof t == "function" && t.prototype || Fat);
}
function wR(i) {
  return Gp(i) && jp(i) == "[object Arguments]";
}
var Ez = Object.prototype, Uat = Ez.hasOwnProperty, Vat = Ez.propertyIsEnumerable;
const Hat = wR(function() {
  return arguments;
}()) ? wR : function(i) {
  return Gp(i) && Uat.call(i, "callee") && !Vat.call(i, "callee");
};
var Az = typeof exports == "object" && exports && !exports.nodeType && exports, xR = Az && typeof module == "object" && module && !module.nodeType && module, bR = xR && xR.exports === Az ? aa.Buffer : void 0;
const Cz = (bR ? bR.isBuffer : void 0) || function() {
  return !1;
};
var Cn = {};
function pM(i) {
  return function(t) {
    return i(t);
  };
}
Cn["[object Float32Array]"] = Cn["[object Float64Array]"] = Cn["[object Int8Array]"] = Cn["[object Int16Array]"] = Cn["[object Int32Array]"] = Cn["[object Uint8Array]"] = Cn["[object Uint8ClampedArray]"] = Cn["[object Uint16Array]"] = Cn["[object Uint32Array]"] = !0, Cn["[object Arguments]"] = Cn["[object Array]"] = Cn["[object ArrayBuffer]"] = Cn["[object Boolean]"] = Cn["[object DataView]"] = Cn["[object Date]"] = Cn["[object Error]"] = Cn["[object Function]"] = Cn["[object Map]"] = Cn["[object Number]"] = Cn["[object Object]"] = Cn["[object RegExp]"] = Cn["[object Set]"] = Cn["[object String]"] = Cn["[object WeakMap]"] = !1;
var Pz = typeof exports == "object" && exports && !exports.nodeType && exports, jd = Pz && typeof module == "object" && module && !module.nodeType && module, Tw = jd && jd.exports === Pz && yz.process;
const Qh = function() {
  try {
    var i = jd && jd.require && jd.require("util").types;
    return i || Tw && Tw.binding && Tw.binding("util");
  } catch {
  }
}();
var SR = Qh && Qh.isTypedArray;
const jat = SR ? pM(SR) : function(i) {
  return Gp(i) && Mz(i.length) && !!Cn[jp(i)];
};
var Gat = Object.prototype.hasOwnProperty;
function Dz(i, t) {
  var e = uM(i), n = !e && Hat(i), r = !e && !n && Cz(i), s = !e && !n && !r && jat(i), a = e || n || r || s, o = a ? function(u, h) {
    for (var p = -1, f = Array(u); ++p < u; )
      f[p] = h(p);
    return f;
  }(i.length, String) : [], l = o.length;
  for (var c in i)
    !t && !Gat.call(i, c) || a && (c == "length" || r && (c == "offset" || c == "parent") || s && (c == "buffer" || c == "byteLength" || c == "byteOffset") || zat(c, l)) || o.push(c);
  return o;
}
function Rz(i, t) {
  return function(e) {
    return i(t(e));
  };
}
const Wat = Rz(Object.keys, Object);
var Zat = Object.prototype.hasOwnProperty;
function Sb(i) {
  return Tz(i) ? Dz(i) : function(t) {
    if (!dM(t))
      return Wat(t);
    var e = [];
    for (var n in Object(t))
      Zat.call(t, n) && n != "constructor" && e.push(n);
    return e;
  }(i);
}
var qat = Object.prototype.hasOwnProperty;
function Xat(i) {
  if (!Wp(i))
    return function(r) {
      var s = [];
      if (r != null)
        for (var a in Object(r))
          s.push(a);
      return s;
    }(i);
  var t = dM(i), e = [];
  for (var n in i)
    (n != "constructor" || !t && qat.call(i, n)) && e.push(n);
  return e;
}
function Mb(i) {
  return Tz(i) ? Dz(i, !0) : Xat(i);
}
const pd = ac(Object, "create");
var Yat = Object.prototype.hasOwnProperty, Jat = Object.prototype.hasOwnProperty;
function Ll(i) {
  var t = -1, e = i == null ? 0 : i.length;
  for (this.clear(); ++t < e; ) {
    var n = i[t];
    this.set(n[0], n[1]);
  }
}
function Dg(i, t) {
  for (var e = i.length; e--; )
    if (bz(i[e][0], t))
      return e;
  return -1;
}
Ll.prototype.clear = function() {
  this.__data__ = pd ? pd(null) : {}, this.size = 0;
}, Ll.prototype.delete = function(i) {
  var t = this.has(i) && delete this.__data__[i];
  return this.size -= t ? 1 : 0, t;
}, Ll.prototype.get = function(i) {
  var t = this.__data__;
  if (pd) {
    var e = t[i];
    return e === "__lodash_hash_undefined__" ? void 0 : e;
  }
  return Yat.call(t, i) ? t[i] : void 0;
}, Ll.prototype.has = function(i) {
  var t = this.__data__;
  return pd ? t[i] !== void 0 : Jat.call(t, i);
}, Ll.prototype.set = function(i, t) {
  var e = this.__data__;
  return this.size += this.has(i) ? 0 : 1, e[i] = pd && t === void 0 ? "__lodash_hash_undefined__" : t, this;
};
var Kat = Array.prototype.splice;
function ka(i) {
  var t = -1, e = i == null ? 0 : i.length;
  for (this.clear(); ++t < e; ) {
    var n = i[t];
    this.set(n[0], n[1]);
  }
}
ka.prototype.clear = function() {
  this.__data__ = [], this.size = 0;
}, ka.prototype.delete = function(i) {
  var t = this.__data__, e = Dg(t, i);
  return !(e < 0) && (e == t.length - 1 ? t.pop() : Kat.call(t, e, 1), --this.size, !0);
}, ka.prototype.get = function(i) {
  var t = this.__data__, e = Dg(t, i);
  return e < 0 ? void 0 : t[e][1];
}, ka.prototype.has = function(i) {
  return Dg(this.__data__, i) > -1;
}, ka.prototype.set = function(i, t) {
  var e = this.__data__, n = Dg(e, i);
  return n < 0 ? (++this.size, e.push([i, t])) : e[n][1] = t, this;
};
const wp = ac(aa, "Map");
function Rg(i, t) {
  var e, n, r = i.__data__;
  return ((n = typeof (e = t)) == "string" || n == "number" || n == "symbol" || n == "boolean" ? e !== "__proto__" : e === null) ? r[typeof t == "string" ? "string" : "hash"] : r.map;
}
function gh(i) {
  var t = -1, e = i == null ? 0 : i.length;
  for (this.clear(); ++t < e; ) {
    var n = i[t];
    this.set(n[0], n[1]);
  }
}
function Iz(i, t) {
  for (var e = -1, n = t.length, r = i.length; ++e < n; )
    i[r + e] = t[e];
  return i;
}
gh.prototype.clear = function() {
  this.size = 0, this.__data__ = { hash: new Ll(), map: new (wp || ka)(), string: new Ll() };
}, gh.prototype.delete = function(i) {
  var t = Rg(this, i).delete(i);
  return this.size -= t ? 1 : 0, t;
}, gh.prototype.get = function(i) {
  return Rg(this, i).get(i);
}, gh.prototype.has = function(i) {
  return Rg(this, i).has(i);
}, gh.prototype.set = function(i, t) {
  var e = Rg(this, i), n = e.size;
  return e.set(i, t), this.size += e.size == n ? 0 : 1, this;
};
const Oz = Rz(Object.getPrototypeOf, Object);
function vh(i) {
  var t = this.__data__ = new ka(i);
  this.size = t.size;
}
vh.prototype.clear = function() {
  this.__data__ = new ka(), this.size = 0;
}, vh.prototype.delete = function(i) {
  var t = this.__data__, e = t.delete(i);
  return this.size = t.size, e;
}, vh.prototype.get = function(i) {
  return this.__data__.get(i);
}, vh.prototype.has = function(i) {
  return this.__data__.has(i);
}, vh.prototype.set = function(i, t) {
  var e = this.__data__;
  if (e instanceof ka) {
    var n = e.__data__;
    if (!wp || n.length < 199)
      return n.push([i, t]), this.size = ++e.size, this;
    e = this.__data__ = new gh(n);
  }
  return e.set(i, t), this.size = e.size, this;
};
var Lz = typeof exports == "object" && exports && !exports.nodeType && exports, MR = Lz && typeof module == "object" && module && !module.nodeType && module, TR = MR && MR.exports === Lz ? aa.Buffer : void 0, ER = TR ? TR.allocUnsafe : void 0;
function Bz() {
  return [];
}
var $at = Object.prototype.propertyIsEnumerable, AR = Object.getOwnPropertySymbols, Qat = AR ? function(i) {
  return i == null ? [] : (i = Object(i), function(t, e) {
    for (var n = -1, r = t == null ? 0 : t.length, s = 0, a = []; ++n < r; ) {
      var o = t[n];
      e(o, n, t) && (a[s++] = o);
    }
    return a;
  }(AR(i), function(t) {
    return $at.call(i, t);
  }));
} : Bz;
const fM = Qat, zz = Object.getOwnPropertySymbols ? function(i) {
  for (var t = []; i; )
    Iz(t, fM(i)), i = Oz(i);
  return t;
} : Bz;
function kz(i, t, e) {
  var n = t(i);
  return uM(i) ? n : Iz(n, e(i));
}
function tot(i) {
  return kz(i, Sb, fM);
}
function eot(i) {
  return kz(i, Mb, zz);
}
const Tb = ac(aa, "DataView"), Eb = ac(aa, "Promise"), Ab = ac(aa, "Set");
var CR = "[object Map]", PR = "[object Promise]", DR = "[object Set]", RR = "[object WeakMap]", IR = "[object DataView]", not = sc(Tb), rot = sc(wp), iot = sc(Eb), sot = sc(Ab), aot = sc(bb), El = jp;
(Tb && El(new Tb(new ArrayBuffer(1))) != IR || wp && El(new wp()) != CR || Eb && El(Eb.resolve()) != PR || Ab && El(new Ab()) != DR || bb && El(new bb()) != RR) && (El = function(i) {
  var t = jp(i), e = t == "[object Object]" ? i.constructor : void 0, n = e ? sc(e) : "";
  if (n)
    switch (n) {
      case not:
        return IR;
      case rot:
        return CR;
      case iot:
        return PR;
      case sot:
        return DR;
      case aot:
        return RR;
    }
  return t;
});
const mM = El;
var oot = Object.prototype.hasOwnProperty;
const OR = aa.Uint8Array;
function Ew(i) {
  var t = new i.constructor(i.byteLength);
  return new OR(t).set(new OR(i)), t;
}
var lot = /\w*$/, LR = $h ? $h.prototype : void 0, BR = LR ? LR.valueOf : void 0, cot = "[object Boolean]", hot = "[object Date]", uot = "[object Map]", dot = "[object Number]", pot = "[object RegExp]", fot = "[object Set]", mot = "[object String]", got = "[object Symbol]", vot = "[object ArrayBuffer]", yot = "[object DataView]", _ot = "[object Float32Array]", wot = "[object Float64Array]", xot = "[object Int8Array]", bot = "[object Int16Array]", Sot = "[object Int32Array]", Mot = "[object Uint8Array]", Tot = "[object Uint8ClampedArray]", Eot = "[object Uint16Array]", Aot = "[object Uint32Array]";
function Cot(i, t, e) {
  var n, r = i.constructor;
  switch (t) {
    case vot:
      return Ew(i);
    case cot:
    case hot:
      return new r(+i);
    case yot:
      return function(s, a) {
        var o = a ? Ew(s.buffer) : s.buffer;
        return new s.constructor(o, s.byteOffset, s.byteLength);
      }(i, e);
    case _ot:
    case wot:
    case xot:
    case bot:
    case Sot:
    case Mot:
    case Tot:
    case Eot:
    case Aot:
      return function(s, a) {
        var o = a ? Ew(s.buffer) : s.buffer;
        return new s.constructor(o, s.byteOffset, s.length);
      }(i, e);
    case uot:
      return new r();
    case dot:
    case mot:
      return new r(i);
    case pot:
      return function(s) {
        var a = new s.constructor(s.source, lot.exec(s));
        return a.lastIndex = s.lastIndex, a;
      }(i);
    case fot:
      return new r();
    case got:
      return n = i, BR ? Object(BR.call(n)) : {};
  }
}
var zR = Qh && Qh.isMap;
const Pot = zR ? pM(zR) : function(i) {
  return Gp(i) && mM(i) == "[object Map]";
};
var kR = Qh && Qh.isSet;
const Dot = kR ? pM(kR) : function(i) {
  return Gp(i) && mM(i) == "[object Set]";
};
var Rot = 1, Iot = 2, Oot = 4, Nz = "[object Arguments]", Fz = "[object Function]", Lot = "[object GeneratorFunction]", Uz = "[object Object]", xn = {};
function vv(i, t, e, n, r, s) {
  var a, o = t & Rot, l = t & Iot, c = t & Oot;
  if (e && (a = r ? e(i, n, r, s) : e(i)), a !== void 0)
    return a;
  if (!Wp(i))
    return i;
  var u = uM(i);
  if (u) {
    if (a = function(m) {
      var y = m.length, _ = new m.constructor(y);
      return y && typeof m[0] == "string" && oot.call(m, "index") && (_.index = m.index, _.input = m.input), _;
    }(i), !o)
      return function(m, y) {
        var _ = -1, w = m.length;
        for (y || (y = Array(w)); ++_ < w; )
          y[_] = m[_];
        return y;
      }(i, a);
  } else {
    var h = mM(i), p = h == Fz || h == Lot;
    if (Cz(i))
      return function(m, y) {
        if (y)
          return m.slice();
        var _ = m.length, w = ER ? ER(_) : new m.constructor(_);
        return m.copy(w), w;
      }(i, o);
    if (h == Uz || h == Nz || p && !r) {
      if (a = l || p ? {} : function(m) {
        return typeof m.constructor != "function" || dM(m) ? {} : Oat(Oz(m));
      }(i), !o)
        return l ? function(m, y) {
          return Pg(m, zz(m), y);
        }(i, function(m, y) {
          return m && Pg(y, Mb(y), m);
        }(a, i)) : function(m, y) {
          return Pg(m, fM(m), y);
        }(i, function(m, y) {
          return m && Pg(y, Sb(y), m);
        }(a, i));
    } else {
      if (!xn[h])
        return r ? i : {};
      a = Cot(i, h, o);
    }
  }
  s || (s = new vh());
  var f = s.get(i);
  if (f)
    return f;
  s.set(i, a), Dot(i) ? i.forEach(function(m) {
    a.add(vv(m, t, e, m, i, s));
  }) : Pot(i) && i.forEach(function(m, y) {
    a.set(y, vv(m, t, e, y, i, s));
  });
  var v = u ? void 0 : (c ? l ? eot : tot : l ? Mb : Sb)(i);
  return function(m, y) {
    for (var _ = -1, w = m == null ? 0 : m.length; ++_ < w && y(m[_], _, m) !== !1; )
      ;
  }(v || i, function(m, y) {
    v && (m = i[y = m]), Sz(a, y, vv(m, t, e, y, i, s));
  }), a;
}
xn[Nz] = xn["[object Array]"] = xn["[object ArrayBuffer]"] = xn["[object DataView]"] = xn["[object Boolean]"] = xn["[object Date]"] = xn["[object Float32Array]"] = xn["[object Float64Array]"] = xn["[object Int8Array]"] = xn["[object Int16Array]"] = xn["[object Int32Array]"] = xn["[object Map]"] = xn["[object Number]"] = xn[Uz] = xn["[object RegExp]"] = xn["[object Set]"] = xn["[object String]"] = xn["[object Symbol]"] = xn["[object Uint8Array]"] = xn["[object Uint8ClampedArray]"] = xn["[object Uint16Array]"] = xn["[object Uint32Array]"] = !0, xn["[object Error]"] = xn[Fz] = xn["[object WeakMap]"] = !1;
function Vz(i) {
  return vv(i, 5);
}
class Bot {
  constructor(t) {
    U(this, "root");
    U(this, "_treeBounds", new ke());
    U(this, "cancel", !1);
    this.root = t;
  }
  get treeBounds() {
    return this._treeBounds;
  }
  buildRenderTree() {
    var e, n, r;
    const t = (r = (n = (e = this.root.model) == null ? void 0 : e.raw) == null ? void 0 : n.animations) == null ? void 0 : r.reduce((s, a) => s = s.concat(a.tracks.map((o) => o.name)), []);
    this.root.walk((s) => {
      const a = Qt.getInstance().modeList.find((l) => {
        var c, u;
        return l.id === s.model.id && ((u = (c = l == null ? void 0 : l.raw) == null ? void 0 : c.vertices) == null ? void 0 : u.length) > 0;
      });
      a && (s.model.raw = Vz(a.raw));
      const o = this.buildRenderNode(s);
      if (o) {
        const l = ((c, u) => {
          if (c)
            return c.find((h) => h.startsWith(u));
        })(t, o.name);
        l && (o.renderMaterial.trackName = l);
      }
      if (s.model.renderView = o ? new zi(o) : null, s.model.renderView && s.model.renderView.hasGeometry) {
        const l = this.computeTransform(s);
        o.geometry.bakeTransform && l.multiply(o.geometry.bakeTransform), Nn.transformGeometryData(o.geometry, l), s.model.renderView.computeAABB(), this._treeBounds.union(s.model.renderView.aabb), As.keepGeometryData || As.disposeNodeGeometryData(s.model);
      }
      return !0;
    });
  }
  buildRenderTreeAsync(t) {
    return Qt.getInstance().walkAsync((n) => {
      const r = this.buildRenderNode(n);
      if (n.model.renderView = r ? new zi(r) : null, n.model.renderView && n.model.renderView.hasGeometry) {
        const s = this.computeTransform(n);
        r.geometry.bakeTransform && s.multiply(r.geometry.bakeTransform), Nn.transformGeometryData(r.geometry, s), n.model.renderView.computeAABB(), this._treeBounds.union(n.model.renderView.aabb), As.keepGeometryData || As.disposeNodeGeometryData(n.model);
      }
      return !this.cancel;
    }, this.root, t);
  }
  buildRenderNode(t) {
    var r, s;
    let e = null;
    const n = As.convertNodeToGeometryData(t.model);
    if (n) {
      const a = this.getRenderMaterialNode(t), o = this.getDisplayStyleNode(t);
      e = { id: t.model.id, name: (s = (r = t.model) == null ? void 0 : r.raw) == null ? void 0 : s.name, speckleType: As.getSpeckleType(t.model), geometry: n, renderMaterial: xb.renderMaterialFromNode(a || o), displayStyle: xb.displayStyleFromNode(o || a) };
    }
    return e;
  }
  getRenderMaterialNode(t) {
    if (t.model.raw.renderMaterial)
      return t;
    const e = Qt.getInstance().getAncestors(t);
    for (let n = 0; n < e.length; n++)
      if (e[n].model.raw.renderMaterial)
        return e[n];
  }
  getDisplayStyleNode(t) {
    if (t.model.raw.displayStyle)
      return t;
    const e = Qt.getInstance().getAncestors(t);
    for (let n = 0; n < e.length; n++)
      if (e[n].model.raw.displayStyle)
        return e[n];
  }
  computeTransform(t) {
    const e = new Vt(), n = Qt.getInstance().getAncestors(t);
    for (let r = 0; r < n.length; r++)
      if (n[r].model.renderView) {
        const s = n[r].model.renderView.renderData;
        if (s.speckleType === li.BlockInstance)
          e.premultiply(s.geometry.transform);
        else if (s.speckleType === li.RevitInstance) {
          if (r > 0) {
            const a = n[r].model.raw.id;
            if (n[r - 1].model.raw.host === a)
              continue;
          }
          e.premultiply(s.geometry.transform);
        }
      }
    return e;
  }
  getAtomicRenderViews(...t) {
    return this.root.all((e) => {
      var n;
      return e.model.renderView !== null && t.includes(e.model.renderView.renderData.speckleType) && (e.model.atomic || e.parent.model.atomic && !((n = e.parent.model.renderView) != null && n.hasGeometry));
    }).map((e) => e.model.renderView);
  }
  getRenderViewsForNode(t, e) {
    return t.model.atomic && t.model.renderView ? [t.model.renderView] : (e || t.parent).all((n) => n.model.renderView && n.model.renderView.hasGeometry).map((n) => n.model.renderView);
  }
  getRenderViewNodesForNode(t, e) {
    return t.model.atomic && t.model.renderView ? [t] : (e || t.parent).all((n) => n.model.renderView && n.model.renderView.hasGeometry);
  }
  getAtomicParent(t) {
    return t.model.atomic ? t.model.renderView : Qt.getInstance().getAncestors(t).find((e) => e.model.atomic);
  }
  getRenderViewsForNodeId(t) {
    const e = Qt.getInstance().findId(t);
    return e ? this.getRenderViewsForNode(e) : (De.warn(`Id ${t} does not exist`), null);
  }
  getRenderViewForNodeId(t) {
    const e = Qt.getInstance().findId(t);
    return e ? e.model.renderView : (De.warn(`Id ${t} does not exist`), null);
  }
  purge() {
    this.root = null;
  }
  cancelBuild(t) {
    this.cancel = !0, Qt.getInstance().purge(t), this.purge();
  }
}
class gM {
  constructor() {
    U(this, "boxes", new Array());
    U(this, "worldBox", new ke());
    U(this, "_worldOrigin", new D());
  }
  get worldSize() {
    this.worldBox.getCenter(this._worldOrigin);
    const t = new D().subVectors(this.worldBox.max, this.worldBox.min);
    return { x: t.x, y: t.y, z: t.z };
  }
  get worldOrigin() {
    return this._worldOrigin;
  }
  expandWorld(t) {
    this.boxes.push(t), this.updateWorld();
  }
  reduceWorld(t) {
    this.boxes.splice(this.boxes.indexOf(t), 1), this.updateWorld();
  }
  updateWorld() {
    this.worldBox.makeEmpty();
    for (let t = 0; t < this.boxes.length; t++)
      this.worldBox.union(this.boxes[t]);
  }
  resetWorld() {
    this.worldBox.makeEmpty(), this.boxes.length = 0;
  }
  static getPause(t) {
    switch (t) {
      case 0:
        return this.getPauseFunction(1e3, 0);
      case 1:
        return this.getPauseFunction(100, 16);
      case 2:
        return this.getPauseFunction(16, 8);
    }
  }
  static getPauseFunction(t, e) {
    return ((n, r) => {
      let s = 0;
      return async () => {
        Date.now() - s >= n && (s = Date.now(), await new Promise((a) => setTimeout(a, r)));
      };
    })(t, e);
  }
}
const mn = class mn {
  constructor() {
    U(this, "supressWarnings", !0);
    U(this, "tree");
    U(this, "_root");
    U(this, "modeList", []);
    this.tree = new lb();
  }
  static clear() {
    mn.instance = null, mn.renderTreeInstances = {};
  }
  setModeList(t) {
    mn.instance.modeList.push(t);
  }
  static getInstance() {
    return mn.instance || (mn.instance = new mn(), mn.instance._root = mn.getInstance().parse({ id: "MOTHERSHIP", raw: {}, atomic: !0, children: [], renderView: null }), mn.instance.modeList = []), mn.instance;
  }
  static getRenderTree(t) {
    if (!mn.getInstance()._root)
      return console.error("WorldTree not initialised"), null;
    const e = t || mn.getInstance().root.model.id;
    return mn.renderTreeInstances[e] || (mn.renderTreeInstances[e] = new Bot(mn.getInstance().findId(e))), mn.renderTreeInstances[e];
  }
  static getDataTree() {
    return Sit.build(mn.instance._root);
  }
  static getAnimationsClips() {
    var e, n;
    return mn.getInstance()._root ? (n = (e = mn.getInstance().root.model.children[0]) == null ? void 0 : e.raw) == null ? void 0 : n.animations : (console.error("WorldTree not initialised"), null);
  }
  get root() {
    return this._root;
  }
  parse(t) {
    return this.tree.parse(t);
  }
  addSubtree(t) {
    this._root.addChild(t);
  }
  addNode(t, e) {
    e !== null ? e.addChild(t) : De.error("Invalid parent node!");
  }
  removeNode(t) {
    t.drop();
  }
  findAll(t, e) {
    return e || this.supressWarnings || De.warn("Root will be used for searching. You might not want that"), (e || this.root).all(t);
  }
  findId(t, e) {
    return e || this.supressWarnings || De.warn("Root will be used for searching. You might not want that"), (e || this.root).first((n) => n.model.id === t);
  }
  getAncestors(t) {
    return t.getPath().reverse().slice(1);
  }
  walk(t, e) {
    e || this.supressWarnings || De.warn("Root will be used for searching. You might not want that"), this._root.walk(t, e);
  }
  async walkAsync(t, e, n) {
    e || this.supressWarnings || De.warn("Root will be used for searching. You might not want that");
    const r = gM.getPause(n), s = async function* o(l, c) {
      let u, h;
      for (yield l(c), u = 0, h = c.children.length; u < h; u++)
        yield* o(l, c.children[u]);
    }(t, e || this._root);
    let a = !0;
    for await (const o of s)
      a = o, o === !1 && s.return(), await r();
    return Promise.resolve(a);
  }
  purge(t) {
    if (t)
      return delete mn.renderTreeInstances[t], void this.removeNode(this.findId(t));
    Object.keys(mn.renderTreeInstances).forEach((e) => delete mn.renderTreeInstances[e]), this._root.drop(), this._root.children.length = 0, this.tree = new lb(), this._root = mn.getInstance().parse({ id: "MOTHERSHIP", raw: {}, atomic: !0, children: [] });
  }
};
U(mn, "instance"), U(mn, "renderTreeInstances", {});
let Qt = mn;
class zot {
  constructor(t) {
    U(this, "objectLoader");
    U(this, "lastAsyncPause");
    U(this, "activePromises");
    U(this, "maxChildrenPromises");
    U(this, "spoofIDs", !0);
    U(this, "isRoot", !0);
    U(this, "NodeConverterMapping", { View3D: this.View3DToNode.bind(this), BlockInstance: this.BlockInstanceToNode.bind(this), Pointcloud: this.PointcloudToNode.bind(this), Brep: this.BrepToNode.bind(this), Mesh: this.MeshToNode.bind(this), Point: this.PointToNode.bind(this), Line: this.LineToNode.bind(this), Polyline: this.PolylineToNode.bind(this), Box: this.BoxToNode.bind(this), Polycurve: this.PolycurveToNode.bind(this), Curve: this.CurveToNode.bind(this), Circle: this.CircleToNode.bind(this), Arc: this.ArcToNode.bind(this), Ellipse: this.EllipseToNode.bind(this), RevitInstance: this.RevitInstanceToNode.bind(this), AnimationClips: this.AnimationClipsToNode.bind(this) });
    t || De.warn("Converter initialized without a corresponding object loader. Any objects that include references will throw errors."), this.objectLoader = t, this.lastAsyncPause = Date.now(), this.activePromises = 0, this.maxChildrenPromises = 200, Qt.getInstance();
  }
  async asyncPause() {
    Date.now() - this.lastAsyncPause >= 100 && (this.lastAsyncPause = Date.now(), await new Promise((t) => setTimeout(t, 0)));
  }
  async traverse(t, e, n, r = null) {
    if (await this.asyncPause(), e === null || typeof e != "object")
      return;
    e.referencedId && (e = await this.resolveReference(e));
    const s = [];
    if (Array.isArray(e)) {
      for (const u of e) {
        if (typeof u != "object")
          break;
        if (this.activePromises >= this.maxChildrenPromises)
          await this.traverse(t, u, n, r);
        else {
          const h = this.traverse(t, u, n, r);
          s.push(h);
        }
      }
      return this.activePromises += s.length, await Promise.all(s), void (this.activePromises -= s.length);
    }
    const a = Qt.getInstance().parse({ id: r ? this.getNodeId(e) : t, raw: Object.assign({}, e), atomic: !0, root: this.isRoot, children: [] });
    this.isRoot = !1, r === null ? Qt.getInstance().addSubtree(a) : Qt.getInstance().addNode(a, r);
    const o = this.getSpeckleType(e);
    if (this.directNodeConverterExists(e))
      try {
        await this.convertToNode(e.data || e, a);
        const u = Vz(a.model);
        return Qt.getInstance().setModeList(u), void await n(null);
      } catch (u) {
        De.warn(`(Traversing - direct) Failed to convert ${o} with id: ${e.id}`, u);
      }
    const l = e;
    let c = this.getDisplayValue(l);
    if (a.model.atomic = !!c, c) {
      if (Array.isArray(c))
        for (const u of c) {
          const h = await this.resolveReference(u);
          h.units || (h.units = e.units);
          const p = Qt.getInstance().parse({ id: this.getNodeId(h), raw: Object.assign({}, h), atomic: !1, children: [] });
          await this.convertToNode(h, p), Qt.getInstance().addNode(p, a), await n({});
        }
      else {
        c = await this.resolveReference(c), c.units || (c.units = e.units);
        try {
          const u = Qt.getInstance().parse({ id: this.getNodeId(c), raw: Object.assign({}, c), atomic: !1, children: [] });
          await this.convertToNode(c, u), Qt.getInstance().addNode(u, a), await n({});
        } catch (u) {
          De.warn(`(Traversing) Failed to convert obj with id: ${e.id} — ${u.message}`);
        }
      }
      if (e.speckle_type.toLowerCase().includes("builtelements"))
        return void (e.elements && (s.push(this.traverse(t, e.elements, n, a)), this.activePromises += s.length, await Promise.all(s), this.activePromises -= s.length));
    }
    for (const u in l)
      if (u !== "__parents" && u !== "bbox" && u !== "__closure" && !["displayMesh", "@displayMesh", "displayValue", "@displayValue"].includes(u) && typeof l[u] == "object" && l[u] !== null)
        if (this.activePromises >= this.maxChildrenPromises)
          await this.traverse(t, l[u], n, a);
        else {
          const h = this.traverse(t, l[u], n, a);
          s.push(h);
        }
    this.activePromises += s.length, await Promise.all(s), this.activePromises -= s.length;
  }
  getNodeId(t) {
    return this.spoofIDs ? IB() : t.id;
  }
  async dechunk(t) {
    if (!t || t.length === 0 || !t[0].referencedId)
      return t;
    const e = [];
    for (const n of t) {
      const r = await this.objectLoader.getObject(n.referencedId);
      e.push(r.data);
    }
    return [].concat(...e);
  }
  async resolveReference(t) {
    return t.referencedId ? await this.objectLoader.getObject(t.referencedId) : t;
  }
  getSpeckleType(t) {
    let e = "Base";
    return e = t.data ? t.data.speckle_type ? t.data.speckle_type.split(".").reverse()[0] : e : t.speckle_type ? t.speckle_type.split(".").reverse()[0] : e, e;
  }
  directNodeConverterExists(t) {
    return this.getSpeckleType(t) in this.NodeConverterMapping;
  }
  async convertToNode(t, e) {
    t.referencedId && (t = await this.resolveReference(t));
    try {
      return this.directNodeConverterExists(t) ? await this.NodeConverterMapping[this.getSpeckleType(t)](t, e) : null;
    } catch (n) {
      throw De.warn(`(Direct convert) Failed to convert object with id: ${t.id}`), n;
    }
  }
  getDisplayValue(t) {
    return t.displayValue || t["@displayValue"] || t.displayMesh || t["@displayMesh"];
  }
  async View3DToNode(t, e) {
    t.origin.units = t.units, t.target.units = t.units;
  }
  async BlockInstanceToNode(t, e) {
    const n = await this.resolveReference(t.blockDefinition);
    e.model.raw.definition = n;
    for (const r of n.geometry) {
      const s = await this.resolveReference(r), a = Qt.getInstance().parse({ id: this.getNodeId(s), raw: Object.assign({}, s), atomic: !0, children: [] });
      Qt.getInstance().addNode(a, e), await this.convertToNode(s, a);
    }
  }
  async RevitInstanceToNode(t, e) {
    const n = async (s, a) => {
      if (s)
        for (const o of s) {
          const l = await this.resolveReference(o), c = Qt.getInstance().parse({ id: this.getNodeId(l), raw: Object.assign({}, l), atomic: !0, children: [] });
          a && (c.model.raw.host = a), Qt.getInstance().addNode(c, e), await this.convertToNode(l, c);
        }
    }, r = await this.resolveReference(t.definition);
    e.model.raw.definition = r, await n(r.elements), await n(r.displayValue), await n(t.elements, t.id);
  }
  async PointcloudToNode(t, e) {
    e.model.raw.points = await this.dechunk(t.points), e.model.raw.colors = await this.dechunk(t.colors);
  }
  async BrepToNode(t, e) {
    try {
      if (!t)
        return;
      let n = t.displayValue || t.displayMesh;
      Array.isArray(n) && (n = n[0]);
      const r = await this.resolveReference(n), s = Qt.getInstance().parse({ id: this.getNodeId(r), raw: Object.assign({}, r), atomic: !1, children: [] });
      await this.convertToNode(r, s), Qt.getInstance().addNode(s, e), delete t.Edges, delete t.Faces, delete t.Loops, delete t.Trims, delete t.Curve2D, delete t.Curve3D, delete t.Surfaces, delete t.Vertices;
    } catch (n) {
      throw De.warn(`Failed to convert brep id: ${t.id}`), n;
    }
  }
  async MeshToNode(t, e) {
    if (t)
      if (t.vertices && t.vertices.length !== 0)
        if (t.faces && t.faces.length !== 0) {
          if (e.model.raw.vertices = await this.dechunk(t.vertices), e.model.raw.faces = await this.dechunk(t.faces), e.model.raw.colors = await this.dechunk(t.colors), e.model.raw.normal = await this.dechunk(t.normal), e.model.raw.textureCoordinates = await this.dechunk(t.textureCoordinates || []), e.model.raw.uv2 = await this.dechunk(t.uv2 || []), e.model.raw.tangent = await this.dechunk(t.tangent || []), e.model.raw.morphAttributes && e.model.raw.morphAttributes.length > 0) {
            let n;
            for (let r = 0; r < e.model.raw.morphAttributes.length; r++)
              n = e.model.raw.morphAttributes[r], e.model.raw.morphAttributes[r].data = await this.dechunk(n.data || []);
          }
        } else
          De.warn(`Object id ${t.id} of type ${t.speckle_type} has no face data and will be ignored`);
      else
        De.warn(`Object id ${t.id} of type ${t.speckle_type} has no vertex position data and will be ignored`);
  }
  async PointToNode(t, e) {
  }
  async LineToNode(t, e) {
  }
  async PolylineToNode(t, e) {
    e.model.raw.value = await this.dechunk(t.value);
  }
  async AnimationClipsToNode(t, e) {
    e.model.raw.value = t;
  }
  async BoxToNode(t, e) {
  }
  async PolycurveToNode(t, e) {
    e.model.nestedNodes = [];
    for (let n = 0; n < t.segments.length; n++) {
      let r = t.segments[n];
      this.directNodeConverterExists(r) || (r = this.getDisplayValue(r), r.referencedId && (r = await this.resolveReference(r)));
      const s = Qt.getInstance().parse({ id: this.getNodeId(r), raw: Object.assign({}, r), atomic: !1, children: [] });
      await this.convertToNode(r, s), e.model.nestedNodes.push(s);
    }
  }
  async CurveToNode(t, e) {
    if (!t.displayValue)
      return void De.warn(`Object ${t.id} of type ${t.speckle_type} has no display value and will be ignored`);
    const n = await this.resolveReference(t.displayValue);
    n.units = n.units || t.units;
    const r = Qt.getInstance().parse({ id: this.getNodeId(n), raw: Object.assign({}, n), atomic: !1, children: [] });
    await this.convertToNode(n, r), Qt.getInstance().addNode(r, e);
  }
  async CircleToNode(t, e) {
  }
  async ArcToNode(t, e) {
  }
  async EllipseToNode(t, e) {
  }
}
class NR {
  constructor(t, e, n, r) {
    U(this, "_objectUrl");
    U(this, "objectId");
    U(this, "token");
    U(this, "loader");
    U(this, "converter");
    U(this, "cancel", !1);
    U(this, "emiter");
    this.emiter = t, this._objectUrl = e, this.token = null;
    try {
      this.token = n || localStorage.getItem("AuthToken");
    } catch {
    }
    this.token || De.error("Viewer: no auth token present. Requests to non-public stream objects will fail.");
    const s = new URL(e), a = s.pathname.split("/");
    if (a.length < 5 || s.pathname.indexOf("streams") === -1 || s.pathname.indexOf("objects") === -1)
      throw new Error("Unexpected object url format.");
    const o = a.slice(0, a.length - 4).filter((u) => !!u).reduce((u, h) => `${u}/${h}`, ""), l = s.origin + o, c = a[a.length - 3];
    this.objectId = a[a.length - 1], this.loader = new yit({ serverUrl: l, token: this.token, streamId: c, objectId: this.objectId, options: { enableCaching: r, customLogger: De.log } }), this.converter = new zot(this.loader), this.cancel = !1;
  }
  get objectUrl() {
    return this._objectUrl;
  }
  async load() {
    const t = performance.now();
    let e = !0, n = 0, r = 0, s = 0, a = null;
    De.warn("Downloading object ", this.objectUrl);
    for await (const o of this.loader.getObjectIterator()) {
      if (this.cancel)
        return this.emiter.emit(tn.LoadProgress, { progress: 1, id: this.objectId, url: this.objectUrl }), void this.emiter.emit("load-cancelled", this.objectUrl);
      await this.converter.asyncPause(), e && (a = this.converter.traverse(this.objectUrl, o, async () => {
        await this.converter.asyncPause(), s++;
      }), e = !1, r = o.totalChildrenCount), n++, this.emiter.emit(tn.LoadProgress, { progress: n / (r + 1), id: this.objectId });
    }
    a && await a, De.warn(`Finished downloading object ${this.objectId} in ${(performance.now() - t) / 1e3} seconds`), this.emiter.emit(tn.DownloadComplete, this.objectUrl), s === 0 && (De.warn(`Viewer: no 3d objects found in object ${this.objectId}`), this.emiter.emit("load-warning", { message: `No displayable objects found in object ${this.objectId}.` }));
  }
  cancelLoad() {
    this.cancel = !0;
  }
  dispose() {
    this.loader.dispose();
  }
}
class R0 {
  constructor() {
    this._events = {};
  }
  on(t, e) {
    this._events[t] || (this._events[t] = []), this._events[t].push(e);
  }
  removeListener(t, e) {
    this._events[t] && (this._events[t] = this._events[t].filter((n) => n !== e));
  }
  emit(t, ...e) {
    this._events[t] && this._events[t].forEach((n) => {
      n(...e);
    });
  }
  dispose() {
    this._events = null;
  }
}
/*!
 * camera-controls
 * https://github.com/yomotsu/camera-controls
 * (c) 2017 @yomotsu
 * Released under the MIT License.
 */
const ih = 1, sh = 2, ah = 4, Zt = Object.freeze({ NONE: 0, ROTATE: 1, TRUCK: 2, OFFSET: 4, DOLLY: 8, ZOOM: 16, TOUCH_ROTATE: 32, TOUCH_TRUCK: 64, TOUCH_OFFSET: 128, TOUCH_DOLLY: 256, TOUCH_ZOOM: 512, TOUCH_DOLLY_TRUCK: 1024, TOUCH_DOLLY_OFFSET: 2048, TOUCH_DOLLY_ROTATE: 4096, TOUCH_ZOOM_TRUCK: 8192, TOUCH_ZOOM_OFFSET: 16384, TOUCH_ZOOM_ROTATE: 32768 });
function bl(i) {
  return i.isPerspectiveCamera;
}
function To(i) {
  return i.isOrthographicCamera;
}
const oh = 2 * Math.PI, FR = Math.PI / 2, Hz = 1e-5;
function Ln(i, t = Hz) {
  return Math.abs(i) < t;
}
function On(i, t, e = Hz) {
  return Ln(i - t, e);
}
function UR(i, t) {
  return Math.round(i / t) * t;
}
function fd(i) {
  return isFinite(i) ? i : i < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;
}
function md(i) {
  return Math.abs(i) < Number.MAX_VALUE ? i : i * (1 / 0);
}
function Aw(i, t) {
  t.set(0, 0), i.forEach((e) => {
    t.x += e.clientX, t.y += e.clientY;
  }), t.x /= i.length, t.y /= i.length;
}
function Cw(i, t) {
  return !!To(i) && (console.warn(`${t} is not supported in OrthographicCamera`), !0);
}
function VR(i) {
  return i.invert ? i.invert() : i.inverse(), i;
}
let kot = class {
  constructor() {
    this._listeners = {};
  }
  addEventListener(i, t) {
    const e = this._listeners;
    e[i] === void 0 && (e[i] = []), e[i].indexOf(t) === -1 && e[i].push(t);
  }
  hasEventListener(i, t) {
    const e = this._listeners;
    return e[i] !== void 0 && e[i].indexOf(t) !== -1;
  }
  removeEventListener(i, t) {
    const e = this._listeners[i];
    if (e !== void 0) {
      const n = e.indexOf(t);
      n !== -1 && e.splice(n, 1);
    }
  }
  removeAllEventListeners(i) {
    i ? Array.isArray(this._listeners[i]) && (this._listeners[i].length = 0) : this._listeners = {};
  }
  dispatchEvent(i) {
    const t = this._listeners[i.type];
    if (t !== void 0) {
      i.target = this;
      const e = t.slice(0);
      for (let n = 0, r = e.length; n < r; n++)
        e[n].call(this, i);
    }
  }
};
const Ig = 1 / 8, jz = typeof window < "u", Not = jz && /Mac/.test(navigator.platform), HR = !(jz && "PointerEvent" in window);
let pe, jR, Og, Pw, wi, Fe, un, lh, Hs, js, Sl, GR, WR, ws, gd, ch, ZR, Dw, qR, Rw, Iw, Lg;
class Eo extends kot {
  static install(t) {
    pe = t.THREE, jR = Object.freeze(new pe.Vector3(0, 0, 0)), Og = Object.freeze(new pe.Vector3(0, 1, 0)), Pw = Object.freeze(new pe.Vector3(0, 0, 1)), wi = new pe.Vector2(), Fe = new pe.Vector3(), un = new pe.Vector3(), lh = new pe.Vector3(), Hs = new pe.Vector3(), js = new pe.Vector3(), Sl = new pe.Vector3(), GR = new pe.Vector3(), WR = new pe.Vector3(), ws = new pe.Spherical(), gd = new pe.Spherical(), ch = new pe.Box3(), ZR = new pe.Box3(), Dw = new pe.Sphere(), qR = new pe.Quaternion(), Rw = new pe.Quaternion(), Iw = new pe.Matrix4(), Lg = new pe.Raycaster();
  }
  static get ACTION() {
    return Zt;
  }
  constructor(t, e) {
    super(), this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.minDistance = 0, this.maxDistance = 1 / 0, this.infinityDolly = !1, this.minZoom = 0.01, this.maxZoom = 1 / 0, this.dampingFactor = 0.05, this.draggingDampingFactor = 0.25, this.azimuthRotateSpeed = 1, this.polarRotateSpeed = 1, this.dollySpeed = 1, this.truckSpeed = 2, this.dollyToCursor = !1, this.dragToOffset = !1, this.verticalDragToForward = !1, this.boundaryFriction = 0, this.restThreshold = 0.01, this.colliderMeshes = [], this.cancel = () => {
    }, this._enabled = !0, this._state = Zt.NONE, this._viewport = null, this._affectOffset = !1, this._dollyControlAmount = 0, this._hasRested = !0, this._boundaryEnclosesCamera = !1, this._needsUpdate = !0, this._updatedLastTime = !1, this._elementRect = new DOMRect(), this._activePointers = [], this._truckInternal = (M, A, C) => {
      if (bl(this._camera)) {
        const I = Fe.copy(this._camera.position).sub(this._target), k = this._camera.getEffectiveFOV() * pe.MathUtils.DEG2RAD, R = I.length() * Math.tan(0.5 * k), L = this.truckSpeed * M * R / this._elementRect.height, E = this.truckSpeed * A * R / this._elementRect.height;
        this.verticalDragToForward ? (C ? this.setFocalOffset(this._focalOffsetEnd.x + L, this._focalOffsetEnd.y, this._focalOffsetEnd.z, !0) : this.truck(L, 0, !0), this.forward(-E, !0)) : C ? this.setFocalOffset(this._focalOffsetEnd.x + L, this._focalOffsetEnd.y + E, this._focalOffsetEnd.z, !0) : this.truck(L, E, !0);
      } else if (To(this._camera)) {
        const I = this._camera, k = M * (I.right - I.left) / I.zoom / this._elementRect.width, R = A * (I.top - I.bottom) / I.zoom / this._elementRect.height;
        C ? this.setFocalOffset(this._focalOffsetEnd.x + k, this._focalOffsetEnd.y + R, this._focalOffsetEnd.z, !0) : this.truck(k, R, !0);
      }
    }, this._rotateInternal = (M, A) => {
      const C = oh * this.azimuthRotateSpeed * M / this._elementRect.height, I = oh * this.polarRotateSpeed * A / this._elementRect.height;
      this.rotate(C, I, !0);
    }, this._dollyInternal = (M, A, C) => {
      const I = Math.pow(0.95, -M * this.dollySpeed), k = this._sphericalEnd.radius * I, R = this._sphericalEnd.radius, L = R * (M >= 0 ? -1 : 1);
      this.dollyTo(k), this.infinityDolly && (k < this.minDistance || this.maxDistance === this.minDistance) && (this._camera.getWorldDirection(Fe), this._targetEnd.add(Fe.normalize().multiplyScalar(L)), this._target.add(Fe.normalize().multiplyScalar(L))), this.dollyToCursor && (this._dollyControlAmount += this._sphericalEnd.radius - R, this.infinityDolly && (k < this.minDistance || this.maxDistance === this.minDistance) && (this._dollyControlAmount -= L), this._dollyControlCoord.set(A, C));
    }, this._zoomInternal = (M, A, C) => {
      const I = Math.pow(0.95, M * this.dollySpeed), k = this._zoomEnd;
      this.zoomTo(this._zoom * I), this.dollyToCursor && (this._dollyControlAmount += this._zoomEnd - k, this._dollyControlCoord.set(A, C));
    }, pe === void 0 && console.error("camera-controls: `THREE` is undefined. You must first run `CameraControls.install( { THREE: THREE } )`. Check the docs for further information."), this._camera = t, this._yAxisUpSpace = new pe.Quaternion().setFromUnitVectors(this._camera.up, Og), this._yAxisUpSpaceInverse = VR(this._yAxisUpSpace.clone()), this._state = Zt.NONE, this._target = new pe.Vector3(), this._targetEnd = this._target.clone(), this._focalOffset = new pe.Vector3(), this._focalOffsetEnd = this._focalOffset.clone(), this._spherical = new pe.Spherical().setFromVector3(Fe.copy(this._camera.position).applyQuaternion(this._yAxisUpSpace)), this._sphericalEnd = this._spherical.clone(), this._zoom = this._camera.zoom, this._zoomEnd = this._zoom, this._nearPlaneCorners = [new pe.Vector3(), new pe.Vector3(), new pe.Vector3(), new pe.Vector3()], this._updateNearPlaneCorners(), this._boundary = new pe.Box3(new pe.Vector3(-1 / 0, -1 / 0, -1 / 0), new pe.Vector3(1 / 0, 1 / 0, 1 / 0)), this._target0 = this._target.clone(), this._position0 = this._camera.position.clone(), this._zoom0 = this._zoom, this._focalOffset0 = this._focalOffset.clone(), this._dollyControlAmount = 0, this._dollyControlCoord = new pe.Vector2(), this.mouseButtons = { left: Zt.ROTATE, middle: Zt.DOLLY, right: Zt.TRUCK, wheel: bl(this._camera) ? Zt.DOLLY : To(this._camera) ? Zt.ZOOM : Zt.NONE }, this.touches = { one: Zt.TOUCH_ROTATE, two: bl(this._camera) ? Zt.TOUCH_DOLLY_TRUCK : To(this._camera) ? Zt.TOUCH_ZOOM_TRUCK : Zt.NONE, three: Zt.TOUCH_TRUCK };
    const n = new pe.Vector2(), r = new pe.Vector2(), s = new pe.Vector2(), a = (M) => {
      if (!this._enabled || !this._domElement)
        return;
      const A = { pointerId: M.pointerId, clientX: M.clientX, clientY: M.clientY, deltaX: 0, deltaY: 0 };
      this._activePointers.push(A), this._domElement.ownerDocument.removeEventListener("pointermove", c, { passive: !1 }), this._domElement.ownerDocument.removeEventListener("pointerup", p), this._domElement.ownerDocument.addEventListener("pointermove", c, { passive: !1 }), this._domElement.ownerDocument.addEventListener("pointerup", p), w(M);
    }, o = (M) => {
      if (!this._enabled || !this._domElement)
        return;
      const A = { pointerId: 0, clientX: M.clientX, clientY: M.clientY, deltaX: 0, deltaY: 0 };
      this._activePointers.push(A), this._domElement.ownerDocument.removeEventListener("mousemove", u), this._domElement.ownerDocument.removeEventListener("mouseup", f), this._domElement.ownerDocument.addEventListener("mousemove", u), this._domElement.ownerDocument.addEventListener("mouseup", f), w(M);
    }, l = (M) => {
      this._enabled && this._domElement && (M.preventDefault(), Array.prototype.forEach.call(M.changedTouches, (A) => {
        const C = { pointerId: A.identifier, clientX: A.clientX, clientY: A.clientY, deltaX: 0, deltaY: 0 };
        this._activePointers.push(C);
      }), this._domElement.ownerDocument.removeEventListener("touchmove", h, { passive: !1 }), this._domElement.ownerDocument.removeEventListener("touchend", v), this._domElement.ownerDocument.addEventListener("touchmove", h, { passive: !1 }), this._domElement.ownerDocument.addEventListener("touchend", v), w(M));
    }, c = (M) => {
      M.cancelable && M.preventDefault();
      const A = M.pointerId, C = this._findPointerById(A);
      if (C) {
        if (C.clientX = M.clientX, C.clientY = M.clientY, C.deltaX = M.movementX, C.deltaY = M.movementY, M.pointerType === "touch")
          switch (this._activePointers.length) {
            case 1:
              this._state = this.touches.one;
              break;
            case 2:
              this._state = this.touches.two;
              break;
            case 3:
              this._state = this.touches.three;
          }
        else
          this._state = 0, (M.buttons & ih) === ih && (this._state = this._state | this.mouseButtons.left), (M.buttons & ah) === ah && (this._state = this._state | this.mouseButtons.middle), (M.buttons & sh) === sh && (this._state = this._state | this.mouseButtons.right);
        b();
      }
    }, u = (M) => {
      const A = this._findPointerById(0);
      A && (A.clientX = M.clientX, A.clientY = M.clientY, A.deltaX = M.movementX, A.deltaY = M.movementY, this._state = 0, (M.buttons & ih) === ih && (this._state = this._state | this.mouseButtons.left), (M.buttons & ah) === ah && (this._state = this._state | this.mouseButtons.middle), (M.buttons & sh) === sh && (this._state = this._state | this.mouseButtons.right), b());
    }, h = (M) => {
      M.cancelable && M.preventDefault(), Array.prototype.forEach.call(M.changedTouches, (A) => {
        const C = A.identifier, I = this._findPointerById(C);
        I && (I.clientX = A.clientX, I.clientY = A.clientY);
      }), b();
    }, p = (M) => {
      const A = M.pointerId, C = this._findPointerById(A);
      if (C && this._activePointers.splice(this._activePointers.indexOf(C), 1), M.pointerType === "touch")
        switch (this._activePointers.length) {
          case 0:
            this._state = Zt.NONE;
            break;
          case 1:
            this._state = this.touches.one;
            break;
          case 2:
            this._state = this.touches.two;
            break;
          case 3:
            this._state = this.touches.three;
        }
      else
        this._state = Zt.NONE;
      T();
    }, f = () => {
      const M = this._findPointerById(0);
      M && this._activePointers.splice(this._activePointers.indexOf(M), 1), this._state = Zt.NONE, T();
    }, v = (M) => {
      switch (Array.prototype.forEach.call(M.changedTouches, (A) => {
        const C = A.identifier, I = this._findPointerById(C);
        I && this._activePointers.splice(this._activePointers.indexOf(I), 1);
      }), this._activePointers.length) {
        case 0:
          this._state = Zt.NONE;
          break;
        case 1:
          this._state = this.touches.one;
          break;
        case 2:
          this._state = this.touches.two;
          break;
        case 3:
          this._state = this.touches.three;
      }
      T();
    };
    let m = -1;
    const y = (M) => {
      if (!this._enabled || this.mouseButtons.wheel === Zt.NONE)
        return;
      if (M.preventDefault(), this.dollyToCursor || this.mouseButtons.wheel === Zt.ROTATE || this.mouseButtons.wheel === Zt.TRUCK) {
        const R = performance.now();
        m - R < 1e3 && this._getClientRect(this._elementRect), m = R;
      }
      const A = Not ? -1 : -3, C = M.deltaMode === 1 ? M.deltaY / A : M.deltaY / (10 * A), I = this.dollyToCursor ? (M.clientX - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0, k = this.dollyToCursor ? (M.clientY - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0;
      switch (this.mouseButtons.wheel) {
        case Zt.ROTATE:
          this._rotateInternal(M.deltaX, M.deltaY);
          break;
        case Zt.TRUCK:
          this._truckInternal(M.deltaX, M.deltaY, !1);
          break;
        case Zt.OFFSET:
          this._truckInternal(M.deltaX, M.deltaY, !0);
          break;
        case Zt.DOLLY:
          this._dollyInternal(-C, I, k);
          break;
        case Zt.ZOOM:
          this._zoomInternal(-C, I, k);
      }
      this.dispatchEvent({ type: "control" });
    }, _ = (M) => {
      this._enabled && M.preventDefault();
    }, w = (M) => {
      if (this._enabled) {
        if (Aw(this._activePointers, wi), this._getClientRect(this._elementRect), n.copy(wi), r.copy(wi), this._activePointers.length >= 2) {
          const A = wi.x - this._activePointers[1].clientX, C = wi.y - this._activePointers[1].clientY, I = Math.sqrt(A * A + C * C);
          s.set(0, I);
          const k = 0.5 * (this._activePointers[0].clientX + this._activePointers[1].clientX), R = 0.5 * (this._activePointers[0].clientY + this._activePointers[1].clientY);
          r.set(k, R);
        }
        if ("touches" in M || "pointerType" in M && M.pointerType === "touch")
          switch (this._activePointers.length) {
            case 1:
              this._state = this.touches.one;
              break;
            case 2:
              this._state = this.touches.two;
              break;
            case 3:
              this._state = this.touches.three;
          }
        else
          this._state = 0, (M.buttons & ih) === ih && (this._state = this._state | this.mouseButtons.left), (M.buttons & ah) === ah && (this._state = this._state | this.mouseButtons.middle), (M.buttons & sh) === sh && (this._state = this._state | this.mouseButtons.right);
        this.dispatchEvent({ type: "controlstart" });
      }
    }, b = () => {
      if (!this._enabled)
        return;
      Aw(this._activePointers, wi);
      const M = this._domElement && document.pointerLockElement === this._domElement, A = M ? -this._activePointers[0].deltaX : r.x - wi.x, C = M ? -this._activePointers[0].deltaY : r.y - wi.y;
      if (r.copy(wi), (this._state & Zt.ROTATE) !== Zt.ROTATE && (this._state & Zt.TOUCH_ROTATE) !== Zt.TOUCH_ROTATE && (this._state & Zt.TOUCH_DOLLY_ROTATE) !== Zt.TOUCH_DOLLY_ROTATE && (this._state & Zt.TOUCH_ZOOM_ROTATE) !== Zt.TOUCH_ZOOM_ROTATE || this._rotateInternal(A, C), (this._state & Zt.DOLLY) === Zt.DOLLY || (this._state & Zt.ZOOM) === Zt.ZOOM) {
        const I = this.dollyToCursor ? (n.x - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0, k = this.dollyToCursor ? (n.y - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0;
        (this._state & Zt.DOLLY) === Zt.DOLLY ? this._dollyInternal(C * Ig, I, k) : this._zoomInternal(C * Ig, I, k);
      }
      if ((this._state & Zt.TOUCH_DOLLY) === Zt.TOUCH_DOLLY || (this._state & Zt.TOUCH_ZOOM) === Zt.TOUCH_ZOOM || (this._state & Zt.TOUCH_DOLLY_TRUCK) === Zt.TOUCH_DOLLY_TRUCK || (this._state & Zt.TOUCH_ZOOM_TRUCK) === Zt.TOUCH_ZOOM_TRUCK || (this._state & Zt.TOUCH_DOLLY_OFFSET) === Zt.TOUCH_DOLLY_OFFSET || (this._state & Zt.TOUCH_ZOOM_OFFSET) === Zt.TOUCH_ZOOM_OFFSET || (this._state & Zt.TOUCH_DOLLY_ROTATE) === Zt.TOUCH_DOLLY_ROTATE || (this._state & Zt.TOUCH_ZOOM_ROTATE) === Zt.TOUCH_ZOOM_ROTATE) {
        const I = wi.x - this._activePointers[1].clientX, k = wi.y - this._activePointers[1].clientY, R = Math.sqrt(I * I + k * k), L = s.y - R;
        s.set(0, R);
        const E = this.dollyToCursor ? (r.x - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0, q = this.dollyToCursor ? (r.y - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0;
        (this._state & Zt.TOUCH_DOLLY) === Zt.TOUCH_DOLLY || (this._state & Zt.TOUCH_DOLLY_ROTATE) === Zt.TOUCH_DOLLY_ROTATE || (this._state & Zt.TOUCH_DOLLY_TRUCK) === Zt.TOUCH_DOLLY_TRUCK || (this._state & Zt.TOUCH_DOLLY_OFFSET) === Zt.TOUCH_DOLLY_OFFSET ? this._dollyInternal(L * Ig, E, q) : this._zoomInternal(L * Ig, E, q);
      }
      (this._state & Zt.TRUCK) !== Zt.TRUCK && (this._state & Zt.TOUCH_TRUCK) !== Zt.TOUCH_TRUCK && (this._state & Zt.TOUCH_DOLLY_TRUCK) !== Zt.TOUCH_DOLLY_TRUCK && (this._state & Zt.TOUCH_ZOOM_TRUCK) !== Zt.TOUCH_ZOOM_TRUCK || this._truckInternal(A, C, !1), (this._state & Zt.OFFSET) !== Zt.OFFSET && (this._state & Zt.TOUCH_OFFSET) !== Zt.TOUCH_OFFSET && (this._state & Zt.TOUCH_DOLLY_OFFSET) !== Zt.TOUCH_DOLLY_OFFSET && (this._state & Zt.TOUCH_ZOOM_OFFSET) !== Zt.TOUCH_ZOOM_OFFSET || this._truckInternal(A, C, !0), this.dispatchEvent({ type: "control" });
    }, T = () => {
      Aw(this._activePointers, wi), r.copy(wi), this._activePointers.length === 0 && this._domElement && (this._domElement.ownerDocument.removeEventListener("pointermove", c, { passive: !1 }), this._domElement.ownerDocument.removeEventListener("pointerup", p), this._domElement.ownerDocument.removeEventListener("touchmove", h, { passive: !1 }), this._domElement.ownerDocument.removeEventListener("touchend", v), this.dispatchEvent({ type: "controlend" }));
    };
    this._addAllEventListeners = (M) => {
      this._domElement = M, this._domElement.style.touchAction = "none", this._domElement.style.userSelect = "none", this._domElement.style.webkitUserSelect = "none", this._domElement.addEventListener("pointerdown", a), HR && this._domElement.addEventListener("mousedown", o), HR && this._domElement.addEventListener("touchstart", l), this._domElement.addEventListener("pointercancel", p), this._domElement.addEventListener("wheel", y, { passive: !1 }), this._domElement.addEventListener("contextmenu", _);
    }, this._removeAllEventListeners = () => {
      this._domElement && (this._domElement.removeEventListener("pointerdown", a), this._domElement.removeEventListener("mousedown", o), this._domElement.removeEventListener("touchstart", l), this._domElement.removeEventListener("pointercancel", p), this._domElement.removeEventListener("wheel", y, { passive: !1 }), this._domElement.removeEventListener("contextmenu", _), this._domElement.ownerDocument.removeEventListener("pointermove", c, { passive: !1 }), this._domElement.ownerDocument.removeEventListener("mousemove", u), this._domElement.ownerDocument.removeEventListener("touchmove", h, { passive: !1 }), this._domElement.ownerDocument.removeEventListener("pointerup", p), this._domElement.ownerDocument.removeEventListener("mouseup", f), this._domElement.ownerDocument.removeEventListener("touchend", v));
    }, this.cancel = () => {
      this._state !== Zt.NONE && (this._state = Zt.NONE, this._activePointers.length = 0, T());
    }, e && this.connect(e), this.update(0);
  }
  get camera() {
    return this._camera;
  }
  set camera(t) {
    this._camera = t, this.updateCameraUp(), this._camera.updateProjectionMatrix(), this._updateNearPlaneCorners(), this._needsUpdate = !0;
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(t) {
    this._domElement && (this._enabled = t, t ? (this._domElement.style.touchAction = "none", this._domElement.style.userSelect = "none", this._domElement.style.webkitUserSelect = "none") : (this.cancel(), this._domElement.style.touchAction = "", this._domElement.style.userSelect = "", this._domElement.style.webkitUserSelect = ""));
  }
  get active() {
    return !this._hasRested;
  }
  get currentAction() {
    return this._state;
  }
  get distance() {
    return this._spherical.radius;
  }
  set distance(t) {
    this._spherical.radius === t && this._sphericalEnd.radius === t || (this._spherical.radius = t, this._sphericalEnd.radius = t, this._needsUpdate = !0);
  }
  get azimuthAngle() {
    return this._spherical.theta;
  }
  set azimuthAngle(t) {
    this._spherical.theta === t && this._sphericalEnd.theta === t || (this._spherical.theta = t, this._sphericalEnd.theta = t, this._needsUpdate = !0);
  }
  get polarAngle() {
    return this._spherical.phi;
  }
  set polarAngle(t) {
    this._spherical.phi === t && this._sphericalEnd.phi === t || (this._spherical.phi = t, this._sphericalEnd.phi = t, this._needsUpdate = !0);
  }
  get boundaryEnclosesCamera() {
    return this._boundaryEnclosesCamera;
  }
  set boundaryEnclosesCamera(t) {
    this._boundaryEnclosesCamera = t, this._needsUpdate = !0;
  }
  addEventListener(t, e) {
    super.addEventListener(t, e);
  }
  removeEventListener(t, e) {
    super.removeEventListener(t, e);
  }
  rotate(t, e, n = !1) {
    return this.rotateTo(this._sphericalEnd.theta + t, this._sphericalEnd.phi + e, n);
  }
  rotateAzimuthTo(t, e = !1) {
    return this.rotateTo(t, this._sphericalEnd.phi, e);
  }
  rotatePolarTo(t, e = !1) {
    return this.rotateTo(this._sphericalEnd.theta, t, e);
  }
  rotateTo(t, e, n = !1) {
    const r = pe.MathUtils.clamp(t, this.minAzimuthAngle, this.maxAzimuthAngle), s = pe.MathUtils.clamp(e, this.minPolarAngle, this.maxPolarAngle);
    this._sphericalEnd.theta = r, this._sphericalEnd.phi = s, this._sphericalEnd.makeSafe(), this._needsUpdate = !0, n || (this._spherical.theta = this._sphericalEnd.theta, this._spherical.phi = this._sphericalEnd.phi);
    const a = !n || On(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && On(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold);
    return this._createOnRestPromise(a);
  }
  dolly(t, e = !1) {
    return this.dollyTo(this._sphericalEnd.radius - t, e);
  }
  dollyTo(t, e = !1) {
    const n = this._sphericalEnd.radius, r = pe.MathUtils.clamp(t, this.minDistance, this.maxDistance);
    if (this.colliderMeshes.length >= 1) {
      const a = this._collisionTest(), o = On(a, this._spherical.radius);
      if (!(n > r) && o)
        return Promise.resolve();
      this._sphericalEnd.radius = Math.min(r, a);
    } else
      this._sphericalEnd.radius = r;
    this._needsUpdate = !0, e || (this._spherical.radius = this._sphericalEnd.radius);
    const s = !e || On(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
    return this._createOnRestPromise(s);
  }
  zoom(t, e = !1) {
    return this.zoomTo(this._zoomEnd + t, e);
  }
  zoomTo(t, e = !1) {
    this._zoomEnd = pe.MathUtils.clamp(t, this.minZoom, this.maxZoom), this._needsUpdate = !0, e || (this._zoom = this._zoomEnd);
    const n = !e || On(this._zoom, this._zoomEnd, this.restThreshold);
    return this._createOnRestPromise(n);
  }
  pan(t, e, n = !1) {
    return console.warn("`pan` has been renamed to `truck`"), this.truck(t, e, n);
  }
  truck(t, e, n = !1) {
    this._camera.updateMatrix(), Hs.setFromMatrixColumn(this._camera.matrix, 0), js.setFromMatrixColumn(this._camera.matrix, 1), Hs.multiplyScalar(t), js.multiplyScalar(-e);
    const r = Fe.copy(Hs).add(js), s = un.copy(this._targetEnd).add(r);
    return this.moveTo(s.x, s.y, s.z, n);
  }
  forward(t, e = !1) {
    Fe.setFromMatrixColumn(this._camera.matrix, 0), Fe.crossVectors(this._camera.up, Fe), Fe.multiplyScalar(t);
    const n = un.copy(this._targetEnd).add(Fe);
    return this.moveTo(n.x, n.y, n.z, e);
  }
  moveTo(t, e, n, r = !1) {
    const s = Fe.set(t, e, n).sub(this._targetEnd);
    this._encloseToBoundary(this._targetEnd, s, this.boundaryFriction), this._needsUpdate = !0, r || this._target.copy(this._targetEnd);
    const a = !r || On(this._target.x, this._targetEnd.x, this.restThreshold) && On(this._target.y, this._targetEnd.y, this.restThreshold) && On(this._target.z, this._targetEnd.z, this.restThreshold);
    return this._createOnRestPromise(a);
  }
  fitToBox(t, e, { cover: n = !1, paddingLeft: r = 0, paddingRight: s = 0, paddingBottom: a = 0, paddingTop: o = 0 } = {}) {
    const l = [], c = t.isBox3 ? ch.copy(t) : ch.setFromObject(t);
    c.isEmpty() && (console.warn("camera-controls: fitTo() cannot be used with an empty box. Aborting"), Promise.resolve());
    const u = UR(this._sphericalEnd.theta, FR), h = UR(this._sphericalEnd.phi, FR);
    l.push(this.rotateTo(u, h, e));
    const p = Fe.setFromSpherical(this._sphericalEnd).normalize(), f = qR.setFromUnitVectors(p, Pw), v = On(Math.abs(p.y), 1);
    v && f.multiply(Rw.setFromAxisAngle(Og, u)), f.multiply(this._yAxisUpSpaceInverse);
    const m = ZR.makeEmpty();
    un.copy(c.min).applyQuaternion(f), m.expandByPoint(un), un.copy(c.min).setX(c.max.x).applyQuaternion(f), m.expandByPoint(un), un.copy(c.min).setY(c.max.y).applyQuaternion(f), m.expandByPoint(un), un.copy(c.max).setZ(c.min.z).applyQuaternion(f), m.expandByPoint(un), un.copy(c.min).setZ(c.max.z).applyQuaternion(f), m.expandByPoint(un), un.copy(c.max).setY(c.min.y).applyQuaternion(f), m.expandByPoint(un), un.copy(c.max).setX(c.min.x).applyQuaternion(f), m.expandByPoint(un), un.copy(c.max).applyQuaternion(f), m.expandByPoint(un), m.min.x -= r, m.min.y -= a, m.max.x += s, m.max.y += o, f.setFromUnitVectors(Pw, p), v && f.premultiply(Rw.invert()), f.premultiply(this._yAxisUpSpace);
    const y = m.getSize(Fe), _ = m.getCenter(un).applyQuaternion(f);
    if (bl(this._camera)) {
      const w = this.getDistanceToFitBox(y.x, y.y, y.z, n);
      l.push(this.moveTo(_.x, _.y, _.z, e)), l.push(this.dollyTo(w, e)), l.push(this.setFocalOffset(0, 0, 0, e));
    } else if (To(this._camera)) {
      const w = this._camera, b = w.right - w.left, T = w.top - w.bottom, M = n ? Math.max(b / y.x, T / y.y) : Math.min(b / y.x, T / y.y);
      l.push(this.moveTo(_.x, _.y, _.z, e)), l.push(this.zoomTo(M, e)), l.push(this.setFocalOffset(0, 0, 0, e));
    }
    return Promise.all(l);
  }
  fitToSphere(t, e) {
    const n = [], r = t instanceof pe.Sphere ? Dw.copy(t) : function(s, a) {
      const o = a, l = o.center;
      ch.makeEmpty(), s.traverseVisible((u) => {
        u.isMesh && ch.expandByObject(u);
      }), ch.getCenter(l);
      let c = 0;
      return s.traverseVisible((u) => {
        if (!u.isMesh)
          return;
        const h = u, p = h.geometry.clone();
        if (p.applyMatrix4(h.matrixWorld), p.isBufferGeometry) {
          const f = p.attributes.position;
          for (let v = 0, m = f.count; v < m; v++)
            Fe.fromBufferAttribute(f, v), c = Math.max(c, l.distanceToSquared(Fe));
        } else {
          const f = p.attributes.position, v = new pe.Vector3();
          for (let m = 0, y = f.count; m < y; m++)
            v.fromBufferAttribute(f, m), c = Math.max(c, l.distanceToSquared(v));
        }
      }), o.radius = Math.sqrt(c), o;
    }(t, Dw);
    if (n.push(this.moveTo(r.center.x, r.center.y, r.center.z, e)), bl(this._camera)) {
      const s = this.getDistanceToFitSphere(r.radius);
      n.push(this.dollyTo(s, e));
    } else if (To(this._camera)) {
      const s = this._camera.right - this._camera.left, a = this._camera.top - this._camera.bottom, o = 2 * r.radius, l = Math.min(s / o, a / o);
      n.push(this.zoomTo(l, e));
    }
    return n.push(this.setFocalOffset(0, 0, 0, e)), Promise.all(n);
  }
  setLookAt(t, e, n, r, s, a, o = !1) {
    const l = un.set(r, s, a), c = Fe.set(t, e, n);
    this._targetEnd.copy(l), this._sphericalEnd.setFromVector3(c.sub(l).applyQuaternion(this._yAxisUpSpace)), this.normalizeRotations(), this._needsUpdate = !0, o || (this._target.copy(this._targetEnd), this._spherical.copy(this._sphericalEnd));
    const u = !o || On(this._target.x, this._targetEnd.x, this.restThreshold) && On(this._target.y, this._targetEnd.y, this.restThreshold) && On(this._target.z, this._targetEnd.z, this.restThreshold) && On(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && On(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold) && On(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
    return this._createOnRestPromise(u);
  }
  lerpLookAt(t, e, n, r, s, a, o, l, c, u, h, p, f, v = !1) {
    const m = Fe.set(r, s, a), y = un.set(t, e, n);
    ws.setFromVector3(y.sub(m).applyQuaternion(this._yAxisUpSpace));
    const _ = lh.set(u, h, p), w = un.set(o, l, c);
    gd.setFromVector3(w.sub(_).applyQuaternion(this._yAxisUpSpace)), this._targetEnd.copy(m.lerp(_, f));
    const b = gd.theta - ws.theta, T = gd.phi - ws.phi, M = gd.radius - ws.radius;
    this._sphericalEnd.set(ws.radius + M * f, ws.phi + T * f, ws.theta + b * f), this.normalizeRotations(), this._needsUpdate = !0, v || (this._target.copy(this._targetEnd), this._spherical.copy(this._sphericalEnd));
    const A = !v || On(this._target.x, this._targetEnd.x, this.restThreshold) && On(this._target.y, this._targetEnd.y, this.restThreshold) && On(this._target.z, this._targetEnd.z, this.restThreshold) && On(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && On(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold) && On(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
    return this._createOnRestPromise(A);
  }
  setPosition(t, e, n, r = !1) {
    return this.setLookAt(t, e, n, this._targetEnd.x, this._targetEnd.y, this._targetEnd.z, r);
  }
  setTarget(t, e, n, r = !1) {
    const s = this.getPosition(Fe), a = this.setLookAt(s.x, s.y, s.z, t, e, n, r);
    return this._sphericalEnd.phi = pe.MathUtils.clamp(this.polarAngle, this.minPolarAngle, this.maxPolarAngle), a;
  }
  setFocalOffset(t, e, n, r = !1) {
    this._focalOffsetEnd.set(t, e, n), this._needsUpdate = !0, r || this._focalOffset.copy(this._focalOffsetEnd), this._affectOffset = !Ln(t) || !Ln(e) || !Ln(n);
    const s = !r || On(this._focalOffset.x, this._focalOffsetEnd.x, this.restThreshold) && On(this._focalOffset.y, this._focalOffsetEnd.y, this.restThreshold) && On(this._focalOffset.z, this._focalOffsetEnd.z, this.restThreshold);
    return this._createOnRestPromise(s);
  }
  setOrbitPoint(t, e, n) {
    this._camera.updateMatrixWorld(), Hs.setFromMatrixColumn(this._camera.matrixWorldInverse, 0), js.setFromMatrixColumn(this._camera.matrixWorldInverse, 1), Sl.setFromMatrixColumn(this._camera.matrixWorldInverse, 2);
    const r = Fe.set(t, e, n), s = r.distanceTo(this._camera.position), a = r.sub(this._camera.position);
    Hs.multiplyScalar(a.x), js.multiplyScalar(a.y), Sl.multiplyScalar(a.z), Fe.copy(Hs).add(js).add(Sl), Fe.z = Fe.z + s, this.dollyTo(s, !1), this.setFocalOffset(-Fe.x, Fe.y, -Fe.z, !1), this.moveTo(t, e, n, !1);
  }
  setBoundary(t) {
    if (!t)
      return this._boundary.min.set(-1 / 0, -1 / 0, -1 / 0), this._boundary.max.set(1 / 0, 1 / 0, 1 / 0), void (this._needsUpdate = !0);
    this._boundary.copy(t), this._boundary.clampPoint(this._targetEnd, this._targetEnd), this._needsUpdate = !0;
  }
  setViewport(t, e, n, r) {
    t !== null ? (this._viewport = this._viewport || new pe.Vector4(), typeof t == "number" ? this._viewport.set(t, e, n, r) : this._viewport.copy(t)) : this._viewport = null;
  }
  getDistanceToFitBox(t, e, n, r = !1) {
    if (Cw(this._camera, "getDistanceToFitBox"))
      return this._spherical.radius;
    const s = t / e, a = this._camera.getEffectiveFOV() * pe.MathUtils.DEG2RAD, o = this._camera.aspect;
    return 0.5 * ((r ? s > o : s < o) ? e : t / o) / Math.tan(0.5 * a) + 0.5 * n;
  }
  getDistanceToFitSphere(t) {
    if (Cw(this._camera, "getDistanceToFitSphere"))
      return this._spherical.radius;
    const e = this._camera.getEffectiveFOV() * pe.MathUtils.DEG2RAD, n = 2 * Math.atan(Math.tan(0.5 * e) * this._camera.aspect), r = 1 < this._camera.aspect ? e : n;
    return t / Math.sin(0.5 * r);
  }
  getTarget(t) {
    return (t && t.isVector3 ? t : new pe.Vector3()).copy(this._targetEnd);
  }
  getPosition(t) {
    return (t && t.isVector3 ? t : new pe.Vector3()).setFromSpherical(this._sphericalEnd).applyQuaternion(this._yAxisUpSpaceInverse).add(this._targetEnd);
  }
  getFocalOffset(t) {
    return (t && t.isVector3 ? t : new pe.Vector3()).copy(this._focalOffsetEnd);
  }
  normalizeRotations() {
    this._sphericalEnd.theta = this._sphericalEnd.theta % oh, this._sphericalEnd.theta < 0 && (this._sphericalEnd.theta += oh), this._spherical.theta += oh * Math.round((this._sphericalEnd.theta - this._spherical.theta) / oh);
  }
  reset(t = !1) {
    const e = [this.setLookAt(this._position0.x, this._position0.y, this._position0.z, this._target0.x, this._target0.y, this._target0.z, t), this.setFocalOffset(this._focalOffset0.x, this._focalOffset0.y, this._focalOffset0.z, t), this.zoomTo(this._zoom0, t)];
    return Promise.all(e);
  }
  saveState() {
    this.getTarget(this._target0), this.getPosition(this._position0), this._zoom0 = this._zoom, this._focalOffset0.copy(this._focalOffset);
  }
  updateCameraUp() {
    this._yAxisUpSpace.setFromUnitVectors(this._camera.up, Og), VR(this._yAxisUpSpaceInverse.copy(this._yAxisUpSpace));
  }
  update(t) {
    const e = this._state === Zt.NONE ? this.dampingFactor : this.draggingDampingFactor, n = Math.min(e * t * 60, 1), r = this._sphericalEnd.theta - this._spherical.theta, s = this._sphericalEnd.phi - this._spherical.phi, a = this._sphericalEnd.radius - this._spherical.radius, o = GR.subVectors(this._targetEnd, this._target), l = WR.subVectors(this._focalOffsetEnd, this._focalOffset);
    if (Ln(r) && Ln(s) && Ln(a) && Ln(o.x) && Ln(o.y) && Ln(o.z) && Ln(l.x) && Ln(l.y) && Ln(l.z) ? (this._spherical.copy(this._sphericalEnd), this._target.copy(this._targetEnd), this._focalOffset.copy(this._focalOffsetEnd)) : (this._spherical.set(this._spherical.radius + a * n, this._spherical.phi + s * n, this._spherical.theta + r * n), this._target.add(o.multiplyScalar(n)), this._focalOffset.add(l.multiplyScalar(n)), this._needsUpdate = !0), this._dollyControlAmount !== 0) {
      if (bl(this._camera)) {
        const p = this._camera, f = Fe.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).normalize().negate(), v = un.copy(f).cross(p.up).normalize();
        v.lengthSq() === 0 && (v.x = 1);
        const m = lh.crossVectors(v, f), y = this._sphericalEnd.radius * Math.tan(p.getEffectiveFOV() * pe.MathUtils.DEG2RAD * 0.5), _ = (this._sphericalEnd.radius - this._dollyControlAmount - this._sphericalEnd.radius) / this._sphericalEnd.radius, w = Fe.copy(this._targetEnd).add(v.multiplyScalar(this._dollyControlCoord.x * y * p.aspect)).add(m.multiplyScalar(this._dollyControlCoord.y * y));
        this._targetEnd.lerp(w, _);
      } else if (To(this._camera)) {
        const p = this._camera, f = Fe.set(this._dollyControlCoord.x, this._dollyControlCoord.y, (p.near + p.far) / (p.near - p.far)).unproject(p), v = un.set(0, 0, -1).applyQuaternion(p.quaternion), m = lh.copy(f).add(v.multiplyScalar(-f.dot(p.up))), y = -(this._zoom - this._dollyControlAmount - this._zoomEnd) / this._zoom, _ = Fe.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).normalize().negate(), w = this._targetEnd.dot(_);
        this._targetEnd.lerp(m, y);
        const b = this._targetEnd.dot(_), T = _.multiplyScalar(b - w);
        this._targetEnd.sub(T);
      }
      this._target.copy(this._targetEnd), this._boundary.clampPoint(this._targetEnd, this._targetEnd), this._dollyControlAmount = 0;
    }
    const c = this._zoomEnd - this._zoom;
    this._zoom += c * n, this._camera.zoom !== this._zoom && (Ln(c) && (this._zoom = this._zoomEnd), this._camera.zoom = this._zoom, this._camera.updateProjectionMatrix(), this._updateNearPlaneCorners(), this._needsUpdate = !0);
    const u = this._collisionTest();
    this._spherical.radius = Math.min(this._spherical.radius, u), this._spherical.makeSafe(), this._camera.position.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(this._target), this._camera.lookAt(this._target), this._affectOffset && (this._camera.updateMatrixWorld(), Hs.setFromMatrixColumn(this._camera.matrix, 0), js.setFromMatrixColumn(this._camera.matrix, 1), Sl.setFromMatrixColumn(this._camera.matrix, 2), Hs.multiplyScalar(this._focalOffset.x), js.multiplyScalar(-this._focalOffset.y), Sl.multiplyScalar(this._focalOffset.z), Fe.copy(Hs).add(js).add(Sl), this._camera.position.add(Fe)), this._boundaryEnclosesCamera && this._encloseToBoundary(this._camera.position.copy(this._target), Fe.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse), 1);
    const h = this._needsUpdate;
    return h && !this._updatedLastTime ? (this._hasRested = !1, this.dispatchEvent({ type: "wake" }), this.dispatchEvent({ type: "update" })) : h ? (this.dispatchEvent({ type: "update" }), Ln(r, this.restThreshold) && Ln(s, this.restThreshold) && Ln(a, this.restThreshold) && Ln(o.x, this.restThreshold) && Ln(o.y, this.restThreshold) && Ln(o.z, this.restThreshold) && Ln(l.x, this.restThreshold) && Ln(l.y, this.restThreshold) && Ln(l.z, this.restThreshold) && Ln(c, this.restThreshold) && !this._hasRested && (this._hasRested = !0, this.dispatchEvent({ type: "rest" }))) : !h && this._updatedLastTime && this.dispatchEvent({ type: "sleep" }), this._updatedLastTime = h, this._needsUpdate = !1, h;
  }
  toJSON() {
    return JSON.stringify({ enabled: this._enabled, minDistance: this.minDistance, maxDistance: fd(this.maxDistance), minZoom: this.minZoom, maxZoom: fd(this.maxZoom), minPolarAngle: this.minPolarAngle, maxPolarAngle: fd(this.maxPolarAngle), minAzimuthAngle: fd(this.minAzimuthAngle), maxAzimuthAngle: fd(this.maxAzimuthAngle), dampingFactor: this.dampingFactor, draggingDampingFactor: this.draggingDampingFactor, dollySpeed: this.dollySpeed, truckSpeed: this.truckSpeed, dollyToCursor: this.dollyToCursor, verticalDragToForward: this.verticalDragToForward, target: this._targetEnd.toArray(), position: Fe.setFromSpherical(this._sphericalEnd).add(this._targetEnd).toArray(), zoom: this._zoomEnd, focalOffset: this._focalOffsetEnd.toArray(), target0: this._target0.toArray(), position0: this._position0.toArray(), zoom0: this._zoom0, focalOffset0: this._focalOffset0.toArray() });
  }
  fromJSON(t, e = !1) {
    const n = JSON.parse(t), r = Fe.fromArray(n.position);
    this.enabled = n.enabled, this.minDistance = n.minDistance, this.maxDistance = md(n.maxDistance), this.minZoom = n.minZoom, this.maxZoom = md(n.maxZoom), this.minPolarAngle = n.minPolarAngle, this.maxPolarAngle = md(n.maxPolarAngle), this.minAzimuthAngle = md(n.minAzimuthAngle), this.maxAzimuthAngle = md(n.maxAzimuthAngle), this.dampingFactor = n.dampingFactor, this.draggingDampingFactor = n.draggingDampingFactor, this.dollySpeed = n.dollySpeed, this.truckSpeed = n.truckSpeed, this.dollyToCursor = n.dollyToCursor, this.verticalDragToForward = n.verticalDragToForward, this._target0.fromArray(n.target0), this._position0.fromArray(n.position0), this._zoom0 = n.zoom0, this._focalOffset0.fromArray(n.focalOffset0), this.moveTo(n.target[0], n.target[1], n.target[2], e), ws.setFromVector3(r.sub(this._targetEnd).applyQuaternion(this._yAxisUpSpace)), this.rotateTo(ws.theta, ws.phi, e), this.zoomTo(n.zoom, e), this.setFocalOffset(n.focalOffset[0], n.focalOffset[1], n.focalOffset[2], e), this._needsUpdate = !0;
  }
  connect(t) {
    this._domElement ? console.warn("camera-controls is already connected.") : (t.setAttribute("data-camera-controls-version", "1.38.1"), this._addAllEventListeners(t));
  }
  disconnect() {
    this._removeAllEventListeners(), this._domElement = void 0;
  }
  dispose() {
    this.disconnect(), this._domElement && "setAttribute" in this._domElement && this._domElement.removeAttribute("data-camera-controls-version");
  }
  _findPointerById(t) {
    let e = null;
    return this._activePointers.some((n) => n.pointerId === t && (e = n, !0)), e;
  }
  _encloseToBoundary(t, e, n) {
    const r = e.lengthSq();
    if (r === 0)
      return t;
    const s = un.copy(e).add(t), a = this._boundary.clampPoint(s, lh).sub(s), o = a.lengthSq();
    if (o === 0)
      return t.add(e);
    if (o === r)
      return t;
    if (n === 0)
      return t.add(e).add(a);
    {
      const l = 1 + n * o / e.dot(a);
      return t.add(un.copy(e).multiplyScalar(l)).add(a.multiplyScalar(1 - n));
    }
  }
  _updateNearPlaneCorners() {
    if (bl(this._camera)) {
      const t = this._camera, e = t.near, n = t.getEffectiveFOV() * pe.MathUtils.DEG2RAD, r = Math.tan(0.5 * n) * e, s = r * t.aspect;
      this._nearPlaneCorners[0].set(-s, -r, 0), this._nearPlaneCorners[1].set(s, -r, 0), this._nearPlaneCorners[2].set(s, r, 0), this._nearPlaneCorners[3].set(-s, r, 0);
    } else if (To(this._camera)) {
      const t = this._camera, e = 1 / t.zoom, n = t.left * e, r = t.right * e, s = t.top * e, a = t.bottom * e;
      this._nearPlaneCorners[0].set(n, s, 0), this._nearPlaneCorners[1].set(r, s, 0), this._nearPlaneCorners[2].set(r, a, 0), this._nearPlaneCorners[3].set(n, a, 0);
    }
  }
  _collisionTest() {
    let t = 1 / 0;
    if (!(this.colliderMeshes.length >= 1) || Cw(this._camera, "_collisionTest"))
      return t;
    const e = Fe.setFromSpherical(this._spherical).divideScalar(this._spherical.radius);
    Iw.lookAt(jR, e, this._camera.up);
    for (let n = 0; n < 4; n++) {
      const r = un.copy(this._nearPlaneCorners[n]);
      r.applyMatrix4(Iw);
      const s = lh.addVectors(this._target, r);
      Lg.set(s, e), Lg.far = this._spherical.radius + 1;
      const a = Lg.intersectObjects(this.colliderMeshes);
      a.length !== 0 && a[0].distance < t && (t = a[0].distance);
    }
    return t;
  }
  _getClientRect(t) {
    if (!this._domElement)
      return;
    const e = this._domElement.getBoundingClientRect();
    return t.x = e.left, t.y = e.top, this._viewport ? (t.x += this._viewport.x, t.y += e.height - this._viewport.w - this._viewport.y, t.width = this._viewport.z, t.height = this._viewport.w) : (t.width = e.width, t.height = e.height), t;
  }
  _createOnRestPromise(t) {
    return t ? Promise.resolve() : (this._hasRested = !1, this.dispatchEvent({ type: "transitionstart" }), new Promise((e) => {
      const n = () => {
        this.removeEventListener("rest", n), e();
      };
      this.addEventListener("rest", n);
    }));
  }
  _addAllEventListeners(t) {
  }
  _removeAllEventListeners() {
  }
}
var Ni;
(function(i) {
  i.HOLD_START = "holdStart", i.HOLD_END = "holdEnd", i.HOLDING = "holding";
})(Ni || (Ni = {}));
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var Cb = function(i, t) {
  return Cb = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, n) {
    e.__proto__ = n;
  } || function(e, n) {
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }, Cb(i, t);
};
function vM(i, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
  function e() {
    this.constructor = i;
  }
  Cb(i, t), i.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var Fot = function() {
  function i() {
    this._listeners = {};
  }
  return i.prototype.addEventListener = function(t, e) {
    var n = this._listeners;
    n[t] === void 0 && (n[t] = []), n[t].indexOf(e) === -1 && n[t].push(e);
  }, i.prototype.removeEventListener = function(t, e) {
    var n = this._listeners[t];
    if (n !== void 0) {
      var r = n.indexOf(e);
      r !== -1 && n.splice(r, 1);
    }
  }, i.prototype.dispatchEvent = function(t) {
    var e = this._listeners[t.type];
    if (e !== void 0) {
      t.target = this;
      for (var n = e.slice(0), r = 0, s = n.length; r < s; r++)
        n[r].call(this, t);
    }
  }, i;
}(), Gz = function(i) {
  function t(e) {
    var n = i.call(this) || this;
    return n._enabled = !0, n._holding = !1, n._intervalId = -1, n._deltaTime = 0, n._elapsedTime = 0, n._lastTime = 0, n._holdStart = function(r) {
      if (n._enabled && !n._holding) {
        n._deltaTime = 0, n._elapsedTime = 0, n._lastTime = performance.now(), n.dispatchEvent({ type: Ni.HOLD_START, deltaTime: n._deltaTime, elapsedTime: n._elapsedTime, originalEvent: r }), n._holding = !0;
        var s = function() {
          n._intervalId = n.holdIntervalDelay ? window.setTimeout(s, n.holdIntervalDelay) : window.requestAnimationFrame(s);
          var a = performance.now();
          n._deltaTime = a - n._lastTime, n._elapsedTime += n._deltaTime, n._lastTime = performance.now(), n.dispatchEvent({ type: Ni.HOLDING, deltaTime: n._deltaTime, elapsedTime: n._elapsedTime });
        };
        n._intervalId = n.holdIntervalDelay ? window.setTimeout(s, n.holdIntervalDelay) : window.requestAnimationFrame(s);
      }
    }, n._holdEnd = function(r) {
      if (n._enabled && n._holding) {
        var s = performance.now();
        n._deltaTime = s - n._lastTime, n._elapsedTime += n._deltaTime, n._lastTime = performance.now(), n.dispatchEvent({ type: Ni.HOLD_END, deltaTime: n._deltaTime, elapsedTime: n._elapsedTime, originalEvent: r }), window.clearTimeout(n._intervalId), window.cancelAnimationFrame(n._intervalId), n._holding = !1;
      }
    }, n.holdIntervalDelay = e, n;
  }
  return vM(t, i), Object.defineProperty(t.prototype, "enabled", { get: function() {
    return this._enabled;
  }, set: function(e) {
    this._enabled !== e && (this._enabled = e, this._enabled || this._holdEnd());
  }, enumerable: !1, configurable: !0 }), t;
}(Fot);
(function(i) {
  function t(e, n) {
    var r = i.call(this, n) || this;
    r._holdStart = r._holdStart.bind(r), r._holdEnd = r._holdEnd.bind(r);
    var s = r._holdStart, a = r._holdEnd;
    return e.addEventListener("mousedown", s), document.addEventListener("mouseup", a), window.addEventListener("blur", r._holdEnd), r;
  }
  vM(t, i);
})(Gz);
var Bg = function(i) {
  function t(e, n) {
    var r = i.call(this, n) || this;
    return r._holdStart = r._holdStart.bind(r), r._holdEnd = r._holdEnd.bind(r), document.addEventListener("keydown", function(s) {
      (function(a) {
        var o = a.target;
        return o.tagName === "INPUT" || o.tagName === "SELECT" || o.tagName === "TEXTAREA" || o.isContentEditable;
      })(s) || s.keyCode === e && r._holdStart(s);
    }), document.addEventListener("keyup", function(s) {
      s.keyCode === e && r._holdEnd(s);
    }), window.addEventListener("blur", r._holdEnd), r;
  }
  return vM(t, i), t;
}(Gz);
let Pb;
var rn;
function Ow(i) {
  return i.isOrthographicCamera;
}
(rn = Pb || (Pb = {}))[rn.NONE = 0] = "NONE", rn[rn.ROTATE = 1] = "ROTATE", rn[rn.TRUCK = 2] = "TRUCK", rn[rn.OFFSET = 3] = "OFFSET", rn[rn.DOLLY = 4] = "DOLLY", rn[rn.ZOOM = 5] = "ZOOM", rn[rn.TOUCH_ROTATE = 6] = "TOUCH_ROTATE", rn[rn.TOUCH_TRUCK = 7] = "TOUCH_TRUCK", rn[rn.TOUCH_OFFSET = 8] = "TOUCH_OFFSET", rn[rn.TOUCH_DOLLY = 9] = "TOUCH_DOLLY", rn[rn.TOUCH_ZOOM = 10] = "TOUCH_ZOOM", rn[rn.TOUCH_DOLLY_TRUCK = 11] = "TOUCH_DOLLY_TRUCK", rn[rn.TOUCH_DOLLY_OFFSET = 12] = "TOUCH_DOLLY_OFFSET", rn[rn.TOUCH_ZOOM_TRUCK = 13] = "TOUCH_ZOOM_TRUCK", rn[rn.TOUCH_ZOOM_OFFSET = 14] = "TOUCH_ZOOM_OFFSET";
const Wz = 1e-5;
function Xe(i, t = Wz) {
  return Math.abs(i) < t;
}
function Lw(i, t, e = Wz) {
  return Xe(i - t, e);
}
let XR, YR, Gs, Bw, zw, zg, kg, Ng;
class JR extends Eo {
  constructor() {
    super(...arguments);
    U(this, "_didDolly", !1);
    U(this, "_didDollyLastFrame", !1);
    U(this, "_isTrucking", !1);
    U(this, "_hasRestedLastFrame", !1);
    U(this, "_didZoom", !1);
    U(this, "overrideDollyLerpRatio", 0);
    U(this, "overrideZoomLerpRatio", 0);
    U(this, "_dollyInternal", (e, n, r) => {
      const s = Math.pow(0.95, -e * this.dollySpeed), a = this._sphericalEnd.radius * s, o = this._sphericalEnd.radius, l = o * (e >= 0 ? -1 : 1);
      this.dollyTo(a, !0, 0.9), this.infinityDolly && (a < this.minDistance || this.maxDistance === this.minDistance) && (this._camera.getWorldDirection(Gs), this._targetEnd.add(Gs.normalize().multiplyScalar(l)), this._target.add(Gs.normalize().multiplyScalar(l))), this.dollyToCursor && (this._dollyControlAmount += this._sphericalEnd.radius - o, this.infinityDolly && (a < this.minDistance || this.maxDistance === this.minDistance) && (this._dollyControlAmount -= l), this._dollyControlCoord.set(n, r));
    });
    U(this, "_zoomInternal", (e, n, r) => {
      const s = Math.pow(0.95, e * this.dollySpeed);
      this.zoomTo(this._zoom * s, !1, 1), this._didDolly = !0, this.dispatchEvent({ type: "controlstart" }), this.dollyToCursor && (this._dollyControlAmount = this._zoomEnd, this._dollyControlCoord.set(n, r));
    });
  }
  static install() {
    Gs = new D(), Bw = new D(), zw = new D(), zg = new D(), kg = new D(), Ng = new D(), XR = new D(), YR = new D();
  }
  get hasRested() {
    return this._hasRested;
  }
  set isTrucking(e) {
    this._isTrucking = e;
  }
  zoomTo(e, n = !1, r = void 0) {
    this._zoomEnd = Hl.clamp(e, this.minZoom, this.maxZoom), this._needsUpdate = !0, this.overrideZoomLerpRatio = n ? 0.05 : r, n || (this._zoom = this._zoomEnd);
    const s = !n || Lw(this._zoom, this._zoomEnd, this.restThreshold);
    return this._createOnRestPromise(s);
  }
  dollyTo(e, n = !0, r = void 0) {
    const s = this._sphericalEnd.radius, a = Hl.clamp(e, this.minDistance, this.maxDistance);
    if (this.colliderMeshes.length >= 1) {
      const l = this._collisionTest(), c = Lw(l, this._spherical.radius);
      if (!(s > a) && c)
        return Promise.resolve();
      this._sphericalEnd.radius = Math.min(a, l);
    } else
      this._sphericalEnd.radius = a;
    this._needsUpdate = !0, this.overrideDollyLerpRatio = r, n || (this._spherical.radius = this._sphericalEnd.radius, this._didDolly = !0, this.dispatchEvent({ type: "controlstart" }));
    const o = !n || Lw(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
    return this._createOnRestPromise(o);
  }
  update(e) {
    this._hasRestedLastFrame = this._hasRested;
    const n = this._state === Pb.NONE ? this.dampingFactor : this.draggingDampingFactor, r = Math.min(n * e * 60, 1), s = this._sphericalEnd.theta - this._spherical.theta, a = this._sphericalEnd.phi - this._spherical.phi, o = this._sphericalEnd.radius - this._spherical.radius, l = XR.subVectors(this._targetEnd, this._target), c = YR.subVectors(this._focalOffsetEnd, this._focalOffset);
    if (Xe(s) && Xe(a) && Xe(o) && Xe(l.x) && Xe(l.y) && Xe(l.z) && Xe(c.x) && Xe(c.y) && Xe(c.z) ? (this._spherical.copy(this._sphericalEnd), this._target.copy(this._targetEnd), this._focalOffset.copy(this._focalOffsetEnd)) : (this._spherical.set(this._spherical.radius + o * (this.overrideDollyLerpRatio ? this.overrideDollyLerpRatio : r), this._spherical.phi + a * r, this._spherical.theta + s * r), this._target.add(l.multiplyScalar(r)), this._focalOffset.add(c.multiplyScalar(r)), this._needsUpdate = !0), this._dollyControlAmount !== 0) {
      if (this._camera.isPerspectiveCamera) {
        const f = this._camera, v = Gs.setFromSpherical(this._sphericalEnd).applyQuaternion(this._yAxisUpSpaceInverse).normalize().negate(), m = Bw.copy(v).cross(f.up).normalize();
        m.lengthSq() === 0 && (m.x = 1);
        const y = zw.crossVectors(m, v), _ = this._sphericalEnd.radius * Math.tan(f.getEffectiveFOV() * Hl.DEG2RAD * 0.5), w = (this._sphericalEnd.radius - this._dollyControlAmount - this._sphericalEnd.radius) / this._sphericalEnd.radius, b = Gs.copy(this._targetEnd).add(m.multiplyScalar(this._dollyControlCoord.x * _ * f.aspect)).add(y.multiplyScalar(this._dollyControlCoord.y * _));
        this._targetEnd.lerp(b, w), this._target.copy(this._targetEnd);
      } else if (Ow(this._camera)) {
        const f = this._camera, v = Gs.set(this._dollyControlCoord.x, this._dollyControlCoord.y, (f.near + f.far) / (f.near - f.far)).unproject(f), m = Bw.set(0, 0, -1).applyQuaternion(f.quaternion), y = m.dot(f.up), _ = Xe(y) ? -v.dot(f.up) : -v.dot(f.up) / y, w = zw.copy(v).add(m.multiplyScalar(_));
        this._targetEnd.lerp(w, 1 - f.zoom / this._dollyControlAmount), this._target.copy(this._targetEnd);
      }
      this._dollyControlAmount = 0;
    }
    const u = this._collisionTest();
    this._spherical.radius = Math.min(this._spherical.radius, u), this._spherical.makeSafe(), this._camera.position.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(this._target), this._camera.lookAt(this._target), (!Xe(this._focalOffset.x) || !Xe(this._focalOffset.y) || !Xe(this._focalOffset.z)) && (this._camera.updateMatrix(), zg.setFromMatrixColumn(this._camera.matrix, 0), kg.setFromMatrixColumn(this._camera.matrix, 1), Ng.setFromMatrixColumn(this._camera.matrix, 2), zg.multiplyScalar(this._focalOffset.x), kg.multiplyScalar(-this._focalOffset.y), Ng.multiplyScalar(this._focalOffset.z), Gs.copy(zg).add(kg).add(Ng), this._camera.position.add(Gs)), this._boundaryEnclosesCamera && this._encloseToBoundary(this._camera.position.copy(this._target), Gs.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse), 1);
    const h = this._zoomEnd - this._zoom;
    this._zoom += h * (this.overrideZoomLerpRatio ? this.overrideZoomLerpRatio : r), this._camera.zoom !== this._zoom ? (Xe(h) && (this._zoom = this._zoomEnd), this._camera.zoom = this._zoom, this._camera.updateProjectionMatrix(), this._updateNearPlaneCorners(), this._needsUpdate = !0, this._didZoom = !0) : this._didZoom = !1;
    const p = this._needsUpdate;
    return p && !this._updatedLastTime ? (this._hasRested = !1, this.dispatchEvent({ type: "wake" }), this.dispatchEvent({ type: "update" })) : p ? (this.dispatchEvent({ type: "update" }), !(Xe(s, this.restThreshold) && Xe(a, this.restThreshold) && Xe(o, this.restThreshold) && Xe(l.x, this.restThreshold) && Xe(l.y, this.restThreshold) && Xe(l.z, this.restThreshold) && Xe(c.x, this.restThreshold) && Xe(c.y, this.restThreshold) && Xe(c.z, this.restThreshold)) || this._hasRested || this._isTrucking || Ow(this._camera) && this._didZoom || (this._hasRested = !0, this.dispatchEvent({ type: "rest" }))) : !p && this._updatedLastTime && this.dispatchEvent({ type: "sleep" }), this._didDollyLastFrame && (!(Xe(s, this.restThreshold) && Xe(a, this.restThreshold) && Xe(o, this.restThreshold) && Xe(l.x, this.restThreshold) && Xe(l.y, this.restThreshold) && Xe(l.z, this.restThreshold) && Xe(c.x, this.restThreshold) && Xe(c.y, this.restThreshold) && Xe(c.z, this.restThreshold)) || this._isTrucking || Ow(this._camera) && this._didZoom || (this.dispatchEvent({ type: "rest" }), this._didDollyLastFrame = !1)), this._didDolly && (this._didDolly = !1, this._didDollyLastFrame = !0), this._updatedLastTime = p, this._needsUpdate = !1, p && !this._hasRested;
  }
}
class Uot {
  constructor(t) {
    this.viewer = t, this.camera = new Cr(55, window.innerWidth / window.innerHeight), this.camera.up.set(0, 0, 1), this.camera.position.set(1, 1, 1), this.camera.updateProjectionMatrix();
    const e = this.viewer.container.offsetWidth / this.viewer.container.offsetHeight;
    this.orthoCamera = new Yl(-50 * e / 2, 50 * e / 2, 25, -25, 1e-3, 1e4), this.orthoCamera.up.set(0, 0, 1), this.orthoCamera.position.set(100, 100, 100), this.orthoCamera.updateProjectionMatrix(), Eo.install({ THREE: NU }), JR.install(), this.controls = new JR(this.camera, this.viewer.container), this.controls.maxPolarAngle = Math.PI, this.setupWASDControls(), this.cameras = [{ camera: this.camera, controls: this.controls, name: "perspective", active: !0 }, { camera: this.orthoCamera, controls: this.controls, name: "ortho", active: !1 }], this.orbiting = !1, this.controls.addEventListener("transitionstart", () => {
      this.orbiting = !0;
    }), this.controls.addEventListener("controlend", (n) => {
    }), this.controls.addEventListener("rest", () => {
      setTimeout(() => {
        this.orbiting = !0;
      }, 400);
    }), window.addEventListener("resize", this.onWindowResize.bind(this), !1), this.onWindowResize();
  }
  get activeCam() {
    return this.cameras[0].active ? this.cameras[0] : this.cameras[1];
  }
  set activeCam(t) {
    if (t === "perspective")
      this.setPerspectiveCameraOn();
    else {
      if (t !== "ortho")
        throw new Error(`'${t}' projection mode is invalid. Try with 'perspective' or 'ortho'.`);
      this.setOrthoCameraOn();
    }
  }
  set enabled(t) {
    this.controls.enabled = t;
  }
  setPerspectiveCameraOn() {
    this.cameras[0].active || (this.cameras[0].active = !0, this.cameras[1].active = !1, this.setupPerspectiveCamera(), this.viewer.needsRender = !0);
  }
  setOrthoCameraOn() {
    this.cameras[1].active || (this.cameras[0].active = !1, this.cameras[1].active = !0, this.setupOrthoCamera(), this.viewer.needsRender = !0);
  }
  toggleCameras() {
    this.cameras[0].active ? this.setOrthoCameraOn() : this.setPerspectiveCameraOn();
  }
  setZUpOrYUp() {
    this.camera.position.set(1, 1, 1), this.camera.updateProjectionMatrix(), this.camera.up.y === 1 ? this.camera.up.set(0, 0, 1) : this.camera.up.set(0, 1, 0), this.controls.updateCameraUp();
  }
  setMiddleMouse(t) {
    this.controls.mouseButtons.middle = t === 1 ? Eo.ACTION.DOLLY : Eo.ACTION.TRUCK;
  }
  setupOrthoCamera() {
    this.previousDistance = this.controls.distance, this.controls.mouseButtons.wheel = Eo.ACTION.ZOOM;
    const t = new D();
    this.camera.getWorldDirection(t);
    const e = new D();
    this.controls.getTarget(e);
    const n = e.clone().sub(this.camera.position).dot(t), r = this.viewer.container.offsetWidth / this.viewer.container.offsetHeight, s = this.camera.fov, a = 2 * n * Math.atan(s * (Math.PI / 180) / 2), o = a * r;
    this.orthoCamera.zoom = 1, this.orthoCamera.left = o / -2, this.orthoCamera.right = o / 2, this.orthoCamera.top = a / 2, this.orthoCamera.bottom = a / -2, this.orthoCamera.far = this.camera.far, this.orthoCamera.near = 1e-4, this.orthoCamera.updateProjectionMatrix(), this.orthoCamera.position.copy(this.camera.position), this.orthoCamera.quaternion.copy(this.camera.quaternion), this.controls.camera = this.orthoCamera;
    const l = this.orthoCamera.position, c = new ke().setFromObject(this.viewer.speckleRenderer.allObjects), u = new Mi();
    c.getBoundingSphere(u);
    let h = u.distanceToPoint(l);
    h < 0 && (h *= -1, this.controls.setPosition(l.x + h, l.y + h, l.z + h)), this.viewer.emit("projection-change", "ortho");
  }
  setupPerspectiveCamera() {
    this.controls.mouseButtons.wheel = Eo.ACTION.DOLLY, this.camera.position.copy(this.orthoCamera.position), this.camera.quaternion.copy(this.orthoCamera.quaternion), this.camera.updateProjectionMatrix(), this.controls.distance = this.previousDistance, this.controls.camera = this.camera, this.controls.zoomTo(1), this.enableRotations(), this.viewer.emit("projection-change", "perspective");
  }
  disableRotations() {
    this.controls.mouseButtons.left = Eo.ACTION.TRUCK;
  }
  enableRotations() {
    this.controls.mouseButtons.left = Eo.ACTION.ROTATE;
  }
  setupWASDControls() {
    const r = new Bg(87, 16.666), s = new Bg(65, 16.666), a = new Bg(83, 16.666), o = new Bg(68, 16.666), l = new Array(4), c = (u, h) => {
      l[u] = h, l.every((p) => p === !1) ? (this.controls.isTrucking = !1, this.controls.dispatchEvent({ type: "rest" })) : this.controls.isTrucking = !0;
    };
    s.addEventListener(Ni.HOLD_START, (function() {
      this.controls.dispatchEvent({ type: "controlstart" });
    }).bind(this)), s.addEventListener("holding", (function(u) {
      this.viewer.mouseOverRenderer !== !1 && (c(0, !0), this.controls.truck(-0.01 * u.deltaTime, 0, !1));
    }).bind(this)), s.addEventListener(Ni.HOLD_END, (function() {
      c(0, !1);
    }).bind(this)), o.addEventListener(Ni.HOLD_START, (function() {
      this.controls.dispatchEvent({ type: "controlstart" });
    }).bind(this)), o.addEventListener("holding", (function(u) {
      this.viewer.mouseOverRenderer !== !1 && (c(1, !0), this.controls.truck(0.01 * u.deltaTime, 0, !1));
    }).bind(this)), o.addEventListener(Ni.HOLD_END, (function() {
      c(1, !1);
    }).bind(this)), r.addEventListener(Ni.HOLD_START, (function() {
      this.controls.dispatchEvent({ type: "controlstart" });
    }).bind(this)), r.addEventListener("holding", (function(u) {
      this.viewer.mouseOverRenderer !== !1 && (c(2, !0), this.controls.forward(0.01 * u.deltaTime, !1));
    }).bind(this)), r.addEventListener(Ni.HOLD_END, (function() {
      c(2, !1);
    }).bind(this)), a.addEventListener(Ni.HOLD_START, (function() {
      this.controls.dispatchEvent({ type: "controlstart" });
    }).bind(this)), a.addEventListener("holding", (function(u) {
      this.viewer.mouseOverRenderer !== !1 && (c(3, !0), this.controls.forward(-0.01 * u.deltaTime, !1));
    }).bind(this)), a.addEventListener(Ni.HOLD_END, (function() {
      c(3, !1);
    }).bind(this));
  }
  onWindowResize() {
    this.camera.aspect = this.viewer.container.offsetWidth / this.viewer.container.offsetHeight, this.camera.updateProjectionMatrix();
    const t = new D();
    this.camera.getWorldDirection(t);
    const e = new D();
    this.controls.getTarget(e);
    const n = e.clone().sub(this.camera.position).dot(t), r = this.viewer.container.offsetWidth / this.viewer.container.offsetHeight, s = this.camera.fov, a = 2 * n * Math.atan(s * (Math.PI / 180) / 2), o = a * r;
    this.orthoCamera.zoom = 1, this.orthoCamera.left = o / -2, this.orthoCamera.right = o / 2, this.orthoCamera.top = a / 2, this.orthoCamera.bottom = a / -2, this.orthoCamera.updateProjectionMatrix();
  }
  _setOrbitPoint(t, e) {
    const n = this.viewer.container.getBoundingClientRect(), r = t - n.left, s = e - n.top, a = new wt(r / n.width * 2 - 1, (n.height - s) / n.height * 2 - 1), o = new iu();
    o.setFromCamera(a, this.camera);
    const l = o.intersectObjects(this.viewer.sceneManager.allObjects);
    l.length !== 0 && this.controls.setOrbitPoint(l[0].point.x, l[0].point.y, l[0].point.z, !1);
  }
}
const KR = new Vt(), hh = new Uo(), kw = new Mi(), Nw = new D(), Ta = new D(), Ea = new D(), Aa = new D(), Fw = new D(), Uw = new D(), Vw = new D(), Fg = new D(), Ug = new D(), Vg = new D(), Hg = new wt(), jg = new wt(), Gg = new wt(), Hw = new D(), Wg = new D(), jw = new Uo(), $R = new Vt();
class Vot extends Nt {
  constructor(e, n, r) {
    super(e, n);
    U(this, "boundsTree", null);
    U(this, "boundsTreeSizeInBytes", 0);
    U(this, "batchMaterial", null);
    this.batchMaterial = n, this.boundsTree = r, this.geometry.boundsTree = this.boundsTree, this.boundsTreeSizeInBytes = function(s) {
      const a = /* @__PURE__ */ new Set(), o = [s];
      let l = 0;
      for (; o.length; ) {
        const c = o.pop();
        if (!a.has(c)) {
          a.add(c);
          for (let u in c) {
            if (!c.hasOwnProperty(u))
              continue;
            l += BD(u);
            const h = c[u];
            !h || typeof h != "object" && typeof h != "function" ? l += BD(h) : /(Uint|Int|Float)(8|16|32)Array/.test(h.constructor.name) || h instanceof ArrayBuffer ? l += h.byteLength : o.push(h);
          }
        }
      }
      return l;
    }(this.boundsTree) - this.geometry.attributes.position.array.byteLength;
  }
  get BVH() {
    return this.boundsTree;
  }
  convertRaycastIntersect(e, n, r) {
    return e === null ? null : (e.point.applyMatrix4(n.matrixWorld), e.distance = e.point.distanceTo(r.ray.origin), e.object = n, e.distance < r.near || e.distance > r.far ? null : e);
  }
  raycast(e, n) {
    if (this.boundsTree) {
      if (this.batchMaterial === void 0)
        return;
      $R.copy(this.matrixWorld).invert(), jw.copy(e.ray).applyMatrix4($R);
      const r = this.boundsTree;
      if (e.firstHitOnly === !0) {
        const s = this.convertRaycastIntersect(r.raycastFirst(jw, this.batchMaterial), this, e);
        s && n.push(s);
      } else {
        const s = r.raycast(jw, this.batchMaterial);
        for (let a = 0, o = s.length; a < o; a++) {
          const l = this.convertRaycastIntersect(s[a], this, e);
          l && n.push(l);
        }
      }
    } else {
      const r = this.geometry, s = this.material, a = this.matrixWorld;
      if (s === void 0 || (r.boundingSphere === null && r.computeBoundingSphere(), kw.copy(r.boundingSphere), kw.applyMatrix4(a), e.ray.intersectsSphere(kw) === !1) || (KR.copy(a).invert(), hh.copy(e.ray).applyMatrix4(KR), r.boundingBox !== null && hh.intersectsBox(r.boundingBox) === !1))
        return;
      let o;
      const l = r.index, c = r.attributes.position, u = r.attributes.position_low, h = r.morphAttributes.position, p = r.morphTargetsRelative, f = r.attributes.uv, v = r.attributes.uv2, m = r.groups, y = r.drawRange;
      if (l !== null)
        if (Array.isArray(s))
          for (let _ = 0, w = m.length; _ < w; _++) {
            const b = m[_], T = s[b.materialIndex];
            for (let M = Math.max(b.start, y.start), A = Math.min(l.count, Math.min(b.start + b.count, y.start + y.count)); M < A; M += 3) {
              const C = l.getX(M), I = l.getX(M + 1), k = l.getX(M + 2);
              o = Zg(this, T, e, hh, u, c, h, p, f, v, C, I, k), o && (o.faceIndex = Math.floor(M / 3), o.face.materialIndex = b.materialIndex, n.push(o));
            }
          }
        else
          for (let _ = Math.max(0, y.start), w = Math.min(l.count, y.start + y.count); _ < w; _ += 3) {
            const b = l.getX(_), T = l.getX(_ + 1), M = l.getX(_ + 2);
            o = Zg(this, s, e, hh, u, c, h, p, f, v, b, T, M), o && (o.faceIndex = Math.floor(_ / 3), n.push(o));
          }
      else if (c !== void 0)
        if (Array.isArray(s))
          for (let _ = 0, w = m.length; _ < w; _++) {
            const b = m[_], T = s[b.materialIndex];
            for (let M = Math.max(b.start, y.start), A = Math.min(c.count, Math.min(b.start + b.count, y.start + y.count)); M < A; M += 3)
              o = Zg(this, T, e, hh, u, c, h, p, f, v, M, M + 1, M + 2), o && (o.faceIndex = Math.floor(M / 3), o.face.materialIndex = b.materialIndex, n.push(o));
          }
        else
          for (let _ = Math.max(0, y.start), w = Math.min(c.count, y.start + y.count); _ < w; _ += 3)
            o = Zg(this, s, e, hh, u, c, h, p, f, v, _, _ + 1, _ + 2), o && (o.faceIndex = Math.floor(_ / 3), n.push(o));
    }
  }
}
function Zg(i, t, e, n, r, s, a, o, l, c, u, h, p) {
  Ta.fromBufferAttribute(s, u), Ea.fromBufferAttribute(s, h), Aa.fromBufferAttribute(s, p), r && (Ta.add(Nw.fromBufferAttribute(r, u)), Ea.add(Nw.fromBufferAttribute(r, h)), Aa.add(Nw.fromBufferAttribute(r, p)));
  const f = i.morphTargetInfluences;
  if (a && f) {
    Fg.set(0, 0, 0), Ug.set(0, 0, 0), Vg.set(0, 0, 0);
    for (let m = 0, y = a.length; m < y; m++) {
      const _ = f[m], w = a[m];
      _ !== 0 && (Fw.fromBufferAttribute(w, u), Uw.fromBufferAttribute(w, h), Vw.fromBufferAttribute(w, p), o ? (Fg.addScaledVector(Fw, _), Ug.addScaledVector(Uw, _), Vg.addScaledVector(Vw, _)) : (Fg.addScaledVector(Fw.sub(Ta), _), Ug.addScaledVector(Uw.sub(Ea), _), Vg.addScaledVector(Vw.sub(Aa), _)));
    }
    Ta.add(Fg), Ea.add(Ug), Aa.add(Vg);
  }
  i.isSkinnedMesh && (i.boneTransform(u, Ta), i.boneTransform(h, Ea), i.boneTransform(p, Aa));
  const v = function(m, y, _, w, b, T, M, A) {
    let C;
    if (C = y.side === 1 ? w.intersectTriangle(M, T, b, !0, A) : w.intersectTriangle(b, T, M, y.side !== 2, A), C === null)
      return null;
    Wg.copy(A), Wg.applyMatrix4(m.matrixWorld);
    const I = _.ray.origin.distanceTo(Wg);
    return I < _.near || I > _.far ? null : { distance: I, point: Wg.clone(), object: m, uv: void 0, uv2: void 0, face: void 0 };
  }(i, t, e, n, Ta, Ea, Aa, Hw);
  if (v) {
    l && (Hg.fromBufferAttribute(l, u), jg.fromBufferAttribute(l, h), Gg.fromBufferAttribute(l, p), v.uv = Pr.getUV(Hw, Ta, Ea, Aa, Hg, jg, Gg, new wt())), c && (Hg.fromBufferAttribute(c, u), jg.fromBufferAttribute(c, h), Gg.fromBufferAttribute(c, p), v.uv2 = Pr.getUV(Hw, Ta, Ea, Aa, Hg, jg, Gg, new wt()));
    const m = { a: u, b: h, c: p, normal: new D(), materialIndex: 0 };
    Pr.getNormal(Ta, Ea, Aa, m.normal), v.face = m;
  }
  return v;
}
class Hot {
  constructor(t, e, n) {
    U(this, "id");
    U(this, "subtreeId");
    U(this, "renderViews");
    U(this, "geometry");
    U(this, "batchMaterial");
    U(this, "mesh");
    U(this, "boundsTree");
    U(this, "bounds", new ke());
    U(this, "gradientIndexBuffer");
    U(this, "indexBuffer0");
    U(this, "indexBuffer1");
    U(this, "indexBufferIndex", 0);
    U(this, "geometryGroups");
    this.id = t, this.subtreeId = e, this.renderViews = n, this.geometryGroups = [];
  }
  get geometryType() {
    return this.renderViews[0].geometryType;
  }
  get renderObject() {
    return this.mesh;
  }
  getCount() {
    return this.geometry.index.count;
  }
  setBatchMaterial(t) {
    this.batchMaterial = t;
  }
  onUpdate(t) {
  }
  onRender(t) {
  }
  setVisibleRange(...t) {
    if (t.length === 1 && t[0] === Jh)
      return this.geometry.setDrawRange(0, 0), void (this.mesh.visible = !1);
    if (t.length === 1 && t[0].offset === ra.offset && t[0].count === ra.count)
      return this.geometry.setDrawRange(0, this.getCount()), void (this.mesh.visible = !0);
    let e = 1 / 0, n = 0;
    t.forEach((r) => {
      e = Math.min(e, r.offset), n = Math.max(n, r.offset);
    }), this.geometry.setDrawRange(e, n - e + t.find((r) => r.offset === n).count), this.mesh.visible = !0;
  }
  getVisibleRange() {
    return this.geometry.groups.length === 0 ? ra : { offset: this.geometry.drawRange.start, count: this.geometry.drawRange.count };
  }
  setDrawRanges(...t) {
    const e = t.map((l) => l.material), n = [...Array.from(new Set(e.map((l) => l)))];
    if (Array.isArray(this.mesh.material) && this.geometry.groups && this.geometry.groups.length > 0)
      return this.mesh.material.includes(n[0]) || this.mesh.material.push(n[0]), this.geometry.clearGroups(), void this.geometry.addGroup(t[0].offset, t[0].count, this.mesh.material.length - 1);
    Array.isArray(this.mesh.material) || (this.mesh.material = [this.mesh.material]);
    for (let l = 0; l < n.length; l++)
      this.mesh.material.includes(n[l]) || this.mesh.material.push(n[l]);
    const r = t.sort((l, c) => l.offset - c.offset), s = [];
    let a = 1 / 0, o = 0;
    for (let l = 0; l < r.length; l++) {
      if (r[l].materialOptions) {
        if (r[l].materialOptions.rampIndex !== void 0) {
          const u = r[l].offset, h = r[l].offset + r[l].count, p = r[l].materialOptions.rampIndex + 0.5 / r[l].materialOptions.rampWidth, f = this.updateGradientIndexBufferData(u, r[l].count === 1 / 0 ? this.geometry.attributes.gradientIndex.array.length : h, p);
          a = Math.min(a, f.minIndex), o = Math.max(o, f.maxIndex);
        }
        r[l].materialOptions.rampTexture && r[l].material.setGradientTexture(r[l].materialOptions.rampTexture);
      }
      const c = this.getDrawRangeCollision(r[l]);
      c ? c.materialIndex = this.mesh.material.indexOf(r[l].material) : s.push(r[l]);
    }
    this.updateGradientIndexBuffer();
    for (let l = 0; l < s.length; l++)
      this.geometry.addGroup(s[l].offset, s[l].count, this.mesh.material.indexOf(s[l].material));
  }
  getDrawRangeCollision(t) {
    if (this.geometry.groups.length > 0) {
      for (let e = 0; e < this.geometry.groups.length; e++)
        if (t.offset === this.geometry.groups[e].start)
          return this.geometry.groups[e];
      return null;
    }
    return null;
  }
  getCurrentIndexBuffer() {
    return this.indexBufferIndex % 2 == 0 ? this.indexBuffer0 : this.indexBuffer1;
  }
  getNextIndexBuffer() {
    return ++this.indexBufferIndex % 2 == 0 ? this.indexBuffer0 : this.indexBuffer1;
  }
  autoFillDrawRanges() {
    this.autoFillDrawRangesShuffleIBO();
  }
  autoFillDrawRangesShuffleIBO() {
    const t = this.geometry.groups.sort((p, f) => p.start - f.start).slice(), e = t.map((p) => p.start);
    for (let p = 0; p < this.renderViews.length; p++)
      e.includes(this.renderViews[p].batchStart) || t.push({ start: this.renderViews[p].batchStart, count: this.renderViews[p].batchCount, materialIndex: 0 });
    t.sort((p, f) => {
      const v = this.mesh.material[p.materialIndex], m = this.mesh.material[f.materialIndex], y = +(m == null ? void 0 : m.visible) - +(v == null ? void 0 : v.visible);
      return y !== 0 ? y : +(v == null ? void 0 : v.transparent) - +(m == null ? void 0 : m.transparent);
    });
    const n = [];
    t.reduce((p, f) => (p.indexOf(f.materialIndex) === -1 && p.push(f.materialIndex), p), n);
    const r = [];
    for (let p = 0; p < n.length; p++)
      r.push(t.filter((f) => f.materialIndex === n[p]));
    const s = this.getCurrentIndexBuffer(), a = this.getNextIndexBuffer(), o = [], l = {};
    let c = 0;
    for (let p = 0; p < r.length; p++) {
      const f = r[p], v = c;
      let m = 0;
      for (let y = 0; y < f.length; y++) {
        const _ = f[y].start, w = f[y].count, b = s.array.subarray(_, _ + w);
        a.array.set(b, c), l[_] = c, c += w, m += w;
      }
      o.push({ offset: v, count: m, materialIndex: f[0].materialIndex });
    }
    this.geometry.groups = [];
    for (let p = 0; p < o.length; p++)
      this.geometry.addGroup(o[p].offset, o[p].count, o[p].materialIndex);
    const u = this.createRenderViewMapping();
    for (const p in u) {
      const f = u[p];
      f.setBatchData(f.batchId, l[p], f.batchCount);
    }
    this.geometry.setIndex(a), this.geometry.index.needsUpdate = !0;
    const h = this.geometry.groups.find((p) => {
      var f;
      return ((f = this.mesh.material[p.materialIndex]) == null ? void 0 : f.visible) === !1;
    });
    h && this.setVisibleRange({ offset: 0, count: h.start });
  }
  createRenderViewMapping() {
    const t = {};
    for (let e = 0; e < this.renderViews.length; e++)
      t[this.renderViews[e].batchStart] = this.renderViews[e];
    return t;
  }
  resetDrawRanges() {
    var n, r, s;
    this.mesh.material = this.batchMaterial, this.mesh.visible = !0, this.geometry.clearGroups(), this.geometry.setDrawRange(0, 1 / 0);
    let t, e = 0;
    for (let a = 0; a < this.renderViews.length; a++)
      if (t = (s = (r = (n = this.renderViews[a]) == null ? void 0 : n.renderData) == null ? void 0 : r.geometry) == null ? void 0 : s.groups, t && t.length > 0) {
        for (let o = 0; o < t.length; o++)
          this.geometry.addGroup(t[o].start + e, t[o].count, t[o].materialIndex);
        e = e + t[t.length - 1].start + t[t.length - 1].count;
      }
  }
  buildBatch() {
    var k, R, L, E, q, it, rt, ft, nt, vt, $, W, ct, mt, dt, Mt, At;
    const t = this.renderViews.flatMap((H) => H.renderData.geometry.attributes.INDEX).length, e = this.renderViews.flatMap((H) => H.renderData.geometry.attributes.POSITION).length, n = this.renderViews.flatMap((H) => H.renderData.geometry.attributes.UV || []).length, r = this.renderViews.flatMap((H) => H.renderData.geometry.attributes.UV2 || []).length, s = this.renderViews.flatMap((H) => H.renderData.geometry.attributes.TANGENT || []).length, a = this.renderViews.flatMap((H) => H.renderData.geometry.attributes.COLOR || []).length, o = this.renderViews.flatMap((H) => H.renderData.geometry.attributes.NORMAL || []).length;
    let l, c;
    this.renderViews.length === 1 && ((k = this.renderViews[0]._renderData) != null && k.geometry.attributes.MORPHATTRIBUTES) && (l = (R = this.renderViews[0]._renderData) == null ? void 0 : R.geometry.attributes.MORPHATTRIBUTES, c = {}, l.forEach((H) => {
      const N = H.speckle_type.split(".").pop();
      c[N] = H.range.reduce((st, et) => {
        const { start: J, count: K } = et, S = H.data.slice(J, J + K), Z = new Ze(new Float32Array(S), 3, !1);
        return st.push(Z), st;
      }, []);
    }));
    const u = new Uint32Array(t), h = new Float64Array(e), p = new Float32Array(a), f = new Float32Array(o);
    p.fill(1);
    const v = new Float32Array(n), m = new Float32Array(r), y = new Float32Array(s);
    let _ = 0, w = 0, b = 0, T = 0, M = 0, A = 0, C = [];
    for (let H = 0; H < this.renderViews.length; H++) {
      this.addGeometryGroup(this.renderViews[H].renderData.geometry);
      const N = this.renderViews[H].renderData.geometry, st = this.renderViews[H].renderData.geometry.groups || [];
      for (let et = 0; et < st.length; et++)
        C.push({ ...st[et], start: st[et].start + w });
      u.set(N.attributes.INDEX.map((et) => et + _ / 3), w), h.set(N.attributes.POSITION, _), N.attributes.UV && N.attributes.UV.length > 0 && v.set(N.attributes.UV, b), N.attributes.UV2 && N.attributes.UV2.length > 0 && m.set(N.attributes.UV2, T), N.attributes.TANGENT && N.attributes.TANGENT.length > 0 && y.set(N.attributes.TANGENT, M), N.attributes.NORMAL && N.attributes.NORMAL.length > 0 && f.set(N.attributes.NORMAL, A), N.attributes.COLOR && N.attributes.COLOR.length > 0 && p.length > 0 && p.set(N.attributes.COLOR, _), this.renderViews[H].setBatchData(this.id, w, N.attributes.INDEX.length, _ / 3, _ / 3 + N.attributes.POSITION.length / 3), _ += N.attributes.POSITION.length, w += N.attributes.INDEX.length, b += ((L = N.attributes.UV) == null ? void 0 : L.length) || 0, T += ((E = N.attributes.UV2) == null ? void 0 : E.length) || 0, M += ((it = (q = N.attributes) == null ? void 0 : q.TANGENT) == null ? void 0 : it.length) || 0, A += ((ft = (rt = N.attributes) == null ? void 0 : rt.NORMAL) == null ? void 0 : ft.length) || 0, As.keepGeometryData || this.renderViews[H].disposeGeometry();
    }
    let I = null;
    (this.batchMaterial.vertexColors || Array.isArray(this.batchMaterial) && ((nt = this.batchMaterial) != null && nt.find((H) => H.vertexColors))) && (I = p), this.makeMeshGeometry(u, h, I, v, m, y, f), c && Object.keys(c).length > 0 && (this.geometry.morphAttributes = c, this.geometry.morphTargetsRelative = !0), this.boundsTree = Nn.buildBVH(u, h, Qt.getRenderTree(this.subtreeId).treeBounds);
    for (let H = 0; H < C.length; H++)
      this.geometry.addGroup(C[H].start, C[H].count, C[H].materialIndex), this.boundsTree.geometry.addGroup(C[H].start, C[H].count, C[H].materialIndex);
    this.boundsTree.getBoundingBox(this.bounds), this.mesh = new Vot(this.geometry, this.batchMaterial, this.boundsTree), this.mesh.uuid = this.id, this.mesh.layers.set(pn.STREAM_CONTENT_MESH), this.renderViews.length === 1 && (this.mesh.name = this.renderViews[0]._renderData.name, ($ = (vt = this.renderViews[0]._renderData) == null ? void 0 : vt.geometry) != null && $.morphTargetDictionary && (this.mesh.morphTargetDictionary = (ct = (W = this.renderViews[0]._renderData) == null ? void 0 : W.geometry) == null ? void 0 : ct.morphTargetDictionary, this.mesh.userData.targetNames = Object.keys(this.mesh.morphTargetDictionary)), (dt = (mt = this.renderViews[0]._renderData) == null ? void 0 : mt.geometry) != null && dt.morphTargetInfluences && (this.mesh.morphTargetInfluences = (At = (Mt = this.renderViews[0]._renderData) == null ? void 0 : Mt.geometry) == null ? void 0 : At.morphTargetInfluences));
  }
  getRenderView(t) {
    for (let e = 0; e < this.renderViews.length; e++) {
      const n = this.boundsTree.geometry.index.array[3 * t];
      if (n >= this.renderViews[e].vertStart && n < this.renderViews[e].vertEnd)
        return this.renderViews[e];
    }
  }
  getMaterialAtIndex(t) {
    for (let e = 0; e < this.renderViews.length; e++) {
      const n = this.boundsTree.geometry.index.array[3 * t];
      if (n >= this.renderViews[e].vertStart && n < this.renderViews[e].vertEnd) {
        const r = this.renderViews[e], s = this.geometry.groups.find((a) => r.batchStart >= a.start && r.batchStart + r.batchCount <= a.count + a.start);
        return Array.isArray(this.mesh.material) ? s ? this.mesh.material[s.materialIndex] : (De.warn("Malformed material index!"), null) : this.mesh.material;
      }
    }
  }
  addGeometryGroup(t) {
    const e = new Uint32Array(t.attributes.INDEX), n = new Float64Array(t.attributes.POSITION);
    let r, s, a, o, l;
    t.attributes.COLOR && (r = new Float32Array(t.attributes.COLOR)), t.attributes.UV && (s = new Float32Array(t.attributes.UV)), t.attributes.UV2 && (a = new Float32Array(t.attributes.UV2)), t.attributes.TANGENT && (o = new Float32Array(t.attributes.TANGENT)), t.attributes.NORMAL && (l = new Float32Array(t.attributes.NORMAL));
    const c = this.makeSingleGeometry(e, n, r, s, a, o, l);
    if (t.groups && t.groups.length > 0)
      for (let u = 0; u < t.groups.length; u++)
        c.addGroup(t.groups[u].start, t.groups[u].count, t.groups[u].materialIndex);
    this.geometryGroups.push(c);
  }
  makeSingleGeometry(t, e, n = void 0, r = void 0, s = void 0, a = void 0, o = void 0) {
    const l = new _e(), c = e.length >= 65535 || t.length >= 65535 ? new Wl(t, 1) : new Gl(t, 1);
    return l.setIndex(c), e && l.setAttribute("position", new Wt(e, 3)), n && l.setAttribute("color", new Wt(n, 3)), r && r.length > 2 && l.setAttribute("uv", new Wt(r, 2)), s && s.length > 2 && l.setAttribute("uv2", new Wt(s, 2)), a && a.length > 4 && l.setAttribute("tangent", new Wt(a, 4)), o && (o == null ? void 0 : o.length) > 3 && l.setAttribute("normal", new Wt(o, 3)), Nn.computeVertexNormals(l, e), l.computeBoundingSphere(), l.computeBoundingBox(), Nn.updateRTEGeometry(l, e), l;
  }
  makeMeshGeometry(t, e, n = void 0, r = void 0, s = void 0, a = void 0, o = void 0) {
    this.geometry = new _e(), e.length >= 65535 || t.length >= 65535 ? (this.indexBuffer0 = new Wl(t, 1), this.indexBuffer1 = new Wl(new Uint32Array(t.length), 1)) : (this.indexBuffer0 = new Gl(t, 1), this.indexBuffer1 = new Gl(new Uint16Array(t.length), 1)), this.geometry.setIndex(this.indexBuffer0), e && this.geometry.setAttribute("position", new Wt(e, 3)), n && this.geometry.setAttribute("color", new Wt(n, 3)), r && r.length > 2 && this.geometry.setAttribute("uv", new Wt(r, 2)), s && s.length > 2 && this.geometry.setAttribute("uv2", new Wt(s, 2)), a && a.length > 4 && this.geometry.setAttribute("tangent", new Wt(a, 4)), o && (o == null ? void 0 : o.length) > 3 && this.geometry.setAttribute("normal", new Wt(o, 3));
    const l = new Float32Array(e.length / 3);
    return this.gradientIndexBuffer = new Wt(l, 1), this.gradientIndexBuffer.setUsage(35048), this.geometry.setAttribute("gradientIndex", this.gradientIndexBuffer), this.updateGradientIndexBufferData(0, l.length, 0), this.updateGradientIndexBuffer(), Nn.computeVertexNormals(this.geometry, e), this.geometry.computeBoundingSphere(), this.geometry.computeBoundingBox(), I0.World.expandWorld(this.geometry.boundingBox), Nn.updateRTEGeometry(this.geometry, e), this.geometry;
  }
  updateGradientIndexBufferData(t, e, n) {
    const r = this.geometry.index.array, s = this.gradientIndexBuffer.array;
    let a = 1 / 0, o = 0;
    for (let l = t; l < e; l++) {
      const c = r[l];
      a = Math.min(a, c), o = Math.max(o, c), s[c] = n;
    }
    return this.gradientIndexBuffer.updateRange = { offset: a, count: o - a + 1 }, this.gradientIndexBuffer.needsUpdate = !0, this.geometry.attributes.gradientIndex.needsUpdate = !0, { minIndex: a, maxIndex: o };
  }
  updateGradientIndexBuffer(t, e) {
    this.gradientIndexBuffer.updateRange = { offset: t !== void 0 ? t : 0, count: t !== void 0 && e !== void 0 ? e - t + 1 : -1 }, this.gradientIndexBuffer.needsUpdate = !0, this.geometry.attributes.gradientIndex.needsUpdate = !0;
  }
  purge() {
    this.renderViews.length = 0, this.geometry.dispose(), this.batchMaterial.dispose(), this.mesh = null;
  }
}
const QR = new ke(), qg = new D();
class Kv extends rS {
  constructor() {
    super(), this.isLineSegmentsGeometry = !0, this.type = "LineSegmentsGeometry", this.setIndex([0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5]), this.setAttribute("position", new Wt([-1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0], 3)), this.setAttribute("uv", new Wt([-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2], 2));
  }
  applyMatrix4(t) {
    const e = this.attributes.instanceStart, n = this.attributes.instanceEnd;
    return e !== void 0 && (e.applyMatrix4(t), n.applyMatrix4(t), e.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
  }
  setPositions(t) {
    let e;
    t instanceof Float32Array ? e = t : Array.isArray(t) && (e = new Float32Array(t));
    const n = new Vh(e, 6, 1);
    return this.setAttribute("instanceStart", new Lr(n, 3, 0)), this.setAttribute("instanceEnd", new Lr(n, 3, 3)), this.computeBoundingBox(), this.computeBoundingSphere(), this;
  }
  setColors(t) {
    let e;
    t instanceof Float32Array ? e = t : Array.isArray(t) && (e = new Float32Array(t));
    const n = new Vh(e, 6, 1);
    return this.setAttribute("instanceColorStart", new Lr(n, 3, 0)), this.setAttribute("instanceColorEnd", new Lr(n, 3, 3)), this;
  }
  fromWireframeGeometry(t) {
    return this.setPositions(t.attributes.position.array), this;
  }
  fromEdgesGeometry(t) {
    return this.setPositions(t.attributes.position.array), this;
  }
  fromMesh(t) {
    return this.fromWireframeGeometry(new Xb(t.geometry)), this;
  }
  fromLineSegments(t) {
    const e = t.geometry;
    return this.setPositions(e.attributes.position.array), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new ke());
    const t = this.attributes.instanceStart, e = this.attributes.instanceEnd;
    t !== void 0 && e !== void 0 && (this.boundingBox.setFromBufferAttribute(t), QR.setFromBufferAttribute(e), this.boundingBox.union(QR));
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new Mi()), this.boundingBox === null && this.computeBoundingBox();
    const t = this.attributes.instanceStart, e = this.attributes.instanceEnd;
    if (t !== void 0 && e !== void 0) {
      const n = this.boundingSphere.center;
      this.boundingBox.getCenter(n);
      let r = 0;
      for (let s = 0, a = t.count; s < a; s++)
        qg.fromBufferAttribute(t, s), r = Math.max(r, n.distanceToSquared(qg)), qg.fromBufferAttribute(e, s), r = Math.max(r, n.distanceToSquared(qg));
      this.boundingSphere.radius = Math.sqrt(r), isNaN(this.boundingSphere.radius) && console.error("THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.", this);
    }
  }
  toJSON() {
  }
  applyMatrix(t) {
    return console.warn("THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4()."), this.applyMatrix4(t);
  }
}
const tI = new D(), eI = new D(), Rr = new ze(), Ir = new ze(), Ws = new ze(), Gw = new D(), Ww = new Vt(), Or = new ss(), nI = new D(), Xg = new ke(), Yg = new Mi(), Zs = new ze();
let qs, Bl;
function rI(i, t, e) {
  return Zs.set(0, 0, -t, 1).applyMatrix4(i.projectionMatrix), Zs.multiplyScalar(1 / Zs.w), Zs.x = Bl / e.width, Zs.y = Bl / e.height, Zs.applyMatrix4(i.projectionMatrixInverse), Zs.multiplyScalar(1 / Zs.w), Math.abs(Math.max(Zs.x, Zs.y));
}
class yM extends Nt {
  constructor(t = new Kv(), e = new NB({ color: 16777215 * Math.random() })) {
    super(t, e), this.isLineSegments2 = !0, this.type = "LineSegments2";
  }
  computeLineDistances() {
    const t = this.geometry, e = t.attributes.instanceStart, n = t.attributes.instanceEnd, r = new Float32Array(2 * e.count);
    for (let a = 0, o = 0, l = e.count; a < l; a++, o += 2)
      tI.fromBufferAttribute(e, a), eI.fromBufferAttribute(n, a), r[o] = o === 0 ? 0 : r[o - 1], r[o + 1] = r[o] + tI.distanceTo(eI);
    const s = new Vh(r, 2, 1);
    return t.setAttribute("instanceDistanceStart", new Lr(s, 1, 0)), t.setAttribute("instanceDistanceEnd", new Lr(s, 1, 1)), this;
  }
  raycast(t, e) {
    const n = this.material.worldUnits, r = t.camera;
    r !== null || n || console.error('LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.');
    const s = t.params.Line2 !== void 0 && t.params.Line2.threshold || 0;
    qs = t.ray;
    const a = this.matrixWorld, o = this.geometry, l = this.material;
    let c, u;
    Bl = l.linewidth + s, o.boundingSphere === null && o.computeBoundingSphere(), Yg.copy(o.boundingSphere).applyMatrix4(a), n ? c = 0.5 * Bl : c = rI(r, Math.max(r.near, Yg.distanceToPoint(qs.origin)), l.resolution), Yg.radius += c, qs.intersectsSphere(Yg) !== !1 && (o.boundingBox === null && o.computeBoundingBox(), Xg.copy(o.boundingBox).applyMatrix4(a), n ? u = 0.5 * Bl : u = rI(r, Math.max(r.near, Xg.distanceToPoint(qs.origin)), l.resolution), Xg.expandByScalar(u), qs.intersectsBox(Xg) !== !1 && (n ? function(h, p) {
      const f = h.matrixWorld, v = h.geometry, m = v.attributes.instanceStart, y = v.attributes.instanceEnd;
      for (let _ = 0, w = Math.min(v.instanceCount, m.count); _ < w; _++) {
        Or.start.fromBufferAttribute(m, _), Or.end.fromBufferAttribute(y, _), Or.applyMatrix4(f);
        const b = new D(), T = new D();
        qs.distanceSqToSegment(Or.start, Or.end, T, b), T.distanceTo(b) < 0.5 * Bl && p.push({ point: T, pointOnLine: b, distance: qs.origin.distanceTo(T), object: h, face: null, faceIndex: _, uv: null, uv2: null });
      }
    }(this, e) : function(h, p, f) {
      const v = p.projectionMatrix, m = h.material.resolution, y = h.matrixWorld, _ = h.geometry, w = _.attributes.instanceStart, b = _.attributes.instanceEnd, T = Math.min(_.instanceCount, w.count), M = -p.near;
      qs.at(1, Ws), Ws.w = 1, Ws.applyMatrix4(p.matrixWorldInverse), Ws.applyMatrix4(v), Ws.multiplyScalar(1 / Ws.w), Ws.x *= m.x / 2, Ws.y *= m.y / 2, Ws.z = 0, Gw.copy(Ws), Ww.multiplyMatrices(p.matrixWorldInverse, y);
      for (let A = 0, C = T; A < C; A++) {
        if (Rr.fromBufferAttribute(w, A), Ir.fromBufferAttribute(b, A), Rr.w = 1, Ir.w = 1, Rr.applyMatrix4(Ww), Ir.applyMatrix4(Ww), Rr.z > M && Ir.z > M)
          continue;
        if (Rr.z > M) {
          const E = Rr.z - Ir.z, q = (Rr.z - M) / E;
          Rr.lerp(Ir, q);
        } else if (Ir.z > M) {
          const E = Ir.z - Rr.z, q = (Ir.z - M) / E;
          Ir.lerp(Rr, q);
        }
        Rr.applyMatrix4(v), Ir.applyMatrix4(v), Rr.multiplyScalar(1 / Rr.w), Ir.multiplyScalar(1 / Ir.w), Rr.x *= m.x / 2, Rr.y *= m.y / 2, Ir.x *= m.x / 2, Ir.y *= m.y / 2, Or.start.copy(Rr), Or.start.z = 0, Or.end.copy(Ir), Or.end.z = 0;
        const I = Or.closestPointToPointParameter(Gw, !0);
        Or.at(I, nI);
        const k = Hl.lerp(Rr.z, Ir.z, I), R = k >= -1 && k <= 1, L = Gw.distanceTo(nI) < 0.5 * Bl;
        if (R && L) {
          Or.start.fromBufferAttribute(w, A), Or.end.fromBufferAttribute(b, A), Or.start.applyMatrix4(y), Or.end.applyMatrix4(y);
          const E = new D(), q = new D();
          qs.distanceSqToSegment(Or.start, Or.end, q, E), f.push({ point: q, pointOnLine: E, distance: qs.origin.distanceTo(q), object: h, face: null, faceIndex: A, uv: null, uv2: null });
        }
      }
    }(this, r, e)));
  }
}
const Gd = class Gd {
  constructor(t, e, n) {
    U(this, "id");
    U(this, "subtreeId");
    U(this, "renderViews");
    U(this, "geometry");
    U(this, "batchMaterial");
    U(this, "mesh");
    U(this, "colorBuffer");
    this.id = t, this.subtreeId = e, this.renderViews = n;
  }
  get renderObject() {
    return this.mesh;
  }
  get geometryType() {
    return this.renderViews[0].geometryType;
  }
  getCount() {
    return this.geometry.attributes.position.array.length / 6;
  }
  setBatchMaterial(t) {
    this.batchMaterial = t;
  }
  onUpdate(t) {
  }
  onRender(t) {
    t.getDrawingBufferSize(this.batchMaterial.resolution);
  }
  setVisibleRange(...t) {
    if (t.length === 1 && t[0].offset === Jh.offset && t[0].count === Jh.count)
      return void (this.mesh.visible = !1);
    if (t.length === 1 && t[0].offset === ra.offset && t[0].count === ra.count)
      return void (this.mesh.visible = !0);
    this.mesh.visible = !0;
    const e = this.colorBuffer.array;
    for (let n = 0; n < e.length; n += 4)
      e[n + 3] = 0;
    for (let n = 0; n < t.length; n++) {
      const r = t[n].offset * this.colorBuffer.stride, s = t[n].offset * this.colorBuffer.stride + t[n].count * this.colorBuffer.stride;
      for (let a = r; a < s; a += 4)
        e[a + 3] = 1;
    }
    this.colorBuffer.updateRange = { offset: 0, count: e.length }, this.colorBuffer.needsUpdate = !0, this.geometry.attributes.instanceColorStart.needsUpdate = !0, this.geometry.attributes.instanceColorEnd.needsUpdate = !0;
  }
  getVisibleRange() {
    return ra;
  }
  setDrawRanges(...t) {
    const e = this.colorBuffer.array;
    for (let n = 0; n < t.length; n++) {
      const r = t[n].material, s = t[n].materialOptions, a = s && s.rampIndexColor ? s.rampIndexColor : r.color, o = r.visible ? 1 : 0, l = t[n].offset * this.colorBuffer.stride, c = t[n].offset * this.colorBuffer.stride + t[n].count * this.colorBuffer.stride;
      Gd.vector4Buffer.set(a.r, a.g, a.b, o), this.updateColorBuffer(l, t[n].count === 1 / 0 ? this.colorBuffer.array.length : c, Gd.vector4Buffer);
    }
    this.colorBuffer.updateRange = { offset: 0, count: e.length }, this.colorBuffer.needsUpdate = !0, this.geometry.attributes.instanceColorStart.needsUpdate = !0, this.geometry.attributes.instanceColorEnd.needsUpdate = !0;
  }
  autoFillDrawRanges() {
  }
  resetDrawRanges() {
    this.setDrawRanges({ offset: 0, count: 1 / 0, material: this.batchMaterial }), this.mesh.material = this.batchMaterial, this.mesh.visible = !0;
  }
  buildBatch() {
    let t = 0;
    this.renderViews.forEach((r) => t += r.needsSegmentConversion ? 2 * (r.renderData.geometry.attributes.POSITION.length - 3) : r.renderData.geometry.attributes.POSITION.length);
    const e = new Float64Array(t);
    let n = 0;
    for (let r = 0; r < this.renderViews.length; r++) {
      const s = this.renderViews[r].renderData.geometry;
      let a = null;
      if (this.renderViews[r].needsSegmentConversion) {
        const o = s.attributes.POSITION.length - 3;
        a = new Array(2 * o);
        for (let l = 0; l < o; l += 3)
          a[2 * l] = s.attributes.POSITION[l], a[2 * l + 1] = s.attributes.POSITION[l + 1], a[2 * l + 2] = s.attributes.POSITION[l + 2], a[2 * l + 3] = s.attributes.POSITION[l + 3], a[2 * l + 4] = s.attributes.POSITION[l + 4], a[2 * l + 5] = s.attributes.POSITION[l + 5];
      } else
        a = s.attributes.POSITION;
      e.set(a, n), this.renderViews[r].setBatchData(this.id, n / 6, a.length / 6), n += a.length;
    }
    this.makeLineGeometry(e), this.mesh = new yM(this.geometry, this.batchMaterial), this.mesh.computeLineDistances(), this.mesh.scale.set(1, 1, 1), this.mesh.uuid = this.id, this.mesh.layers.set(pn.STREAM_CONTENT_LINE);
  }
  getRenderView(t) {
    for (let e = 0; e < this.renderViews.length; e++)
      if (t >= this.renderViews[e].batchStart && t < this.renderViews[e].batchEnd && this.colorBuffer.array[t * this.colorBuffer.stride + 3] !== 0)
        return this.renderViews[e];
  }
  makeLineGeometry(t) {
    this.geometry = this.makeLineGeometryTriangle(new Float32Array(t)), Nn.updateRTEGeometry(this.geometry, t), I0.World.expandWorld(this.geometry.boundingBox);
  }
  makeLineGeometryTriangle(t) {
    const e = new Kv();
    e.setPositions(t);
    const n = new Float32Array(t.length + t.length / 3);
    return this.colorBuffer = new Vh(n, 8, 1), this.colorBuffer.setUsage(35048), this.updateColorBuffer(0, n.length, new ze(this.batchMaterial.color.r, this.batchMaterial.color.g, this.batchMaterial.color.b, 1)), e.setAttribute("instanceColorStart", new Lr(this.colorBuffer, 4, 0)), e.setAttribute("instanceColorEnd", new Lr(this.colorBuffer, 4, 4)), e.computeBoundingBox(), e;
  }
  updateColorBuffer(t, e, n) {
    const r = this.colorBuffer.array;
    for (let s = t; s < e; s += 4)
      r[s] = n.x, r[s + 1] = n.y, r[s + 2] = n.z, r[s + 3] = n.w;
  }
  purge() {
    this.renderViews.length = 0, this.geometry.dispose(), this.batchMaterial.dispose(), this.mesh = null, this.colorBuffer.length = 0;
  }
};
U(Gd, "vector4Buffer", new ze());
let Db = Gd;
class jot {
  constructor(t, e, n) {
    U(this, "id");
    U(this, "subtreeId");
    U(this, "renderViews");
    U(this, "geometry");
    U(this, "batchMaterial");
    U(this, "mesh");
    this.id = t, this.subtreeId = e, this.renderViews = n;
  }
  get renderObject() {
    return this.mesh;
  }
  get geometryType() {
    return this.renderViews[0].geometryType;
  }
  getCount() {
    return this.geometry.attributes.position.array.length / 3;
  }
  setBatchMaterial(t) {
    this.batchMaterial = t;
  }
  onUpdate(t) {
  }
  onRender(t) {
  }
  setVisibleRange(...t) {
    if (t.length === 1 && t[0] === Jh)
      return this.geometry.setDrawRange(0, 0), void (this.mesh.visible = !1);
    let e = 1 / 0, n = 0;
    t.forEach((r) => {
      e = Math.min(e, r.offset), n = Math.max(n, r.offset);
    }), this.geometry.setDrawRange(e, n - e + t.find((r) => r.offset === n).count), this.mesh.visible = !0;
  }
  getVisibleRange() {
    return ra;
  }
  setDrawRanges(...t) {
    const e = t.map((a) => a.material), n = [...Array.from(new Set(e.map((a) => a)))];
    Array.isArray(this.mesh.material) ? this.mesh.material = this.mesh.material.concat(n) : this.mesh.material = [this.mesh.material, ...n];
    const r = t.sort((a, o) => a.offset - o.offset), s = [];
    for (let a = 0; a < r.length; a++) {
      const o = this.getDrawRangeCollision(r[a]);
      o ? (De.warn(`Draw range collision @ ${this.id} overwritting...`), o.materialIndex = this.mesh.material.indexOf(r[a].material)) : s.push(r[a]);
    }
    for (let a = 0; a < s.length; a++)
      this.geometry.addGroup(s[a].offset, s[a].count, this.mesh.material.indexOf(s[a].material));
  }
  getDrawRangeCollision(t) {
    if (this.geometry.groups.length > 0) {
      for (let e = 0; e < this.geometry.groups.length; e++)
        if (t.offset === this.geometry.groups[e].start)
          return this.geometry.groups[e];
      return null;
    }
    return null;
  }
  autoFillDrawRanges() {
    const t = this.geometry.groups.sort((s, a) => s.start - a.start).slice();
    for (let s = 0; s < t.length; s++)
      if (s === 0)
        t[s].start > 0 && this.geometry.addGroup(0, t[s].start, 0), t.length === 1 && t[s].start + t[s].count < this.getCount() && this.geometry.addGroup(t[s].start + t[s].count, this.getCount() - t[s].start + t[s].count, 0);
      else {
        if (s === t.length - 1) {
          t[s].start + t[s].count < this.getCount() && this.geometry.addGroup(t[s].start + t[s].count, this.getCount() - t[s].start + t[s].count, 0), t[s - 1].start + t[s - 1].count < t[s].start && this.geometry.addGroup(t[s - 1].start + t[s - 1].count, t[s].start - (t[s - 1].start + t[s - 1].count), 0);
          continue;
        }
        t[s - 1].start + t[s - 1].count < t[s].start && this.geometry.addGroup(t[s - 1].start + t[s - 1].count, t[s].start - (t[s - 1].start + t[s - 1].count), 0);
      }
    this.geometry.groups.sort((s, a) => s.start - a.start);
    let e = 0;
    this.geometry.groups.forEach((s) => {
      e += s.count;
    }), e < this.getCount() && console.error(`DrawRange autocomplete failed! ${e}vs${this.getCount()}`);
    const n = [];
    this.geometry.groups.reduce((s, a) => (s.indexOf(a.materialIndex) === -1 && s.push(a.materialIndex), s), n);
    const r = [];
    for (let s = 0; s < n.length; s++)
      r.push(this.geometry.groups.filter((a) => a.materialIndex === n[s]));
    this.geometry.groups = [];
    for (let s = 0; s < r.length; s++) {
      const a = r[s];
      for (let o = 0; o < a.length; ) {
        let l = a[o].start, c = a[o].count, u = a[o].count, h = o + 1;
        for (; h < a.length; h++) {
          if (l + c !== a[h].start) {
            this.geometry.addGroup(a[o].start, u, a[o].materialIndex);
            break;
          }
          l = a[h].start, c = a[h].count, u += a[h].count;
        }
        h === a.length && this.geometry.addGroup(a[o].start, u, a[o].materialIndex), o = h;
      }
    }
  }
  resetDrawRanges() {
    this.mesh.material = this.batchMaterial, this.mesh.visible = !0, this.geometry.clearGroups(), this.geometry.setDrawRange(0, 1 / 0);
  }
  buildBatch() {
    const t = this.renderViews.flatMap((s) => s.renderData.geometry.attributes.POSITION).length, e = new Float64Array(t), n = new Float32Array(t).fill(1);
    let r = 0;
    for (let s = 0; s < this.renderViews.length; s++) {
      const a = this.renderViews[s].renderData.geometry;
      e.set(a.attributes.POSITION, r), a.attributes.COLOR && n.set(a.attributes.COLOR, r), this.renderViews[s].setBatchData(this.id, r / 3, a.attributes.POSITION.length / 3), r += a.attributes.POSITION.length, As.keepGeometryData || this.renderViews[s].disposeGeometry();
    }
    this.makePointGeometry(e, n), this.mesh = new sx(this.geometry, this.batchMaterial), this.mesh.uuid = this.id, this.mesh.layers.set(pn.STREAM_CONTENT_POINT);
  }
  getRenderView(t) {
    for (let e = 0; e < this.renderViews.length; e++)
      if (t >= this.renderViews[e].batchStart && t < this.renderViews[e].batchEnd)
        return this.renderViews[e];
  }
  makePointGeometry(t, e) {
    return this.geometry = new _e(), this.geometry.setAttribute("position", new Wt(t, 3)), this.geometry.setAttribute("color", new Wt(e, 3)), this.geometry.computeVertexNormals(), this.geometry.computeBoundingSphere(), this.geometry.computeBoundingBox(), I0.World.expandWorld(this.geometry.boundingBox), Nn.updateRTEGeometry(this.geometry, t), this.geometry;
  }
  purge() {
    this.renderViews.length = 0, this.geometry.dispose(), this.batchMaterial.dispose(), this.mesh = null;
  }
}
class Zz {
  constructor() {
    U(this, "materials");
    U(this, "batches", {});
    this.materials = new xb(), this.materials.createDefaultMaterials();
  }
  makeBatches(t, e, n) {
    const r = Qt.getRenderTree(t).getAtomicRenderViews(...e).sort((a, o) => a.renderMaterialHash === 0 ? -1 : o.renderMaterialHash === 0 ? 1 : a.renderMaterialHash - o.renderMaterialHash), s = [...Array.from(new Set(r.map((a) => a.renderMaterialHash)))];
    De.warn(`Batch count: ${s}`);
    for (let a = 0; a < s.length; a++) {
      const o = this.buildBatch(t, r, s[a], n);
      this.batches[o.id] = o;
    }
  }
  async *makeBatchesAsync(t, e, n, r) {
    const s = gM.getPause(r), a = Qt.getRenderTree(t).getAtomicRenderViews(...e).sort((l, c) => l.renderMaterialHash === 0 ? -1 : c.renderMaterialHash === 0 ? 1 : l.renderMaterialHash - c.renderMaterialHash), o = [...Array.from(new Set(a.map((l) => l.renderMaterialHash)))];
    De.warn(`Batch count: ${o.length}`);
    for (let l = 0; l < o.length; l++) {
      const c = this.buildBatch(t, a, o[l], n);
      this.batches[c.id] = c, yield this.batches[c.id], await s();
    }
  }
  buildBatch(t, e, n, r) {
    var p, f, v, m;
    let s = e.filter((y) => y.renderMaterialHash === n);
    s = s.filter((y) => y.validGeometry);
    const a = r !== void 0 ? r : s[0].geometryType;
    let o = null;
    if (a === ae.MESH) {
      if (o = s[0].renderData.renderMaterial, o) {
        const y = ((m = (v = (f = (p = s[0].renderData) == null ? void 0 : p.geometry) == null ? void 0 : f.attributes) == null ? void 0 : v.MORPHATTRIBUTES) == null ? void 0 : m.length) > 0;
        o.existMorphAttributes = y;
      }
    } else
      a === ae.LINE ? o = s[0].renderData.displayStyle : (a === ae.POINT || a === ae.POINT_CLOUD) && (o = s[0].renderData.renderMaterial);
    const l = e.some((y) => {
      var _, w, b, T;
      return ((T = (b = (w = (_ = y == null ? void 0 : y._renderData) == null ? void 0 : _.geometry) == null ? void 0 : w.attributes) == null ? void 0 : b.UV) == null ? void 0 : T.length) > 0;
    });
    Array.isArray(o) ? o.forEach((y) => y.haveUv = l) : o && (o.haveUv = l);
    const c = this.materials.updateMaterialMap(n, o, a), u = IB();
    let h = null;
    switch (a) {
      case ae.MESH:
        h = new Hot(u, t, s);
        break;
      case ae.LINE:
        h = new Db(u, t, s);
        break;
      case ae.POINT:
      case ae.POINT_CLOUD:
        h = new jot(u, t, s);
    }
    return h.setBatchMaterial(c), h.buildBatch(), h;
  }
  update(t) {
    for (const e in this.batches)
      this.batches[e].onUpdate(t);
  }
  render(t) {
    for (const e in this.batches)
      this.batches[e].onRender(t);
  }
  saveVisiblity() {
    const t = {};
    for (const e in this.batches) {
      const n = this.batches[e];
      t[e] = n.getVisibleRange();
    }
    return t;
  }
  applyVisibility(t) {
    for (const e in this.batches) {
      const n = this.batches[e], r = t[e];
      r ? n.setVisibleRange(r) : n.setVisibleRange(Jh);
    }
  }
  getTransparent() {
    const t = {};
    for (const e in this.batches) {
      const n = this.batches[e], r = n.renderObject;
      if (r.geometry.groups.length === 0)
        r.material.transparent === !0 && (t[e] = ra);
      else {
        const s = r.geometry.groups.find((o) => {
          var l;
          return ((l = r.material[o.materialIndex]) == null ? void 0 : l.visible) === !0;
        }), a = r.geometry.groups.find((o) => {
          var l;
          return ((l = r.material[o.materialIndex]) == null ? void 0 : l.visible) === !1;
        });
        s && (t[e] = { offset: s.start, count: a !== void 0 ? a.start : n.getCount() - s.start });
      }
    }
    return t;
  }
  getStencil() {
    const t = {};
    for (const e in this.batches) {
      const n = this.batches[e].renderObject;
      if (n.geometry.groups.length === 0)
        n.material.stencilWrite === !0 && (t[e] = ra);
      else {
        const r = n.geometry.groups.find((s) => {
          var a;
          return ((a = n.material[s.materialIndex]) == null ? void 0 : a.stencilWrite) === !0;
        });
        r && (t[e] = { offset: r.start, count: r.count });
      }
    }
    return t;
  }
  getOpaque() {
    const t = {};
    for (const e in this.batches) {
      const n = this.batches[e], r = n.renderObject;
      if (r.geometry.groups.length === 0)
        r.material.transparent === !1 && (t[e] = ra);
      else {
        const s = r.geometry.groups.find((a) => {
          var o, l;
          return ((o = r.material[a.materialIndex]) == null ? void 0 : o.transparent) === !0 || ((l = r.material[a.materialIndex]) == null ? void 0 : l.visible) === !1;
        });
        t[e] = { offset: 0, count: s !== void 0 ? s.start : n.getCount() };
      }
    }
    return t;
  }
  purgeBatches(t) {
    for (const e in this.batches)
      this.batches[e].subtreeId === t && (this.batches[e].purge(), delete this.batches[e]);
  }
  getBatches(t, e) {
    return Object.values(this.batches).filter((n) => {
      const r = t === void 0 || n.subtreeId === t, s = e === void 0 || n.geometryType === e;
      return r && s;
    });
  }
  getRenderView(t, e) {
    return this.batches[t].getRenderView(e);
  }
  resetBatchesDrawRanges() {
    for (const t in this.batches)
      this.batches[t].resetDrawRanges();
  }
  setObjectsFilterMaterial(t, e, n = !0) {
    let r = t;
    n && (r = [...Array.from(new Set(t.map((a) => a)))]);
    const s = [...Array.from(new Set(r.map((a) => a.batchId)))];
    for (let a = 0; a < s.length; a++) {
      if (!s[a])
        continue;
      const o = this.batches[s[a]], l = r.filter((c) => c.batchId === s[a]).map((c) => ({ offset: c.batchStart, count: c.batchCount, material: this.materials.getFilterMaterial(c, e.filterType), materialOptions: this.materials.getFilterMaterialOptions(e) }));
      o.setDrawRanges(...l);
    }
    return s;
  }
  autoFillDrawRanges(t) {
    [...Array.from(new Set(t.map((e) => e)))].forEach((e) => {
      e && this.batches[e].autoFillDrawRanges();
    });
  }
  isolateRenderView(t) {
    const e = Qt.getRenderTree().getRenderViewsForNodeId(t), n = [...Array.from(new Set(e.map((r) => r.batchId)))];
    for (const r in this.batches)
      if (n.includes(r)) {
        const s = [];
        for (let a = 0; a < this.batches[r].renderViews.length; a++)
          e.includes(this.batches[r].renderViews[a]) ? s.push({ offset: this.batches[r].renderViews[a].batchStart, count: this.batches[r].renderViews[a].batchCount, material: this.materials.getFilterMaterial(this.batches[r].renderViews[a], ki.SELECT) }) : s.push({ offset: this.batches[r].renderViews[a].batchStart, count: this.batches[r].renderViews[a].batchCount, material: this.materials.getFilterMaterial(this.batches[r].renderViews[a], ki.GHOST) });
        s.length > 0 && (this.batches[r].setDrawRanges(...s), this.batches[r].autoFillDrawRanges());
      } else
        this.batches[r].setDrawRanges({ offset: 0, count: 1 / 0, material: this.materials.getFilterMaterial(this.batches[r].renderViews[0], ki.GHOST) }), this.batches[r].setVisibleRange(Jh);
  }
  async isolateRenderViewBatch(t) {
    const e = Qt.getRenderTree().getRenderViewForNodeId(t);
    for (const n in this.batches)
      n !== e.batchId && this.batches[n].setDrawRanges({ offset: 0, count: 1 / 0, material: this.materials.getFilterMaterial(this.batches[n].renderViews[0], ki.GHOST) });
  }
}
const Got = { hover: !1 };
class Wot extends R0 {
  constructor(e, n) {
    let r;
    super();
    U(this, "tapTimeout");
    U(this, "lastTap", 0);
    U(this, "touchLocation");
    U(this, "container");
    this.container = e, this.container.addEventListener("pointerdown", (s) => {
      s.preventDefault(), r = (/* @__PURE__ */ new Date()).getTime();
    }), this.container.addEventListener("pointerup", (s) => {
      if (s.preventDefault(), (/* @__PURE__ */ new Date()).getTime() - r > 250)
        return;
      const a = this._getNormalisedClickPosition(s);
      a.event = s, s.shiftKey && (a.multiSelect = !0), this.emit(tn.ObjectClicked, a);
    }), this.container.addEventListener("touchstart", (s) => {
      this.touchLocation = s.targetTouches[0];
    }), this.container.addEventListener("touchend", (s) => {
      if (s.targetTouches.length > 0)
        return;
      const a = (/* @__PURE__ */ new Date()).getTime(), o = a - this.lastTap;
      clearTimeout(this.tapTimeout), o < 500 && o > 0 ? this.emit(tn.ObjectDoubleClicked, this._getNormalisedClickPosition(this.touchLocation)) : this.tapTimeout = setTimeout(function() {
        clearTimeout(this.tapTimeout);
      }, 500), this.lastTap = a;
    }), this.container.addEventListener("dblclick", (s) => {
      this.emit(tn.ObjectDoubleClicked, this._getNormalisedClickPosition(s));
    });
  }
  _getNormalisedClickPosition(e) {
    const n = this.container, r = this.container.getBoundingClientRect(), s = (e.clientX - r.left) * n.width / r.width, a = (e.clientY - r.top) * n.height / r.height;
    return new wt(s / n.width * 2 - 1, a / n.height * -2 + 1);
  }
  dispose() {
    super.dispose();
  }
}
class Zot extends iu {
  constructor(e, n, r = 0, s = 1 / 0) {
    super(e, n, r, s);
    U(this, "onObjectIntersectionTest", null);
    this.layers.disableAll(), this.layers.enable(pn.STREAM_CONTENT), this.layers.enable(pn.STREAM_CONTENT_MESH), this.layers.enable(pn.STREAM_CONTENT_LINE);
  }
  intersectObjects(e, n = !0, r = []) {
    for (let s = 0, a = e.length; s < a; s++)
      qz(e[s], this, r, n);
    return r.sort(qot), r;
  }
}
function qot(i, t) {
  return i.distance - t.distance;
}
function qz(i, t, e, n) {
  if (i.layers.test(t.layers) && (t.onObjectIntersectionTest && t.onObjectIntersectionTest(i), i.raycast(t, e)), n === !0) {
    const r = i.children;
    for (let s = 0, a = r.length; s < a; s++)
      qz(r[s], t, e, !0);
  }
}
class Xot {
  constructor() {
    U(this, "raycaster");
    U(this, "boxBuffer", new ke());
    U(this, "vec0Buffer", new ze());
    U(this, "vec1Buffer", new ze());
    this.raycaster = new Zot(), this.raycaster.params.Line = { threshold: 0.01 }, this.raycaster.params.Line2 = {}, this.raycaster.params.Line2.threshold = 1, this.raycaster.onObjectIntersectionTest = this.onObjectIntersection.bind(this);
  }
  onObjectIntersection(t) {
    if (t instanceof yM) {
      const e = this.boxBuffer.setFromObject(t), n = this.vec0Buffer.set(e.min.x, e.min.y, e.min.z, 1), r = this.vec1Buffer.set(e.max.y, e.max.y, e.max.z, 1);
      n.applyMatrix4(this.raycaster.camera.matrixWorldInverse).applyMatrix4(this.raycaster.camera.projectionMatrix), r.applyMatrix4(this.raycaster.camera.matrixWorldInverse).applyMatrix4(this.raycaster.camera.projectionMatrix), n.multiplyScalar(0.5).multiplyScalar(1 / n.w).addScalar(0.5), r.multiplyScalar(0.5).multiplyScalar(1 / r.w).addScalar(0.5);
      const s = new wt().set(n.x, n.y).distanceTo(new wt(r.x, r.y)), a = t.material, o = a.linewidth, l = a.worldUnits;
      this.raycaster.params.Line2.threshold = l ? s < 1 ? 2 * o : o : s < 1 ? 8 * o : 5 * o;
    }
  }
  intersect(t, e, n, r = !0, s = null, a = void 0, o = !1) {
    return this.raycaster.setFromCamera(n, e), this.raycaster.firstHitOnly = o, this.intersectInternal(t, r, s, a);
  }
  intersectRay(t, e, n, r = !0, s = null, a = void 0, o = !1) {
    return this.raycaster.camera = e, this.raycaster.set(n.origin, n.direction), this.raycaster.firstHitOnly = o, this.intersectInternal(t, r, s, a);
  }
  intersectInternal(t, e, n, r) {
    const s = this.raycaster.layers.mask;
    r !== void 0 && (this.raycaster.layers.disableAll(), r.forEach((l) => {
      this.raycaster.layers.enable(l);
    }));
    const a = t.getObjectByName("ContentGroup");
    let o = [];
    if (a) {
      const l = performance.now();
      o = this.raycaster.intersectObjects(a.children), De.warn("Interesct time -> ", performance.now() - l);
    }
    return this.raycaster.layers.mask = s, o.length === 0 ? null : (e && o.sort((l, c) => l.distance - c.distance), n && (o = o.filter((l) => n.containsPoint(l.point))), o);
  }
}
const Tr = class Tr extends n0 {
  constructor(t, e = []) {
    super(t), this.userData.uViewer_high = { value: new D() }, this.userData.uViewer_low = { value: new D() }, this.userData.rteModelViewMatrix = { value: new Vt() }, this.userData.near = { value: 0 }, this.userData.far = { value: 0 }, this.vertProgram = `
#include <common>
#ifdef USE_RTE
    // The high component is stored as the default 'position' attribute buffer
    attribute vec3 position_low;
    uniform vec3 uViewer_high;
    uniform vec3 uViewer_low;
    uniform mat4 rteModelViewMatrix;
#endif
#ifdef LINEAR_DEPTH
    varying vec4 vViewPosition;
#endif
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
// This is used for computing an equivalent of gl_FragCoord.z that is as high precision as possible.
// Some platforms compute gl_FragCoord at a lower precision which makes the manually computed value better for
// depth-based postprocessing effects. Reproduced on iPad with A10 processor / iPadOS 13.3.1.
varying vec2 vHighPrecisionZW;

vec4 computeRelativePositionSeparate(in vec3 position_low, in vec3 position_high, in vec3 relativeTo_low, in vec3 relativeTo_high){
    /* 
    Vector calculation for the high and low differences works on everything 
    *BESIDES* Apple Silicon (or whatever they call it) GPUs

    It would seem that when this code gets compiled, vector types get a lower precision(?)
    which completely brakes the 2 float -> double reconstructio. Doing it separately for each 
    vector component using floats works fine.
    */
    vec3 highDifference;
    vec3 lowDifference;
    float t1 = position_low.x - relativeTo_low.x;
    float e = t1 - position_low.x;
    float t2 = ((-relativeTo_low.x - e) + (position_low.x - (t1 - e))) + position_high.x - relativeTo_high.x;
    highDifference.x = t1 + t2;
    lowDifference.x = t2 - (highDifference.x - t1);

    t1 = position_low.y - relativeTo_low.y;
    e = t1 - position_low.y;
    t2 = ((-relativeTo_low.y - e) + (position_low.y - (t1 - e))) + position_high.y - relativeTo_high.y;
    highDifference.y = t1 + t2;
    lowDifference.y = t2 - (highDifference.y - t1);

    t1 = position_low.z - relativeTo_low.z;
    e = t1 - position_low.z;
    t2 = ((-relativeTo_low.z - e) + (position_low.z - (t1 - e))) + position_high.z - relativeTo_high.z;
    highDifference.z = t1 + t2;
    lowDifference.z = t2 - (highDifference.z - t1);

    vec3 position = highDifference.xyz + lowDifference.xyz;
    return vec4(position, 1.);
}

vec4 computeRelativePosition(in vec3 position_low, in vec3 position_high, in vec3 relativeTo_low, in vec3 relativeTo_high){
    /* 
    Source https://github.com/virtualglobebook/OpenGlobe/blob/master/Source/Examples/Chapter05/Jitter/GPURelativeToEyeDSFUN90/Shaders/VS.glsl 
    Note here, we're storing the high part of the position encoding inside three's default 'position' attribute buffer so we avoid redundancy 
    */
    vec3 t1 = position_low.xyz - relativeTo_low;
    vec3 e = t1 - position_low.xyz;
    vec3 t2 = ((-relativeTo_low - e) + (position_low.xyz - (t1 - e))) + position_high.xyz - relativeTo_high;
    vec3 highDifference = t1 + t2;
    vec3 lowDifference = t2 - (highDifference - t1);
    
    vec3 position = highDifference.xyz + lowDifference.xyz;
    return vec4(position, 1.);
}


void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	//#include <project_vertex> // EDITED CHUNK
    #ifdef USE_RTE
        vec4 mvPosition = computeRelativePositionSeparate(position_low.xyz, position.xyz, uViewer_low, uViewer_high);
    #else
        vec4 mvPosition = vec4( transformed, 1.0 );
    #endif
    
    #ifdef USE_INSTANCING

        mvPosition = instanceMatrix * mvPosition;

    #endif
    mvPosition = rteModelViewMatrix * mvPosition;

    #ifdef LINEAR_DEPTH
        vViewPosition = mvPosition;
    #endif 
    
    gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	// #include <clipping_planes_vertex>
    #if NUM_CLIPPING_PLANES > 0
	    vClipPosition = - mvPosition.xyz;
    #endif
	vHighPrecisionZW = gl_Position.zw;
}
`, this.fragProgram = `
#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#ifdef LINEAR_DEPTH
    varying vec4 vViewPosition;
	uniform float near;
	uniform float far;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;

void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	// #include <alphatest_fragment>
	#ifdef USE_ALPHATEST
		if ( diffuseColor.a < alphaTest ) discard;
		/** This is a workaround for rejecting shadows for certain materials, since three.js gave me no choice*/
		#ifdef ALPHATEST_REJECTION
			if (alphaTest > 0. ) discard;
		#endif
	#endif
	#include <logdepthbuf_fragment>
	// Higher precision equivalent of gl_FragCoord.z. This assumes depthRange has been left to its default values.
	#ifdef LINEAR_DEPTH
		/** View z is negative moving away from the camera */
		gl_FragColor = packDepthToRGBA((vViewPosition.z + near) / (near - far));
	#else
		float fragCoordZ = (0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5);
		#if DEPTH_PACKING == 3200
			gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
		#elif DEPTH_PACKING == 3201
			gl_FragColor = packDepthToRGBA( fragCoordZ );
		#endif
	#endif
}
`, this.uniforms = Jn.merge([Pn.standard.uniforms, { uViewer_high: { value: this.userData.uViewer_high.value }, uViewer_low: { value: this.userData.uViewer_low.value }, rteModelViewMatrix: { value: this.userData.rteModelViewMatrix.value }, near: { value: this.userData.near.value }, far: { value: this.userData.far.value } }]), this.onBeforeCompile = function(n) {
      n.uniforms.uViewer_high = this.userData.uViewer_high, n.uniforms.uViewer_low = this.userData.uViewer_low, n.uniforms.rteModelViewMatrix = this.userData.rteModelViewMatrix, n.uniforms.near = this.userData.near, n.uniforms.far = this.userData.far, n.vertexShader = this.vertProgram, n.fragmentShader = this.fragProgram;
    }, e && (this.defines = {});
    for (let n = 0; n < e.length; n++)
      this.defines[e[n]] = " ";
  }
  clone() {
    const t = super.clone();
    return t.userData.uViewer_high = this.userData.uViewer_high, t.userData.uViewer_low = this.userData.uViewer_low, t.userData.rteModelViewMatrix = this.userData.rteModelViewMatrix, t.userData.near = this.userData.near, t.userData.far = this.userData.far, t;
  }
  copy(t) {
    return super.copy(t), this.userData = {}, this.userData.uViewer_high = { value: new D() }, this.userData.uViewer_low = { value: new D() }, this.userData.rteModelViewMatrix = { value: new Vt() }, this.userData.near = { value: 0 }, this.userData.far = { value: 0 }, this.defines.USE_RTE = " ", this;
  }
  onBeforeRender(t, e, n, r, s, a) {
    Tr.matBuff.copy(n.matrixWorldInverse), Tr.matBuff.elements[12] = 0, Tr.matBuff.elements[13] = 0, Tr.matBuff.elements[14] = 0, Tr.matBuff.multiply(s.matrixWorld), s.modelViewMatrix.copy(Tr.matBuff), Tr.vecBuff0.set(n.matrixWorld.elements[12], n.matrixWorld.elements[13], n.matrixWorld.elements[14]), Nn.DoubleToHighLowVector(Tr.vecBuff0, Tr.vecBuff1, Tr.vecBuff2), this.userData.uViewer_low.value.copy(Tr.vecBuff1), this.userData.uViewer_high.value.copy(Tr.vecBuff2), this.userData.rteModelViewMatrix.value.copy(s.modelViewMatrix);
    const o = t.properties.get(this).currentProgram;
    if (o) {
      t.getContext().useProgram(o.program);
      const l = o.getUniforms();
      t.getContext().uniformMatrix4fv(l.map.rteModelViewMatrix.addr, !1, this.userData.rteModelViewMatrix.value.elements);
    }
    this.needsUpdate = !0;
  }
};
U(Tr, "matBuff", new Vt()), U(Tr, "vecBuff0", new D()), U(Tr, "vecBuff1", new D()), U(Tr, "vecBuff2", new D());
let xp = Tr;
const _M = { uniforms: { tDiffuse: { value: null }, opacity: { value: 1 } }, vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`, fragmentShader: `

		uniform float opacity;

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		void main() {

			gl_FragColor = texture2D( tDiffuse, vUv );
			gl_FragColor.a *= opacity;


		}` };
class Qa {
  constructor() {
    this.enabled = !0, this.needsSwap = !0, this.clear = !1, this.renderToScreen = !1;
  }
  setSize() {
  }
  render() {
    console.error("THREE.Pass: .render() must be implemented in derived pass.");
  }
  dispose() {
  }
}
const Yot = new Yl(-1, 1, 1, -1, 0, 1), Rb = new _e();
Rb.setAttribute("position", new Wt([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3)), Rb.setAttribute("uv", new Wt([0, 2, 0, 0, 2, 0], 2));
class oc {
  constructor(t) {
    this._mesh = new Nt(Rb, t);
  }
  dispose() {
    this._mesh.geometry.dispose();
  }
  render(t) {
    t.render(this._mesh, Yot);
  }
  get material() {
    return this._mesh.material;
  }
  set material(t) {
    this._mesh.material = t;
  }
}
class Jot extends Qa {
  constructor(t, e) {
    super(), this.textureID = e !== void 0 ? e : "tDiffuse", t instanceof Gn ? (this.uniforms = t.uniforms, this.material = t) : t && (this.uniforms = Jn.clone(t.uniforms), this.material = new Gn({ defines: Object.assign({}, t.defines), uniforms: this.uniforms, vertexShader: t.vertexShader, fragmentShader: t.fragmentShader })), this.fsQuad = new oc(this.material);
  }
  render(t, e, n) {
    this.uniforms[this.textureID] && (this.uniforms[this.textureID].value = n.texture), this.fsQuad.material = this.material, this.renderToScreen ? (t.setRenderTarget(null), this.fsQuad.render(t)) : (t.setRenderTarget(e), this.clear && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), this.fsQuad.render(t));
  }
  dispose() {
    this.material.dispose(), this.fsQuad.dispose();
  }
}
class iI extends Qa {
  constructor(t, e) {
    super(), this.scene = t, this.camera = e, this.clear = !0, this.needsSwap = !1, this.inverse = !1;
  }
  render(t, e, n) {
    const r = t.getContext(), s = t.state;
    let a, o;
    s.buffers.color.setMask(!1), s.buffers.depth.setMask(!1), s.buffers.color.setLocked(!0), s.buffers.depth.setLocked(!0), this.inverse ? (a = 0, o = 1) : (a = 1, o = 0), s.buffers.stencil.setTest(!0), s.buffers.stencil.setOp(r.REPLACE, r.REPLACE, r.REPLACE), s.buffers.stencil.setFunc(r.ALWAYS, a, 4294967295), s.buffers.stencil.setClear(o), s.buffers.stencil.setLocked(!0), t.setRenderTarget(n), this.clear && t.clear(), t.render(this.scene, this.camera), t.setRenderTarget(e), this.clear && t.clear(), t.render(this.scene, this.camera), s.buffers.color.setLocked(!1), s.buffers.depth.setLocked(!1), s.buffers.stencil.setLocked(!1), s.buffers.stencil.setFunc(r.EQUAL, 1, 4294967295), s.buffers.stencil.setOp(r.KEEP, r.KEEP, r.KEEP), s.buffers.stencil.setLocked(!0);
  }
}
class Kot extends Qa {
  constructor() {
    super(), this.needsSwap = !1;
  }
  render(t) {
    t.state.buffers.stencil.setLocked(!1), t.state.buffers.stencil.setTest(!1);
  }
}
class $ot {
  constructor(t, e) {
    if (this.renderer = t, e === void 0) {
      const n = t.getSize(new wt());
      this._pixelRatio = t.getPixelRatio(), this._width = n.width, this._height = n.height, (e = new ir(this._width * this._pixelRatio, this._height * this._pixelRatio)).texture.name = "EffectComposer.rt1";
    } else
      this._pixelRatio = 1, this._width = e.width, this._height = e.height;
    this.renderTarget1 = e, this.renderTarget2 = e.clone(), this.renderTarget2.texture.name = "EffectComposer.rt2", this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2, this.renderToScreen = !0, this.passes = [], this.copyPass = new Jot(_M), this.clock = new Cv();
  }
  swapBuffers() {
    const t = this.readBuffer;
    this.readBuffer = this.writeBuffer, this.writeBuffer = t;
  }
  addPass(t) {
    this.passes.push(t), t.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
  }
  insertPass(t, e) {
    this.passes.splice(e, 0, t), t.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
  }
  removePass(t) {
    const e = this.passes.indexOf(t);
    e !== -1 && this.passes.splice(e, 1);
  }
  isLastEnabledPass(t) {
    for (let e = t + 1; e < this.passes.length; e++)
      if (this.passes[e].enabled)
        return !1;
    return !0;
  }
  render(t) {
    t === void 0 && (t = this.clock.getDelta());
    const e = this.renderer.getRenderTarget();
    let n = !1;
    for (let r = 0, s = this.passes.length; r < s; r++) {
      const a = this.passes[r];
      if (a.enabled !== !1) {
        if (a.renderToScreen = this.renderToScreen && this.isLastEnabledPass(r), a.render(this.renderer, this.writeBuffer, this.readBuffer, t, n), a.needsSwap) {
          if (n) {
            const o = this.renderer.getContext(), l = this.renderer.state.buffers.stencil;
            l.setFunc(o.NOTEQUAL, 1, 4294967295), this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, t), l.setFunc(o.EQUAL, 1, 4294967295);
          }
          this.swapBuffers();
        }
        iI !== void 0 && (a instanceof iI ? n = !0 : a instanceof Kot && (n = !1));
      }
    }
    this.renderer.setRenderTarget(e);
  }
  reset(t) {
    if (t === void 0) {
      const e = this.renderer.getSize(new wt());
      this._pixelRatio = this.renderer.getPixelRatio(), this._width = e.width, this._height = e.height, (t = this.renderTarget1.clone()).setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
    }
    this.renderTarget1.dispose(), this.renderTarget2.dispose(), this.renderTarget1 = t, this.renderTarget2 = t.clone(), this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2;
  }
  setSize(t, e) {
    this._width = t, this._height = e;
    const n = this._width * this._pixelRatio, r = this._height * this._pixelRatio;
    this.renderTarget1.setSize(n, r), this.renderTarget2.setSize(n, r);
    for (let s = 0; s < this.passes.length; s++)
      this.passes[s].setSize(n, r);
  }
  setPixelRatio(t) {
    this._pixelRatio = t, this.setSize(this._width, this._height);
  }
  dispose() {
    this.renderTarget1.dispose(), this.renderTarget2.dispose(), this.copyPass.dispose();
  }
}
class Qot extends Qa {
  constructor() {
    super();
    U(this, "fsQuad");
    U(this, "materialCopy");
    U(this, "frameIndex", 0);
    this.materialCopy = new Gn({ defines: { ACCUMULATE: 0 }, uniforms: { tDiffuse: { value: null }, tDiffuseInterp: { value: null }, frameIndex: { value: 0 } }, vertexShader: `
		varying vec2 vUv;
		void main() {
			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
		}`, fragmentShader: `
		uniform float opacity;
		uniform sampler2D tDiffuse;
        uniform sampler2D tDiffuseInterp;
		varying vec2 vUv;
        #if ACCUMULATE == 1
            uniform float frameIndex;
        #endif

		void main() {
            vec3 currentSample = texture2D( tDiffuse, vUv ).rgb;
            
            #if ACCUMULATE == 1
                vec3 interpSample = texture2D( tDiffuseInterp, vUv ).rgb;
			    gl_FragColor.rgb = mix(interpSample, currentSample, frameIndex/float(NUM_FRAMES));
            #else
                gl_FragColor.rgb = currentSample;
            #endif
			gl_FragColor.a = 1.;
		}`, blending: 0 }), this.materialCopy.transparent = !0, this.materialCopy.depthTest = !1, this.materialCopy.depthWrite = !1, this.materialCopy.blending = 5, this.materialCopy.blendSrc = 208, this.materialCopy.blendDst = 200, this.materialCopy.blendEquation = 100, this.materialCopy.blendSrcAlpha = 206, this.materialCopy.blendDstAlpha = 200, this.materialCopy.blendEquationAlpha = 100, this.materialCopy.needsUpdate = !0, this.fsQuad = new oc(this.materialCopy);
  }
  setTexture(e, n) {
    this.materialCopy.uniforms[e].value = n, this.materialCopy.needsUpdate = !0;
  }
  get displayName() {
    return "APPLYSAO";
  }
  get outputTexture() {
    return null;
  }
  setParams(e) {
  }
  setFrameIndex(e) {
    this.frameIndex = e;
  }
  setRenderType(e) {
    e === wM.NORMAL ? this.materialCopy.defines.ACCUMULATE = 0 : (this.materialCopy.defines.ACCUMULATE = 1, this.frameIndex = 0), this.materialCopy.needsUpdate = !0;
  }
  update(e, n) {
    this.materialCopy.defines.NUM_FRAMES = eu.ACCUMULATE_FRAMES, this.materialCopy.uniforms.frameIndex.value = this.frameIndex, this.materialCopy.needsUpdate = !0;
  }
  render(e, n, r) {
    e.setRenderTarget(null);
    const s = e.autoClear;
    e.autoClear = !1, this.fsQuad.render(e), e.autoClear = s;
  }
}
class tlt extends Qa {
  constructor() {
    super();
    U(this, "fsQuad");
    U(this, "materialCopy");
    this.materialCopy = new Gn({ defines: { INPUT_TYPE: 0 }, uniforms: Jn.clone(_M.uniforms), vertexShader: `
    varying vec2 vUv;
    void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
    }`, fragmentShader: `
    uniform float opacity;
    uniform sampler2D tDiffuse;
    varying vec2 vUv;

    const float UnpackDownscale = 255. / 256.;
    const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
    const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );

    float unpackRGBAToDepth( const in vec4 v ) {
        return dot( v, UnpackFactors );
    }

    vec3 unpackRGBToNormal( const in vec3 rgb ) {
        return 2.0 * rgb.xyz - 1.0;
    }

    void main() {
        vec4 inSample = texture2D( tDiffuse, vUv );
        vec3 outSample = inSample.rgb;
        #if OUTPUT_TYPE == 1
            outSample.rgb = vec3(unpackRGBAToDepth(inSample));
        #endif
        // #if OUTPUT_TYPE == 3
        //     outSample.rgb = unpackRGBToNormal(inSample.rgb);
        // #endif

        gl_FragColor.rgb = outSample;
        gl_FragColor.a = 1.;
    }`, blending: 0 }), this.materialCopy.needsUpdate = !0, this.fsQuad = new oc(this.materialCopy);
  }
  setOutputType(e) {
    this.materialCopy.defines.OUTPUT_TYPE = e, this.materialCopy.needsUpdate = !0;
  }
  setTexture(e, n) {
    this.materialCopy.uniforms[e].value = n, this.materialCopy.needsUpdate = !0;
  }
  get displayName() {
    return "COPY-OUTPUT";
  }
  get outputTexture() {
    return null;
  }
  render(e, n, r) {
    e.setRenderTarget(null);
    const s = e.autoClear;
    e.autoClear = !1, this.fsQuad.render(e), e.autoClear = s;
  }
}
class gu extends Qa {
  constructor() {
    super();
    U(this, "layers", null);
  }
  get displayName() {
    return "BASE";
  }
  get outputTexture() {
    return null;
  }
  setLayers(e) {
    this.layers = e;
  }
  applyLayers(e) {
    this.layers !== null ? (e.layers.disableAll(), this.layers.forEach((n) => {
      e.layers.enable(n);
    })) : e.layers.enableAll();
  }
}
var Al = ((i) => (i[i.PERSPECTIVE_DEPTH = 0] = "PERSPECTIVE_DEPTH", i[i.LINEAR_DEPTH = 1] = "LINEAR_DEPTH", i))(Al || {}), Da = ((i) => (i[i.FULL = 0] = "FULL", i[i.HALF = 1] = "HALF", i))(Da || {});
class elt extends gu {
  constructor() {
    super();
    U(this, "renderTarget");
    U(this, "renderTargetHalf");
    U(this, "depthMaterial", null);
    U(this, "depthBufferSize", 0);
    U(this, "scene");
    U(this, "camera");
    U(this, "colorBuffer", new Ht());
    U(this, "onBeforeRender", null);
    U(this, "onAfterRender", null);
    this.renderTarget = new ir(256, 256, { minFilter: 1003, magFilter: 1003 }), this.renderTargetHalf = new ir(256, 256, { minFilter: 1003, magFilter: 1003 }), this.renderTarget.depthBuffer = !0, this.renderTarget.stencilBuffer = !0, this.renderTargetHalf.depthBuffer = !0, this.renderTargetHalf.stencilBuffer = !0, this.depthMaterial = new xp({ depthPacking: 3201 }, ["USE_RTE", "ALPHATEST_REJECTION"]), this.depthMaterial.blending = 0, this.depthMaterial.side = 2;
  }
  get displayName() {
    return "DEPTH";
  }
  get outputTexture() {
    return this.renderTarget.texture;
  }
  get outputTextureHalf() {
    return this.renderTargetHalf.texture;
  }
  set depthType(e) {
    e === 1 ? this.depthMaterial.defines.LINEAR_DEPTH = " " : delete this.depthMaterial.defines.LINEAR_DEPTH, this.depthMaterial.needsUpdate = !0;
  }
  set depthSize(e) {
    this.depthBufferSize = e;
  }
  setClippingPlanes(e) {
    this.depthMaterial.clippingPlanes = e;
  }
  update(e, n) {
    this.camera = n, this.scene = e, this.depthMaterial.userData.near.value = n.near, this.depthMaterial.userData.far.value = n.far, this.depthMaterial.needsUpdate = !0;
  }
  render(e, n, r) {
    this.onBeforeRender(), e.getClearColor(this.colorBuffer);
    const s = e.getClearAlpha(), a = e.autoClear;
    e.setRenderTarget(this.depthBufferSize === 0 ? this.renderTarget : this.renderTargetHalf), e.autoClear = !1, e.setClearColor(0), e.setClearAlpha(1), e.clear();
    const o = e.shadowMap.enabled, l = e.shadowMap.needsUpdate;
    this.scene.overrideMaterial = this.depthMaterial, e.shadowMap.enabled = !1, e.shadowMap.needsUpdate = !1, this.applyLayers(this.camera), e.render(this.scene, this.camera), e.shadowMap.enabled = o, e.shadowMap.needsUpdate = l, this.scene.overrideMaterial = null, e.autoClear = a, e.setClearColor(this.colorBuffer), e.setClearAlpha(s), this.onAfterRender();
  }
  setSize(e, n) {
    this.renderTarget.setSize(e, n), this.renderTargetHalf.setSize(0.5 * e, 0.5 * n);
  }
}
const Er = class Er extends Yb {
  constructor(t, e = []) {
    super(t), this.userData.uViewer_high = { value: new D() }, this.userData.uViewer_low = { value: new D() }, this.vertProgram = `
#define NORMAL
#ifdef USE_RTE
    // The high component is stored as the default 'position' attribute buffer
    attribute vec3 position_low;
    uniform vec3 uViewer_high;
    uniform vec3 uViewer_low;
#endif
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

vec4 computeRelativePositionSeparate(in vec3 position_low, in vec3 position_high, in vec3 relativeTo_low, in vec3 relativeTo_high){
    /* 
    Vector calculation for the high and low differences works on everything 
    *BESIDES* Apple Silicon (or whatever they call it) GPUs

    It would seem that when this code gets compiled, vector types get a lower precision(?)
    which completely brakes the 2 float -> double reconstructio. Doing it separately for each 
    vector component using floats works fine.
    */
    vec3 highDifference;
    vec3 lowDifference;
    float t1 = position_low.x - relativeTo_low.x;
    float e = t1 - position_low.x;
    float t2 = ((-relativeTo_low.x - e) + (position_low.x - (t1 - e))) + position_high.x - relativeTo_high.x;
    highDifference.x = t1 + t2;
    lowDifference.x = t2 - (highDifference.x - t1);

    t1 = position_low.y - relativeTo_low.y;
    e = t1 - position_low.y;
    t2 = ((-relativeTo_low.y - e) + (position_low.y - (t1 - e))) + position_high.y - relativeTo_high.y;
    highDifference.y = t1 + t2;
    lowDifference.y = t2 - (highDifference.y - t1);

    t1 = position_low.z - relativeTo_low.z;
    e = t1 - position_low.z;
    t2 = ((-relativeTo_low.z - e) + (position_low.z - (t1 - e))) + position_high.z - relativeTo_high.z;
    highDifference.z = t1 + t2;
    lowDifference.z = t2 - (highDifference.z - t1);

    vec3 position = highDifference.xyz + lowDifference.xyz;
    return vec4(position, 1.);
}

vec4 computeRelativePosition(in vec3 position_low, in vec3 position_high, in vec3 relativeTo_low, in vec3 relativeTo_high){
    /* 
    Source https://github.com/virtualglobebook/OpenGlobe/blob/master/Source/Examples/Chapter05/Jitter/GPURelativeToEyeDSFUN90/Shaders/VS.glsl 
    Note here, we're storing the high part of the position encoding inside three's default 'position' attribute buffer so we avoid redundancy 
    */
    vec3 t1 = position_low.xyz - relativeTo_low;
    vec3 e = t1 - position_low.xyz;
    vec3 t2 = ((-relativeTo_low - e) + (position_low.xyz - (t1 - e))) + position_high.xyz - relativeTo_high;
    vec3 highDifference = t1 + t2;
    vec3 lowDifference = t2 - (highDifference - t1);
    
    vec3 position = highDifference.xyz + lowDifference.xyz;
    return vec4(position, 1.);
}

void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
    //#include <project_vertex> // EDITED CHUNK
    #ifdef USE_RTE
        vec4 mvPosition = computeRelativePositionSeparate(position_low.xyz, position.xyz, uViewer_low, uViewer_high);
    #else
        vec4 mvPosition = vec4( transformed, 1.0 );
    #endif
    
    #ifdef USE_INSTANCING

        mvPosition = instanceMatrix * mvPosition;

    #endif
    mvPosition = modelViewMatrix * mvPosition;

    gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	vViewPosition = - mvPosition.xyz;
#endif
}
`, this.fragProgram = `
#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}
`, this.uniforms = Jn.merge([Pn.standard.uniforms, { uViewer_high: { value: this.userData.uViewer_high.value }, uViewer_low: { value: this.userData.uViewer_low.value } }]), this.onBeforeCompile = function(n) {
      n.uniforms.uViewer_high = this.userData.uViewer_high, n.uniforms.uViewer_low = this.userData.uViewer_low, n.vertexShader = this.vertProgram, n.fragmentShader = this.fragProgram;
    }, e && (this.defines = {});
    for (let n = 0; n < e.length; n++)
      this.defines[e[n]] = " ";
  }
  copy(t) {
    return super.copy(t), this.userData = {}, this.userData.uViewer_high = { value: new D() }, this.userData.uViewer_low = { value: new D() }, this.defines.USE_RTE = " ", this;
  }
  onBeforeRender(t, e, n, r, s, a) {
    Er.matBuff.copy(n.matrixWorldInverse), Er.matBuff.elements[12] = 0, Er.matBuff.elements[13] = 0, Er.matBuff.elements[14] = 0, Er.matBuff.multiply(s.matrixWorld), s.modelViewMatrix.copy(Er.matBuff), Er.vecBuff0.set(n.matrixWorld.elements[12], n.matrixWorld.elements[13], n.matrixWorld.elements[14]), Nn.DoubleToHighLowVector(Er.vecBuff0, Er.vecBuff1, Er.vecBuff2), this.userData.uViewer_low.value.copy(Er.vecBuff1), this.userData.uViewer_high.value.copy(Er.vecBuff2), this.needsUpdate = !0;
  }
};
U(Er, "matBuff", new Vt()), U(Er, "vecBuff0", new D()), U(Er, "vecBuff1", new D()), U(Er, "vecBuff2", new D());
let Ib = Er;
class nlt extends gu {
  constructor() {
    super();
    U(this, "renderTarget");
    U(this, "normalsMaterial", null);
    U(this, "scene");
    U(this, "camera");
    U(this, "colorBuffer", new Ht());
    U(this, "onBeforeRender", null);
    U(this, "onAfterRender", null);
    this.renderTarget = new ir(256, 256), this.renderTarget.depthBuffer = !0, this.renderTarget.stencilBuffer = !0, this.normalsMaterial = new Ib({}, ["USE_RTE"]), this.normalsMaterial.blending = 0, this.normalsMaterial.side = 2;
  }
  get displayName() {
    return "GEOMETRY-NORMALS";
  }
  get outputTexture() {
    return this.renderTarget.texture;
  }
  setClippingPlanes(e) {
    this.normalsMaterial.clippingPlanes = e;
  }
  update(e, n) {
    this.camera = n, this.scene = e;
  }
  render(e, n, r) {
    this.onBeforeRender(), e.getClearColor(this.colorBuffer);
    const s = e.getClearAlpha(), a = e.autoClear;
    e.setRenderTarget(this.renderTarget), e.autoClear = !1, e.setClearColor(0), e.setClearAlpha(1), e.clear();
    const o = e.shadowMap.enabled, l = e.shadowMap.needsUpdate;
    this.scene.overrideMaterial = this.normalsMaterial, e.shadowMap.enabled = !1, e.shadowMap.needsUpdate = !1, this.applyLayers(this.camera), e.render(this.scene, this.camera), e.shadowMap.enabled = o, e.shadowMap.needsUpdate = l, this.scene.overrideMaterial = null, e.autoClear = a, e.setClearColor(this.colorBuffer), e.setClearAlpha(s), this.onAfterRender();
  }
  setSize(e, n) {
    this.renderTarget.setSize(e, n);
  }
}
const rlt = { defines: { NUM_SAMPLES: 7, NUM_RINGS: 4, NORMAL_TEXTURE: 0, DIFFUSE_TEXTURE: 0, DEPTH_PACKING: 1, PERSPECTIVE_CAMERA: 1 }, uniforms: { tDepth: { value: null }, tDiffuse: { value: null }, tNormal: { value: null }, size: { value: new wt(512, 512) }, cameraNear: { value: 1 }, cameraFar: { value: 100 }, cameraProjectionMatrix: { value: new Vt() }, cameraInverseProjectionMatrix: { value: new Vt() }, scale: { value: 1 }, intensity: { value: 0.1 }, bias: { value: 0.5 }, minResolution: { value: 0 }, kernelRadius: { value: 100 }, randomSeed: { value: 0 } }, vertexShader: `

		varying vec2 vUv;

		void main() {
			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
		}`, fragmentShader: `

		#include <common>

		varying vec2 vUv;

		#if DIFFUSE_TEXTURE == 1
		uniform sampler2D tDiffuse;
		#endif

		uniform sampler2D tDepth;

		#if NORMAL_TEXTURE == 1
		uniform sampler2D tNormal;
		#endif

		uniform float cameraNear;
		uniform float cameraFar;
		uniform mat4 cameraProjectionMatrix;
		uniform mat4 cameraInverseProjectionMatrix;

		uniform float scale;
		uniform float intensity;
		uniform float bias;
		uniform float kernelRadius;
		uniform float minResolution;
		uniform vec2 size;
		uniform float randomSeed;

		// RGBA depth

		#include <packing>

		vec4 getDefaultColor( const in vec2 screenPosition ) {
			#if DIFFUSE_TEXTURE == 1
			return texture2D( tDiffuse, vUv );
			#else
			return vec4( 1.0 );
			#endif
		}

		float getDepth( const in vec2 screenPosition ) {
			#if DEPTH_PACKING == 1
			return unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );
			#else
			return texture2D( tDepth, screenPosition ).x;
			#endif
		}

		float getViewZ( const in float depth ) {
			#if PERSPECTIVE_CAMERA == 1
			return perspectiveDepthToViewZ( depth, cameraNear, cameraFar );
			#else
			return orthographicDepthToViewZ( depth, cameraNear, cameraFar );
			#endif
		}

		vec3 getViewPosition( const in vec2 screenPosition, const in float depth, const in float viewZ ) {
			float clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];
			vec4 clipPosition = vec4( ( vec3( screenPosition, depth ) - 0.5 ) * 2.0, 1.0 );
			clipPosition *= clipW; // unprojection.

			return ( cameraInverseProjectionMatrix * clipPosition ).xyz;
		}

		vec3 getViewNormal( const in vec3 viewPosition, const in vec2 screenPosition ) {
			#if NORMAL_TEXTURE == 1
			return unpackRGBToNormal( texture2D( tNormal, screenPosition ).xyz );
			#else
			return normalize( cross( dFdx( viewPosition ), dFdy( viewPosition ) ) );
			#endif
		}

		float scaleDividedByCameraFar;
		float minResolutionMultipliedByCameraFar;

		float getOcclusion( const in vec3 centerViewPosition, const in vec3 centerViewNormal, const in vec3 sampleViewPosition ) {
			vec3 viewDelta = sampleViewPosition - centerViewPosition;
			float viewDistance = length( viewDelta );
			float scaledScreenDistance = scaleDividedByCameraFar * viewDistance;

			return max(0.0, (dot(centerViewNormal, viewDelta) - minResolutionMultipliedByCameraFar) / scaledScreenDistance - bias) / (1.0 + pow2( scaledScreenDistance ) );
		}

		// moving costly divides into consts
		const float ANGLE_STEP = PI2 * float( NUM_RINGS ) / float( NUM_SAMPLES );
		const float INV_NUM_SAMPLES = 1.0 / float( NUM_SAMPLES );

		float getAmbientOcclusion( const in vec3 centerViewPosition ) {
			// precompute some variables require in getOcclusion.
			scaleDividedByCameraFar = scale / cameraFar;
			minResolutionMultipliedByCameraFar = minResolution * cameraFar;
			vec3 centerViewNormal = getViewNormal( centerViewPosition, vUv );

			// jsfiddle that shows sample pattern: https://jsfiddle.net/a16ff1p7/
			float angle = rand( vUv + randomSeed ) * PI2;
			vec2 radius = vec2( kernelRadius * INV_NUM_SAMPLES ) / size;
			vec2 radiusStep = radius;

			float occlusionSum = 0.0;
			float weightSum = 0.0;

			for( int i = 0; i < NUM_SAMPLES; i ++ ) {
				vec2 sampleUv = vUv + vec2( cos( angle ), sin( angle ) ) * radius;
				radius += radiusStep;
				angle += ANGLE_STEP;

				float sampleDepth = getDepth( sampleUv );
				if( sampleDepth >= ( 1.0 - EPSILON ) ) {
					continue;
				}

				float sampleViewZ = getViewZ( sampleDepth );
				vec3 sampleViewPosition = getViewPosition( sampleUv, sampleDepth, sampleViewZ );
				occlusionSum += getOcclusion( centerViewPosition, centerViewNormal, sampleViewPosition );
				weightSum += 1.0;
			}

			if( weightSum == 0.0 ) discard;

			return occlusionSum * ( intensity / weightSum );
		}

		void main() {
			float centerDepth = getDepth( vUv );
			if( centerDepth >= ( 1.0 - EPSILON ) ) {
				discard;
			}

			float centerViewZ = getViewZ( centerDepth );
			vec3 viewPosition = getViewPosition( vUv, centerDepth, centerViewZ );

			float ambientOcclusion = getAmbientOcclusion( viewPosition );

			gl_FragColor = getDefaultColor( vUv );
			gl_FragColor.xyz *=  1.0 - ambientOcclusion;
		}` }, Jr = { defines: { KERNEL_RADIUS: 4, DEPTH_PACKING: 1, PERSPECTIVE_CAMERA: 1 }, uniforms: { tDiffuse: { value: null }, size: { value: new wt(512, 512) }, sampleUvOffsets: { value: [new wt(0, 0)] }, sampleWeights: { value: [1] }, tDepth: { value: null }, cameraNear: { value: 10 }, cameraFar: { value: 1e3 }, depthCutoff: { value: 10 } }, vertexShader: `

		#include <common>

		uniform vec2 size;

		varying vec2 vUv;
		varying vec2 vInvSize;

		void main() {
			vUv = uv;
			vInvSize = 1.0 / size;

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
		}`, fragmentShader: `

		#include <common>
		#include <packing>

		uniform sampler2D tDiffuse;
		uniform sampler2D tDepth;

		uniform float cameraNear;
		uniform float cameraFar;
		uniform float depthCutoff;

		uniform vec2 sampleUvOffsets[ KERNEL_RADIUS + 1 ];
		uniform float sampleWeights[ KERNEL_RADIUS + 1 ];

		varying vec2 vUv;
		varying vec2 vInvSize;

		float getDepth( const in vec2 screenPosition ) {
			#if DEPTH_PACKING == 1
			return unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );
			#else
			return texture2D( tDepth, screenPosition ).x;
			#endif
		}

		float getViewZ( const in float depth ) {
			#if PERSPECTIVE_CAMERA == 1
			return perspectiveDepthToViewZ( depth, cameraNear, cameraFar );
			#else
			return orthographicDepthToViewZ( depth, cameraNear, cameraFar );
			#endif
		}

		void main() {
			float depth = getDepth( vUv );
			if( depth >= ( 1.0 - EPSILON ) ) {
				discard;
			}

			float centerViewZ = -getViewZ( depth );
			bool rBreak = false, lBreak = false;

			float weightSum = sampleWeights[0];
			vec4 diffuseSum = texture2D( tDiffuse, vUv ) * weightSum;

			for( int i = 1; i <= KERNEL_RADIUS; i ++ ) {

				float sampleWeight = sampleWeights[i];
				vec2 sampleUvOffset = sampleUvOffsets[i] * vInvSize;

				vec2 sampleUv = vUv + sampleUvOffset;
				float viewZ = -getViewZ( getDepth( sampleUv ) );

				if( abs( viewZ - centerViewZ ) > depthCutoff ) rBreak = true;

				if( ! rBreak ) {
					diffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;
					weightSum += sampleWeight;
				}

				sampleUv = vUv - sampleUvOffset;
				viewZ = -getViewZ( getDepth( sampleUv ) );

				if( abs( viewZ - centerViewZ ) > depthCutoff ) lBreak = true;

				if( ! lBreak ) {
					diffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;
					weightSum += sampleWeight;
				}

			}

			gl_FragColor = diffuseSum / weightSum;
		}` }, tu = { createSampleWeights: function(i, t) {
  const e = [];
  for (let n = 0; n <= i; n++)
    e.push(ilt(n, t));
  return e;
}, createSampleOffsets: function(i, t) {
  const e = [];
  for (let n = 0; n <= i; n++)
    e.push(t.clone().multiplyScalar(n));
  return e;
}, configure: function(i, t, e, n) {
  i.defines.KERNEL_RADIUS = t, i.uniforms.sampleUvOffsets.value = tu.createSampleOffsets(t, n), i.uniforms.sampleWeights.value = tu.createSampleWeights(t, e), i.needsUpdate = !0;
} };
function ilt(i, t) {
  return Math.exp(-i * i / (t * t * 2)) / (Math.sqrt(2 * Math.PI) * t);
}
var yv = ((i) => (i[i.DEFAULT = 0] = "DEFAULT", i[i.IMPROVED = 1] = "IMPROVED", i[i.ACCURATE = 2] = "ACCURATE", i))(yv || {}), yh = ((i) => (i[i.RECONSTRUCTED_NORMALS = 0] = "RECONSTRUCTED_NORMALS", i[i.AO = 1] = "AO", i[i.AO_BLURRED = 2] = "AO_BLURRED", i))(yh || {});
const Xz = { intensity: 1.5, scale: 0, kernelRadius: 5, bias: 0.2, normalsType: 2, blurEnabled: !0, blurRadius: 2, blurStdDev: 4, blurDepthCutoff: 7e-3 };
class slt extends Qa {
  constructor() {
    super();
    U(this, "params", Xz);
    U(this, "colorBuffer", new Ht());
    U(this, "saoMaterial", null);
    U(this, "vBlurMaterial", null);
    U(this, "hBlurMaterial", null);
    U(this, "saoRenderTarget", null);
    U(this, "blurIntermediateRenderTarget", null);
    U(this, "fsQuad", null);
    U(this, "_outputType", 2);
    U(this, "outputScale", 0.5);
    U(this, "prevStdDev");
    U(this, "prevNumSamples");
    this.saoRenderTarget = new ir(256, 256), this.blurIntermediateRenderTarget = new ir(256, 256), this.saoMaterial = new Gn({ defines: { NUM_SAMPLES: 7, NUM_RINGS: 4, NORMAL_TEXTURE: 0, DIFFUSE_TEXTURE: 0, DEPTH_PACKING: 1, PERSPECTIVE_CAMERA: 1 }, fragmentShader: `
		#include <common>
		varying vec2 vUv;
		#if DIFFUSE_TEXTURE == 1
		uniform sampler2D tDiffuse;
		#endif
		uniform sampler2D tDepth;
		#if NORMAL_TEXTURE == 1
		uniform sampler2D tNormal;
		#endif
		uniform float cameraNear;
		uniform float cameraFar;
		uniform mat4 cameraProjectionMatrix;
		uniform mat4 cameraInverseProjectionMatrix;
		uniform float scale;
		uniform float intensity;
		uniform float bias;
		uniform float kernelRadius;
		uniform float minResolution;
		uniform vec2 size;
		uniform float randomSeed;
		// RGBA depth
		#include <packing>
		vec4 getDefaultColor( const in vec2 screenPosition ) {
			#if DIFFUSE_TEXTURE == 1
			return texture2D( tDiffuse, vUv );
			#else
			return vec4( 1.0 );
			#endif
		}
		float getDepth( const in vec2 screenPosition ) {
			#if DEPTH_PACKING == 1
			return unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );
			#else
			return texture2D( tDepth, screenPosition ).x;
			#endif
		}
		float getViewZ( const in float depth ) {
			#if PERSPECTIVE_CAMERA == 1
			return perspectiveDepthToViewZ( depth, cameraNear, cameraFar );
			#else
			return orthographicDepthToViewZ( depth, cameraNear, cameraFar );
			#endif
		}
		vec3 getViewPosition( const in vec2 screenPosition, const in float depth, const in float viewZ ) {
			float clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];
			vec4 clipPosition = vec4( ( vec3( screenPosition, depth ) - 0.5 ) * 2.0, 1.0 );
			clipPosition *= clipW; // unprojection.
			return ( cameraInverseProjectionMatrix * clipPosition ).xyz;
		}

		//https://wickedengine.net/2019/09/22/improved-normal-reconstruction-from-depth/
		vec3 viewNormalImproved(in vec2 uv, in vec3 origin)
		{	
			highp vec2 dd = abs(vec2(1./size.x, 1./size.y));
			highp vec2 ddx = vec2(dd.x, 0.);
			highp vec2 ddy = vec2(0., dd.y);

			float sampleDepth = getDepth( uv - ddy );
			float sampleViewZ = getViewZ( sampleDepth );
			highp vec3 top = getViewPosition( uv - ddy, sampleDepth, sampleViewZ );

			sampleDepth = getDepth( uv + ddy );
			sampleViewZ = getViewZ( sampleDepth );
			highp vec3 bottom = getViewPosition( uv + ddy, sampleDepth, sampleViewZ );

			highp vec3 center = origin;
			
			sampleDepth = getDepth( uv - ddx );
			sampleViewZ = getViewZ( sampleDepth );
			highp vec3 left = getViewPosition( uv - ddx, sampleDepth, sampleViewZ );

			sampleDepth = getDepth( uv + ddx );
			sampleViewZ = getViewZ( sampleDepth );
			highp vec3 right = getViewPosition( uv + ddx, sampleDepth, sampleViewZ );

			 // get the difference between the current and each offset position
			vec3 l = center - left;
			vec3 r = right - center;
			vec3 d = center - top;
			vec3 u = bottom - center;

			// pick horizontal and vertical diff with the smallest z difference
			vec3 hDeriv = abs(l.z) < abs(r.z) ? l : r;
			vec3 vDeriv = abs(d.z) < abs(u.z) ? d : u;

			// get view space normal from the cross product of the two smallest offsets
			vec3 viewNormal = normalize(cross(hDeriv, vDeriv));

			return viewNormal;
		}

		vec3 viewNormalAccurate(in vec2 uv, in vec3 origin, in float centerDepth) {
			highp vec2 dd = abs(vec2(1./size.x, 1./size.y));
			highp vec2 ddx = vec2(dd.x, 0.);
			highp vec2 ddy = vec2(0., dd.y);

			float sampleDepth = getDepth( uv - ddy );
			float sampleViewZ = getViewZ( sampleDepth );
			highp vec3 top = getViewPosition( uv - ddy, sampleDepth, sampleViewZ );

			sampleDepth = getDepth( uv + ddy );
			sampleViewZ = getViewZ( sampleDepth );
			highp vec3 bottom = getViewPosition( uv + ddy, sampleDepth, sampleViewZ );

			highp vec3 center = origin;
			
			sampleDepth = getDepth( uv - ddx );
			sampleViewZ = getViewZ( sampleDepth );
			highp vec3 left = getViewPosition( uv - ddx, sampleDepth, sampleViewZ );

			sampleDepth = getDepth( uv + ddx );
			sampleViewZ = getViewZ( sampleDepth );
			highp vec3 right = getViewPosition( uv + ddx, sampleDepth, sampleViewZ );

			 // get the difference between the current and each offset position
			vec3 l = center - left;
			vec3 r = right - center;
			vec3 d = center - top;
			vec3 u = bottom - center;

			// get depth values at 1 & 2 pixels offsets from current along the horizontal axis
			vec4 H = vec4(
				getDepth(uv - ddx),
				getDepth(uv + ddx),
				getDepth(uv - 2. * ddx),
				getDepth(uv + 2. * ddx)
			);

			// get depth values at 1 & 2 pixels offsets from current along the vertical axis
			vec4 V = vec4(
				getDepth(uv - ddy),
				getDepth(uv + ddy),
				getDepth(uv - 2. * ddy),
				getDepth(uv + 2. * ddy)
			);

			// current pixel's depth difference from slope of offset depth samples
			// differs from original article because we're using non-linear depth values
			// see article's comments
			vec2 he = abs((2. * H.xy - H.zw) - centerDepth);
			vec2 ve = abs((2. * V.xy - V.zw) - centerDepth);

			// pick horizontal and vertical diff with the smallest depth difference from slopes
			vec3 hDeriv = he.x < he.y ? l : r;
			vec3 vDeriv = ve.x < ve.y ? d : u;

			// get view space normal from the cross product of the best derivatives
			vec3 viewNormal = normalize(cross(hDeriv, vDeriv));

			return viewNormal;

		}

		vec3 getViewNormal( const in vec3 viewPosition, const in vec2 screenPosition, in float centerDepth ) {
			#if NORMAL_TEXTURE == 1
				return unpackRGBToNormal( texture2D( tNormal, screenPosition ).xyz );
			#elif IMPROVED_NORMAL_RECONSTRUCTION == 1
				return viewNormalImproved(screenPosition, viewPosition);
			#elif ACCURATE_NORMAL_RECONSTRUCTION == 1
				return viewNormalAccurate(screenPosition, viewPosition, centerDepth);
			#else
				return normalize( cross( dFdx( viewPosition ), dFdy( viewPosition ) ) );
			#endif
		}

		float scaleDividedByCameraFar;
		float minResolutionMultipliedByCameraFar;
		float getOcclusion( const in vec3 centerViewPosition, const in vec3 centerViewNormal, const in vec3 sampleViewPosition ) {
			vec3 viewDelta = sampleViewPosition - centerViewPosition;
			float viewDistance = length( viewDelta );
			float scaledScreenDistance = scaleDividedByCameraFar * viewDistance;
			return max(0.0, (dot(centerViewNormal, viewDelta) - minResolutionMultipliedByCameraFar) / scaledScreenDistance - bias) / (1.0 + pow2( scaledScreenDistance ) );
		}
		// moving costly divides into consts
		const float ANGLE_STEP = PI2 * float( NUM_RINGS ) / float( NUM_SAMPLES );
		const float INV_NUM_SAMPLES = 1.0 / float( NUM_SAMPLES );
		float getAmbientOcclusion( const in vec3 centerViewPosition, in float centerDepth ) {
			// precompute some variables require in getOcclusion.
			scaleDividedByCameraFar = scale / cameraFar;
			minResolutionMultipliedByCameraFar = minResolution * cameraFar;
			vec3 centerViewNormal = getViewNormal( centerViewPosition, vUv, centerDepth );
			// jsfiddle that shows sample pattern: https://jsfiddle.net/a16ff1p7/
			float angle = rand( vUv + randomSeed ) * PI2;
			vec2 radius = vec2( kernelRadius * INV_NUM_SAMPLES ) / size;
			vec2 radiusStep = radius;
			float occlusionSum = 0.0;
			float weightSum = 0.0;
			for( int i = 0; i < NUM_SAMPLES; i ++ ) {
				vec2 sampleUv = vUv + vec2( cos( angle ), sin( angle ) ) * radius;
				radius += radiusStep;
				angle += ANGLE_STEP;
				float sampleDepth = getDepth( sampleUv );
				if( sampleDepth >= ( 1.0 - EPSILON ) ) {
					continue;
				}
				float sampleViewZ = getViewZ( sampleDepth );
				vec3 sampleViewPosition = getViewPosition( sampleUv, sampleDepth, sampleViewZ );
				occlusionSum += getOcclusion( centerViewPosition, centerViewNormal, sampleViewPosition );
				weightSum += 1.0;
			}
			if( weightSum == 0.0 ) discard;
			return occlusionSum * ( intensity / weightSum );
		}
		void main() {
			float centerDepth = getDepth( vUv );
			if( centerDepth >= ( 1.0 - EPSILON ) ) {
				discard;
			}
			float centerViewZ = getViewZ( centerDepth );
			vec3 viewPosition = getViewPosition( vUv, centerDepth, centerViewZ );

			#ifdef OUTPUT_RECONSTRUCTED_NORMALS
				vec3 normal;
				#if IMPROVED_NORMAL_RECONSTRUCTION == 1
					normal = viewNormalImproved(vUv, viewPosition);
				#elif ACCURATE_NORMAL_RECONSTRUCTION == 1
					normal = viewNormalAccurate(vUv, viewPosition, centerDepth);
				#else
					normal = normalize( cross( dFdx( viewPosition ), dFdy( viewPosition ) ) );
				#endif
				gl_FragColor.rgb = packNormalToRGB(normal);
				gl_FragColor.a = 1.;
				return;
			#endif
			
			float ambientOcclusion = getAmbientOcclusion( viewPosition, centerDepth );
			gl_FragColor = getDefaultColor( vUv );
			gl_FragColor.xyz *=  1. - ambientOcclusion;
		}`, vertexShader: `
		varying vec2 vUv;
		void main() {
			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
		}`, uniforms: Jn.clone(rlt.uniforms) }), this.saoMaterial.extensions.derivatives = !0, this.saoMaterial.defines.DEPTH_PACKING = 1, this.saoMaterial.uniforms.tDepth.value = null, this.saoMaterial.uniforms.tNormal.value = null, this.saoMaterial.uniforms.size.value.set(256, 256), this.saoMaterial.uniforms.minResolution.value = 0, this.saoMaterial.blending = 0, this.vBlurMaterial = new Gn({ uniforms: Jn.clone(Jr.uniforms), defines: Object.assign({}, Jr.defines), vertexShader: Jr.vertexShader, fragmentShader: Jr.fragmentShader }), this.vBlurMaterial.defines.DEPTH_PACKING = 1, this.vBlurMaterial.uniforms.tDiffuse.value = this.saoRenderTarget.texture, this.vBlurMaterial.uniforms.tDepth.value = null, this.vBlurMaterial.uniforms.size.value.set(256, 256), this.vBlurMaterial.blending = 0, this.hBlurMaterial = new Gn({ uniforms: Jn.clone(Jr.uniforms), defines: Object.assign({}, Jr.defines), vertexShader: Jr.vertexShader, fragmentShader: Jr.fragmentShader }), this.hBlurMaterial.defines.DEPTH_PACKING = 1, this.hBlurMaterial.uniforms.tDiffuse.value = this.blurIntermediateRenderTarget.texture, this.hBlurMaterial.uniforms.tDepth.value = null, this.hBlurMaterial.uniforms.size.value.set(256, 256), this.hBlurMaterial.blending = 0, this.fsQuad = new oc(this.saoMaterial);
  }
  get displayName() {
    return "SAO";
  }
  get outputTexture() {
    return this.saoRenderTarget.texture;
  }
  setParams(e) {
    Object.assign(this.params, e);
  }
  setOutputType(e) {
    this._outputType = e;
  }
  setTexture(e, n) {
    e === "tDepth" && (this.saoMaterial.uniforms.tDepth.value = n, this.vBlurMaterial.uniforms.tDepth.value = n, this.hBlurMaterial.uniforms.tDepth.value = n), e === "tNormal" && (this.saoMaterial.uniforms.tNormal.value = n), this.saoMaterial.needsUpdate = !0, this.vBlurMaterial.needsUpdate = !0, this.hBlurMaterial.needsUpdate = !0;
  }
  update(e, n) {
    this._outputType === 0 ? this.saoMaterial.defines.OUTPUT_RECONSTRUCTED_NORMALS = "" : delete this.saoMaterial.defines.OUTPUT_RECONSTRUCTED_NORMALS, this.params.scale = n.far, this.saoMaterial.defines.PERSPECTIVE_CAMERA = n.isPerspectiveCamera ? 1 : 0, this.saoMaterial.defines.NORMAL_TEXTURE = this.params.normalsType === 0 ? 1 : 0, this.saoMaterial.defines.IMPROVED_NORMAL_RECONSTRUCTION = this.params.normalsType === 1 ? 1 : 0, this.saoMaterial.defines.ACCURATE_NORMAL_RECONSTRUCTION = this.params.normalsType === 2 ? 1 : 0, this.saoMaterial.uniforms.cameraNear.value = n.near, this.saoMaterial.uniforms.cameraFar.value = n.far, this.saoMaterial.uniforms.cameraInverseProjectionMatrix.value.copy(n.projectionMatrixInverse), this.saoMaterial.uniforms.cameraProjectionMatrix.value = n.projectionMatrix, this.saoMaterial.uniforms.intensity.value = this.params.intensity, this.saoMaterial.uniforms.scale.value = this.params.scale, this.saoMaterial.uniforms.kernelRadius.value = this.params.kernelRadius, this.saoMaterial.uniforms.bias.value = this.params.bias, this.saoMaterial.needsUpdate = !0, this.vBlurMaterial.defines.PERSPECTIVE_CAMERA = n.isPerspectiveCamera ? 1 : 0, this.hBlurMaterial.defines.PERSPECTIVE_CAMERA = n.isPerspectiveCamera ? 1 : 0, this.vBlurMaterial.uniforms.cameraNear.value = n.near, this.vBlurMaterial.uniforms.cameraFar.value = n.far, this.hBlurMaterial.uniforms.cameraNear.value = n.near, this.hBlurMaterial.uniforms.cameraFar.value = n.far;
    const r = this.params.blurDepthCutoff * (n.far - n.near);
    this.vBlurMaterial.uniforms.depthCutoff.value = r, this.hBlurMaterial.uniforms.depthCutoff.value = r, this.params.blurRadius = Math.floor(this.params.blurRadius), this.prevStdDev === this.params.blurStdDev && this.prevNumSamples === this.params.blurRadius || (tu.configure(this.vBlurMaterial, this.params.blurRadius, this.params.blurStdDev, new wt(0, 1)), tu.configure(this.hBlurMaterial, this.params.blurRadius, this.params.blurStdDev, new wt(1, 0)), this.prevStdDev = this.params.blurStdDev, this.prevNumSamples = this.params.blurRadius), this.vBlurMaterial.needsUpdate = !0, this.hBlurMaterial.needsUpdate = !0;
  }
  render(e) {
    e.getClearColor(this.colorBuffer);
    const n = e.getClearAlpha(), r = e.autoClear;
    e.setRenderTarget(this.saoRenderTarget), e.autoClear = !1, e.setClearColor(16777215), e.setClearAlpha(1), e.clear(), this.fsQuad.material = this.saoMaterial, this.fsQuad.render(e), this.params.blurEnabled && this._outputType === 2 && (e.setRenderTarget(this.blurIntermediateRenderTarget), e.setClearColor(16777215), e.setClearAlpha(1), e.clear(), this.fsQuad.material = this.vBlurMaterial, this.fsQuad.render(e), e.setRenderTarget(this.saoRenderTarget), this.fsQuad.material = this.hBlurMaterial, this.fsQuad.render(e)), e.autoClear = r, e.setClearColor(this.colorBuffer), e.setClearAlpha(n);
  }
  setSize(e, n) {
    const r = e * this.outputScale, s = n * this.outputScale;
    this.saoRenderTarget.setSize(r, s), this.blurIntermediateRenderTarget.setSize(r, s), this.saoMaterial.uniforms.size.value.set(r, s), this.vBlurMaterial.uniforms.size.value.set(r, s), this.hBlurMaterial.uniforms.size.value.set(r, s), this.saoMaterial.needsUpdate = !0;
  }
}
class sI {
  constructor(t = Math) {
    this.grad3 = [[1, 1, 0], [-1, 1, 0], [1, -1, 0], [-1, -1, 0], [1, 0, 1], [-1, 0, 1], [1, 0, -1], [-1, 0, -1], [0, 1, 1], [0, -1, 1], [0, 1, -1], [0, -1, -1]], this.grad4 = [[0, 1, 1, 1], [0, 1, 1, -1], [0, 1, -1, 1], [0, 1, -1, -1], [0, -1, 1, 1], [0, -1, 1, -1], [0, -1, -1, 1], [0, -1, -1, -1], [1, 0, 1, 1], [1, 0, 1, -1], [1, 0, -1, 1], [1, 0, -1, -1], [-1, 0, 1, 1], [-1, 0, 1, -1], [-1, 0, -1, 1], [-1, 0, -1, -1], [1, 1, 0, 1], [1, 1, 0, -1], [1, -1, 0, 1], [1, -1, 0, -1], [-1, 1, 0, 1], [-1, 1, 0, -1], [-1, -1, 0, 1], [-1, -1, 0, -1], [1, 1, 1, 0], [1, 1, -1, 0], [1, -1, 1, 0], [1, -1, -1, 0], [-1, 1, 1, 0], [-1, 1, -1, 0], [-1, -1, 1, 0], [-1, -1, -1, 0]], this.p = [];
    for (let e = 0; e < 256; e++)
      this.p[e] = Math.floor(256 * t.random());
    this.perm = [];
    for (let e = 0; e < 512; e++)
      this.perm[e] = this.p[255 & e];
    this.simplex = [[0, 1, 2, 3], [0, 1, 3, 2], [0, 0, 0, 0], [0, 2, 3, 1], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [1, 2, 3, 0], [0, 2, 1, 3], [0, 0, 0, 0], [0, 3, 1, 2], [0, 3, 2, 1], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [1, 3, 2, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [1, 2, 0, 3], [0, 0, 0, 0], [1, 3, 0, 2], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [2, 3, 0, 1], [2, 3, 1, 0], [1, 0, 2, 3], [1, 0, 3, 2], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [2, 0, 3, 1], [0, 0, 0, 0], [2, 1, 3, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [2, 0, 1, 3], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [3, 0, 1, 2], [3, 0, 2, 1], [0, 0, 0, 0], [3, 1, 2, 0], [2, 1, 0, 3], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [3, 1, 0, 2], [0, 0, 0, 0], [3, 2, 0, 1], [3, 2, 1, 0]];
  }
  dot(t, e, n) {
    return t[0] * e + t[1] * n;
  }
  dot3(t, e, n, r) {
    return t[0] * e + t[1] * n + t[2] * r;
  }
  dot4(t, e, n, r, s) {
    return t[0] * e + t[1] * n + t[2] * r + t[3] * s;
  }
  noise(t, e) {
    let n, r, s;
    const a = (t + e) * (0.5 * (Math.sqrt(3) - 1)), o = Math.floor(t + a), l = Math.floor(e + a), c = (3 - Math.sqrt(3)) / 6, u = (o + l) * c, h = t - (o - u), p = e - (l - u);
    let f, v;
    h > p ? (f = 1, v = 0) : (f = 0, v = 1);
    const m = h - f + c, y = p - v + c, _ = h - 1 + 2 * c, w = p - 1 + 2 * c, b = 255 & o, T = 255 & l, M = this.perm[b + this.perm[T]] % 12, A = this.perm[b + f + this.perm[T + v]] % 12, C = this.perm[b + 1 + this.perm[T + 1]] % 12;
    let I = 0.5 - h * h - p * p;
    I < 0 ? n = 0 : (I *= I, n = I * I * this.dot(this.grad3[M], h, p));
    let k = 0.5 - m * m - y * y;
    k < 0 ? r = 0 : (k *= k, r = k * k * this.dot(this.grad3[A], m, y));
    let R = 0.5 - _ * _ - w * w;
    return R < 0 ? s = 0 : (R *= R, s = R * R * this.dot(this.grad3[C], _, w)), 70 * (n + r + s);
  }
  noise3d(t, e, n) {
    let r, s, a, o;
    const l = (t + e + n) * 0.3333333333333333, c = Math.floor(t + l), u = Math.floor(e + l), h = Math.floor(n + l), p = 1 / 6, f = (c + u + h) * p, v = t - (c - f), m = e - (u - f), y = n - (h - f);
    let _, w, b, T, M, A;
    v >= m ? m >= y ? (_ = 1, w = 0, b = 0, T = 1, M = 1, A = 0) : v >= y ? (_ = 1, w = 0, b = 0, T = 1, M = 0, A = 1) : (_ = 0, w = 0, b = 1, T = 1, M = 0, A = 1) : m < y ? (_ = 0, w = 0, b = 1, T = 0, M = 1, A = 1) : v < y ? (_ = 0, w = 1, b = 0, T = 0, M = 1, A = 1) : (_ = 0, w = 1, b = 0, T = 1, M = 1, A = 0);
    const C = v - _ + p, I = m - w + p, k = y - b + p, R = v - T + 2 * p, L = m - M + 2 * p, E = y - A + 2 * p, q = v - 1 + 0.5, it = m - 1 + 0.5, rt = y - 1 + 0.5, ft = 255 & c, nt = 255 & u, vt = 255 & h, $ = this.perm[ft + this.perm[nt + this.perm[vt]]] % 12, W = this.perm[ft + _ + this.perm[nt + w + this.perm[vt + b]]] % 12, ct = this.perm[ft + T + this.perm[nt + M + this.perm[vt + A]]] % 12, mt = this.perm[ft + 1 + this.perm[nt + 1 + this.perm[vt + 1]]] % 12;
    let dt = 0.6 - v * v - m * m - y * y;
    dt < 0 ? r = 0 : (dt *= dt, r = dt * dt * this.dot3(this.grad3[$], v, m, y));
    let Mt = 0.6 - C * C - I * I - k * k;
    Mt < 0 ? s = 0 : (Mt *= Mt, s = Mt * Mt * this.dot3(this.grad3[W], C, I, k));
    let At = 0.6 - R * R - L * L - E * E;
    At < 0 ? a = 0 : (At *= At, a = At * At * this.dot3(this.grad3[ct], R, L, E));
    let H = 0.6 - q * q - it * it - rt * rt;
    return H < 0 ? o = 0 : (H *= H, o = H * H * this.dot3(this.grad3[mt], q, it, rt)), 32 * (r + s + a + o);
  }
  noise4d(t, e, n, r) {
    const s = this.grad4, a = this.simplex, o = this.perm, l = (Math.sqrt(5) - 1) / 4, c = (5 - Math.sqrt(5)) / 20;
    let u, h, p, f, v;
    const m = (t + e + n + r) * l, y = Math.floor(t + m), _ = Math.floor(e + m), w = Math.floor(n + m), b = Math.floor(r + m), T = (y + _ + w + b) * c, M = t - (y - T), A = e - (_ - T), C = n - (w - T), I = r - (b - T), k = (M > A ? 32 : 0) + (M > C ? 16 : 0) + (A > C ? 8 : 0) + (M > I ? 4 : 0) + (A > I ? 2 : 0) + (C > I ? 1 : 0), R = a[k][0] >= 3 ? 1 : 0, L = a[k][1] >= 3 ? 1 : 0, E = a[k][2] >= 3 ? 1 : 0, q = a[k][3] >= 3 ? 1 : 0, it = a[k][0] >= 2 ? 1 : 0, rt = a[k][1] >= 2 ? 1 : 0, ft = a[k][2] >= 2 ? 1 : 0, nt = a[k][3] >= 2 ? 1 : 0, vt = a[k][0] >= 1 ? 1 : 0, $ = a[k][1] >= 1 ? 1 : 0, W = a[k][2] >= 1 ? 1 : 0, ct = a[k][3] >= 1 ? 1 : 0, mt = M - R + c, dt = A - L + c, Mt = C - E + c, At = I - q + c, H = M - it + 2 * c, N = A - rt + 2 * c, st = C - ft + 2 * c, et = I - nt + 2 * c, J = M - vt + 3 * c, K = A - $ + 3 * c, S = C - W + 3 * c, Z = I - ct + 3 * c, G = M - 1 + 4 * c, F = A - 1 + 4 * c, z = C - 1 + 4 * c, Y = I - 1 + 4 * c, pt = 255 & y, ht = 255 & _, lt = 255 & w, yt = 255 & b, O = o[pt + o[ht + o[lt + o[yt]]]] % 32, V = o[pt + R + o[ht + L + o[lt + E + o[yt + q]]]] % 32, tt = o[pt + it + o[ht + rt + o[lt + ft + o[yt + nt]]]] % 32, gt = o[pt + vt + o[ht + $ + o[lt + W + o[yt + ct]]]] % 32, Tt = o[pt + 1 + o[ht + 1 + o[lt + 1 + o[yt + 1]]]] % 32;
    let ot = 0.6 - M * M - A * A - C * C - I * I;
    ot < 0 ? u = 0 : (ot *= ot, u = ot * ot * this.dot4(s[O], M, A, C, I));
    let St = 0.6 - mt * mt - dt * dt - Mt * Mt - At * At;
    St < 0 ? h = 0 : (St *= St, h = St * St * this.dot4(s[V], mt, dt, Mt, At));
    let It = 0.6 - H * H - N * N - st * st - et * et;
    It < 0 ? p = 0 : (It *= It, p = It * It * this.dot4(s[tt], H, N, st, et));
    let xt = 0.6 - J * J - K * K - S * S - Z * Z;
    xt < 0 ? f = 0 : (xt *= xt, f = xt * xt * this.dot4(s[gt], J, K, S, Z));
    let Ft = 0.6 - G * G - F * F - z * z - Y * Y;
    return Ft < 0 ? v = 0 : (Ft *= Ft, v = Ft * Ft * this.dot4(s[Tt], G, F, z, Y)), 27 * (u + h + p + f + v);
  }
}
const Yz = { intensity: 1, kernelRadius: 30, kernelSize: 16, bias: 0.01, minDistance: 0, maxDistance: 8e-3 };
class alt extends Qa {
  constructor() {
    super();
    U(this, "aoMaterial", null);
    U(this, "accumulateMaterial", null);
    U(this, "_generationBuffer");
    U(this, "_accumulationBuffer");
    U(this, "params", Yz);
    U(this, "fsQuad");
    U(this, "frameIndex", 0);
    U(this, "kernels", []);
    U(this, "noiseTextures", []);
    this._generationBuffer = new ir(256, 256), this._accumulationBuffer = new ir(256, 256), this.aoMaterial = new Gn({ fragmentShader: `
		#include <common>
		varying vec2 vUv;
		uniform sampler2D tDepth;
		uniform sampler2D tNormal;
        uniform vec2 size;

		uniform float cameraNear;
		uniform float cameraFar;
		uniform mat4 cameraProjectionMatrix;
		uniform mat4 cameraInverseProjectionMatrix;

		uniform float scale;
		uniform float intensity;
		uniform float bias;
		uniform float kernelRadius;
		uniform float minResolution;
        uniform float frameIndex;
		uniform float tanFov;

		#define AO_ESTIMATOR 1
		// #define KERNEL_SIZE 16
		uniform sampler2D tNoise;
		uniform vec3 kernel[ KERNEL_SIZE ];
		uniform float minDistance;
		uniform float maxDistance;

        #define NUM_SAMPLES 16
        #define SPIRAL_TURNS 2
		
        // #define NUM_FRAMES 16

		#define NORMAL_TEXTURE 0
		#define IMPROVED_NORMAL_RECONSTRUCTION 0
		#define ACCURATE_NORMAL_RECONSTRUCTION 1
		
		// RGBA depth
		#include <packing>
		vec4 getDefaultColor( const in vec2 screenPosition ) {
			return vec4( 1.0 );
		}


		float getLinearDepth( const in vec2 screenPosition ) {
			return unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );
		}

		float getPerspectiveDepth(const in vec2 coords) {
			float linearDepth = unpackRGBAToDepth( texture2D( tDepth, coords ) );
			#if PERSPECTIVE_CAMERA == 1
				float viewZ = orthographicDepthToViewZ(linearDepth, cameraNear, cameraFar);
				float centerDepth = viewZToPerspectiveDepth(viewZ, cameraNear, cameraFar);
				return centerDepth;
			#else
				return linearDepth;
			#endif
		}

		float getViewDepth(const in float linearDepth) {
			return orthographicDepthToViewZ(linearDepth, cameraNear, cameraFar);
		}

		float getViewZ( const in float depth ) {
			#if PERSPECTIVE_CAMERA == 1
			return perspectiveDepthToViewZ( depth, cameraNear, cameraFar );
			#else
			return orthographicDepthToViewZ( depth, cameraNear, cameraFar );
			#endif
		}

		vec3 getViewPosition( const in vec2 screenPosition, const in float depth, const in float viewZ ) {
			float clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];
			vec4 clipPosition = vec4( ( vec3( screenPosition, depth ) - 0.5 ) * 2.0, 1.0 );
			clipPosition *= clipW; // unprojection.
			return ( cameraInverseProjectionMatrix * clipPosition ).xyz;
		}

		//https://wickedengine.net/2019/09/22/improved-normal-reconstruction-from-depth/
		vec3 viewNormalImproved(in vec2 uv, in vec3 origin)
		{	
			highp vec2 dd = abs(vec2(1./size.x, 1./size.y));
			highp vec2 ddx = vec2(dd.x, 0.);
			highp vec2 ddy = vec2(0., dd.y);

			float sampleDepth = getPerspectiveDepth( uv - ddy );
			float sampleViewZ = getViewZ( sampleDepth );
			highp vec3 top = getViewPosition( uv - ddy, sampleDepth, sampleViewZ );

			sampleDepth = getPerspectiveDepth( uv + ddy );
			sampleViewZ = getViewZ( sampleDepth );
			highp vec3 bottom = getViewPosition( uv + ddy, sampleDepth, sampleViewZ );

			highp vec3 center = origin;
			
			sampleDepth = getPerspectiveDepth( uv - ddx );
			sampleViewZ = getViewZ( sampleDepth );
			highp vec3 left = getViewPosition( uv - ddx, sampleDepth, sampleViewZ );

			sampleDepth = getPerspectiveDepth( uv + ddx );
			sampleViewZ = getViewZ( sampleDepth );
			highp vec3 right = getViewPosition( uv + ddx, sampleDepth, sampleViewZ );

			 // get the difference between the current and each offset position
			vec3 l = center - left;
			vec3 r = right - center;
			vec3 d = center - top;
			vec3 u = bottom - center;

			// pick horizontal and vertical diff with the smallest z difference
			vec3 hDeriv = abs(l.z) < abs(r.z) ? l : r;
			vec3 vDeriv = abs(d.z) < abs(u.z) ? d : u;

			// get view space normal from the cross product of the two smallest offsets
			vec3 viewNormal = normalize(cross(hDeriv, vDeriv));

			return viewNormal;
		}

		vec3 viewNormalAccurate(in vec2 uv, in vec3 origin, in float centerDepth) {
			highp vec2 dd = abs(vec2(1./size.x, 1./size.y));
			highp vec2 ddx = vec2(dd.x, 0.);
			highp vec2 ddy = vec2(0., dd.y);

			float sampleDepth = getPerspectiveDepth( uv - ddy );
			float sampleViewZ = getViewZ( sampleDepth );
			highp vec3 top = getViewPosition( uv - ddy, sampleDepth, sampleViewZ );

			sampleDepth = getPerspectiveDepth( uv + ddy );
			sampleViewZ = getViewZ( sampleDepth );
			highp vec3 bottom = getViewPosition( uv + ddy, sampleDepth, sampleViewZ );

			highp vec3 center = origin;
			
			sampleDepth = getPerspectiveDepth( uv - ddx );
			sampleViewZ = getViewZ( sampleDepth );
			highp vec3 left = getViewPosition( uv - ddx, sampleDepth, sampleViewZ );

			sampleDepth = getPerspectiveDepth( uv + ddx );
			sampleViewZ = getViewZ( sampleDepth );
			highp vec3 right = getViewPosition( uv + ddx, sampleDepth, sampleViewZ );

			 // get the difference between the current and each offset position
			vec3 l = center - left;
			vec3 r = right - center;
			vec3 d = center - top;
			vec3 u = bottom - center;

			// get depth values at 1 & 2 pixels offsets from current along the horizontal axis
			vec4 H = vec4(
				getLinearDepth(uv - ddx),
				getLinearDepth(uv + ddx),
				getLinearDepth(uv - 2. * ddx),
				getLinearDepth(uv + 2. * ddx)
			);

			// get depth values at 1 & 2 pixels offsets from current along the vertical axis
			vec4 V = vec4(
				getLinearDepth(uv - ddy),
				getLinearDepth(uv + ddy),
				getLinearDepth(uv - 2. * ddy),
				getLinearDepth(uv + 2. * ddy)
			);

			// current pixel's depth difference from slope of offset depth samples
			// differs from original article because we're using non-linear depth values
			// see article's comments
			vec2 he = abs((2. * H.xy - H.zw) - centerDepth);
			vec2 ve = abs((2. * V.xy - V.zw) - centerDepth);

			// pick horizontal and vertical diff with the smallest depth difference from slopes
			vec3 hDeriv = he.x < he.y ? l : r;
			vec3 vDeriv = ve.x < ve.y ? d : u;

			// get view space normal from the cross product of the best derivatives
			vec3 viewNormal = normalize(cross(hDeriv, vDeriv));

			return viewNormal;

		}

		vec3 getViewNormal( const in vec3 viewPosition, const in vec2 screenPosition, in float centerDepth ) {
			#if NORMAL_TEXTURE == 1
				return unpackRGBToNormal( texture2D( tNormal, screenPosition ).xyz );
			#elif IMPROVED_NORMAL_RECONSTRUCTION == 1
				return viewNormalImproved(screenPosition, viewPosition);
			#elif ACCURATE_NORMAL_RECONSTRUCTION == 1
				return viewNormalAccurate(screenPosition, viewPosition, centerDepth);
			#else
				return normalize( cross( dFdx( viewPosition ), dFdy( viewPosition ) ) );
			#endif
		}


		float scaleDividedByCameraFar;
		float minResolutionMultipliedByCameraFar;
        // moving costly divides into consts
		const float INV_NUM_SAMPLES = 1.0 / float( NUM_SAMPLES );
        const float offset = PI2 / float(NUM_FRAMES);

		float computeKernelSize(float d, float r) {
			#if PERSPECTIVE_CAMERA == 1
				// Apparently this is wrong
				// return (r * tan(fov) * d) / (size.y * 0.5);
				// And this is correct
				float rp = r / (size.y * 0.5);
				return sqrt((rp*rp*tanFov*tanFov*d*d)/(1. + rp*rp*tanFov*tanFov));
			#else
				float twoOrthoSize = size.y / (2./ cameraProjectionMatrix[1][1]);
				return r / twoOrthoSize;
			#endif
		}

		float getAmbientOcclusion( const in vec3 centerViewPosition, in float centerDepth ) {
            #if AO_ESTIMATOR == 0
                // precompute some variables require in getOcclusion.
                scaleDividedByCameraFar = scale / cameraFar;
                minResolutionMultipliedByCameraFar = minResolution * cameraFar;
                vec3 centerViewNormal = getViewNormal( centerViewPosition, vUv, centerDepth );
                // jsfiddle that shows sample pattern: https://jsfiddle.net/TenHands/jun67k9y/7/
                float occlusionSum = 0.0;
                float weightSum = 0.0;
                for( int i = 0; i < NUM_SAMPLES; i ++ ) {
                    float alpha = ( float(i) + 1. ) / float(NUM_SAMPLES);
                    float angle = float(SPIRAL_TURNS)  * alpha;
                    vec2 radius = (kernelRadius / size) * pow( alpha, 1.1 );
                    vec2 sampleUv = vUv + vec2( cos( angle + frameIndex * offset ), sin( angle + frameIndex * offset ) ) * radius;

                    float sampleDepth = getPerspectiveDepth( sampleUv );
                    if( sampleDepth >= ( 1.0 - EPSILON ) ) {
                        continue;
                    }
                    float sampleViewZ = getViewZ( sampleDepth );
                    vec3 sampleViewPosition = getViewPosition( sampleUv, sampleDepth, sampleViewZ );

					/** McGuire Estimator*/
					vec3 v = sampleViewPosition - centerViewPosition;
					float vv = dot(v, v);
					float vn = dot(v, centerViewNormal) - bias;
					
					// Note large epsilon to avoid overdarkening within cracks
					float radius2 = 2.;//uSampleRadiusWS * uSampleRadiusWS
					float epsilon = 0.01;
					
					float f = max(radius2 - vv, 0.0) / radius2;
					occlusionSum += f * f * f * max(vn / (epsilon + vv), 0.0) / 4.;

					/** Three.js SAO Estimator*/
                    // vec3 viewDelta = sampleViewPosition - centerViewPosition;
                    // float viewDistance = length( viewDelta );
                    // float scaledScreenDistance = scaleDividedByCameraFar * viewDistance;
                    // occlusionSum += max(0.0, (dot(centerViewNormal, viewDelta) - minResolutionMultipliedByCameraFar) / scaledScreenDistance - bias) / (1.0 + pow2( scaledScreenDistance ) );
                    weightSum += 1.0;
                }
                if( weightSum == 0.0 ) discard;
                return occlusionSum * ( intensity / weightSum );
			#elif AO_ESTIMATOR == 1
				vec3 viewPosition = centerViewPosition;
				vec3 viewNormal = getViewNormal( centerViewPosition, vUv, centerDepth );
				vec2 noiseScale = vec2( size.x / 4.0, size.y / 4.0 );
				vec3 random = vec3( texture2D( tNoise, vUv * noiseScale ).r );
				// compute matrix used to reorient a kernel vector
				vec3 tangent = normalize( random - viewNormal * dot( random, viewNormal ) );
				vec3 bitangent = cross( viewNormal, tangent );
				mat3 kernelMatrix = mat3( tangent, bitangent, viewNormal );
				float occlusion = 0.0;
				float kernelSize_ws = computeKernelSize(-viewPosition.z, kernelRadius);
				float div = float( KERNEL_SIZE);
				float maxDist = kernelSize_ws / (cameraFar - cameraNear);
				for ( int i = 0; i < KERNEL_SIZE; i ++ ) {
					vec3 sampleVector = kernelMatrix * kernel[ i ]; // reorient sample vector in view space
					vec3 samplePoint = viewPosition + ( sampleVector * kernelSize_ws ); // calculate sample point
					vec4 samplePointNDC = cameraProjectionMatrix * vec4( samplePoint, 1.0 ); // project point and calculate NDC
					samplePointNDC /= samplePointNDC.w;
					vec2 samplePointUv = samplePointNDC.xy * 0.5 + 0.5; // compute uv coordinates
					float realDepth = getLinearDepth( samplePointUv ); // get linear depth from depth texture
					float sampleDepth = viewZToOrthographicDepth( samplePoint.z + bias, cameraNear, cameraFar ); // compute linear depth of the sample view Z value
					float delta = sampleDepth - realDepth;
					if ( delta > 0. && delta < maxDist ) { // if fragment is before sample point, increase occlusion
						occlusion += 1.0;
					}
				}
				return clamp( occlusion * intensity / div, 0.0, 1.0 );
			#endif
			}
		void main() {
			float linearDepth = unpackRGBAToDepth( texture2D( tDepth, vUv ) );
			float centerDepth = getPerspectiveDepth(vUv);
			if( centerDepth >= ( 1.0 - EPSILON ) ) {
				discard;
			}
			float centerViewZ = getViewDepth(linearDepth);
			vec3 viewPosition = getViewPosition( vUv, centerDepth, centerViewZ );
			vec3 viewNormal = getViewNormal(viewPosition, vUv, linearDepth);
			float ambientOcclusion = getAmbientOcclusion( viewPosition, centerDepth );
			gl_FragColor = getDefaultColor( vUv );
			gl_FragColor.xyz *=  ambientOcclusion;
			gl_FragColor.a = 1.;
		}`, vertexShader: `
		varying vec2 vUv;
		void main() {
			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
		}`, uniforms: { tDepth: { value: null }, tNormal: { value: null }, size: { value: new wt(512, 512) }, cameraNear: { value: 1 }, cameraFar: { value: 100 }, cameraProjectionMatrix: { value: new Vt() }, cameraInverseProjectionMatrix: { value: new Vt() }, tanFov: { value: 0 }, scale: { value: 1 }, intensity: { value: 1 }, bias: { value: 0 }, minResolution: { value: 0 }, kernelRadius: { value: 0.5 }, frameIndex: { value: 0 }, tNoise: { value: null }, kernel: { value: null }, minDistance: { value: 1e-3 }, maxDistance: { value: 1 } } }), this.aoMaterial.extensions.derivatives = !0, this.aoMaterial.uniforms.size.value.set(256, 256), this.aoMaterial.blending = 0, this.accumulateMaterial = new Gn({ defines: {}, fragmentShader: `
    uniform float opacity;
    uniform sampler2D tDiffuse;
    varying vec2 vUv;
    // #define NUM_FRAMES 16

    void main() {
        vec4 frameSample = texture2D( tDiffuse, vUv );
        gl_FragColor.xyz = frameSample.rgb * 1./float(NUM_FRAMES);
        gl_FragColor.a = 1.;//*= opacity;
    }`, vertexShader: `
    varying vec2 vUv;
    void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
    }`, uniforms: { tDiffuse: { value: null }, opacity: { value: 1 } } }), this.accumulateMaterial.uniforms.tDiffuse.value = this._generationBuffer.texture, this.accumulateMaterial.blending = 5, this.accumulateMaterial.blendSrc = 201, this.accumulateMaterial.blendDst = 201, this.accumulateMaterial.blendEquation = 102, this.accumulateMaterial.blendSrcAlpha = 201, this.accumulateMaterial.blendDstAlpha = 201, this.accumulateMaterial.blendEquationAlpha = 100, this.fsQuad = new oc(this.aoMaterial);
  }
  setTexture(e, n) {
    e === "tDepth" && (this.aoMaterial.uniforms.tDepth.value = n), e === "tNormal" && (this.aoMaterial.uniforms.tNormal.value = n), this.aoMaterial.needsUpdate = !0;
  }
  get outputTexture() {
    return this._accumulationBuffer.texture;
  }
  get displayName() {
    return "STATIC-AO";
  }
  setParams(e) {
    Object.assign(this.params, e), this.kernels = [], this.noiseTextures = [];
  }
  setFrameIndex(e) {
    this.frameIndex = e;
  }
  update(e, n) {
    this.aoMaterial.defines.PERSPECTIVE_CAMERA = n.isPerspectiveCamera ? 1 : 0, this.aoMaterial.defines.NUM_FRAMES = eu.ACCUMULATE_FRAMES, this.aoMaterial.defines.KERNEL_SIZE = this.params.kernelSize, this.accumulateMaterial.defines.NUM_FRAMES = eu.ACCUMULATE_FRAMES, this.aoMaterial.uniforms.cameraNear.value = n.near, this.aoMaterial.uniforms.cameraFar.value = n.far, this.aoMaterial.uniforms.cameraInverseProjectionMatrix.value.copy(n.projectionMatrixInverse), this.aoMaterial.uniforms.cameraProjectionMatrix.value.copy(n.projectionMatrix);
    const r = n.fov / 2 * Math.PI / 180;
    this.aoMaterial.uniforms.tanFov.value = Math.tan(r), this.kernels[this.frameIndex] || this.generateSampleKernel(this.frameIndex), this.noiseTextures[this.frameIndex] || this.generateRandomKernelRotations(this.frameIndex), this.aoMaterial.uniforms.kernel.value = this.kernels[this.frameIndex], this.aoMaterial.uniforms.tNoise.value = this.noiseTextures[this.frameIndex], this.aoMaterial.uniforms.intensity.value = this.params.intensity, this.aoMaterial.uniforms.kernelRadius.value = this.params.kernelRadius, this.aoMaterial.uniforms.bias.value = this.params.bias, this.aoMaterial.uniforms.frameIndex.value = this.frameIndex, this.aoMaterial.uniforms.minDistance.value = this.params.minDistance, this.aoMaterial.uniforms.maxDistance.value = this.params.maxDistance, this.aoMaterial.needsUpdate = !0, this.accumulateMaterial.needsUpdate = !0;
  }
  render(e, n, r) {
    const s = new Ht();
    e.getClearColor(s);
    const a = e.getClearAlpha(), o = e.autoClear;
    this.renderFrame(e), e.autoClear = o, e.setClearColor(s), e.setClearAlpha(a);
  }
  renderFrame(e) {
    e.setRenderTarget(this._generationBuffer), e.autoClear = !1, e.setClearColor(0), e.setClearAlpha(1), e.clear(!0), this.fsQuad.material = this.aoMaterial, this.fsQuad.render(e), e.setRenderTarget(this._accumulationBuffer), this.frameIndex === 0 && (e.setClearColor(16777215), e.setClearAlpha(1), e.clear(!0)), this.fsQuad.material = this.accumulateMaterial, this.fsQuad.render(e);
  }
  setSize(e, n) {
    this._generationBuffer.setSize(e, n), this._accumulationBuffer.setSize(e, n), this.aoMaterial.uniforms.size.value.set(e, n), this.aoMaterial.needsUpdate = !0;
  }
  generateSampleKernel(e) {
    const n = this.params.kernelSize;
    this.kernels[e] = [];
    for (let r = 0; r < n; r++) {
      const s = new D();
      s.x = 2 * Math.random() - 1, s.y = 2 * Math.random() - 1, s.z = Math.random(), s.normalize();
      let a = r / n;
      a = Hl.lerp(0.1, 1, a * a), s.multiplyScalar(a), this.kernels[e].push(s);
    }
  }
  generateRandomKernelRotations(e) {
    sI === void 0 && console.error("THREE.SSAOPass: The pass relies on SimplexNoise.");
    const n = new sI(), r = new Float32Array(16);
    for (let s = 0; s < 16; s++) {
      const a = 2 * Math.random() - 1, o = 2 * Math.random() - 1, l = 0;
      r[s] = n.noise3d(a, o, l);
    }
    this.noiseTextures[e] = new Ro(r, 4, 4, 1028, 1015), this.noiseTextures[e].wrapS = 1e3, this.noiseTextures[e].wrapT = 1e3, this.noiseTextures[e].needsUpdate = !0;
  }
}
class olt extends gu {
  constructor() {
    super();
    U(this, "camera");
    U(this, "scene");
    U(this, "overrideMaterial", null);
    U(this, "_oldClearColor", new Ht());
    U(this, "clearColor", null);
    U(this, "clearAlpha", 0);
    U(this, "clearDepth", !0);
  }
  get displayName() {
    return "COLOR";
  }
  get outputTexture() {
    return null;
  }
  update(e, n) {
    this.camera = n, this.scene = e;
  }
  render(e, n, r) {
    const s = e.autoClear;
    let a, o;
    e.autoClear = !1, this.overrideMaterial !== void 0 && (o = this.scene.overrideMaterial, this.scene.overrideMaterial = this.overrideMaterial), this.clearColor && (e.getClearColor(this._oldClearColor), a = e.getClearAlpha(), e.setClearColor(this.clearColor, this.clearAlpha)), this.clearDepth && e.clearDepth(), this.applyLayers(this.camera), e.setRenderTarget(this.renderToScreen ? null : r), this.clear && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), e.render(this.scene, this.camera), this.clearColor && e.setClearColor(this._oldClearColor, a), this.overrideMaterial !== void 0 && (this.scene.overrideMaterial = o), e.autoClear = s;
  }
}
class Jz extends Kh {
  constructor(t, e = []) {
    super(t), this.userData.uViewer_high = { value: new D() }, this.userData.uViewer_low = { value: new D() }, this.userData.size = { value: new wt() }, this.userData.displacement = { value: 0 }, this.vertProgram = `
#include <common>
#ifdef USE_RTE
    // The high component is stored as the default 'position' attribute buffer
    attribute vec3 position_low;
    uniform vec3 uViewer_high;
    uniform vec3 uViewer_low;
#endif
uniform vec2 size;
uniform float displacement;
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

vec4 computeRelativePositionSeparate(in vec3 position_low, in vec3 position_high, in vec3 relativeTo_low, in vec3 relativeTo_high){
    /* 
    Vector calculation for the high and low differences works on everything 
    *BESIDES* Apple Silicon (or whatever they call it) GPUs

    It would seem that when this code gets compiled, vector types get a lower precision(?)
    which completely brakes the 2 float -> double reconstructio. Doing it separately for each 
    vector component using floats works fine.
    */
    vec3 highDifference;
    vec3 lowDifference;
    float t1 = position_low.x - relativeTo_low.x;
    float e = t1 - position_low.x;
    float t2 = ((-relativeTo_low.x - e) + (position_low.x - (t1 - e))) + position_high.x - relativeTo_high.x;
    highDifference.x = t1 + t2;
    lowDifference.x = t2 - (highDifference.x - t1);

    t1 = position_low.y - relativeTo_low.y;
    e = t1 - position_low.y;
    t2 = ((-relativeTo_low.y - e) + (position_low.y - (t1 - e))) + position_high.y - relativeTo_high.y;
    highDifference.y = t1 + t2;
    lowDifference.y = t2 - (highDifference.y - t1);

    t1 = position_low.z - relativeTo_low.z;
    e = t1 - position_low.z;
    t2 = ((-relativeTo_low.z - e) + (position_low.z - (t1 - e))) + position_high.z - relativeTo_high.z;
    highDifference.z = t1 + t2;
    lowDifference.z = t2 - (highDifference.z - t1);

    vec3 position = highDifference.xyz + lowDifference.xyz;
    return vec4(position, 1.);
}

vec4 computeRelativePosition(in vec3 position_low, in vec3 position_high, in vec3 relativeTo_low, in vec3 relativeTo_high){
    /* 
    Source https://github.com/virtualglobebook/OpenGlobe/blob/master/Source/Examples/Chapter05/Jitter/GPURelativeToEyeDSFUN90/Shaders/VS.glsl 
    Note here, we're storing the high part of the position encoding inside three's default 'position' attribute buffer so we avoid redundancy 
    */
    vec3 t1 = position_low.xyz - relativeTo_low;
    vec3 e = t1 - position_low.xyz;
    vec3 t2 = ((-relativeTo_low - e) + (position_low.xyz - (t1 - e))) + position_high.xyz - relativeTo_high;
    vec3 highDifference = t1 + t2;
    vec3 lowDifference = t2 - (highDifference - t1);
    
    vec3 position = highDifference.xyz + lowDifference.xyz;
    return vec4(position, 1.);
}

void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	// #include <project_vertex> COMMENTED CHUNK
    #ifdef USE_RTE
        vec4 mvPosition = computeRelativePositionSeparate(position_low.xyz, position.xyz, uViewer_low, uViewer_high);
    #else
        vec4 mvPosition = vec4( transformed, 1.0 );
    #endif
    
    #ifdef USE_INSTANCING

        mvPosition = instanceMatrix * mvPosition;

    #endif
    mvPosition = modelViewMatrix * mvPosition;

    gl_Position = projectionMatrix * mvPosition;
    
    // Transform normal vector from object space to clip space.
    vec3 normalHCS = mat3(projectionMatrix) * normalMatrix * normal;

    // Move vertex along normal vector in clip space.
    gl_Position.xy += normalize(normalHCS.xy) / size * gl_Position.w * displacement * 2.;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}
`, this.fragProgram = `
uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	// accumulation (baked indirect lighting only)
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	// modulation
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}
`, this.uniforms = Jn.merge([Pn.standard.uniforms, { uViewer_high: { value: this.userData.uViewer_high.value }, uViewer_low: { value: this.userData.uViewer_low.value }, size: { value: this.userData.size.value }, displacement: { value: this.userData.displacement.value } }]), this.onBeforeCompile = function(n) {
      n.uniforms.uViewer_high = this.userData.uViewer_high, n.uniforms.uViewer_low = this.userData.uViewer_low, n.uniforms.size = this.userData.size, n.uniforms.displacement = this.userData.displacement, n.vertexShader = this.vertProgram, n.fragmentShader = this.fragProgram;
    }, e && (this.defines = {});
    for (let n = 0; n < e.length; n++)
      this.defines[e[n]] = " ";
  }
}
class llt extends gu {
  constructor() {
    super();
    U(this, "camera");
    U(this, "scene");
    U(this, "overrideMaterial", null);
    U(this, "_oldClearColor", new Ht());
    U(this, "clearColor", null);
    U(this, "clearAlpha", 0);
    U(this, "clearDepth", !0);
    U(this, "drawBufferSize", new wt());
    U(this, "onBeforeRender", null);
    U(this, "onAfterRender", null);
    this.overrideMaterial = new Jz({ color: 16711680 }, ["USE_RTE"]), this.overrideMaterial.userData.displacement.value = 2, this.overrideMaterial.colorWrite = !1, this.overrideMaterial.depthWrite = !1, this.overrideMaterial.stencilWrite = !0, this.overrideMaterial.stencilFunc = 519, this.overrideMaterial.stencilWriteMask = 255, this.overrideMaterial.stencilRef = 255, this.overrideMaterial.stencilZFail = 7681, this.overrideMaterial.stencilZPass = 7681, this.overrideMaterial.stencilFail = 7681, this.overrideMaterial.side = 2;
  }
  get displayName() {
    return "STENCIL";
  }
  get outputTexture() {
    return null;
  }
  update(e, n) {
    this.camera = n, this.scene = e;
  }
  setClippingPlanes(e) {
    this.overrideMaterial.clippingPlanes = e;
  }
  render(e, n, r) {
    this.onBeforeRender && this.onBeforeRender();
    const s = e.autoClear;
    let a, o;
    e.autoClear = !1, this.overrideMaterial !== void 0 && (o = this.scene.overrideMaterial, this.scene.overrideMaterial = this.overrideMaterial), this.clearColor && (e.getClearColor(this._oldClearColor), a = e.getClearAlpha(), e.setClearColor(this.clearColor, this.clearAlpha)), this.clearDepth && e.clearDepth(), this.applyLayers(this.camera), e.setRenderTarget(this.renderToScreen ? null : r), this.clear && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), e.getDrawingBufferSize(this.drawBufferSize), this.overrideMaterial.userData.size.value.copy(this.drawBufferSize), e.clear(!1, !1, !0);
    const l = e.shadowMap.enabled;
    e.shadowMap.enabled = !1, e.render(this.scene, this.camera), e.shadowMap.enabled = l, this.clearColor && e.setClearColor(this._oldClearColor, a), this.overrideMaterial !== void 0 && (this.scene.overrideMaterial = o), e.autoClear = s, this.onAfterRender && this.onAfterRender();
  }
}
class clt extends gu {
  constructor() {
    super();
    U(this, "camera");
    U(this, "scene");
    U(this, "overrideMaterial", null);
    U(this, "_oldClearColor", new Ht());
    U(this, "clearColor", null);
    U(this, "clearAlpha", 0);
    U(this, "clearDepth", !0);
    U(this, "drawBufferSize", new wt());
    U(this, "onBeforeRender", null);
    U(this, "onAfterRender", null);
    this.overrideMaterial = new Jz({ color: 304635 }, ["USE_RTE"]), this.overrideMaterial.userData.displacement.value = 2, this.overrideMaterial.colorWrite = !0, this.overrideMaterial.depthWrite = !1, this.overrideMaterial.stencilWrite = !0, this.overrideMaterial.stencilFunc = 514, this.overrideMaterial.stencilRef = 255, this.overrideMaterial.side = 2;
  }
  get displayName() {
    return "STENCIL";
  }
  get outputTexture() {
    return null;
  }
  update(e, n) {
    this.camera = n, this.scene = e;
  }
  setClippingPlanes(e) {
    this.overrideMaterial.clippingPlanes = e;
  }
  render(e, n, r) {
    this.onBeforeRender && this.onBeforeRender();
    const s = e.autoClear;
    let a, o;
    e.autoClear = !1, this.overrideMaterial !== void 0 && (o = this.scene.overrideMaterial, this.scene.overrideMaterial = this.overrideMaterial), this.clearColor && (e.getClearColor(this._oldClearColor), a = e.getClearAlpha(), e.setClearColor(this.clearColor, this.clearAlpha)), this.clearDepth && e.clearDepth(), this.applyLayers(this.camera), e.setRenderTarget(this.renderToScreen ? null : r), this.clear && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), e.getDrawingBufferSize(this.drawBufferSize), this.overrideMaterial.userData.size.value.copy(this.drawBufferSize);
    const l = e.shadowMap.enabled;
    e.shadowMap.enabled = !1, e.render(this.scene, this.camera), e.shadowMap.enabled = l, this.clearColor && e.setClearColor(this._oldClearColor, a), this.overrideMaterial !== void 0 && (this.scene.overrideMaterial = o), e.autoClear = s, this.onAfterRender && this.onAfterRender();
  }
}
var wM = ((i) => (i[i.NORMAL = 0] = "NORMAL", i[i.ACCUMULATION = 1] = "ACCUMULATION", i))(wM || {});
const Kz = { pipelineOutput: 2, accumulationFrames: 16, dynamicAoEnabled: !1, dynamicAoParams: Xz, staticAoEnabled: !1, staticAoParams: Yz }, Wd = class Wd {
  constructor(t, e) {
    U(this, "_renderer", null);
    U(this, "_batcher", null);
    U(this, "_pipelineOptions", Object.assign({}, Kz));
    U(this, "_needsProgressive", !1);
    U(this, "_resetFrame", !1);
    U(this, "composer", null);
    U(this, "depthPass", null);
    U(this, "normalsPass", null);
    U(this, "stencilPass", null);
    U(this, "renderPass", null);
    U(this, "stencilMaskPass", null);
    U(this, "dynamicAoPass", null);
    U(this, "applySaoPass", null);
    U(this, "copyOutputPass", null);
    U(this, "staticAoPass", null);
    U(this, "texturePass", null);
    U(this, "drawingSize", new wt());
    U(this, "_renderType", 0);
    U(this, "accumulationFrame", 0);
    this._renderer = t, this._batcher = e, this.composer = new $ot(t), this.composer.readBuffer = null, this.composer.writeBuffer = null;
  }
  set pipelineOptions(t) {
    Object.assign(this._pipelineOptions, t), this.dynamicAoPass.setParams(t.dynamicAoParams), this.staticAoPass.setParams(t.staticAoParams), this.accumulationFrame = 0, Wd.ACCUMULATE_FRAMES = t.accumulationFrames, this.pipelineOutput = t.pipelineOutput;
  }
  set pipelineOutput(t) {
    let e = [];
    switch (this.clearPipeline(), t) {
      case 8:
        e = this.getDefaultPipeline(), this.depthPass.depthSize = Da.FULL, this.applySaoPass.setTexture("tDiffuse", this.staticAoPass.outputTexture), this.applySaoPass.setTexture("tDiffuseInterp", this.dynamicAoPass.outputTexture), this.needsProgressive = !1;
        break;
      case 0:
        e.push(this.depthPass), e.push(this.copyOutputPass), this.depthPass.depthSize = Da.FULL, this.copyOutputPass.setTexture("tDiffuse", this.depthPass.outputTexture), this.copyOutputPass.setOutputType(0), this.needsProgressive = !1;
        break;
      case 1:
        e.push(this.depthPass), e.push(this.copyOutputPass), this.depthPass.depthSize = Da.FULL, this.copyOutputPass.setTexture("tDiffuse", this.depthPass.outputTexture), this.copyOutputPass.setOutputType(1), this.needsProgressive = !1;
        break;
      case 2:
        e.push(this.renderPass);
        break;
      case 3:
        e.push(this.normalsPass), e.push(this.copyOutputPass), this.normalsPass.enabled = !0, this.copyOutputPass.setTexture("tDiffuse", this.normalsPass.outputTexture), this.copyOutputPass.setOutputType(3), this.needsProgressive = !1;
        break;
      case 4:
        e.push(this.depthPass), e.push(this.dynamicAoPass), e.push(this.copyOutputPass), this.dynamicAoPass.enabled = !0, this.depthPass.depthType = Al.PERSPECTIVE_DEPTH, this.depthPass.depthSize = Da.HALF, this.dynamicAoPass.setOutputType(yh.RECONSTRUCTED_NORMALS), this.copyOutputPass.setTexture("tDiffuse", this.dynamicAoPass.outputTexture), this.copyOutputPass.setOutputType(3), this.needsProgressive = !1;
        break;
      case 5:
        e.push(this.depthPass), e.push(this.normalsPass), e.push(this.dynamicAoPass), e.push(this.copyOutputPass), this.normalsPass.enabled = this._pipelineOptions.dynamicAoParams.normalsType === yv.DEFAULT, this.dynamicAoPass.enabled = !0, this.depthPass.depthType = Al.PERSPECTIVE_DEPTH, this.copyOutputPass.setTexture("tDiffuse", this.dynamicAoPass.outputTexture), this.copyOutputPass.setOutputType(2), this.dynamicAoPass.setOutputType(yh.AO), this.needsProgressive = !1;
        break;
      case 6:
        e.push(this.depthPass), e.push(this.normalsPass), e.push(this.dynamicAoPass), e.push(this.copyOutputPass), this.normalsPass.enabled = this._pipelineOptions.dynamicAoParams.normalsType === yv.DEFAULT, this.dynamicAoPass.enabled = !0, this.depthPass.depthType = Al.PERSPECTIVE_DEPTH, this.depthPass.depthSize = Da.HALF, this.copyOutputPass.setTexture("tDiffuse", this.dynamicAoPass.outputTexture), this.copyOutputPass.setOutputType(2), this.dynamicAoPass.setOutputType(yh.AO_BLURRED), this.needsProgressive = !1;
        break;
      case 7:
        e.push(this.depthPass), e.push(this.dynamicAoPass), e.push(this.staticAoPass), e.push(this.copyOutputPass), this.depthPass.depthType = Al.LINEAR_DEPTH, this.depthPass.depthSize = Da.FULL, this.copyOutputPass.setTexture("tDiffuse", this.staticAoPass.outputTexture), this.copyOutputPass.setOutputType(2), this.needsProgressive = !0;
    }
    this.setPipeline(e);
  }
  set needsProgressive(t) {
    this._needsProgressive = t, t || (this._renderType = 0), t && this._renderType === 0 && (this._renderType = 1), this.accumulationFrame = 0;
  }
  get renderType() {
    return this._renderType;
  }
  configure() {
    let t;
    this.depthPass = new elt(), this.normalsPass = new nlt(), this.dynamicAoPass = new slt(), this.stencilPass = new llt(), this.renderPass = new olt(), this.stencilMaskPass = new clt(), this.applySaoPass = new Qot(), this.staticAoPass = new alt(), this.copyOutputPass = new tlt(), this.copyOutputPass.renderToScreen = !0, this.depthPass.setLayers([pn.STREAM_CONTENT_MESH]), this.normalsPass.setLayers([pn.STREAM_CONTENT_MESH]), this.stencilPass.setLayers([pn.STREAM_CONTENT_MESH]), this.renderPass.setLayers([pn.PROPS, pn.STREAM_CONTENT, pn.STREAM_CONTENT_MESH, pn.STREAM_CONTENT_LINE, pn.STREAM_CONTENT_POINT, pn.SHADOWCATCHER]), this.stencilMaskPass.setLayers([pn.STREAM_CONTENT_MESH]), this.depthPass.onBeforeRender = () => {
      t = this._batcher.saveVisiblity();
      const e = this._batcher.getOpaque();
      this._batcher.applyVisibility(e);
    }, this.depthPass.onAfterRender = () => {
      this._batcher.applyVisibility(t);
    }, this.normalsPass.onBeforeRender = () => {
      t = this._batcher.saveVisiblity();
      const e = this._batcher.getOpaque();
      this._batcher.applyVisibility(e);
    }, this.normalsPass.onAfterRender = () => {
      this._batcher.applyVisibility(t);
    }, this.stencilPass.onBeforeRender = () => {
      t = this._batcher.saveVisiblity();
      const e = this._batcher.getStencil();
      this._batcher.applyVisibility(e);
    }, this.stencilPass.onAfterRender = () => {
      this._batcher.applyVisibility(t);
    }, this.stencilMaskPass.onBeforeRender = () => {
      t = this._batcher.saveVisiblity();
      const e = this._batcher.getStencil();
      this._batcher.applyVisibility(e);
    }, this.stencilMaskPass.onAfterRender = () => {
      this._batcher.applyVisibility(t);
    }, this.setPipeline(this.getDefaultPipeline());
  }
  getDefaultPipeline() {
    this.renderPass.renderToScreen = !0, this.normalsPass.enabled = this._pipelineOptions.dynamicAoParams.normalsType === yv.DEFAULT, this.dynamicAoPass.setOutputType(this._pipelineOptions.dynamicAoParams.blurEnabled ? yh.AO_BLURRED : yh.AO), this.applySaoPass.renderToScreen = !0, this.dynamicAoPass.setTexture("tDepth", this.depthPass.outputTextureHalf), this.dynamicAoPass.setTexture("tNormal", this.normalsPass.outputTexture), this.applySaoPass.setTexture("tDiffuse", this.dynamicAoPass.outputTexture), this.applySaoPass.setTexture("tDiffuseInterp", this.dynamicAoPass.outputTexture), this.staticAoPass.setTexture("tDepth", this.depthPass.outputTexture), this.staticAoPass.setTexture("tNormal", this.normalsPass.outputTexture);
    const t = [];
    return t.push(this.depthPass), t.push(this.normalsPass), t.push(this.dynamicAoPass), t.push(this.staticAoPass), t.push(this.stencilPass), t.push(this.renderPass), t.push(this.stencilMaskPass), t.push(this.applySaoPass), this.needsProgressive = !0, t;
  }
  clearPipeline() {
    for (; this.composer.passes.length > 0; )
      this.composer.removePass(this.composer.passes[0]);
  }
  setPipeline(t) {
    for (let e = 0; e < t.length; e++)
      this.composer.addPass(t[e]);
  }
  insertPass(t, e) {
    this.composer.insertPass(t, e);
  }
  clearPass(t) {
    this.composer.removePass(t);
  }
  updateClippingPlanes(t) {
    this.depthPass.setClippingPlanes(t), this.stencilPass.setClippingPlanes(t), this.stencilMaskPass.setClippingPlanes(t);
  }
  reset() {
    this._resetFrame = !0, this.onStationaryEnd();
  }
  update(t) {
    this.stencilPass.update(t.scene, t.camera), this.renderPass.update(t.scene, t.camera), this.stencilMaskPass.update(t.scene, t.camera), this.depthPass.update(t.scene, t.camera), this.dynamicAoPass.update(t.scene, t.camera), this.normalsPass.update(t.scene, t.camera), this.staticAoPass.update(t.scene, t.camera), this.applySaoPass.update(t.scene, t.camera), this.staticAoPass.setFrameIndex(this.accumulationFrame), this.applySaoPass.setFrameIndex(this.accumulationFrame);
  }
  render() {
    if (this._renderer.getDrawingBufferSize(this.drawingSize), this.drawingSize.length() !== 0) {
      if (this._renderer.clear(!0), this._renderType === 0) {
        this.composer.render();
        const t = this._resetFrame;
        return this._resetFrame && (this._resetFrame = !1, this.onStationaryBegin()), t;
      }
      return this.composer.render(), this.accumulationFrame++, this.accumulationFrame < Wd.ACCUMULATE_FRAMES;
    }
  }
  resize(t, e) {
    this.composer.setSize(t, e), this.accumulationFrame = 0;
  }
  onStationaryBegin() {
    this._needsProgressive && (this._renderType !== 1 ? (this._renderType = 1, this.accumulationFrame = 0, this.depthPass.enabled = !0, this.depthPass.depthType = Al.LINEAR_DEPTH, this.depthPass.depthSize = Da.FULL, this.normalsPass.enabled = !1, this.dynamicAoPass.enabled = !1, this.renderPass.enabled = !0, this.applySaoPass.enabled = !0, this.staticAoPass.enabled = !0, this.applySaoPass.setTexture("tDiffuse", this.staticAoPass.outputTexture), this.applySaoPass.setTexture("tDiffuseInterp", this.dynamicAoPass.outputTexture), this.applySaoPass.setRenderType(this._renderType)) : this.accumulationFrame = 0);
  }
  onStationaryEnd() {
    this._needsProgressive && this._renderType !== 0 && (this.accumulationFrame = 0, this._renderType = 0, this.depthPass.depthType = Al.PERSPECTIVE_DEPTH, this.depthPass.depthSize = Da.HALF, this.staticAoPass.enabled = !1, this.applySaoPass.enabled = !0, this.dynamicAoPass.enabled = !0, this.applySaoPass.setTexture("tDiffuse", this.dynamicAoPass.outputTexture), this.applySaoPass.setRenderType(this._renderType));
  }
};
U(Wd, "ACCUMULATE_FRAMES", 16);
let eu = Wd;
var Cl = ((i) => (i.POSITIVE_X = "POSITIVE_X", i.POSITIVE_Y = "POSITIVE_Y", i.POSITIVE_Z = "POSITIVE_Z", i.NEGATIVE_X = "NEGATIVE_X", i.NEGATIVE_Y = "NEGATIVE_Y", i.NEGATIVE_Z = "NEGATIVE_Z", i))(Cl || {});
const Oa = class Oa {
  constructor() {
    U(this, "tmpVec", new D());
    U(this, "tmpVec2", new D());
    U(this, "up", new D(0, 1, 0));
    U(this, "down", new D(0, -1, 0));
    U(this, "left", new D(-1, 0, 0));
    U(this, "right", new D(1, 0, 0));
    U(this, "forward", new D(0, 0, 1));
    U(this, "back", new D(0, 0, -1));
    U(this, "planeOutlines", {});
    this.planeOutlines.POSITIVE_X = this.createPlaneOutline("POSITIVE_X"), this.planeOutlines.NEGATIVE_X = this.createPlaneOutline("NEGATIVE_X"), this.planeOutlines.POSITIVE_Y = this.createPlaneOutline("POSITIVE_Y"), this.planeOutlines.NEGATIVE_Y = this.createPlaneOutline("NEGATIVE_Y"), this.planeOutlines.NEGATIVE_Z = this.createPlaneOutline("NEGATIVE_Z"), this.planeOutlines.POSITIVE_Z = this.createPlaneOutline("POSITIVE_Z");
  }
  getPlaneOutline(t) {
    return this.planeOutlines[t];
  }
  enable(t) {
    for (const e in this.planeOutlines)
      this.planeOutlines[e].renderable.visible = t;
  }
  updateClippingPlanes(t) {
    for (const e in this.planeOutlines) {
      const n = t.filter((r) => this.getPlaneId(r) !== e);
      this.planeOutlines[e].renderable.material.clippingPlanes = n;
    }
  }
  updatePlaneOutline(t, e) {
    const n = new D(), r = new D(), s = new D(), a = new D(), o = new D(), l = new ss(), c = this.getPlaneId(e), u = this.planeOutlines[c].renderable;
    let h = 0, p = u.geometry.attributes.instanceStart.data;
    const f = new Array();
    for (let m = 0; m < t.length; m++) {
      const y = new Hn().copy(e);
      t[m].boundsTree.shapecast({ intersectsBounds: (_) => y.intersectsBox(_), intersectsTriangle: (_, w) => {
        const b = t[m].getMaterialAtIndex(w);
        if (b instanceof vz || b.visible === !1 || b === null)
          return;
        const T = y;
        let M = 0;
        l.start.copy(_.a), l.end.copy(_.b), T.intersectLine(l, n) && (n.add(o.copy(y.normal).multiplyScalar(Oa.Z_OFFSET)), f[3 * h] = n.x, f[3 * h + 1] = n.y, f[3 * h + 2] = n.z, h++, M++), l.start.copy(_.b), l.end.copy(_.c), T.intersectLine(l, n) && (n.add(o.copy(y.normal).multiplyScalar(Oa.Z_OFFSET)), f[3 * h] = n.x, f[3 * h + 1] = n.y, f[3 * h + 2] = n.z, M++, h++), l.start.copy(_.c), l.end.copy(_.a), T.intersectLine(l, n) && (n.add(o.copy(y.normal).multiplyScalar(Oa.Z_OFFSET)), f[3 * h] = n.x, f[3 * h + 1] = n.y, f[3 * h + 2] = n.z, M++, h++), M === 3 && (r.set(f[3 * (h - 3)], f[3 * (h - 3) + 1], f[3 * (h - 3) + 2]), s.set(f[3 * (h - 2)], f[3 * (h - 2) + 1], f[3 * (h - 2) + 2]), a.set(f[3 * (h - 1)], f[3 * (h - 1) + 1], f[3 * (h - 1) + 2]), a.equals(r) || a.equals(s) ? (M--, h--) : r.equals(s) && (a.set(n.x, n.y, n.z), a.add(o.copy(y.normal).multiplyScalar(Oa.Z_OFFSET)), f[3 * (h - 2)] = a.x, f[3 * (h - 2) + 1] = a.y, f[3 * (h - 2) + 2] = a.z, M--, h--)), M !== 2 && (h -= M);
      } });
    }
    f.length > p.array.length && (this.resizeGeometryBuffer(this.planeOutlines[c], f.length), console.warn(`Resized outline buffer from ${p.array.length} to ${f.length}. ${f.length / 6} instance count`)), p = u.geometry.attributes.instanceStart.data;
    const v = u.geometry.attributes.instanceStartLow.data;
    Nn.DoubleToHighLowBuffer(f, v.array, p.array), p.needsUpdate = !0, p.updateRange = { offset: 0, count: 3 * h }, v.needsUpdate = !0, v.updateRange = { offset: 0, count: 3 * h }, u.visible = !0, u.geometry.instanceCount = h / 2, u.geometry.attributes.instanceStart.needsUpdate = !0, u.geometry.attributes.instanceEnd.needsUpdate = !0, u.geometry.attributes.instanceStartLow.needsUpdate = !0, u.geometry.attributes.instanceEndLow.needsUpdate = !0, u.geometry.computeBoundingBox(), u.geometry.computeBoundingSphere();
  }
  createPlaneOutline(t) {
    const e = new Float64Array(Oa.INITIAL_BUFFER_SIZE), n = new Kv();
    n.setPositions(new Float32Array(e)), n.attributes.instanceStart.data.setUsage(35048), Nn.updateRTEGeometry(n, e);
    const r = new Ss({ color: 294651, linewidth: 2, worldUnits: !1, vertexColors: !1, alphaToCoverage: !1, resolution: new wt(919, 848) });
    r.color = new Ht(294651), r.color.convertSRGBToLinear(), r.linewidth = 2, r.worldUnits = !1, r.resolution = new wt(1513, 1306);
    const s = new yM(n, r);
    return s.name = `${t}-outline`, s.frustumCulled = !1, s.renderOrder = 1, s.layers.set(pn.PROPS), { renderable: s };
  }
  resizeGeometryBuffer(t, e) {
    t.renderable.geometry.dispose();
    const n = new Float32Array(e);
    t.renderable.geometry = new Kv(), t.renderable.geometry.setPositions(new Float32Array(n)), t.renderable.geometry.attributes.instanceStart.data.setUsage(35048), Nn.updateRTEGeometry(t.renderable.geometry, n);
  }
  getPlaneId(t) {
    return this.tmpVec.set(Math.round(t.normal.x), Math.round(t.normal.y), Math.round(t.normal.z)), this.tmpVec.equals(this.right) ? "POSITIVE_X" : this.tmpVec.equals(this.left) ? "NEGATIVE_X" : this.tmpVec.equals(this.up) ? "POSITIVE_Y" : this.tmpVec.equals(this.down) ? "NEGATIVE_Y" : this.tmpVec.equals(this.back) ? "NEGATIVE_Z" : this.tmpVec.equals(this.forward) ? "POSITIVE_Z" : void 0;
  }
};
U(Oa, "INITIAL_BUFFER_SIZE", 6e4), U(Oa, "Z_OFFSET", -1e-3);
let Ob = Oa;
class hlt extends Kh {
  constructor(t, e = []) {
    super(t, e), this.userData.uViewer_high = { value: new D() }, this.userData.uViewer_low = { value: new D() }, this.userData.tex0 = { value: null }, this.userData.tex1 = { value: null }, this.userData.tex2 = { value: null }, this.userData.tex3 = { value: null }, this.userData.weights = { value: new ze() }, this.userData.sigmoidRange = { value: 0 }, this.userData.sigmoidStrength = { value: 0 }, this.vertProgram = `
	varying vec2 vUv;
		void main() {
			vUv = vec2(1. - uv.x, uv.y);
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
		}
`, this.fragProgram = `
varying vec2 vUv;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform sampler2D tex3;
uniform vec4 weights;
uniform float sigmoidRange;
uniform float sigmoidStrength;

void main() {
	float color0 = texture2D(tex0, vUv).r * weights.x;
	float color1 = texture2D(tex1, vUv).r * weights.y;
	float color2 = texture2D(tex2, vUv).r * weights.z;
	float color3 = texture2D(tex3, vUv).r * weights.w;

	// float c0 = mix(color0, 0., color1);
	// float c1 = mix(color1, 0., color0);
	// float c2 = mix(color3, 0., color0 * 0.5 + color1 * 0.5);
	// float sum = c0 + c1 + c2;

	float sum = color0 + color1 + color3 + color2;

	float a = sigmoidRange;//2.;
	float b = 0.03;
	float c = sigmoidStrength;//2.43;
	float d = 0.59;
	float e = 0.14;
	sum = clamp((sum*(a*sum+b))/(sum*(c*sum+d)+e), 0., 1.);

	vec2 sUv = vUv * 2. - 1.;
	sum *= 1. - pow(abs(sUv.x), 6.);
	sum *= 1. - pow(abs(sUv.y), 6.);

	gl_FragColor = vec4( vec3(sum), sum );
}
`, this.uniforms = Jn.merge([Pn.basic.uniforms, { uViewer_high: { value: this.userData.uViewer_high.value }, uViewer_low: { value: this.userData.uViewer_low.value }, tex0: { value: this.userData.tex0.value }, tex1: { value: this.userData.tex1.value }, tex2: { value: this.userData.tex2.value }, tex3: { value: this.userData.tex3.value }, weights: { value: this.userData.weights.value }, sigmoidRange: { value: this.userData.sigmoidRange.value }, sigmoidStrength: { value: this.userData.sigmoidStrength.value } }]), this.onBeforeCompile = function(n) {
      n.uniforms.uViewer_high = this.userData.uViewer_high, n.uniforms.uViewer_low = this.userData.uViewer_low, n.uniforms.tex0 = this.userData.tex0, n.uniforms.tex1 = this.userData.tex1, n.uniforms.tex2 = this.userData.tex2, n.uniforms.tex3 = this.userData.tex3, n.uniforms.weights = this.userData.weights, n.uniforms.sigmoidRange = this.userData.sigmoidRange, n.uniforms.sigmoidStrength = this.userData.sigmoidStrength, n.vertexShader = this.vertProgram, n.fragmentShader = this.fragProgram;
    }, e && (this.defines = {});
    for (let n = 0; n < e.length; n++)
      this.defines[e[n]] = " ";
  }
}
class ult extends gu {
  constructor() {
    super();
    U(this, "levels", 4);
    U(this, "debugCamera", !1);
    U(this, "renderTargets", []);
    U(this, "tempTargets", []);
    U(this, "outputTarget");
    U(this, "camera", null);
    U(this, "scene", null);
    U(this, "_needsUpdate", !1);
    U(this, "fsQuad", null);
    U(this, "blendMaterial", null);
    U(this, "depthMaterial", null);
    U(this, "vBlurMaterial", null);
    U(this, "hBlurMaterial", null);
    U(this, "blurStdDev", Lb.stdDeviation);
    U(this, "blurRadius", Lb.blurRadius);
    U(this, "prevBlurStdDev", 0);
    U(this, "prevBlurRadius", 0);
    U(this, "cameraHelper", null);
    U(this, "onBeforeRender", null);
    U(this, "onAfterRender", null);
    for (let e = 0; e < this.levels; e++) {
      const n = new ir(256, 256, { minFilter: 1006, magFilter: 1006 });
      this.renderTargets.push(n), this.tempTargets.push(n.clone());
    }
    this.outputTarget = new ir(256, 256, { minFilter: 1006, magFilter: 1006 }), this.outputTarget.texture.wrapS = 1e3, this.outputTarget.texture.wrapT = 1e3, this.camera = new Yl(-128, 128, 128, -128, 0, 10), this.vBlurMaterial = new Gn({ uniforms: Jn.clone(Jr.uniforms), defines: Object.assign({}, Jr.defines), vertexShader: Jr.vertexShader, fragmentShader: Jr.fragmentShader }), this.vBlurMaterial.defines.DEPTH_PACKING = 1, this.vBlurMaterial.blending = 0, this.hBlurMaterial = new Gn({ uniforms: Jn.clone(Jr.uniforms), defines: Object.assign({}, Jr.defines), vertexShader: Jr.vertexShader, fragmentShader: Jr.fragmentShader }), this.hBlurMaterial.defines.DEPTH_PACKING = 1, this.hBlurMaterial.blending = 0, this.depthMaterial = new xp({ depthPacking: 3200 }, ["USE_RTE"]), this.depthMaterial.blending = 0, this.depthMaterial.side = 2, this.blendMaterial = new hlt({}), this.fsQuad = new oc(this.vBlurMaterial);
  }
  get displayName() {
    return "Shadowcatcher";
  }
  get outputTexture() {
    return this.outputTarget.texture;
  }
  set needsUpdate(e) {
    this._needsUpdate = e;
  }
  update(e) {
    if (this.scene = e, this._needsUpdate) {
      this.cameraHelper === null && this.debugCamera && (this.cameraHelper = new aS(this.camera), this.cameraHelper.layers.set(pn.PROPS), this.scene.add(this.cameraHelper)), this.cameraHelper && this.cameraHelper.update(), this.vBlurMaterial.defines.PERSPECTIVE_CAMERA = 0, this.hBlurMaterial.defines.PERSPECTIVE_CAMERA = 0, this.vBlurMaterial.uniforms.cameraNear.value = this.camera.near, this.vBlurMaterial.uniforms.cameraFar.value = this.camera.far, this.hBlurMaterial.uniforms.cameraNear.value = this.camera.near, this.hBlurMaterial.uniforms.cameraFar.value = this.camera.far;
      const n = 0;
      this.vBlurMaterial.uniforms.depthCutoff.value = n, this.hBlurMaterial.uniforms.depthCutoff.value = n, this.prevBlurStdDev === this.blurStdDev && this.prevBlurRadius === this.blurRadius || (tu.configure(this.vBlurMaterial, this.blurRadius, this.blurStdDev, new wt(0, 1)), tu.configure(this.hBlurMaterial, this.blurRadius, this.blurStdDev, new wt(1, 0)), this.prevBlurStdDev = this.blurStdDev, this.prevBlurRadius = this.blurRadius), this.vBlurMaterial.needsUpdate = !0, this.hBlurMaterial.needsUpdate = !0;
    }
  }
  render(e, n, r) {
    if (this._needsUpdate) {
      const s = new Ht();
      e.getClearColor(s);
      const a = e.getClearAlpha(), o = e.autoClear;
      this.onBeforeRender && this.onBeforeRender(), this.applyLayers(this.camera);
      const l = this.camera.far;
      for (let c = 0; c < this.renderTargets.length; c++)
        this.camera.far = l, c < 2 && (this.camera.far = l / 100), c === 2 && (this.camera.far = l / 4), this.camera.updateProjectionMatrix(), e.setRenderTarget(this.renderTargets[c]), this.scene.overrideMaterial = this.depthMaterial, e.setClearColor(0), e.setClearAlpha(1), e.render(this.scene, this.camera), this.scene.overrideMaterial = null, e.setRenderTarget(this.tempTargets[c]), e.setClearColor(16777215), e.setClearAlpha(1), e.clear(), this.vBlurMaterial.uniforms.tDiffuse.value = this.renderTargets[c].texture, this.vBlurMaterial.uniforms.size.value.set(this.renderTargets[c].width, this.renderTargets[c].height), this.vBlurMaterial.needsUpdate = !0, this.fsQuad.material = this.vBlurMaterial, this.fsQuad.render(e), e.setRenderTarget(this.renderTargets[c]), this.hBlurMaterial.uniforms.tDiffuse.value = this.tempTargets[c].texture, this.hBlurMaterial.uniforms.size.value.set(this.tempTargets[c].width, this.tempTargets[c].height), this.hBlurMaterial.needsUpdate, this.fsQuad.material = this.hBlurMaterial, this.fsQuad.render(e);
      e.setRenderTarget(this.outputTarget), e.setClearColor(0), e.setClearAlpha(1), this.blendMaterial.userData.tex0.value = this.renderTargets[0].texture, this.blendMaterial.userData.tex1.value = this.renderTargets[1].texture, this.blendMaterial.userData.tex2.value = this.renderTargets[2].texture, this.blendMaterial.userData.tex3.value = this.renderTargets[3].texture, this.fsQuad.material = this.blendMaterial, this.fsQuad.render(e), e.setRenderTarget(null), e.autoClear = o, e.setClearColor(s), e.setClearAlpha(a), this.onAfterRender && this.onAfterRender(), this._needsUpdate = !1;
    }
  }
  updateClippingPlanes(e) {
    this.depthMaterial.clippingPlanes = e, this.depthMaterial.needsUpdate = !0;
  }
  setOutputSize(e, n) {
    if (this.renderTargets[0].width !== e || this.renderTargets[0].height !== n) {
      this.outputTarget.setSize(e, n), this.blendMaterial.needsUpdate = !0;
      let r = 1;
      for (let s = 0; s < this.renderTargets.length; s++) {
        const a = Math.trunc(e * r), o = Math.trunc(n * r);
        this.renderTargets[s].setSize(a, o), this.tempTargets[s].setSize(a, o), r *= 0.5;
      }
    }
  }
  setWeights(e) {
    this.blendMaterial.userData.weights.value = new ze(e.x, e.y, e.z, e.w), this.blendMaterial.needsUpdate = !0;
  }
  updateCamera(e, n, r) {
    const s = e.getSize(new D()), a = e.getCenter(new D());
    this.camera.position.copy(new D().copy(a).add(new D(0, 0, -1e-3))), this.camera.lookAt(a), this.camera.left = s.x / -2, this.camera.right = s.x / 2, this.camera.top = s.y / 2, this.camera.bottom = s.y / -2, this.camera.near = n, this.camera.far = r, this.camera.updateProjectionMatrix();
  }
  updateConfig(e) {
    this.blurRadius = e.blurRadius, this.blurStdDev = e.stdDeviation, this.blendMaterial.userData.sigmoidRange.value = e.sigmoidRange, this.blendMaterial.userData.sigmoidStrength.value = e.sigmoidStrength, this.blendMaterial.needsUpdate = !0;
  }
  setSize(e, n) {
  }
}
const Lb = { textureSize: 512, weights: { x: 1, y: 1, z: 0, w: 1 }, blurRadius: 16, stdDeviation: 4, sigmoidRange: 1.1, sigmoidStrength: 2 }, Ys = class Ys {
  constructor(t, e, n) {
    U(this, "planeMesh", null);
    U(this, "planeSize", new wt());
    U(this, "displayMaterial", null);
    U(this, "shadowcatcherPass", null);
    U(this, "_config", Lb);
    this.shadowcatcherPass = new ult(), this.shadowcatcherPass.setLayers(e), this.displayMaterial = new Kh({ color: 16711680 }, ["USE_RTE"]), this.displayMaterial.toneMapped = !1, this.displayMaterial.map = this.shadowcatcherPass.outputTexture, this.displayMaterial.map.needsUpdate = !0, this.displayMaterial.toneMapped = !1, this.displayMaterial.transparent = !0, this.displayMaterial.blending = 5, this.displayMaterial.blendEquation = 100, this.displayMaterial.blendEquationAlpha = 104, this.displayMaterial.blendSrc = 200, this.displayMaterial.blendSrcAlpha = 201, this.displayMaterial.blendDst = 206, this.displayMaterial.blendDstAlpha = 201, this.displayMaterial.alphaTest = 1e-3, this.planeMesh = new Nt(), this.planeMesh.material = this.displayMaterial, this.planeMesh.layers.set(t), this.planeMesh.name = Ys.MESH_NAME, this.planeMesh.frustumCulled = !1, this.cameraHandler = n;
  }
  get shadowcatcherMesh() {
    return this.planeMesh;
  }
  set configuration(t) {
    this._config = JSON.parse(JSON.stringify(t));
  }
  update(t) {
    this.shadowcatcherPass.updateConfig(this._config), this.shadowcatcherPass.update(t);
  }
  render(t) {
    this.shadowcatcherPass.render(t, null, null);
  }
  bake(t, e, n) {
    this.updatePlaneMesh(t, n);
    const r = this.getTextureSize(e), s = new ke().setFromObject(this.planeMesh), a = t.getSize(new D()).z;
    this.shadowcatcherPass.updateCamera(s, 1e-3, a), this.shadowcatcherPass.setOutputSize(r.x, r.y), this.shadowcatcherPass.setWeights(this._config.weights), this.shadowcatcherPass.needsUpdate = !0;
  }
  updateClippingPlanes(t) {
    this.displayMaterial.clippingPlanes = t, this.displayMaterial.needsUpdate = !0, this.shadowcatcherPass.updateClippingPlanes(t);
  }
  getTextureSize(t) {
    const e = this.planeSize.x / this.planeSize.y, n = new wt();
    return n.x = Math.trunc(this._config.textureSize), n.y = Math.trunc(this._config.textureSize / e), n.y > t * Ys.MAX_TEXTURE_SIZE_SCALE && (n.y = t * Ys.MAX_TEXTURE_SIZE_SCALE, n.x = e * n.y), n;
  }
  updatePlaneMesh(t, e) {
    const n = t.getSize(new D()), r = t.getCenter(new D()), s = this.cameraHandler.camera.up.y === 1 ? 0.5 * n.z : n.y;
    (new wt(n.x, s).distanceTo(this.planeSize) > 1e-3 || e) && this.updatePlaneMeshGeometry(new wt(2 * n.x, 2 * s), new D(r.x, r.y, r.z - 0.5 * n.z - 1e-3)), this.planeSize.set(n.x, s);
  }
  updatePlaneMeshGeometry(t, e) {
    this.planeMesh.geometry && this.planeMesh.geometry.dispose();
    const n = new Wa(t.x, t.y, Ys.PLANE_SUBD, Ys.PLANE_SUBD);
    let r = new Vt().makeTranslation(e.x, e.y, e.z);
    n.applyMatrix4(r);
    const s = new Float64Array(n.attributes.position.array);
    Nn.updateRTEGeometry(n, s), this.planeMesh.geometry = n, this.planeMesh.geometry.computeBoundingBox();
  }
};
U(Ys, "MESH_NAME", "Shadowcatcher"), U(Ys, "PLANE_SUBD", 2), U(Ys, "MAX_TEXTURE_SIZE_SCALE", 0.5);
let Bb = Ys;
function Zw(i) {
  throw new Error('Could not dynamically require "' + i + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var $z = { exports: {} };
/*!

JSZip v3.10.1 - A JavaScript class for generating and reading zip files
<http://stuartk.com/jszip>

(c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/main/LICENSE.markdown.

JSZip uses the library pako released under the MIT license :
https://github.com/nodeca/pako/blob/main/LICENSE
*/
$z.exports = function i(t, e, n) {
  function r(o, l) {
    if (!e[o]) {
      if (!t[o]) {
        if (!l && Zw)
          return Zw(o);
        if (s)
          return s(o, !0);
        var c = new Error("Cannot find module '" + o + "'");
        throw c.code = "MODULE_NOT_FOUND", c;
      }
      var u = e[o] = { exports: {} };
      t[o][0].call(u.exports, function(h) {
        return r(t[o][1][h] || h);
      }, u, u.exports, i, t, e, n);
    }
    return e[o].exports;
  }
  for (var s = Zw, a = 0; a < n.length; a++)
    r(n[a]);
  return r;
}({ 1: [function(i, t, e) {
  var n = i("./utils"), r = i("./support"), s = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
  e.encode = function(a) {
    for (var o, l, c, u, h, p, f, v = [], m = 0, y = a.length, _ = y, w = n.getTypeOf(a) !== "string"; m < a.length; )
      _ = y - m, c = w ? (o = a[m++], l = m < y ? a[m++] : 0, m < y ? a[m++] : 0) : (o = a.charCodeAt(m++), l = m < y ? a.charCodeAt(m++) : 0, m < y ? a.charCodeAt(m++) : 0), u = o >> 2, h = (3 & o) << 4 | l >> 4, p = 1 < _ ? (15 & l) << 2 | c >> 6 : 64, f = 2 < _ ? 63 & c : 64, v.push(s.charAt(u) + s.charAt(h) + s.charAt(p) + s.charAt(f));
    return v.join("");
  }, e.decode = function(a) {
    var o, l, c, u, h, p, f = 0, v = 0, m = "data:";
    if (a.substr(0, m.length) === m)
      throw new Error("Invalid base64 input, it looks like a data url.");
    var y, _ = 3 * (a = a.replace(/[^A-Za-z0-9+/=]/g, "")).length / 4;
    if (a.charAt(a.length - 1) === s.charAt(64) && _--, a.charAt(a.length - 2) === s.charAt(64) && _--, _ % 1 != 0)
      throw new Error("Invalid base64 input, bad content length.");
    for (y = r.uint8array ? new Uint8Array(0 | _) : new Array(0 | _); f < a.length; )
      o = s.indexOf(a.charAt(f++)) << 2 | (u = s.indexOf(a.charAt(f++))) >> 4, l = (15 & u) << 4 | (h = s.indexOf(a.charAt(f++))) >> 2, c = (3 & h) << 6 | (p = s.indexOf(a.charAt(f++))), y[v++] = o, h !== 64 && (y[v++] = l), p !== 64 && (y[v++] = c);
    return y;
  };
}, { "./support": 30, "./utils": 32 }], 2: [function(i, t, e) {
  var n = i("./external"), r = i("./stream/DataWorker"), s = i("./stream/Crc32Probe"), a = i("./stream/DataLengthProbe");
  function o(l, c, u, h, p) {
    this.compressedSize = l, this.uncompressedSize = c, this.crc32 = u, this.compression = h, this.compressedContent = p;
  }
  o.prototype = { getContentWorker: function() {
    var l = new r(n.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new a("data_length")), c = this;
    return l.on("end", function() {
      if (this.streamInfo.data_length !== c.uncompressedSize)
        throw new Error("Bug : uncompressed data size mismatch");
    }), l;
  }, getCompressedWorker: function() {
    return new r(n.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
  } }, o.createWorkerFrom = function(l, c, u) {
    return l.pipe(new s()).pipe(new a("uncompressedSize")).pipe(c.compressWorker(u)).pipe(new a("compressedSize")).withStreamInfo("compression", c);
  }, t.exports = o;
}, { "./external": 6, "./stream/Crc32Probe": 25, "./stream/DataLengthProbe": 26, "./stream/DataWorker": 27 }], 3: [function(i, t, e) {
  var n = i("./stream/GenericWorker");
  e.STORE = { magic: "\0\0", compressWorker: function() {
    return new n("STORE compression");
  }, uncompressWorker: function() {
    return new n("STORE decompression");
  } }, e.DEFLATE = i("./flate");
}, { "./flate": 7, "./stream/GenericWorker": 28 }], 4: [function(i, t, e) {
  var n = i("./utils"), r = function() {
    for (var s, a = [], o = 0; o < 256; o++) {
      s = o;
      for (var l = 0; l < 8; l++)
        s = 1 & s ? 3988292384 ^ s >>> 1 : s >>> 1;
      a[o] = s;
    }
    return a;
  }();
  t.exports = function(s, a) {
    return s !== void 0 && s.length ? n.getTypeOf(s) !== "string" ? function(o, l, c, u) {
      var h = r, p = u + c;
      o ^= -1;
      for (var f = u; f < p; f++)
        o = o >>> 8 ^ h[255 & (o ^ l[f])];
      return -1 ^ o;
    }(0 | a, s, s.length, 0) : function(o, l, c, u) {
      var h = r, p = u + c;
      o ^= -1;
      for (var f = u; f < p; f++)
        o = o >>> 8 ^ h[255 & (o ^ l.charCodeAt(f))];
      return -1 ^ o;
    }(0 | a, s, s.length, 0) : 0;
  };
}, { "./utils": 32 }], 5: [function(i, t, e) {
  e.base64 = !1, e.binary = !1, e.dir = !1, e.createFolders = !0, e.date = null, e.compression = null, e.compressionOptions = null, e.comment = null, e.unixPermissions = null, e.dosPermissions = null;
}, {}], 6: [function(i, t, e) {
  var n = null;
  n = typeof Promise < "u" ? Promise : i("lie"), t.exports = { Promise: n };
}, { lie: 37 }], 7: [function(i, t, e) {
  var n = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Uint32Array < "u", r = i("pako"), s = i("./utils"), a = i("./stream/GenericWorker"), o = n ? "uint8array" : "array";
  function l(c, u) {
    a.call(this, "FlateWorker/" + c), this._pako = null, this._pakoAction = c, this._pakoOptions = u, this.meta = {};
  }
  e.magic = "\b\0", s.inherits(l, a), l.prototype.processChunk = function(c) {
    this.meta = c.meta, this._pako === null && this._createPako(), this._pako.push(s.transformTo(o, c.data), !1);
  }, l.prototype.flush = function() {
    a.prototype.flush.call(this), this._pako === null && this._createPako(), this._pako.push([], !0);
  }, l.prototype.cleanUp = function() {
    a.prototype.cleanUp.call(this), this._pako = null;
  }, l.prototype._createPako = function() {
    this._pako = new r[this._pakoAction]({ raw: !0, level: this._pakoOptions.level || -1 });
    var c = this;
    this._pako.onData = function(u) {
      c.push({ data: u, meta: c.meta });
    };
  }, e.compressWorker = function(c) {
    return new l("Deflate", c);
  }, e.uncompressWorker = function() {
    return new l("Inflate", {});
  };
}, { "./stream/GenericWorker": 28, "./utils": 32, pako: 38 }], 8: [function(i, t, e) {
  function n(h, p) {
    var f, v = "";
    for (f = 0; f < p; f++)
      v += String.fromCharCode(255 & h), h >>>= 8;
    return v;
  }
  function r(h, p, f, v, m, y) {
    var _, w, b = h.file, T = h.compression, M = y !== o.utf8encode, A = s.transformTo("string", y(b.name)), C = s.transformTo("string", o.utf8encode(b.name)), I = b.comment, k = s.transformTo("string", y(I)), R = s.transformTo("string", o.utf8encode(I)), L = C.length !== b.name.length, E = R.length !== I.length, q = "", it = "", rt = "", ft = b.dir, nt = b.date, vt = { crc32: 0, compressedSize: 0, uncompressedSize: 0 };
    p && !f || (vt.crc32 = h.crc32, vt.compressedSize = h.compressedSize, vt.uncompressedSize = h.uncompressedSize);
    var $ = 0;
    p && ($ |= 8), M || !L && !E || ($ |= 2048);
    var W = 0, ct = 0;
    ft && (W |= 16), m === "UNIX" ? (ct = 798, W |= function(dt, Mt) {
      var At = dt;
      return dt || (At = Mt ? 16893 : 33204), (65535 & At) << 16;
    }(b.unixPermissions, ft)) : (ct = 20, W |= function(dt) {
      return 63 & (dt || 0);
    }(b.dosPermissions)), _ = nt.getUTCHours(), _ <<= 6, _ |= nt.getUTCMinutes(), _ <<= 5, _ |= nt.getUTCSeconds() / 2, w = nt.getUTCFullYear() - 1980, w <<= 4, w |= nt.getUTCMonth() + 1, w <<= 5, w |= nt.getUTCDate(), L && (it = n(1, 1) + n(l(A), 4) + C, q += "up" + n(it.length, 2) + it), E && (rt = n(1, 1) + n(l(k), 4) + R, q += "uc" + n(rt.length, 2) + rt);
    var mt = "";
    return mt += `
\0`, mt += n($, 2), mt += T.magic, mt += n(_, 2), mt += n(w, 2), mt += n(vt.crc32, 4), mt += n(vt.compressedSize, 4), mt += n(vt.uncompressedSize, 4), mt += n(A.length, 2), mt += n(q.length, 2), { fileRecord: c.LOCAL_FILE_HEADER + mt + A + q, dirRecord: c.CENTRAL_FILE_HEADER + n(ct, 2) + mt + n(k.length, 2) + "\0\0\0\0" + n(W, 4) + n(v, 4) + A + q + k };
  }
  var s = i("../utils"), a = i("../stream/GenericWorker"), o = i("../utf8"), l = i("../crc32"), c = i("../signature");
  function u(h, p, f, v) {
    a.call(this, "ZipFileWorker"), this.bytesWritten = 0, this.zipComment = p, this.zipPlatform = f, this.encodeFileName = v, this.streamFiles = h, this.accumulate = !1, this.contentBuffer = [], this.dirRecords = [], this.currentSourceOffset = 0, this.entriesCount = 0, this.currentFile = null, this._sources = [];
  }
  s.inherits(u, a), u.prototype.push = function(h) {
    var p = h.meta.percent || 0, f = this.entriesCount, v = this._sources.length;
    this.accumulate ? this.contentBuffer.push(h) : (this.bytesWritten += h.data.length, a.prototype.push.call(this, { data: h.data, meta: { currentFile: this.currentFile, percent: f ? (p + 100 * (f - v - 1)) / f : 100 } }));
  }, u.prototype.openedSource = function(h) {
    this.currentSourceOffset = this.bytesWritten, this.currentFile = h.file.name;
    var p = this.streamFiles && !h.file.dir;
    if (p) {
      var f = r(h, p, !1, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
      this.push({ data: f.fileRecord, meta: { percent: 0 } });
    } else
      this.accumulate = !0;
  }, u.prototype.closedSource = function(h) {
    this.accumulate = !1;
    var p = this.streamFiles && !h.file.dir, f = r(h, p, !0, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
    if (this.dirRecords.push(f.dirRecord), p)
      this.push({ data: function(v) {
        return c.DATA_DESCRIPTOR + n(v.crc32, 4) + n(v.compressedSize, 4) + n(v.uncompressedSize, 4);
      }(h), meta: { percent: 100 } });
    else
      for (this.push({ data: f.fileRecord, meta: { percent: 0 } }); this.contentBuffer.length; )
        this.push(this.contentBuffer.shift());
    this.currentFile = null;
  }, u.prototype.flush = function() {
    for (var h = this.bytesWritten, p = 0; p < this.dirRecords.length; p++)
      this.push({ data: this.dirRecords[p], meta: { percent: 100 } });
    var f = this.bytesWritten - h, v = function(m, y, _, w, b) {
      var T = s.transformTo("string", b(w));
      return c.CENTRAL_DIRECTORY_END + "\0\0\0\0" + n(m, 2) + n(m, 2) + n(y, 4) + n(_, 4) + n(T.length, 2) + T;
    }(this.dirRecords.length, f, h, this.zipComment, this.encodeFileName);
    this.push({ data: v, meta: { percent: 100 } });
  }, u.prototype.prepareNextSource = function() {
    this.previous = this._sources.shift(), this.openedSource(this.previous.streamInfo), this.isPaused ? this.previous.pause() : this.previous.resume();
  }, u.prototype.registerPrevious = function(h) {
    this._sources.push(h);
    var p = this;
    return h.on("data", function(f) {
      p.processChunk(f);
    }), h.on("end", function() {
      p.closedSource(p.previous.streamInfo), p._sources.length ? p.prepareNextSource() : p.end();
    }), h.on("error", function(f) {
      p.error(f);
    }), this;
  }, u.prototype.resume = function() {
    return !!a.prototype.resume.call(this) && (!this.previous && this._sources.length ? (this.prepareNextSource(), !0) : this.previous || this._sources.length || this.generatedError ? void 0 : (this.end(), !0));
  }, u.prototype.error = function(h) {
    var p = this._sources;
    if (!a.prototype.error.call(this, h))
      return !1;
    for (var f = 0; f < p.length; f++)
      try {
        p[f].error(h);
      } catch {
      }
    return !0;
  }, u.prototype.lock = function() {
    a.prototype.lock.call(this);
    for (var h = this._sources, p = 0; p < h.length; p++)
      h[p].lock();
  }, t.exports = u;
}, { "../crc32": 4, "../signature": 23, "../stream/GenericWorker": 28, "../utf8": 31, "../utils": 32 }], 9: [function(i, t, e) {
  var n = i("../compressions"), r = i("./ZipFileWorker");
  e.generateWorker = function(s, a, o) {
    var l = new r(a.streamFiles, o, a.platform, a.encodeFileName), c = 0;
    try {
      s.forEach(function(u, h) {
        c++;
        var p = function(y, _) {
          var w = y || _, b = n[w];
          if (!b)
            throw new Error(w + " is not a valid compression method !");
          return b;
        }(h.options.compression, a.compression), f = h.options.compressionOptions || a.compressionOptions || {}, v = h.dir, m = h.date;
        h._compressWorker(p, f).withStreamInfo("file", { name: u, dir: v, date: m, comment: h.comment || "", unixPermissions: h.unixPermissions, dosPermissions: h.dosPermissions }).pipe(l);
      }), l.entriesCount = c;
    } catch (u) {
      l.error(u);
    }
    return l;
  };
}, { "../compressions": 3, "./ZipFileWorker": 8 }], 10: [function(i, t, e) {
  function n() {
    if (!(this instanceof n))
      return new n();
    if (arguments.length)
      throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
    this.files = /* @__PURE__ */ Object.create(null), this.comment = null, this.root = "", this.clone = function() {
      var r = new n();
      for (var s in this)
        typeof this[s] != "function" && (r[s] = this[s]);
      return r;
    };
  }
  (n.prototype = i("./object")).loadAsync = i("./load"), n.support = i("./support"), n.defaults = i("./defaults"), n.version = "3.10.1", n.loadAsync = function(r, s) {
    return new n().loadAsync(r, s);
  }, n.external = i("./external"), t.exports = n;
}, { "./defaults": 5, "./external": 6, "./load": 11, "./object": 15, "./support": 30 }], 11: [function(i, t, e) {
  var n = i("./utils"), r = i("./external"), s = i("./utf8"), a = i("./zipEntries"), o = i("./stream/Crc32Probe"), l = i("./nodejsUtils");
  function c(u) {
    return new r.Promise(function(h, p) {
      var f = u.decompressed.getContentWorker().pipe(new o());
      f.on("error", function(v) {
        p(v);
      }).on("end", function() {
        f.streamInfo.crc32 !== u.decompressed.crc32 ? p(new Error("Corrupted zip : CRC32 mismatch")) : h();
      }).resume();
    });
  }
  t.exports = function(u, h) {
    var p = this;
    return h = n.extend(h || {}, { base64: !1, checkCRC32: !1, optimizedBinaryString: !1, createFolders: !1, decodeFileName: s.utf8decode }), l.isNode && l.isStream(u) ? r.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")) : n.prepareContent("the loaded zip file", u, !0, h.optimizedBinaryString, h.base64).then(function(f) {
      var v = new a(h);
      return v.load(f), v;
    }).then(function(f) {
      var v = [r.Promise.resolve(f)], m = f.files;
      if (h.checkCRC32)
        for (var y = 0; y < m.length; y++)
          v.push(c(m[y]));
      return r.Promise.all(v);
    }).then(function(f) {
      for (var v = f.shift(), m = v.files, y = 0; y < m.length; y++) {
        var _ = m[y], w = _.fileNameStr, b = n.resolve(_.fileNameStr);
        p.file(b, _.decompressed, { binary: !0, optimizedBinaryString: !0, date: _.date, dir: _.dir, comment: _.fileCommentStr.length ? _.fileCommentStr : null, unixPermissions: _.unixPermissions, dosPermissions: _.dosPermissions, createFolders: h.createFolders }), _.dir || (p.file(b).unsafeOriginalName = w);
      }
      return v.zipComment.length && (p.comment = v.zipComment), p;
    });
  };
}, { "./external": 6, "./nodejsUtils": 14, "./stream/Crc32Probe": 25, "./utf8": 31, "./utils": 32, "./zipEntries": 33 }], 12: [function(i, t, e) {
  var n = i("../utils"), r = i("../stream/GenericWorker");
  function s(a, o) {
    r.call(this, "Nodejs stream input adapter for " + a), this._upstreamEnded = !1, this._bindStream(o);
  }
  n.inherits(s, r), s.prototype._bindStream = function(a) {
    var o = this;
    (this._stream = a).pause(), a.on("data", function(l) {
      o.push({ data: l, meta: { percent: 0 } });
    }).on("error", function(l) {
      o.isPaused ? this.generatedError = l : o.error(l);
    }).on("end", function() {
      o.isPaused ? o._upstreamEnded = !0 : o.end();
    });
  }, s.prototype.pause = function() {
    return !!r.prototype.pause.call(this) && (this._stream.pause(), !0);
  }, s.prototype.resume = function() {
    return !!r.prototype.resume.call(this) && (this._upstreamEnded ? this.end() : this._stream.resume(), !0);
  }, t.exports = s;
}, { "../stream/GenericWorker": 28, "../utils": 32 }], 13: [function(i, t, e) {
  var n = i("readable-stream").Readable;
  function r(s, a, o) {
    n.call(this, a), this._helper = s;
    var l = this;
    s.on("data", function(c, u) {
      l.push(c) || l._helper.pause(), o && o(u);
    }).on("error", function(c) {
      l.emit("error", c);
    }).on("end", function() {
      l.push(null);
    });
  }
  i("../utils").inherits(r, n), r.prototype._read = function() {
    this._helper.resume();
  }, t.exports = r;
}, { "../utils": 32, "readable-stream": 16 }], 14: [function(i, t, e) {
  t.exports = { isNode: typeof Buffer < "u", newBufferFrom: function(n, r) {
    if (Buffer.from && Buffer.from !== Uint8Array.from)
      return Buffer.from(n, r);
    if (typeof n == "number")
      throw new Error('The "data" argument must not be a number');
    return new Buffer(n, r);
  }, allocBuffer: function(n) {
    if (Buffer.alloc)
      return Buffer.alloc(n);
    var r = new Buffer(n);
    return r.fill(0), r;
  }, isBuffer: function(n) {
    return Buffer.isBuffer(n);
  }, isStream: function(n) {
    return n && typeof n.on == "function" && typeof n.pause == "function" && typeof n.resume == "function";
  } };
}, {}], 15: [function(i, t, e) {
  function n(b, T, M) {
    var A, C = s.getTypeOf(T), I = s.extend(M || {}, l);
    I.date = I.date || /* @__PURE__ */ new Date(), I.compression !== null && (I.compression = I.compression.toUpperCase()), typeof I.unixPermissions == "string" && (I.unixPermissions = parseInt(I.unixPermissions, 8)), I.unixPermissions && 16384 & I.unixPermissions && (I.dir = !0), I.dosPermissions && 16 & I.dosPermissions && (I.dir = !0), I.dir && (b = m(b)), I.createFolders && (A = v(b)) && y.call(this, A, !0);
    var k = C === "string" && I.binary === !1 && I.base64 === !1;
    M && M.binary !== void 0 || (I.binary = !k), (T instanceof c && T.uncompressedSize === 0 || I.dir || !T || T.length === 0) && (I.base64 = !1, I.binary = !0, T = "", I.compression = "STORE", C = "string");
    var R = null;
    R = T instanceof c || T instanceof a ? T : p.isNode && p.isStream(T) ? new f(b, T) : s.prepareContent(b, T, I.binary, I.optimizedBinaryString, I.base64);
    var L = new u(b, R, I);
    this.files[b] = L;
  }
  var r = i("./utf8"), s = i("./utils"), a = i("./stream/GenericWorker"), o = i("./stream/StreamHelper"), l = i("./defaults"), c = i("./compressedObject"), u = i("./zipObject"), h = i("./generate"), p = i("./nodejsUtils"), f = i("./nodejs/NodejsStreamInputAdapter"), v = function(b) {
    b.slice(-1) === "/" && (b = b.substring(0, b.length - 1));
    var T = b.lastIndexOf("/");
    return 0 < T ? b.substring(0, T) : "";
  }, m = function(b) {
    return b.slice(-1) !== "/" && (b += "/"), b;
  }, y = function(b, T) {
    return T = T !== void 0 ? T : l.createFolders, b = m(b), this.files[b] || n.call(this, b, null, { dir: !0, createFolders: T }), this.files[b];
  };
  function _(b) {
    return Object.prototype.toString.call(b) === "[object RegExp]";
  }
  var w = { load: function() {
    throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
  }, forEach: function(b) {
    var T, M, A;
    for (T in this.files)
      A = this.files[T], (M = T.slice(this.root.length, T.length)) && T.slice(0, this.root.length) === this.root && b(M, A);
  }, filter: function(b) {
    var T = [];
    return this.forEach(function(M, A) {
      b(M, A) && T.push(A);
    }), T;
  }, file: function(b, T, M) {
    if (arguments.length !== 1)
      return b = this.root + b, n.call(this, b, T, M), this;
    if (_(b)) {
      var A = b;
      return this.filter(function(I, k) {
        return !k.dir && A.test(I);
      });
    }
    var C = this.files[this.root + b];
    return C && !C.dir ? C : null;
  }, folder: function(b) {
    if (!b)
      return this;
    if (_(b))
      return this.filter(function(C, I) {
        return I.dir && b.test(C);
      });
    var T = this.root + b, M = y.call(this, T), A = this.clone();
    return A.root = M.name, A;
  }, remove: function(b) {
    b = this.root + b;
    var T = this.files[b];
    if (T || (b.slice(-1) !== "/" && (b += "/"), T = this.files[b]), T && !T.dir)
      delete this.files[b];
    else
      for (var M = this.filter(function(C, I) {
        return I.name.slice(0, b.length) === b;
      }), A = 0; A < M.length; A++)
        delete this.files[M[A].name];
    return this;
  }, generate: function() {
    throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
  }, generateInternalStream: function(b) {
    var T, M = {};
    try {
      if ((M = s.extend(b || {}, { streamFiles: !1, compression: "STORE", compressionOptions: null, type: "", platform: "DOS", comment: null, mimeType: "application/zip", encodeFileName: r.utf8encode })).type = M.type.toLowerCase(), M.compression = M.compression.toUpperCase(), M.type === "binarystring" && (M.type = "string"), !M.type)
        throw new Error("No output type specified.");
      s.checkSupport(M.type), M.platform !== "darwin" && M.platform !== "freebsd" && M.platform !== "linux" && M.platform !== "sunos" || (M.platform = "UNIX"), M.platform === "win32" && (M.platform = "DOS");
      var A = M.comment || this.comment || "";
      T = h.generateWorker(this, M, A);
    } catch (C) {
      (T = new a("error")).error(C);
    }
    return new o(T, M.type || "string", M.mimeType);
  }, generateAsync: function(b, T) {
    return this.generateInternalStream(b).accumulate(T);
  }, generateNodeStream: function(b, T) {
    return (b = b || {}).type || (b.type = "nodebuffer"), this.generateInternalStream(b).toNodejsStream(T);
  } };
  t.exports = w;
}, { "./compressedObject": 2, "./defaults": 5, "./generate": 9, "./nodejs/NodejsStreamInputAdapter": 12, "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31, "./utils": 32, "./zipObject": 35 }], 16: [function(i, t, e) {
  t.exports = i("stream");
}, { stream: void 0 }], 17: [function(i, t, e) {
  var n = i("./DataReader");
  function r(s) {
    n.call(this, s);
    for (var a = 0; a < this.data.length; a++)
      s[a] = 255 & s[a];
  }
  i("../utils").inherits(r, n), r.prototype.byteAt = function(s) {
    return this.data[this.zero + s];
  }, r.prototype.lastIndexOfSignature = function(s) {
    for (var a = s.charCodeAt(0), o = s.charCodeAt(1), l = s.charCodeAt(2), c = s.charCodeAt(3), u = this.length - 4; 0 <= u; --u)
      if (this.data[u] === a && this.data[u + 1] === o && this.data[u + 2] === l && this.data[u + 3] === c)
        return u - this.zero;
    return -1;
  }, r.prototype.readAndCheckSignature = function(s) {
    var a = s.charCodeAt(0), o = s.charCodeAt(1), l = s.charCodeAt(2), c = s.charCodeAt(3), u = this.readData(4);
    return a === u[0] && o === u[1] && l === u[2] && c === u[3];
  }, r.prototype.readData = function(s) {
    if (this.checkOffset(s), s === 0)
      return [];
    var a = this.data.slice(this.zero + this.index, this.zero + this.index + s);
    return this.index += s, a;
  }, t.exports = r;
}, { "../utils": 32, "./DataReader": 18 }], 18: [function(i, t, e) {
  var n = i("../utils");
  function r(s) {
    this.data = s, this.length = s.length, this.index = 0, this.zero = 0;
  }
  r.prototype = { checkOffset: function(s) {
    this.checkIndex(this.index + s);
  }, checkIndex: function(s) {
    if (this.length < this.zero + s || s < 0)
      throw new Error("End of data reached (data length = " + this.length + ", asked index = " + s + "). Corrupted zip ?");
  }, setIndex: function(s) {
    this.checkIndex(s), this.index = s;
  }, skip: function(s) {
    this.setIndex(this.index + s);
  }, byteAt: function() {
  }, readInt: function(s) {
    var a, o = 0;
    for (this.checkOffset(s), a = this.index + s - 1; a >= this.index; a--)
      o = (o << 8) + this.byteAt(a);
    return this.index += s, o;
  }, readString: function(s) {
    return n.transformTo("string", this.readData(s));
  }, readData: function() {
  }, lastIndexOfSignature: function() {
  }, readAndCheckSignature: function() {
  }, readDate: function() {
    var s = this.readInt(4);
    return new Date(Date.UTC(1980 + (s >> 25 & 127), (s >> 21 & 15) - 1, s >> 16 & 31, s >> 11 & 31, s >> 5 & 63, (31 & s) << 1));
  } }, t.exports = r;
}, { "../utils": 32 }], 19: [function(i, t, e) {
  var n = i("./Uint8ArrayReader");
  function r(s) {
    n.call(this, s);
  }
  i("../utils").inherits(r, n), r.prototype.readData = function(s) {
    this.checkOffset(s);
    var a = this.data.slice(this.zero + this.index, this.zero + this.index + s);
    return this.index += s, a;
  }, t.exports = r;
}, { "../utils": 32, "./Uint8ArrayReader": 21 }], 20: [function(i, t, e) {
  var n = i("./DataReader");
  function r(s) {
    n.call(this, s);
  }
  i("../utils").inherits(r, n), r.prototype.byteAt = function(s) {
    return this.data.charCodeAt(this.zero + s);
  }, r.prototype.lastIndexOfSignature = function(s) {
    return this.data.lastIndexOf(s) - this.zero;
  }, r.prototype.readAndCheckSignature = function(s) {
    return s === this.readData(4);
  }, r.prototype.readData = function(s) {
    this.checkOffset(s);
    var a = this.data.slice(this.zero + this.index, this.zero + this.index + s);
    return this.index += s, a;
  }, t.exports = r;
}, { "../utils": 32, "./DataReader": 18 }], 21: [function(i, t, e) {
  var n = i("./ArrayReader");
  function r(s) {
    n.call(this, s);
  }
  i("../utils").inherits(r, n), r.prototype.readData = function(s) {
    if (this.checkOffset(s), s === 0)
      return new Uint8Array(0);
    var a = this.data.subarray(this.zero + this.index, this.zero + this.index + s);
    return this.index += s, a;
  }, t.exports = r;
}, { "../utils": 32, "./ArrayReader": 17 }], 22: [function(i, t, e) {
  var n = i("../utils"), r = i("../support"), s = i("./ArrayReader"), a = i("./StringReader"), o = i("./NodeBufferReader"), l = i("./Uint8ArrayReader");
  t.exports = function(c) {
    var u = n.getTypeOf(c);
    return n.checkSupport(u), u !== "string" || r.uint8array ? u === "nodebuffer" ? new o(c) : r.uint8array ? new l(n.transformTo("uint8array", c)) : new s(n.transformTo("array", c)) : new a(c);
  };
}, { "../support": 30, "../utils": 32, "./ArrayReader": 17, "./NodeBufferReader": 19, "./StringReader": 20, "./Uint8ArrayReader": 21 }], 23: [function(i, t, e) {
  e.LOCAL_FILE_HEADER = "PK", e.CENTRAL_FILE_HEADER = "PK", e.CENTRAL_DIRECTORY_END = "PK", e.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07", e.ZIP64_CENTRAL_DIRECTORY_END = "PK", e.DATA_DESCRIPTOR = "PK\x07\b";
}, {}], 24: [function(i, t, e) {
  var n = i("./GenericWorker"), r = i("../utils");
  function s(a) {
    n.call(this, "ConvertWorker to " + a), this.destType = a;
  }
  r.inherits(s, n), s.prototype.processChunk = function(a) {
    this.push({ data: r.transformTo(this.destType, a.data), meta: a.meta });
  }, t.exports = s;
}, { "../utils": 32, "./GenericWorker": 28 }], 25: [function(i, t, e) {
  var n = i("./GenericWorker"), r = i("../crc32");
  function s() {
    n.call(this, "Crc32Probe"), this.withStreamInfo("crc32", 0);
  }
  i("../utils").inherits(s, n), s.prototype.processChunk = function(a) {
    this.streamInfo.crc32 = r(a.data, this.streamInfo.crc32 || 0), this.push(a);
  }, t.exports = s;
}, { "../crc32": 4, "../utils": 32, "./GenericWorker": 28 }], 26: [function(i, t, e) {
  var n = i("../utils"), r = i("./GenericWorker");
  function s(a) {
    r.call(this, "DataLengthProbe for " + a), this.propName = a, this.withStreamInfo(a, 0);
  }
  n.inherits(s, r), s.prototype.processChunk = function(a) {
    if (a) {
      var o = this.streamInfo[this.propName] || 0;
      this.streamInfo[this.propName] = o + a.data.length;
    }
    r.prototype.processChunk.call(this, a);
  }, t.exports = s;
}, { "../utils": 32, "./GenericWorker": 28 }], 27: [function(i, t, e) {
  var n = i("../utils"), r = i("./GenericWorker");
  function s(a) {
    r.call(this, "DataWorker");
    var o = this;
    this.dataIsReady = !1, this.index = 0, this.max = 0, this.data = null, this.type = "", this._tickScheduled = !1, a.then(function(l) {
      o.dataIsReady = !0, o.data = l, o.max = l && l.length || 0, o.type = n.getTypeOf(l), o.isPaused || o._tickAndRepeat();
    }, function(l) {
      o.error(l);
    });
  }
  n.inherits(s, r), s.prototype.cleanUp = function() {
    r.prototype.cleanUp.call(this), this.data = null;
  }, s.prototype.resume = function() {
    return !!r.prototype.resume.call(this) && (!this._tickScheduled && this.dataIsReady && (this._tickScheduled = !0, n.delay(this._tickAndRepeat, [], this)), !0);
  }, s.prototype._tickAndRepeat = function() {
    this._tickScheduled = !1, this.isPaused || this.isFinished || (this._tick(), this.isFinished || (n.delay(this._tickAndRepeat, [], this), this._tickScheduled = !0));
  }, s.prototype._tick = function() {
    if (this.isPaused || this.isFinished)
      return !1;
    var a = null, o = Math.min(this.max, this.index + 16384);
    if (this.index >= this.max)
      return this.end();
    switch (this.type) {
      case "string":
        a = this.data.substring(this.index, o);
        break;
      case "uint8array":
        a = this.data.subarray(this.index, o);
        break;
      case "array":
      case "nodebuffer":
        a = this.data.slice(this.index, o);
    }
    return this.index = o, this.push({ data: a, meta: { percent: this.max ? this.index / this.max * 100 : 0 } });
  }, t.exports = s;
}, { "../utils": 32, "./GenericWorker": 28 }], 28: [function(i, t, e) {
  function n(r) {
    this.name = r || "default", this.streamInfo = {}, this.generatedError = null, this.extraStreamInfo = {}, this.isPaused = !0, this.isFinished = !1, this.isLocked = !1, this._listeners = { data: [], end: [], error: [] }, this.previous = null;
  }
  n.prototype = { push: function(r) {
    this.emit("data", r);
  }, end: function() {
    if (this.isFinished)
      return !1;
    this.flush();
    try {
      this.emit("end"), this.cleanUp(), this.isFinished = !0;
    } catch (r) {
      this.emit("error", r);
    }
    return !0;
  }, error: function(r) {
    return !this.isFinished && (this.isPaused ? this.generatedError = r : (this.isFinished = !0, this.emit("error", r), this.previous && this.previous.error(r), this.cleanUp()), !0);
  }, on: function(r, s) {
    return this._listeners[r].push(s), this;
  }, cleanUp: function() {
    this.streamInfo = this.generatedError = this.extraStreamInfo = null, this._listeners = [];
  }, emit: function(r, s) {
    if (this._listeners[r])
      for (var a = 0; a < this._listeners[r].length; a++)
        this._listeners[r][a].call(this, s);
  }, pipe: function(r) {
    return r.registerPrevious(this);
  }, registerPrevious: function(r) {
    if (this.isLocked)
      throw new Error("The stream '" + this + "' has already been used.");
    this.streamInfo = r.streamInfo, this.mergeStreamInfo(), this.previous = r;
    var s = this;
    return r.on("data", function(a) {
      s.processChunk(a);
    }), r.on("end", function() {
      s.end();
    }), r.on("error", function(a) {
      s.error(a);
    }), this;
  }, pause: function() {
    return !this.isPaused && !this.isFinished && (this.isPaused = !0, this.previous && this.previous.pause(), !0);
  }, resume: function() {
    if (!this.isPaused || this.isFinished)
      return !1;
    var r = this.isPaused = !1;
    return this.generatedError && (this.error(this.generatedError), r = !0), this.previous && this.previous.resume(), !r;
  }, flush: function() {
  }, processChunk: function(r) {
    this.push(r);
  }, withStreamInfo: function(r, s) {
    return this.extraStreamInfo[r] = s, this.mergeStreamInfo(), this;
  }, mergeStreamInfo: function() {
    for (var r in this.extraStreamInfo)
      Object.prototype.hasOwnProperty.call(this.extraStreamInfo, r) && (this.streamInfo[r] = this.extraStreamInfo[r]);
  }, lock: function() {
    if (this.isLocked)
      throw new Error("The stream '" + this + "' has already been used.");
    this.isLocked = !0, this.previous && this.previous.lock();
  }, toString: function() {
    var r = "Worker " + this.name;
    return this.previous ? this.previous + " -> " + r : r;
  } }, t.exports = n;
}, {}], 29: [function(i, t, e) {
  var n = i("../utils"), r = i("./ConvertWorker"), s = i("./GenericWorker"), a = i("../base64"), o = i("../support"), l = i("../external"), c = null;
  if (o.nodestream)
    try {
      c = i("../nodejs/NodejsStreamOutputAdapter");
    } catch {
    }
  function u(p, f) {
    return new l.Promise(function(v, m) {
      var y = [], _ = p._internalType, w = p._outputType, b = p._mimeType;
      p.on("data", function(T, M) {
        y.push(T), f && f(M);
      }).on("error", function(T) {
        y = [], m(T);
      }).on("end", function() {
        try {
          var T = function(M, A, C) {
            switch (M) {
              case "blob":
                return n.newBlob(n.transformTo("arraybuffer", A), C);
              case "base64":
                return a.encode(A);
              default:
                return n.transformTo(M, A);
            }
          }(w, function(M, A) {
            var C, I = 0, k = null, R = 0;
            for (C = 0; C < A.length; C++)
              R += A[C].length;
            switch (M) {
              case "string":
                return A.join("");
              case "array":
                return Array.prototype.concat.apply([], A);
              case "uint8array":
                for (k = new Uint8Array(R), C = 0; C < A.length; C++)
                  k.set(A[C], I), I += A[C].length;
                return k;
              case "nodebuffer":
                return Buffer.concat(A);
              default:
                throw new Error("concat : unsupported type '" + M + "'");
            }
          }(_, y), b);
          v(T);
        } catch (M) {
          m(M);
        }
        y = [];
      }).resume();
    });
  }
  function h(p, f, v) {
    var m = f;
    switch (f) {
      case "blob":
      case "arraybuffer":
        m = "uint8array";
        break;
      case "base64":
        m = "string";
    }
    try {
      this._internalType = m, this._outputType = f, this._mimeType = v, n.checkSupport(m), this._worker = p.pipe(new r(m)), p.lock();
    } catch (y) {
      this._worker = new s("error"), this._worker.error(y);
    }
  }
  h.prototype = { accumulate: function(p) {
    return u(this, p);
  }, on: function(p, f) {
    var v = this;
    return p === "data" ? this._worker.on(p, function(m) {
      f.call(v, m.data, m.meta);
    }) : this._worker.on(p, function() {
      n.delay(f, arguments, v);
    }), this;
  }, resume: function() {
    return n.delay(this._worker.resume, [], this._worker), this;
  }, pause: function() {
    return this._worker.pause(), this;
  }, toNodejsStream: function(p) {
    if (n.checkSupport("nodestream"), this._outputType !== "nodebuffer")
      throw new Error(this._outputType + " is not supported by this method");
    return new c(this, { objectMode: this._outputType !== "nodebuffer" }, p);
  } }, t.exports = h;
}, { "../base64": 1, "../external": 6, "../nodejs/NodejsStreamOutputAdapter": 13, "../support": 30, "../utils": 32, "./ConvertWorker": 24, "./GenericWorker": 28 }], 30: [function(i, t, e) {
  if (e.base64 = !0, e.array = !0, e.string = !0, e.arraybuffer = typeof ArrayBuffer < "u" && typeof Uint8Array < "u", e.nodebuffer = typeof Buffer < "u", e.uint8array = typeof Uint8Array < "u", typeof ArrayBuffer > "u")
    e.blob = !1;
  else {
    var n = new ArrayBuffer(0);
    try {
      e.blob = new Blob([n], { type: "application/zip" }).size === 0;
    } catch {
      try {
        var r = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
        r.append(n), e.blob = r.getBlob("application/zip").size === 0;
      } catch {
        e.blob = !1;
      }
    }
  }
  try {
    e.nodestream = !!i("readable-stream").Readable;
  } catch {
    e.nodestream = !1;
  }
}, { "readable-stream": 16 }], 31: [function(i, t, e) {
  for (var n = i("./utils"), r = i("./support"), s = i("./nodejsUtils"), a = i("./stream/GenericWorker"), o = new Array(256), l = 0; l < 256; l++)
    o[l] = 252 <= l ? 6 : 248 <= l ? 5 : 240 <= l ? 4 : 224 <= l ? 3 : 192 <= l ? 2 : 1;
  function c() {
    a.call(this, "utf-8 decode"), this.leftOver = null;
  }
  function u() {
    a.call(this, "utf-8 encode");
  }
  o[254] = o[254] = 1, e.utf8encode = function(h) {
    return r.nodebuffer ? s.newBufferFrom(h, "utf-8") : function(p) {
      var f, v, m, y, _, w = p.length, b = 0;
      for (y = 0; y < w; y++)
        (64512 & (v = p.charCodeAt(y))) == 55296 && y + 1 < w && (64512 & (m = p.charCodeAt(y + 1))) == 56320 && (v = 65536 + (v - 55296 << 10) + (m - 56320), y++), b += v < 128 ? 1 : v < 2048 ? 2 : v < 65536 ? 3 : 4;
      for (f = r.uint8array ? new Uint8Array(b) : new Array(b), y = _ = 0; _ < b; y++)
        (64512 & (v = p.charCodeAt(y))) == 55296 && y + 1 < w && (64512 & (m = p.charCodeAt(y + 1))) == 56320 && (v = 65536 + (v - 55296 << 10) + (m - 56320), y++), v < 128 ? f[_++] = v : (v < 2048 ? f[_++] = 192 | v >>> 6 : (v < 65536 ? f[_++] = 224 | v >>> 12 : (f[_++] = 240 | v >>> 18, f[_++] = 128 | v >>> 12 & 63), f[_++] = 128 | v >>> 6 & 63), f[_++] = 128 | 63 & v);
      return f;
    }(h);
  }, e.utf8decode = function(h) {
    return r.nodebuffer ? n.transformTo("nodebuffer", h).toString("utf-8") : function(p) {
      var f, v, m, y, _ = p.length, w = new Array(2 * _);
      for (f = v = 0; f < _; )
        if ((m = p[f++]) < 128)
          w[v++] = m;
        else if (4 < (y = o[m]))
          w[v++] = 65533, f += y - 1;
        else {
          for (m &= y === 2 ? 31 : y === 3 ? 15 : 7; 1 < y && f < _; )
            m = m << 6 | 63 & p[f++], y--;
          1 < y ? w[v++] = 65533 : m < 65536 ? w[v++] = m : (m -= 65536, w[v++] = 55296 | m >> 10 & 1023, w[v++] = 56320 | 1023 & m);
        }
      return w.length !== v && (w.subarray ? w = w.subarray(0, v) : w.length = v), n.applyFromCharCode(w);
    }(h = n.transformTo(r.uint8array ? "uint8array" : "array", h));
  }, n.inherits(c, a), c.prototype.processChunk = function(h) {
    var p = n.transformTo(r.uint8array ? "uint8array" : "array", h.data);
    if (this.leftOver && this.leftOver.length) {
      if (r.uint8array) {
        var f = p;
        (p = new Uint8Array(f.length + this.leftOver.length)).set(this.leftOver, 0), p.set(f, this.leftOver.length);
      } else
        p = this.leftOver.concat(p);
      this.leftOver = null;
    }
    var v = function(y, _) {
      var w;
      for ((_ = _ || y.length) > y.length && (_ = y.length), w = _ - 1; 0 <= w && (192 & y[w]) == 128; )
        w--;
      return w < 0 || w === 0 ? _ : w + o[y[w]] > _ ? w : _;
    }(p), m = p;
    v !== p.length && (r.uint8array ? (m = p.subarray(0, v), this.leftOver = p.subarray(v, p.length)) : (m = p.slice(0, v), this.leftOver = p.slice(v, p.length))), this.push({ data: e.utf8decode(m), meta: h.meta });
  }, c.prototype.flush = function() {
    this.leftOver && this.leftOver.length && (this.push({ data: e.utf8decode(this.leftOver), meta: {} }), this.leftOver = null);
  }, e.Utf8DecodeWorker = c, n.inherits(u, a), u.prototype.processChunk = function(h) {
    this.push({ data: e.utf8encode(h.data), meta: h.meta });
  }, e.Utf8EncodeWorker = u;
}, { "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./support": 30, "./utils": 32 }], 32: [function(i, t, e) {
  var n = i("./support"), r = i("./base64"), s = i("./nodejsUtils"), a = i("./external");
  function o(f) {
    return f;
  }
  function l(f, v) {
    for (var m = 0; m < f.length; ++m)
      v[m] = 255 & f.charCodeAt(m);
    return v;
  }
  i("setimmediate"), e.newBlob = function(f, v) {
    e.checkSupport("blob");
    try {
      return new Blob([f], { type: v });
    } catch {
      try {
        var m = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
        return m.append(f), m.getBlob(v);
      } catch {
        throw new Error("Bug : can't construct the Blob.");
      }
    }
  };
  var c = { stringifyByChunk: function(f, v, m) {
    var y = [], _ = 0, w = f.length;
    if (w <= m)
      return String.fromCharCode.apply(null, f);
    for (; _ < w; )
      v === "array" || v === "nodebuffer" ? y.push(String.fromCharCode.apply(null, f.slice(_, Math.min(_ + m, w)))) : y.push(String.fromCharCode.apply(null, f.subarray(_, Math.min(_ + m, w)))), _ += m;
    return y.join("");
  }, stringifyByChar: function(f) {
    for (var v = "", m = 0; m < f.length; m++)
      v += String.fromCharCode(f[m]);
    return v;
  }, applyCanBeUsed: { uint8array: function() {
    try {
      return n.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;
    } catch {
      return !1;
    }
  }(), nodebuffer: function() {
    try {
      return n.nodebuffer && String.fromCharCode.apply(null, s.allocBuffer(1)).length === 1;
    } catch {
      return !1;
    }
  }() } };
  function u(f) {
    var v = 65536, m = e.getTypeOf(f), y = !0;
    if (m === "uint8array" ? y = c.applyCanBeUsed.uint8array : m === "nodebuffer" && (y = c.applyCanBeUsed.nodebuffer), y)
      for (; 1 < v; )
        try {
          return c.stringifyByChunk(f, m, v);
        } catch {
          v = Math.floor(v / 2);
        }
    return c.stringifyByChar(f);
  }
  function h(f, v) {
    for (var m = 0; m < f.length; m++)
      v[m] = f[m];
    return v;
  }
  e.applyFromCharCode = u;
  var p = {};
  p.string = { string: o, array: function(f) {
    return l(f, new Array(f.length));
  }, arraybuffer: function(f) {
    return p.string.uint8array(f).buffer;
  }, uint8array: function(f) {
    return l(f, new Uint8Array(f.length));
  }, nodebuffer: function(f) {
    return l(f, s.allocBuffer(f.length));
  } }, p.array = { string: u, array: o, arraybuffer: function(f) {
    return new Uint8Array(f).buffer;
  }, uint8array: function(f) {
    return new Uint8Array(f);
  }, nodebuffer: function(f) {
    return s.newBufferFrom(f);
  } }, p.arraybuffer = { string: function(f) {
    return u(new Uint8Array(f));
  }, array: function(f) {
    return h(new Uint8Array(f), new Array(f.byteLength));
  }, arraybuffer: o, uint8array: function(f) {
    return new Uint8Array(f);
  }, nodebuffer: function(f) {
    return s.newBufferFrom(new Uint8Array(f));
  } }, p.uint8array = { string: u, array: function(f) {
    return h(f, new Array(f.length));
  }, arraybuffer: function(f) {
    return f.buffer;
  }, uint8array: o, nodebuffer: function(f) {
    return s.newBufferFrom(f);
  } }, p.nodebuffer = { string: u, array: function(f) {
    return h(f, new Array(f.length));
  }, arraybuffer: function(f) {
    return p.nodebuffer.uint8array(f).buffer;
  }, uint8array: function(f) {
    return h(f, new Uint8Array(f.length));
  }, nodebuffer: o }, e.transformTo = function(f, v) {
    if (v = v || "", !f)
      return v;
    e.checkSupport(f);
    var m = e.getTypeOf(v);
    return p[m][f](v);
  }, e.resolve = function(f) {
    for (var v = f.split("/"), m = [], y = 0; y < v.length; y++) {
      var _ = v[y];
      _ === "." || _ === "" && y !== 0 && y !== v.length - 1 || (_ === ".." ? m.pop() : m.push(_));
    }
    return m.join("/");
  }, e.getTypeOf = function(f) {
    return typeof f == "string" ? "string" : Object.prototype.toString.call(f) === "[object Array]" ? "array" : n.nodebuffer && s.isBuffer(f) ? "nodebuffer" : n.uint8array && f instanceof Uint8Array ? "uint8array" : n.arraybuffer && f instanceof ArrayBuffer ? "arraybuffer" : void 0;
  }, e.checkSupport = function(f) {
    if (!n[f.toLowerCase()])
      throw new Error(f + " is not supported by this platform");
  }, e.MAX_VALUE_16BITS = 65535, e.MAX_VALUE_32BITS = -1, e.pretty = function(f) {
    var v, m, y = "";
    for (m = 0; m < (f || "").length; m++)
      y += "\\x" + ((v = f.charCodeAt(m)) < 16 ? "0" : "") + v.toString(16).toUpperCase();
    return y;
  }, e.delay = function(f, v, m) {
    setImmediate(function() {
      f.apply(m || null, v || []);
    });
  }, e.inherits = function(f, v) {
    function m() {
    }
    m.prototype = v.prototype, f.prototype = new m();
  }, e.extend = function() {
    var f, v, m = {};
    for (f = 0; f < arguments.length; f++)
      for (v in arguments[f])
        Object.prototype.hasOwnProperty.call(arguments[f], v) && m[v] === void 0 && (m[v] = arguments[f][v]);
    return m;
  }, e.prepareContent = function(f, v, m, y, _) {
    return a.Promise.resolve(v).then(function(w) {
      return n.blob && (w instanceof Blob || ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(w)) !== -1) && typeof FileReader < "u" ? new a.Promise(function(b, T) {
        var M = new FileReader();
        M.onload = function(A) {
          b(A.target.result);
        }, M.onerror = function(A) {
          T(A.target.error);
        }, M.readAsArrayBuffer(w);
      }) : w;
    }).then(function(w) {
      var b = e.getTypeOf(w);
      return b ? (b === "arraybuffer" ? w = e.transformTo("uint8array", w) : b === "string" && (_ ? w = r.decode(w) : m && y !== !0 && (w = function(T) {
        return l(T, n.uint8array ? new Uint8Array(T.length) : new Array(T.length));
      }(w))), w) : a.Promise.reject(new Error("Can't read the data of '" + f + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
    });
  };
}, { "./base64": 1, "./external": 6, "./nodejsUtils": 14, "./support": 30, setimmediate: 54 }], 33: [function(i, t, e) {
  var n = i("./reader/readerFor"), r = i("./utils"), s = i("./signature"), a = i("./zipEntry"), o = i("./support");
  function l(c) {
    this.files = [], this.loadOptions = c;
  }
  l.prototype = { checkSignature: function(c) {
    if (!this.reader.readAndCheckSignature(c)) {
      this.reader.index -= 4;
      var u = this.reader.readString(4);
      throw new Error("Corrupted zip or bug: unexpected signature (" + r.pretty(u) + ", expected " + r.pretty(c) + ")");
    }
  }, isSignature: function(c, u) {
    var h = this.reader.index;
    this.reader.setIndex(c);
    var p = this.reader.readString(4) === u;
    return this.reader.setIndex(h), p;
  }, readBlockEndOfCentral: function() {
    this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2);
    var c = this.reader.readData(this.zipCommentLength), u = o.uint8array ? "uint8array" : "array", h = r.transformTo(u, c);
    this.zipComment = this.loadOptions.decodeFileName(h);
  }, readBlockZip64EndOfCentral: function() {
    this.zip64EndOfCentralSize = this.reader.readInt(8), this.reader.skip(4), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {};
    for (var c, u, h, p = this.zip64EndOfCentralSize - 44; 0 < p; )
      c = this.reader.readInt(2), u = this.reader.readInt(4), h = this.reader.readData(u), this.zip64ExtensibleData[c] = { id: c, length: u, value: h };
  }, readBlockZip64EndOfCentralLocator: function() {
    if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), 1 < this.disksCount)
      throw new Error("Multi-volumes zip are not supported");
  }, readLocalFiles: function() {
    var c, u;
    for (c = 0; c < this.files.length; c++)
      u = this.files[c], this.reader.setIndex(u.localHeaderOffset), this.checkSignature(s.LOCAL_FILE_HEADER), u.readLocalPart(this.reader), u.handleUTF8(), u.processAttributes();
  }, readCentralDir: function() {
    var c;
    for (this.reader.setIndex(this.centralDirOffset); this.reader.readAndCheckSignature(s.CENTRAL_FILE_HEADER); )
      (c = new a({ zip64: this.zip64 }, this.loadOptions)).readCentralPart(this.reader), this.files.push(c);
    if (this.centralDirRecords !== this.files.length && this.centralDirRecords !== 0 && this.files.length === 0)
      throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
  }, readEndOfCentral: function() {
    var c = this.reader.lastIndexOfSignature(s.CENTRAL_DIRECTORY_END);
    if (c < 0)
      throw this.isSignature(0, s.LOCAL_FILE_HEADER) ? new Error("Corrupted zip: can't find end of central directory") : new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html");
    this.reader.setIndex(c);
    var u = c;
    if (this.checkSignature(s.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === r.MAX_VALUE_16BITS || this.diskWithCentralDirStart === r.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === r.MAX_VALUE_16BITS || this.centralDirRecords === r.MAX_VALUE_16BITS || this.centralDirSize === r.MAX_VALUE_32BITS || this.centralDirOffset === r.MAX_VALUE_32BITS) {
      if (this.zip64 = !0, (c = this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR)) < 0)
        throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
      if (this.reader.setIndex(c), this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, s.ZIP64_CENTRAL_DIRECTORY_END) && (this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_END), this.relativeOffsetEndOfZip64CentralDir < 0))
        throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
      this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral();
    }
    var h = this.centralDirOffset + this.centralDirSize;
    this.zip64 && (h += 20, h += 12 + this.zip64EndOfCentralSize);
    var p = u - h;
    if (0 < p)
      this.isSignature(u, s.CENTRAL_FILE_HEADER) || (this.reader.zero = p);
    else if (p < 0)
      throw new Error("Corrupted zip: missing " + Math.abs(p) + " bytes.");
  }, prepareReader: function(c) {
    this.reader = n(c);
  }, load: function(c) {
    this.prepareReader(c), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles();
  } }, t.exports = l;
}, { "./reader/readerFor": 22, "./signature": 23, "./support": 30, "./utils": 32, "./zipEntry": 34 }], 34: [function(i, t, e) {
  var n = i("./reader/readerFor"), r = i("./utils"), s = i("./compressedObject"), a = i("./crc32"), o = i("./utf8"), l = i("./compressions"), c = i("./support");
  function u(h, p) {
    this.options = h, this.loadOptions = p;
  }
  u.prototype = { isEncrypted: function() {
    return (1 & this.bitFlag) == 1;
  }, useUTF8: function() {
    return (2048 & this.bitFlag) == 2048;
  }, readLocalPart: function(h) {
    var p, f;
    if (h.skip(22), this.fileNameLength = h.readInt(2), f = h.readInt(2), this.fileName = h.readData(this.fileNameLength), h.skip(f), this.compressedSize === -1 || this.uncompressedSize === -1)
      throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
    if ((p = function(v) {
      for (var m in l)
        if (Object.prototype.hasOwnProperty.call(l, m) && l[m].magic === v)
          return l[m];
      return null;
    }(this.compressionMethod)) === null)
      throw new Error("Corrupted zip : compression " + r.pretty(this.compressionMethod) + " unknown (inner file : " + r.transformTo("string", this.fileName) + ")");
    this.decompressed = new s(this.compressedSize, this.uncompressedSize, this.crc32, p, h.readData(this.compressedSize));
  }, readCentralPart: function(h) {
    this.versionMadeBy = h.readInt(2), h.skip(2), this.bitFlag = h.readInt(2), this.compressionMethod = h.readString(2), this.date = h.readDate(), this.crc32 = h.readInt(4), this.compressedSize = h.readInt(4), this.uncompressedSize = h.readInt(4);
    var p = h.readInt(2);
    if (this.extraFieldsLength = h.readInt(2), this.fileCommentLength = h.readInt(2), this.diskNumberStart = h.readInt(2), this.internalFileAttributes = h.readInt(2), this.externalFileAttributes = h.readInt(4), this.localHeaderOffset = h.readInt(4), this.isEncrypted())
      throw new Error("Encrypted zip are not supported");
    h.skip(p), this.readExtraFields(h), this.parseZIP64ExtraField(h), this.fileComment = h.readData(this.fileCommentLength);
  }, processAttributes: function() {
    this.unixPermissions = null, this.dosPermissions = null;
    var h = this.versionMadeBy >> 8;
    this.dir = !!(16 & this.externalFileAttributes), h == 0 && (this.dosPermissions = 63 & this.externalFileAttributes), h == 3 && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), this.dir || this.fileNameStr.slice(-1) !== "/" || (this.dir = !0);
  }, parseZIP64ExtraField: function() {
    if (this.extraFields[1]) {
      var h = n(this.extraFields[1].value);
      this.uncompressedSize === r.MAX_VALUE_32BITS && (this.uncompressedSize = h.readInt(8)), this.compressedSize === r.MAX_VALUE_32BITS && (this.compressedSize = h.readInt(8)), this.localHeaderOffset === r.MAX_VALUE_32BITS && (this.localHeaderOffset = h.readInt(8)), this.diskNumberStart === r.MAX_VALUE_32BITS && (this.diskNumberStart = h.readInt(4));
    }
  }, readExtraFields: function(h) {
    var p, f, v, m = h.index + this.extraFieldsLength;
    for (this.extraFields || (this.extraFields = {}); h.index + 4 < m; )
      p = h.readInt(2), f = h.readInt(2), v = h.readData(f), this.extraFields[p] = { id: p, length: f, value: v };
    h.setIndex(m);
  }, handleUTF8: function() {
    var h = c.uint8array ? "uint8array" : "array";
    if (this.useUTF8())
      this.fileNameStr = o.utf8decode(this.fileName), this.fileCommentStr = o.utf8decode(this.fileComment);
    else {
      var p = this.findExtraFieldUnicodePath();
      if (p !== null)
        this.fileNameStr = p;
      else {
        var f = r.transformTo(h, this.fileName);
        this.fileNameStr = this.loadOptions.decodeFileName(f);
      }
      var v = this.findExtraFieldUnicodeComment();
      if (v !== null)
        this.fileCommentStr = v;
      else {
        var m = r.transformTo(h, this.fileComment);
        this.fileCommentStr = this.loadOptions.decodeFileName(m);
      }
    }
  }, findExtraFieldUnicodePath: function() {
    var h = this.extraFields[28789];
    if (h) {
      var p = n(h.value);
      return p.readInt(1) !== 1 || a(this.fileName) !== p.readInt(4) ? null : o.utf8decode(p.readData(h.length - 5));
    }
    return null;
  }, findExtraFieldUnicodeComment: function() {
    var h = this.extraFields[25461];
    if (h) {
      var p = n(h.value);
      return p.readInt(1) !== 1 || a(this.fileComment) !== p.readInt(4) ? null : o.utf8decode(p.readData(h.length - 5));
    }
    return null;
  } }, t.exports = u;
}, { "./compressedObject": 2, "./compressions": 3, "./crc32": 4, "./reader/readerFor": 22, "./support": 30, "./utf8": 31, "./utils": 32 }], 35: [function(i, t, e) {
  function n(p, f, v) {
    this.name = p, this.dir = v.dir, this.date = v.date, this.comment = v.comment, this.unixPermissions = v.unixPermissions, this.dosPermissions = v.dosPermissions, this._data = f, this._dataBinary = v.binary, this.options = { compression: v.compression, compressionOptions: v.compressionOptions };
  }
  var r = i("./stream/StreamHelper"), s = i("./stream/DataWorker"), a = i("./utf8"), o = i("./compressedObject"), l = i("./stream/GenericWorker");
  n.prototype = { internalStream: function(p) {
    var f = null, v = "string";
    try {
      if (!p)
        throw new Error("No output type specified.");
      var m = (v = p.toLowerCase()) === "string" || v === "text";
      v !== "binarystring" && v !== "text" || (v = "string"), f = this._decompressWorker();
      var y = !this._dataBinary;
      y && !m && (f = f.pipe(new a.Utf8EncodeWorker())), !y && m && (f = f.pipe(new a.Utf8DecodeWorker()));
    } catch (_) {
      (f = new l("error")).error(_);
    }
    return new r(f, v, "");
  }, async: function(p, f) {
    return this.internalStream(p).accumulate(f);
  }, nodeStream: function(p, f) {
    return this.internalStream(p || "nodebuffer").toNodejsStream(f);
  }, _compressWorker: function(p, f) {
    if (this._data instanceof o && this._data.compression.magic === p.magic)
      return this._data.getCompressedWorker();
    var v = this._decompressWorker();
    return this._dataBinary || (v = v.pipe(new a.Utf8EncodeWorker())), o.createWorkerFrom(v, p, f);
  }, _decompressWorker: function() {
    return this._data instanceof o ? this._data.getContentWorker() : this._data instanceof l ? this._data : new s(this._data);
  } };
  for (var c = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"], u = function() {
    throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
  }, h = 0; h < c.length; h++)
    n.prototype[c[h]] = u;
  t.exports = n;
}, { "./compressedObject": 2, "./stream/DataWorker": 27, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31 }], 36: [function(i, t, e) {
  (function(n) {
    var r, s, a = n.MutationObserver || n.WebKitMutationObserver;
    if (a) {
      var o = 0, l = new a(p), c = n.document.createTextNode("");
      l.observe(c, { characterData: !0 }), r = function() {
        c.data = o = ++o % 2;
      };
    } else if (n.setImmediate || n.MessageChannel === void 0)
      r = "document" in n && "onreadystatechange" in n.document.createElement("script") ? function() {
        var f = n.document.createElement("script");
        f.onreadystatechange = function() {
          p(), f.onreadystatechange = null, f.parentNode.removeChild(f), f = null;
        }, n.document.documentElement.appendChild(f);
      } : function() {
        setTimeout(p, 0);
      };
    else {
      var u = new n.MessageChannel();
      u.port1.onmessage = p, r = function() {
        u.port2.postMessage(0);
      };
    }
    var h = [];
    function p() {
      var f, v;
      s = !0;
      for (var m = h.length; m; ) {
        for (v = h, h = [], f = -1; ++f < m; )
          v[f]();
        m = h.length;
      }
      s = !1;
    }
    t.exports = function(f) {
      h.push(f) !== 1 || s || r();
    };
  }).call(this, bn !== void 0 ? bn : typeof self < "u" ? self : typeof window < "u" ? window : {});
}, {}], 37: [function(i, t, e) {
  var n = i("immediate");
  function r() {
  }
  var s = {}, a = ["REJECTED"], o = ["FULFILLED"], l = ["PENDING"];
  function c(m) {
    if (typeof m != "function")
      throw new TypeError("resolver must be a function");
    this.state = l, this.queue = [], this.outcome = void 0, m !== r && f(this, m);
  }
  function u(m, y, _) {
    this.promise = m, typeof y == "function" && (this.onFulfilled = y, this.callFulfilled = this.otherCallFulfilled), typeof _ == "function" && (this.onRejected = _, this.callRejected = this.otherCallRejected);
  }
  function h(m, y, _) {
    n(function() {
      var w;
      try {
        w = y(_);
      } catch (b) {
        return s.reject(m, b);
      }
      w === m ? s.reject(m, new TypeError("Cannot resolve promise with itself")) : s.resolve(m, w);
    });
  }
  function p(m) {
    var y = m && m.then;
    if (m && (typeof m == "object" || typeof m == "function") && typeof y == "function")
      return function() {
        y.apply(m, arguments);
      };
  }
  function f(m, y) {
    var _ = !1;
    function w(M) {
      _ || (_ = !0, s.reject(m, M));
    }
    function b(M) {
      _ || (_ = !0, s.resolve(m, M));
    }
    var T = v(function() {
      y(b, w);
    });
    T.status === "error" && w(T.value);
  }
  function v(m, y) {
    var _ = {};
    try {
      _.value = m(y), _.status = "success";
    } catch (w) {
      _.status = "error", _.value = w;
    }
    return _;
  }
  (t.exports = c).prototype.finally = function(m) {
    if (typeof m != "function")
      return this;
    var y = this.constructor;
    return this.then(function(_) {
      return y.resolve(m()).then(function() {
        return _;
      });
    }, function(_) {
      return y.resolve(m()).then(function() {
        throw _;
      });
    });
  }, c.prototype.catch = function(m) {
    return this.then(null, m);
  }, c.prototype.then = function(m, y) {
    if (typeof m != "function" && this.state === o || typeof y != "function" && this.state === a)
      return this;
    var _ = new this.constructor(r);
    return this.state !== l ? h(_, this.state === o ? m : y, this.outcome) : this.queue.push(new u(_, m, y)), _;
  }, u.prototype.callFulfilled = function(m) {
    s.resolve(this.promise, m);
  }, u.prototype.otherCallFulfilled = function(m) {
    h(this.promise, this.onFulfilled, m);
  }, u.prototype.callRejected = function(m) {
    s.reject(this.promise, m);
  }, u.prototype.otherCallRejected = function(m) {
    h(this.promise, this.onRejected, m);
  }, s.resolve = function(m, y) {
    var _ = v(p, y);
    if (_.status === "error")
      return s.reject(m, _.value);
    var w = _.value;
    if (w)
      f(m, w);
    else {
      m.state = o, m.outcome = y;
      for (var b = -1, T = m.queue.length; ++b < T; )
        m.queue[b].callFulfilled(y);
    }
    return m;
  }, s.reject = function(m, y) {
    m.state = a, m.outcome = y;
    for (var _ = -1, w = m.queue.length; ++_ < w; )
      m.queue[_].callRejected(y);
    return m;
  }, c.resolve = function(m) {
    return m instanceof this ? m : s.resolve(new this(r), m);
  }, c.reject = function(m) {
    var y = new this(r);
    return s.reject(y, m);
  }, c.all = function(m) {
    var y = this;
    if (Object.prototype.toString.call(m) !== "[object Array]")
      return this.reject(new TypeError("must be an array"));
    var _ = m.length, w = !1;
    if (!_)
      return this.resolve([]);
    for (var b = new Array(_), T = 0, M = -1, A = new this(r); ++M < _; )
      C(m[M], M);
    return A;
    function C(I, k) {
      y.resolve(I).then(function(R) {
        b[k] = R, ++T !== _ || w || (w = !0, s.resolve(A, b));
      }, function(R) {
        w || (w = !0, s.reject(A, R));
      });
    }
  }, c.race = function(m) {
    var y = this;
    if (Object.prototype.toString.call(m) !== "[object Array]")
      return this.reject(new TypeError("must be an array"));
    var _ = m.length, w = !1;
    if (!_)
      return this.resolve([]);
    for (var b, T = -1, M = new this(r); ++T < _; )
      b = m[T], y.resolve(b).then(function(A) {
        w || (w = !0, s.resolve(M, A));
      }, function(A) {
        w || (w = !0, s.reject(M, A));
      });
    return M;
  };
}, { immediate: 36 }], 38: [function(i, t, e) {
  var n = {};
  (0, i("./lib/utils/common").assign)(n, i("./lib/deflate"), i("./lib/inflate"), i("./lib/zlib/constants")), t.exports = n;
}, { "./lib/deflate": 39, "./lib/inflate": 40, "./lib/utils/common": 41, "./lib/zlib/constants": 44 }], 39: [function(i, t, e) {
  var n = i("./zlib/deflate"), r = i("./utils/common"), s = i("./utils/strings"), a = i("./zlib/messages"), o = i("./zlib/zstream"), l = Object.prototype.toString, c = 0, u = -1, h = 0, p = 8;
  function f(m) {
    if (!(this instanceof f))
      return new f(m);
    this.options = r.assign({ level: u, method: p, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: h, to: "" }, m || {});
    var y = this.options;
    y.raw && 0 < y.windowBits ? y.windowBits = -y.windowBits : y.gzip && 0 < y.windowBits && y.windowBits < 16 && (y.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new o(), this.strm.avail_out = 0;
    var _ = n.deflateInit2(this.strm, y.level, y.method, y.windowBits, y.memLevel, y.strategy);
    if (_ !== c)
      throw new Error(a[_]);
    if (y.header && n.deflateSetHeader(this.strm, y.header), y.dictionary) {
      var w;
      if (w = typeof y.dictionary == "string" ? s.string2buf(y.dictionary) : l.call(y.dictionary) === "[object ArrayBuffer]" ? new Uint8Array(y.dictionary) : y.dictionary, (_ = n.deflateSetDictionary(this.strm, w)) !== c)
        throw new Error(a[_]);
      this._dict_set = !0;
    }
  }
  function v(m, y) {
    var _ = new f(y);
    if (_.push(m, !0), _.err)
      throw _.msg || a[_.err];
    return _.result;
  }
  f.prototype.push = function(m, y) {
    var _, w, b = this.strm, T = this.options.chunkSize;
    if (this.ended)
      return !1;
    w = y === ~~y ? y : y === !0 ? 4 : 0, typeof m == "string" ? b.input = s.string2buf(m) : l.call(m) === "[object ArrayBuffer]" ? b.input = new Uint8Array(m) : b.input = m, b.next_in = 0, b.avail_in = b.input.length;
    do {
      if (b.avail_out === 0 && (b.output = new r.Buf8(T), b.next_out = 0, b.avail_out = T), (_ = n.deflate(b, w)) !== 1 && _ !== c)
        return this.onEnd(_), !(this.ended = !0);
      b.avail_out !== 0 && (b.avail_in !== 0 || w !== 4 && w !== 2) || (this.options.to === "string" ? this.onData(s.buf2binstring(r.shrinkBuf(b.output, b.next_out))) : this.onData(r.shrinkBuf(b.output, b.next_out)));
    } while ((0 < b.avail_in || b.avail_out === 0) && _ !== 1);
    return w === 4 ? (_ = n.deflateEnd(this.strm), this.onEnd(_), this.ended = !0, _ === c) : w !== 2 || (this.onEnd(c), !(b.avail_out = 0));
  }, f.prototype.onData = function(m) {
    this.chunks.push(m);
  }, f.prototype.onEnd = function(m) {
    m === c && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = r.flattenChunks(this.chunks)), this.chunks = [], this.err = m, this.msg = this.strm.msg;
  }, e.Deflate = f, e.deflate = v, e.deflateRaw = function(m, y) {
    return (y = y || {}).raw = !0, v(m, y);
  }, e.gzip = function(m, y) {
    return (y = y || {}).gzip = !0, v(m, y);
  };
}, { "./utils/common": 41, "./utils/strings": 42, "./zlib/deflate": 46, "./zlib/messages": 51, "./zlib/zstream": 53 }], 40: [function(i, t, e) {
  var n = i("./zlib/inflate"), r = i("./utils/common"), s = i("./utils/strings"), a = i("./zlib/constants"), o = i("./zlib/messages"), l = i("./zlib/zstream"), c = i("./zlib/gzheader"), u = Object.prototype.toString;
  function h(f) {
    if (!(this instanceof h))
      return new h(f);
    this.options = r.assign({ chunkSize: 16384, windowBits: 0, to: "" }, f || {});
    var v = this.options;
    v.raw && 0 <= v.windowBits && v.windowBits < 16 && (v.windowBits = -v.windowBits, v.windowBits === 0 && (v.windowBits = -15)), !(0 <= v.windowBits && v.windowBits < 16) || f && f.windowBits || (v.windowBits += 32), 15 < v.windowBits && v.windowBits < 48 && !(15 & v.windowBits) && (v.windowBits |= 15), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new l(), this.strm.avail_out = 0;
    var m = n.inflateInit2(this.strm, v.windowBits);
    if (m !== a.Z_OK)
      throw new Error(o[m]);
    this.header = new c(), n.inflateGetHeader(this.strm, this.header);
  }
  function p(f, v) {
    var m = new h(v);
    if (m.push(f, !0), m.err)
      throw m.msg || o[m.err];
    return m.result;
  }
  h.prototype.push = function(f, v) {
    var m, y, _, w, b, T, M = this.strm, A = this.options.chunkSize, C = this.options.dictionary, I = !1;
    if (this.ended)
      return !1;
    y = v === ~~v ? v : v === !0 ? a.Z_FINISH : a.Z_NO_FLUSH, typeof f == "string" ? M.input = s.binstring2buf(f) : u.call(f) === "[object ArrayBuffer]" ? M.input = new Uint8Array(f) : M.input = f, M.next_in = 0, M.avail_in = M.input.length;
    do {
      if (M.avail_out === 0 && (M.output = new r.Buf8(A), M.next_out = 0, M.avail_out = A), (m = n.inflate(M, a.Z_NO_FLUSH)) === a.Z_NEED_DICT && C && (T = typeof C == "string" ? s.string2buf(C) : u.call(C) === "[object ArrayBuffer]" ? new Uint8Array(C) : C, m = n.inflateSetDictionary(this.strm, T)), m === a.Z_BUF_ERROR && I === !0 && (m = a.Z_OK, I = !1), m !== a.Z_STREAM_END && m !== a.Z_OK)
        return this.onEnd(m), !(this.ended = !0);
      M.next_out && (M.avail_out !== 0 && m !== a.Z_STREAM_END && (M.avail_in !== 0 || y !== a.Z_FINISH && y !== a.Z_SYNC_FLUSH) || (this.options.to === "string" ? (_ = s.utf8border(M.output, M.next_out), w = M.next_out - _, b = s.buf2string(M.output, _), M.next_out = w, M.avail_out = A - w, w && r.arraySet(M.output, M.output, _, w, 0), this.onData(b)) : this.onData(r.shrinkBuf(M.output, M.next_out)))), M.avail_in === 0 && M.avail_out === 0 && (I = !0);
    } while ((0 < M.avail_in || M.avail_out === 0) && m !== a.Z_STREAM_END);
    return m === a.Z_STREAM_END && (y = a.Z_FINISH), y === a.Z_FINISH ? (m = n.inflateEnd(this.strm), this.onEnd(m), this.ended = !0, m === a.Z_OK) : y !== a.Z_SYNC_FLUSH || (this.onEnd(a.Z_OK), !(M.avail_out = 0));
  }, h.prototype.onData = function(f) {
    this.chunks.push(f);
  }, h.prototype.onEnd = function(f) {
    f === a.Z_OK && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = r.flattenChunks(this.chunks)), this.chunks = [], this.err = f, this.msg = this.strm.msg;
  }, e.Inflate = h, e.inflate = p, e.inflateRaw = function(f, v) {
    return (v = v || {}).raw = !0, p(f, v);
  }, e.ungzip = p;
}, { "./utils/common": 41, "./utils/strings": 42, "./zlib/constants": 44, "./zlib/gzheader": 47, "./zlib/inflate": 49, "./zlib/messages": 51, "./zlib/zstream": 53 }], 41: [function(i, t, e) {
  var n = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Int32Array < "u";
  e.assign = function(a) {
    for (var o = Array.prototype.slice.call(arguments, 1); o.length; ) {
      var l = o.shift();
      if (l) {
        if (typeof l != "object")
          throw new TypeError(l + "must be non-object");
        for (var c in l)
          l.hasOwnProperty(c) && (a[c] = l[c]);
      }
    }
    return a;
  }, e.shrinkBuf = function(a, o) {
    return a.length === o ? a : a.subarray ? a.subarray(0, o) : (a.length = o, a);
  };
  var r = { arraySet: function(a, o, l, c, u) {
    if (o.subarray && a.subarray)
      a.set(o.subarray(l, l + c), u);
    else
      for (var h = 0; h < c; h++)
        a[u + h] = o[l + h];
  }, flattenChunks: function(a) {
    var o, l, c, u, h, p;
    for (o = c = 0, l = a.length; o < l; o++)
      c += a[o].length;
    for (p = new Uint8Array(c), o = u = 0, l = a.length; o < l; o++)
      h = a[o], p.set(h, u), u += h.length;
    return p;
  } }, s = { arraySet: function(a, o, l, c, u) {
    for (var h = 0; h < c; h++)
      a[u + h] = o[l + h];
  }, flattenChunks: function(a) {
    return [].concat.apply([], a);
  } };
  e.setTyped = function(a) {
    a ? (e.Buf8 = Uint8Array, e.Buf16 = Uint16Array, e.Buf32 = Int32Array, e.assign(e, r)) : (e.Buf8 = Array, e.Buf16 = Array, e.Buf32 = Array, e.assign(e, s));
  }, e.setTyped(n);
}, {}], 42: [function(i, t, e) {
  var n = i("./common"), r = !0, s = !0;
  try {
    String.fromCharCode.apply(null, [0]);
  } catch {
    r = !1;
  }
  try {
    String.fromCharCode.apply(null, new Uint8Array(1));
  } catch {
    s = !1;
  }
  for (var a = new n.Buf8(256), o = 0; o < 256; o++)
    a[o] = 252 <= o ? 6 : 248 <= o ? 5 : 240 <= o ? 4 : 224 <= o ? 3 : 192 <= o ? 2 : 1;
  function l(c, u) {
    if (u < 65537 && (c.subarray && s || !c.subarray && r))
      return String.fromCharCode.apply(null, n.shrinkBuf(c, u));
    for (var h = "", p = 0; p < u; p++)
      h += String.fromCharCode(c[p]);
    return h;
  }
  a[254] = a[254] = 1, e.string2buf = function(c) {
    var u, h, p, f, v, m = c.length, y = 0;
    for (f = 0; f < m; f++)
      (64512 & (h = c.charCodeAt(f))) == 55296 && f + 1 < m && (64512 & (p = c.charCodeAt(f + 1))) == 56320 && (h = 65536 + (h - 55296 << 10) + (p - 56320), f++), y += h < 128 ? 1 : h < 2048 ? 2 : h < 65536 ? 3 : 4;
    for (u = new n.Buf8(y), f = v = 0; v < y; f++)
      (64512 & (h = c.charCodeAt(f))) == 55296 && f + 1 < m && (64512 & (p = c.charCodeAt(f + 1))) == 56320 && (h = 65536 + (h - 55296 << 10) + (p - 56320), f++), h < 128 ? u[v++] = h : (h < 2048 ? u[v++] = 192 | h >>> 6 : (h < 65536 ? u[v++] = 224 | h >>> 12 : (u[v++] = 240 | h >>> 18, u[v++] = 128 | h >>> 12 & 63), u[v++] = 128 | h >>> 6 & 63), u[v++] = 128 | 63 & h);
    return u;
  }, e.buf2binstring = function(c) {
    return l(c, c.length);
  }, e.binstring2buf = function(c) {
    for (var u = new n.Buf8(c.length), h = 0, p = u.length; h < p; h++)
      u[h] = c.charCodeAt(h);
    return u;
  }, e.buf2string = function(c, u) {
    var h, p, f, v, m = u || c.length, y = new Array(2 * m);
    for (h = p = 0; h < m; )
      if ((f = c[h++]) < 128)
        y[p++] = f;
      else if (4 < (v = a[f]))
        y[p++] = 65533, h += v - 1;
      else {
        for (f &= v === 2 ? 31 : v === 3 ? 15 : 7; 1 < v && h < m; )
          f = f << 6 | 63 & c[h++], v--;
        1 < v ? y[p++] = 65533 : f < 65536 ? y[p++] = f : (f -= 65536, y[p++] = 55296 | f >> 10 & 1023, y[p++] = 56320 | 1023 & f);
      }
    return l(y, p);
  }, e.utf8border = function(c, u) {
    var h;
    for ((u = u || c.length) > c.length && (u = c.length), h = u - 1; 0 <= h && (192 & c[h]) == 128; )
      h--;
    return h < 0 || h === 0 ? u : h + a[c[h]] > u ? h : u;
  };
}, { "./common": 41 }], 43: [function(i, t, e) {
  t.exports = function(n, r, s, a) {
    for (var o = 65535 & n | 0, l = n >>> 16 & 65535 | 0, c = 0; s !== 0; ) {
      for (s -= c = 2e3 < s ? 2e3 : s; l = l + (o = o + r[a++] | 0) | 0, --c; )
        ;
      o %= 65521, l %= 65521;
    }
    return o | l << 16 | 0;
  };
}, {}], 44: [function(i, t, e) {
  t.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
}, {}], 45: [function(i, t, e) {
  var n = function() {
    for (var r, s = [], a = 0; a < 256; a++) {
      r = a;
      for (var o = 0; o < 8; o++)
        r = 1 & r ? 3988292384 ^ r >>> 1 : r >>> 1;
      s[a] = r;
    }
    return s;
  }();
  t.exports = function(r, s, a, o) {
    var l = n, c = o + a;
    r ^= -1;
    for (var u = o; u < c; u++)
      r = r >>> 8 ^ l[255 & (r ^ s[u])];
    return -1 ^ r;
  };
}, {}], 46: [function(i, t, e) {
  var n, r = i("../utils/common"), s = i("./trees"), a = i("./adler32"), o = i("./crc32"), l = i("./messages"), c = 0, u = 4, h = 0, p = -2, f = -1, v = 4, m = 2, y = 8, _ = 9, w = 286, b = 30, T = 19, M = 2 * w + 1, A = 15, C = 3, I = 258, k = I + C + 1, R = 42, L = 113, E = 1, q = 2, it = 3, rt = 4;
  function ft(S, Z) {
    return S.msg = l[Z], Z;
  }
  function nt(S) {
    return (S << 1) - (4 < S ? 9 : 0);
  }
  function vt(S) {
    for (var Z = S.length; 0 <= --Z; )
      S[Z] = 0;
  }
  function $(S) {
    var Z = S.state, G = Z.pending;
    G > S.avail_out && (G = S.avail_out), G !== 0 && (r.arraySet(S.output, Z.pending_buf, Z.pending_out, G, S.next_out), S.next_out += G, Z.pending_out += G, S.total_out += G, S.avail_out -= G, Z.pending -= G, Z.pending === 0 && (Z.pending_out = 0));
  }
  function W(S, Z) {
    s._tr_flush_block(S, 0 <= S.block_start ? S.block_start : -1, S.strstart - S.block_start, Z), S.block_start = S.strstart, $(S.strm);
  }
  function ct(S, Z) {
    S.pending_buf[S.pending++] = Z;
  }
  function mt(S, Z) {
    S.pending_buf[S.pending++] = Z >>> 8 & 255, S.pending_buf[S.pending++] = 255 & Z;
  }
  function dt(S, Z) {
    var G, F, z = S.max_chain_length, Y = S.strstart, pt = S.prev_length, ht = S.nice_match, lt = S.strstart > S.w_size - k ? S.strstart - (S.w_size - k) : 0, yt = S.window, O = S.w_mask, V = S.prev, tt = S.strstart + I, gt = yt[Y + pt - 1], Tt = yt[Y + pt];
    S.prev_length >= S.good_match && (z >>= 2), ht > S.lookahead && (ht = S.lookahead);
    do
      if (yt[(G = Z) + pt] === Tt && yt[G + pt - 1] === gt && yt[G] === yt[Y] && yt[++G] === yt[Y + 1]) {
        Y += 2, G++;
        do
          ;
        while (yt[++Y] === yt[++G] && yt[++Y] === yt[++G] && yt[++Y] === yt[++G] && yt[++Y] === yt[++G] && yt[++Y] === yt[++G] && yt[++Y] === yt[++G] && yt[++Y] === yt[++G] && yt[++Y] === yt[++G] && Y < tt);
        if (F = I - (tt - Y), Y = tt - I, pt < F) {
          if (S.match_start = Z, ht <= (pt = F))
            break;
          gt = yt[Y + pt - 1], Tt = yt[Y + pt];
        }
      }
    while ((Z = V[Z & O]) > lt && --z != 0);
    return pt <= S.lookahead ? pt : S.lookahead;
  }
  function Mt(S) {
    var Z, G, F, z, Y, pt, ht, lt, yt, O, V = S.w_size;
    do {
      if (z = S.window_size - S.lookahead - S.strstart, S.strstart >= V + (V - k)) {
        for (r.arraySet(S.window, S.window, V, V, 0), S.match_start -= V, S.strstart -= V, S.block_start -= V, Z = G = S.hash_size; F = S.head[--Z], S.head[Z] = V <= F ? F - V : 0, --G; )
          ;
        for (Z = G = V; F = S.prev[--Z], S.prev[Z] = V <= F ? F - V : 0, --G; )
          ;
        z += V;
      }
      if (S.strm.avail_in === 0)
        break;
      if (pt = S.strm, ht = S.window, lt = S.strstart + S.lookahead, O = void 0, (yt = z) < (O = pt.avail_in) && (O = yt), G = O === 0 ? 0 : (pt.avail_in -= O, r.arraySet(ht, pt.input, pt.next_in, O, lt), pt.state.wrap === 1 ? pt.adler = a(pt.adler, ht, O, lt) : pt.state.wrap === 2 && (pt.adler = o(pt.adler, ht, O, lt)), pt.next_in += O, pt.total_in += O, O), S.lookahead += G, S.lookahead + S.insert >= C)
        for (Y = S.strstart - S.insert, S.ins_h = S.window[Y], S.ins_h = (S.ins_h << S.hash_shift ^ S.window[Y + 1]) & S.hash_mask; S.insert && (S.ins_h = (S.ins_h << S.hash_shift ^ S.window[Y + C - 1]) & S.hash_mask, S.prev[Y & S.w_mask] = S.head[S.ins_h], S.head[S.ins_h] = Y, Y++, S.insert--, !(S.lookahead + S.insert < C)); )
          ;
    } while (S.lookahead < k && S.strm.avail_in !== 0);
  }
  function At(S, Z) {
    for (var G, F; ; ) {
      if (S.lookahead < k) {
        if (Mt(S), S.lookahead < k && Z === c)
          return E;
        if (S.lookahead === 0)
          break;
      }
      if (G = 0, S.lookahead >= C && (S.ins_h = (S.ins_h << S.hash_shift ^ S.window[S.strstart + C - 1]) & S.hash_mask, G = S.prev[S.strstart & S.w_mask] = S.head[S.ins_h], S.head[S.ins_h] = S.strstart), G !== 0 && S.strstart - G <= S.w_size - k && (S.match_length = dt(S, G)), S.match_length >= C)
        if (F = s._tr_tally(S, S.strstart - S.match_start, S.match_length - C), S.lookahead -= S.match_length, S.match_length <= S.max_lazy_match && S.lookahead >= C) {
          for (S.match_length--; S.strstart++, S.ins_h = (S.ins_h << S.hash_shift ^ S.window[S.strstart + C - 1]) & S.hash_mask, G = S.prev[S.strstart & S.w_mask] = S.head[S.ins_h], S.head[S.ins_h] = S.strstart, --S.match_length != 0; )
            ;
          S.strstart++;
        } else
          S.strstart += S.match_length, S.match_length = 0, S.ins_h = S.window[S.strstart], S.ins_h = (S.ins_h << S.hash_shift ^ S.window[S.strstart + 1]) & S.hash_mask;
      else
        F = s._tr_tally(S, 0, S.window[S.strstart]), S.lookahead--, S.strstart++;
      if (F && (W(S, !1), S.strm.avail_out === 0))
        return E;
    }
    return S.insert = S.strstart < C - 1 ? S.strstart : C - 1, Z === u ? (W(S, !0), S.strm.avail_out === 0 ? it : rt) : S.last_lit && (W(S, !1), S.strm.avail_out === 0) ? E : q;
  }
  function H(S, Z) {
    for (var G, F, z; ; ) {
      if (S.lookahead < k) {
        if (Mt(S), S.lookahead < k && Z === c)
          return E;
        if (S.lookahead === 0)
          break;
      }
      if (G = 0, S.lookahead >= C && (S.ins_h = (S.ins_h << S.hash_shift ^ S.window[S.strstart + C - 1]) & S.hash_mask, G = S.prev[S.strstart & S.w_mask] = S.head[S.ins_h], S.head[S.ins_h] = S.strstart), S.prev_length = S.match_length, S.prev_match = S.match_start, S.match_length = C - 1, G !== 0 && S.prev_length < S.max_lazy_match && S.strstart - G <= S.w_size - k && (S.match_length = dt(S, G), S.match_length <= 5 && (S.strategy === 1 || S.match_length === C && 4096 < S.strstart - S.match_start) && (S.match_length = C - 1)), S.prev_length >= C && S.match_length <= S.prev_length) {
        for (z = S.strstart + S.lookahead - C, F = s._tr_tally(S, S.strstart - 1 - S.prev_match, S.prev_length - C), S.lookahead -= S.prev_length - 1, S.prev_length -= 2; ++S.strstart <= z && (S.ins_h = (S.ins_h << S.hash_shift ^ S.window[S.strstart + C - 1]) & S.hash_mask, G = S.prev[S.strstart & S.w_mask] = S.head[S.ins_h], S.head[S.ins_h] = S.strstart), --S.prev_length != 0; )
          ;
        if (S.match_available = 0, S.match_length = C - 1, S.strstart++, F && (W(S, !1), S.strm.avail_out === 0))
          return E;
      } else if (S.match_available) {
        if ((F = s._tr_tally(S, 0, S.window[S.strstart - 1])) && W(S, !1), S.strstart++, S.lookahead--, S.strm.avail_out === 0)
          return E;
      } else
        S.match_available = 1, S.strstart++, S.lookahead--;
    }
    return S.match_available && (F = s._tr_tally(S, 0, S.window[S.strstart - 1]), S.match_available = 0), S.insert = S.strstart < C - 1 ? S.strstart : C - 1, Z === u ? (W(S, !0), S.strm.avail_out === 0 ? it : rt) : S.last_lit && (W(S, !1), S.strm.avail_out === 0) ? E : q;
  }
  function N(S, Z, G, F, z) {
    this.good_length = S, this.max_lazy = Z, this.nice_length = G, this.max_chain = F, this.func = z;
  }
  function st() {
    this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = y, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new r.Buf16(2 * M), this.dyn_dtree = new r.Buf16(2 * (2 * b + 1)), this.bl_tree = new r.Buf16(2 * (2 * T + 1)), vt(this.dyn_ltree), vt(this.dyn_dtree), vt(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new r.Buf16(A + 1), this.heap = new r.Buf16(2 * w + 1), vt(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new r.Buf16(2 * w + 1), vt(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
  }
  function et(S) {
    var Z;
    return S && S.state ? (S.total_in = S.total_out = 0, S.data_type = m, (Z = S.state).pending = 0, Z.pending_out = 0, Z.wrap < 0 && (Z.wrap = -Z.wrap), Z.status = Z.wrap ? R : L, S.adler = Z.wrap === 2 ? 0 : 1, Z.last_flush = c, s._tr_init(Z), h) : ft(S, p);
  }
  function J(S) {
    var Z = et(S);
    return Z === h && function(G) {
      G.window_size = 2 * G.w_size, vt(G.head), G.max_lazy_match = n[G.level].max_lazy, G.good_match = n[G.level].good_length, G.nice_match = n[G.level].nice_length, G.max_chain_length = n[G.level].max_chain, G.strstart = 0, G.block_start = 0, G.lookahead = 0, G.insert = 0, G.match_length = G.prev_length = C - 1, G.match_available = 0, G.ins_h = 0;
    }(S.state), Z;
  }
  function K(S, Z, G, F, z, Y) {
    if (!S)
      return p;
    var pt = 1;
    if (Z === f && (Z = 6), F < 0 ? (pt = 0, F = -F) : 15 < F && (pt = 2, F -= 16), z < 1 || _ < z || G !== y || F < 8 || 15 < F || Z < 0 || 9 < Z || Y < 0 || v < Y)
      return ft(S, p);
    F === 8 && (F = 9);
    var ht = new st();
    return (S.state = ht).strm = S, ht.wrap = pt, ht.gzhead = null, ht.w_bits = F, ht.w_size = 1 << ht.w_bits, ht.w_mask = ht.w_size - 1, ht.hash_bits = z + 7, ht.hash_size = 1 << ht.hash_bits, ht.hash_mask = ht.hash_size - 1, ht.hash_shift = ~~((ht.hash_bits + C - 1) / C), ht.window = new r.Buf8(2 * ht.w_size), ht.head = new r.Buf16(ht.hash_size), ht.prev = new r.Buf16(ht.w_size), ht.lit_bufsize = 1 << z + 6, ht.pending_buf_size = 4 * ht.lit_bufsize, ht.pending_buf = new r.Buf8(ht.pending_buf_size), ht.d_buf = 1 * ht.lit_bufsize, ht.l_buf = 3 * ht.lit_bufsize, ht.level = Z, ht.strategy = Y, ht.method = G, J(S);
  }
  n = [new N(0, 0, 0, 0, function(S, Z) {
    var G = 65535;
    for (G > S.pending_buf_size - 5 && (G = S.pending_buf_size - 5); ; ) {
      if (S.lookahead <= 1) {
        if (Mt(S), S.lookahead === 0 && Z === c)
          return E;
        if (S.lookahead === 0)
          break;
      }
      S.strstart += S.lookahead, S.lookahead = 0;
      var F = S.block_start + G;
      if ((S.strstart === 0 || S.strstart >= F) && (S.lookahead = S.strstart - F, S.strstart = F, W(S, !1), S.strm.avail_out === 0) || S.strstart - S.block_start >= S.w_size - k && (W(S, !1), S.strm.avail_out === 0))
        return E;
    }
    return S.insert = 0, Z === u ? (W(S, !0), S.strm.avail_out === 0 ? it : rt) : (S.strstart > S.block_start && (W(S, !1), S.strm.avail_out), E);
  }), new N(4, 4, 8, 4, At), new N(4, 5, 16, 8, At), new N(4, 6, 32, 32, At), new N(4, 4, 16, 16, H), new N(8, 16, 32, 32, H), new N(8, 16, 128, 128, H), new N(8, 32, 128, 256, H), new N(32, 128, 258, 1024, H), new N(32, 258, 258, 4096, H)], e.deflateInit = function(S, Z) {
    return K(S, Z, y, 15, 8, 0);
  }, e.deflateInit2 = K, e.deflateReset = J, e.deflateResetKeep = et, e.deflateSetHeader = function(S, Z) {
    return S && S.state ? S.state.wrap !== 2 ? p : (S.state.gzhead = Z, h) : p;
  }, e.deflate = function(S, Z) {
    var G, F, z, Y;
    if (!S || !S.state || 5 < Z || Z < 0)
      return S ? ft(S, p) : p;
    if (F = S.state, !S.output || !S.input && S.avail_in !== 0 || F.status === 666 && Z !== u)
      return ft(S, S.avail_out === 0 ? -5 : p);
    if (F.strm = S, G = F.last_flush, F.last_flush = Z, F.status === R)
      if (F.wrap === 2)
        S.adler = 0, ct(F, 31), ct(F, 139), ct(F, 8), F.gzhead ? (ct(F, (F.gzhead.text ? 1 : 0) + (F.gzhead.hcrc ? 2 : 0) + (F.gzhead.extra ? 4 : 0) + (F.gzhead.name ? 8 : 0) + (F.gzhead.comment ? 16 : 0)), ct(F, 255 & F.gzhead.time), ct(F, F.gzhead.time >> 8 & 255), ct(F, F.gzhead.time >> 16 & 255), ct(F, F.gzhead.time >> 24 & 255), ct(F, F.level === 9 ? 2 : 2 <= F.strategy || F.level < 2 ? 4 : 0), ct(F, 255 & F.gzhead.os), F.gzhead.extra && F.gzhead.extra.length && (ct(F, 255 & F.gzhead.extra.length), ct(F, F.gzhead.extra.length >> 8 & 255)), F.gzhead.hcrc && (S.adler = o(S.adler, F.pending_buf, F.pending, 0)), F.gzindex = 0, F.status = 69) : (ct(F, 0), ct(F, 0), ct(F, 0), ct(F, 0), ct(F, 0), ct(F, F.level === 9 ? 2 : 2 <= F.strategy || F.level < 2 ? 4 : 0), ct(F, 3), F.status = L);
      else {
        var pt = y + (F.w_bits - 8 << 4) << 8;
        pt |= (2 <= F.strategy || F.level < 2 ? 0 : F.level < 6 ? 1 : F.level === 6 ? 2 : 3) << 6, F.strstart !== 0 && (pt |= 32), pt += 31 - pt % 31, F.status = L, mt(F, pt), F.strstart !== 0 && (mt(F, S.adler >>> 16), mt(F, 65535 & S.adler)), S.adler = 1;
      }
    if (F.status === 69)
      if (F.gzhead.extra) {
        for (z = F.pending; F.gzindex < (65535 & F.gzhead.extra.length) && (F.pending !== F.pending_buf_size || (F.gzhead.hcrc && F.pending > z && (S.adler = o(S.adler, F.pending_buf, F.pending - z, z)), $(S), z = F.pending, F.pending !== F.pending_buf_size)); )
          ct(F, 255 & F.gzhead.extra[F.gzindex]), F.gzindex++;
        F.gzhead.hcrc && F.pending > z && (S.adler = o(S.adler, F.pending_buf, F.pending - z, z)), F.gzindex === F.gzhead.extra.length && (F.gzindex = 0, F.status = 73);
      } else
        F.status = 73;
    if (F.status === 73)
      if (F.gzhead.name) {
        z = F.pending;
        do {
          if (F.pending === F.pending_buf_size && (F.gzhead.hcrc && F.pending > z && (S.adler = o(S.adler, F.pending_buf, F.pending - z, z)), $(S), z = F.pending, F.pending === F.pending_buf_size)) {
            Y = 1;
            break;
          }
          Y = F.gzindex < F.gzhead.name.length ? 255 & F.gzhead.name.charCodeAt(F.gzindex++) : 0, ct(F, Y);
        } while (Y !== 0);
        F.gzhead.hcrc && F.pending > z && (S.adler = o(S.adler, F.pending_buf, F.pending - z, z)), Y === 0 && (F.gzindex = 0, F.status = 91);
      } else
        F.status = 91;
    if (F.status === 91)
      if (F.gzhead.comment) {
        z = F.pending;
        do {
          if (F.pending === F.pending_buf_size && (F.gzhead.hcrc && F.pending > z && (S.adler = o(S.adler, F.pending_buf, F.pending - z, z)), $(S), z = F.pending, F.pending === F.pending_buf_size)) {
            Y = 1;
            break;
          }
          Y = F.gzindex < F.gzhead.comment.length ? 255 & F.gzhead.comment.charCodeAt(F.gzindex++) : 0, ct(F, Y);
        } while (Y !== 0);
        F.gzhead.hcrc && F.pending > z && (S.adler = o(S.adler, F.pending_buf, F.pending - z, z)), Y === 0 && (F.status = 103);
      } else
        F.status = 103;
    if (F.status === 103 && (F.gzhead.hcrc ? (F.pending + 2 > F.pending_buf_size && $(S), F.pending + 2 <= F.pending_buf_size && (ct(F, 255 & S.adler), ct(F, S.adler >> 8 & 255), S.adler = 0, F.status = L)) : F.status = L), F.pending !== 0) {
      if ($(S), S.avail_out === 0)
        return F.last_flush = -1, h;
    } else if (S.avail_in === 0 && nt(Z) <= nt(G) && Z !== u)
      return ft(S, -5);
    if (F.status === 666 && S.avail_in !== 0)
      return ft(S, -5);
    if (S.avail_in !== 0 || F.lookahead !== 0 || Z !== c && F.status !== 666) {
      var ht = F.strategy === 2 ? function(lt, yt) {
        for (var O; ; ) {
          if (lt.lookahead === 0 && (Mt(lt), lt.lookahead === 0)) {
            if (yt === c)
              return E;
            break;
          }
          if (lt.match_length = 0, O = s._tr_tally(lt, 0, lt.window[lt.strstart]), lt.lookahead--, lt.strstart++, O && (W(lt, !1), lt.strm.avail_out === 0))
            return E;
        }
        return lt.insert = 0, yt === u ? (W(lt, !0), lt.strm.avail_out === 0 ? it : rt) : lt.last_lit && (W(lt, !1), lt.strm.avail_out === 0) ? E : q;
      }(F, Z) : F.strategy === 3 ? function(lt, yt) {
        for (var O, V, tt, gt, Tt = lt.window; ; ) {
          if (lt.lookahead <= I) {
            if (Mt(lt), lt.lookahead <= I && yt === c)
              return E;
            if (lt.lookahead === 0)
              break;
          }
          if (lt.match_length = 0, lt.lookahead >= C && 0 < lt.strstart && (V = Tt[tt = lt.strstart - 1]) === Tt[++tt] && V === Tt[++tt] && V === Tt[++tt]) {
            gt = lt.strstart + I;
            do
              ;
            while (V === Tt[++tt] && V === Tt[++tt] && V === Tt[++tt] && V === Tt[++tt] && V === Tt[++tt] && V === Tt[++tt] && V === Tt[++tt] && V === Tt[++tt] && tt < gt);
            lt.match_length = I - (gt - tt), lt.match_length > lt.lookahead && (lt.match_length = lt.lookahead);
          }
          if (lt.match_length >= C ? (O = s._tr_tally(lt, 1, lt.match_length - C), lt.lookahead -= lt.match_length, lt.strstart += lt.match_length, lt.match_length = 0) : (O = s._tr_tally(lt, 0, lt.window[lt.strstart]), lt.lookahead--, lt.strstart++), O && (W(lt, !1), lt.strm.avail_out === 0))
            return E;
        }
        return lt.insert = 0, yt === u ? (W(lt, !0), lt.strm.avail_out === 0 ? it : rt) : lt.last_lit && (W(lt, !1), lt.strm.avail_out === 0) ? E : q;
      }(F, Z) : n[F.level].func(F, Z);
      if (ht !== it && ht !== rt || (F.status = 666), ht === E || ht === it)
        return S.avail_out === 0 && (F.last_flush = -1), h;
      if (ht === q && (Z === 1 ? s._tr_align(F) : Z !== 5 && (s._tr_stored_block(F, 0, 0, !1), Z === 3 && (vt(F.head), F.lookahead === 0 && (F.strstart = 0, F.block_start = 0, F.insert = 0))), $(S), S.avail_out === 0))
        return F.last_flush = -1, h;
    }
    return Z !== u ? h : F.wrap <= 0 ? 1 : (F.wrap === 2 ? (ct(F, 255 & S.adler), ct(F, S.adler >> 8 & 255), ct(F, S.adler >> 16 & 255), ct(F, S.adler >> 24 & 255), ct(F, 255 & S.total_in), ct(F, S.total_in >> 8 & 255), ct(F, S.total_in >> 16 & 255), ct(F, S.total_in >> 24 & 255)) : (mt(F, S.adler >>> 16), mt(F, 65535 & S.adler)), $(S), 0 < F.wrap && (F.wrap = -F.wrap), F.pending !== 0 ? h : 1);
  }, e.deflateEnd = function(S) {
    var Z;
    return S && S.state ? (Z = S.state.status) !== R && Z !== 69 && Z !== 73 && Z !== 91 && Z !== 103 && Z !== L && Z !== 666 ? ft(S, p) : (S.state = null, Z === L ? ft(S, -3) : h) : p;
  }, e.deflateSetDictionary = function(S, Z) {
    var G, F, z, Y, pt, ht, lt, yt, O = Z.length;
    if (!S || !S.state || (Y = (G = S.state).wrap) === 2 || Y === 1 && G.status !== R || G.lookahead)
      return p;
    for (Y === 1 && (S.adler = a(S.adler, Z, O, 0)), G.wrap = 0, O >= G.w_size && (Y === 0 && (vt(G.head), G.strstart = 0, G.block_start = 0, G.insert = 0), yt = new r.Buf8(G.w_size), r.arraySet(yt, Z, O - G.w_size, G.w_size, 0), Z = yt, O = G.w_size), pt = S.avail_in, ht = S.next_in, lt = S.input, S.avail_in = O, S.next_in = 0, S.input = Z, Mt(G); G.lookahead >= C; ) {
      for (F = G.strstart, z = G.lookahead - (C - 1); G.ins_h = (G.ins_h << G.hash_shift ^ G.window[F + C - 1]) & G.hash_mask, G.prev[F & G.w_mask] = G.head[G.ins_h], G.head[G.ins_h] = F, F++, --z; )
        ;
      G.strstart = F, G.lookahead = C - 1, Mt(G);
    }
    return G.strstart += G.lookahead, G.block_start = G.strstart, G.insert = G.lookahead, G.lookahead = 0, G.match_length = G.prev_length = C - 1, G.match_available = 0, S.next_in = ht, S.input = lt, S.avail_in = pt, G.wrap = Y, h;
  }, e.deflateInfo = "pako deflate (from Nodeca project)";
}, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./messages": 51, "./trees": 52 }], 47: [function(i, t, e) {
  t.exports = function() {
    this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1;
  };
}, {}], 48: [function(i, t, e) {
  t.exports = function(n, r) {
    var s, a, o, l, c, u, h, p, f, v, m, y, _, w, b, T, M, A, C, I, k, R, L, E, q;
    s = n.state, a = n.next_in, E = n.input, o = a + (n.avail_in - 5), l = n.next_out, q = n.output, c = l - (r - n.avail_out), u = l + (n.avail_out - 257), h = s.dmax, p = s.wsize, f = s.whave, v = s.wnext, m = s.window, y = s.hold, _ = s.bits, w = s.lencode, b = s.distcode, T = (1 << s.lenbits) - 1, M = (1 << s.distbits) - 1;
    t:
      do {
        _ < 15 && (y += E[a++] << _, _ += 8, y += E[a++] << _, _ += 8), A = w[y & T];
        e:
          for (; ; ) {
            if (y >>>= C = A >>> 24, _ -= C, (C = A >>> 16 & 255) == 0)
              q[l++] = 65535 & A;
            else {
              if (!(16 & C)) {
                if (!(64 & C)) {
                  A = w[(65535 & A) + (y & (1 << C) - 1)];
                  continue e;
                }
                if (32 & C) {
                  s.mode = 12;
                  break t;
                }
                n.msg = "invalid literal/length code", s.mode = 30;
                break t;
              }
              I = 65535 & A, (C &= 15) && (_ < C && (y += E[a++] << _, _ += 8), I += y & (1 << C) - 1, y >>>= C, _ -= C), _ < 15 && (y += E[a++] << _, _ += 8, y += E[a++] << _, _ += 8), A = b[y & M];
              n:
                for (; ; ) {
                  if (y >>>= C = A >>> 24, _ -= C, !(16 & (C = A >>> 16 & 255))) {
                    if (!(64 & C)) {
                      A = b[(65535 & A) + (y & (1 << C) - 1)];
                      continue n;
                    }
                    n.msg = "invalid distance code", s.mode = 30;
                    break t;
                  }
                  if (k = 65535 & A, _ < (C &= 15) && (y += E[a++] << _, (_ += 8) < C && (y += E[a++] << _, _ += 8)), h < (k += y & (1 << C) - 1)) {
                    n.msg = "invalid distance too far back", s.mode = 30;
                    break t;
                  }
                  if (y >>>= C, _ -= C, (C = l - c) < k) {
                    if (f < (C = k - C) && s.sane) {
                      n.msg = "invalid distance too far back", s.mode = 30;
                      break t;
                    }
                    if (L = m, (R = 0) === v) {
                      if (R += p - C, C < I) {
                        for (I -= C; q[l++] = m[R++], --C; )
                          ;
                        R = l - k, L = q;
                      }
                    } else if (v < C) {
                      if (R += p + v - C, (C -= v) < I) {
                        for (I -= C; q[l++] = m[R++], --C; )
                          ;
                        if (R = 0, v < I) {
                          for (I -= C = v; q[l++] = m[R++], --C; )
                            ;
                          R = l - k, L = q;
                        }
                      }
                    } else if (R += v - C, C < I) {
                      for (I -= C; q[l++] = m[R++], --C; )
                        ;
                      R = l - k, L = q;
                    }
                    for (; 2 < I; )
                      q[l++] = L[R++], q[l++] = L[R++], q[l++] = L[R++], I -= 3;
                    I && (q[l++] = L[R++], 1 < I && (q[l++] = L[R++]));
                  } else {
                    for (R = l - k; q[l++] = q[R++], q[l++] = q[R++], q[l++] = q[R++], 2 < (I -= 3); )
                      ;
                    I && (q[l++] = q[R++], 1 < I && (q[l++] = q[R++]));
                  }
                  break;
                }
            }
            break;
          }
      } while (a < o && l < u);
    a -= I = _ >> 3, y &= (1 << (_ -= I << 3)) - 1, n.next_in = a, n.next_out = l, n.avail_in = a < o ? o - a + 5 : 5 - (a - o), n.avail_out = l < u ? u - l + 257 : 257 - (l - u), s.hold = y, s.bits = _;
  };
}, {}], 49: [function(i, t, e) {
  var n = i("../utils/common"), r = i("./adler32"), s = i("./crc32"), a = i("./inffast"), o = i("./inftrees"), l = 1, c = 2, u = 0, h = -2, p = 1, f = 852, v = 592;
  function m(R) {
    return (R >>> 24 & 255) + (R >>> 8 & 65280) + ((65280 & R) << 8) + ((255 & R) << 24);
  }
  function y() {
    this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new n.Buf16(320), this.work = new n.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
  }
  function _(R) {
    var L;
    return R && R.state ? (L = R.state, R.total_in = R.total_out = L.total = 0, R.msg = "", L.wrap && (R.adler = 1 & L.wrap), L.mode = p, L.last = 0, L.havedict = 0, L.dmax = 32768, L.head = null, L.hold = 0, L.bits = 0, L.lencode = L.lendyn = new n.Buf32(f), L.distcode = L.distdyn = new n.Buf32(v), L.sane = 1, L.back = -1, u) : h;
  }
  function w(R) {
    var L;
    return R && R.state ? ((L = R.state).wsize = 0, L.whave = 0, L.wnext = 0, _(R)) : h;
  }
  function b(R, L) {
    var E, q;
    return R && R.state ? (q = R.state, L < 0 ? (E = 0, L = -L) : (E = 1 + (L >> 4), L < 48 && (L &= 15)), L && (L < 8 || 15 < L) ? h : (q.window !== null && q.wbits !== L && (q.window = null), q.wrap = E, q.wbits = L, w(R))) : h;
  }
  function T(R, L) {
    var E, q;
    return R ? (q = new y(), (R.state = q).window = null, (E = b(R, L)) !== u && (R.state = null), E) : h;
  }
  var M, A, C = !0;
  function I(R) {
    if (C) {
      var L;
      for (M = new n.Buf32(512), A = new n.Buf32(32), L = 0; L < 144; )
        R.lens[L++] = 8;
      for (; L < 256; )
        R.lens[L++] = 9;
      for (; L < 280; )
        R.lens[L++] = 7;
      for (; L < 288; )
        R.lens[L++] = 8;
      for (o(l, R.lens, 0, 288, M, 0, R.work, { bits: 9 }), L = 0; L < 32; )
        R.lens[L++] = 5;
      o(c, R.lens, 0, 32, A, 0, R.work, { bits: 5 }), C = !1;
    }
    R.lencode = M, R.lenbits = 9, R.distcode = A, R.distbits = 5;
  }
  function k(R, L, E, q) {
    var it, rt = R.state;
    return rt.window === null && (rt.wsize = 1 << rt.wbits, rt.wnext = 0, rt.whave = 0, rt.window = new n.Buf8(rt.wsize)), q >= rt.wsize ? (n.arraySet(rt.window, L, E - rt.wsize, rt.wsize, 0), rt.wnext = 0, rt.whave = rt.wsize) : (q < (it = rt.wsize - rt.wnext) && (it = q), n.arraySet(rt.window, L, E - q, it, rt.wnext), (q -= it) ? (n.arraySet(rt.window, L, E - q, q, 0), rt.wnext = q, rt.whave = rt.wsize) : (rt.wnext += it, rt.wnext === rt.wsize && (rt.wnext = 0), rt.whave < rt.wsize && (rt.whave += it))), 0;
  }
  e.inflateReset = w, e.inflateReset2 = b, e.inflateResetKeep = _, e.inflateInit = function(R) {
    return T(R, 15);
  }, e.inflateInit2 = T, e.inflate = function(R, L) {
    var E, q, it, rt, ft, nt, vt, $, W, ct, mt, dt, Mt, At, H, N, st, et, J, K, S, Z, G, F, z = 0, Y = new n.Buf8(4), pt = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
    if (!R || !R.state || !R.output || !R.input && R.avail_in !== 0)
      return h;
    (E = R.state).mode === 12 && (E.mode = 13), ft = R.next_out, it = R.output, vt = R.avail_out, rt = R.next_in, q = R.input, nt = R.avail_in, $ = E.hold, W = E.bits, ct = nt, mt = vt, Z = u;
    t:
      for (; ; )
        switch (E.mode) {
          case p:
            if (E.wrap === 0) {
              E.mode = 13;
              break;
            }
            for (; W < 16; ) {
              if (nt === 0)
                break t;
              nt--, $ += q[rt++] << W, W += 8;
            }
            if (2 & E.wrap && $ === 35615) {
              Y[E.check = 0] = 255 & $, Y[1] = $ >>> 8 & 255, E.check = s(E.check, Y, 2, 0), W = $ = 0, E.mode = 2;
              break;
            }
            if (E.flags = 0, E.head && (E.head.done = !1), !(1 & E.wrap) || (((255 & $) << 8) + ($ >> 8)) % 31) {
              R.msg = "incorrect header check", E.mode = 30;
              break;
            }
            if ((15 & $) != 8) {
              R.msg = "unknown compression method", E.mode = 30;
              break;
            }
            if (W -= 4, S = 8 + (15 & ($ >>>= 4)), E.wbits === 0)
              E.wbits = S;
            else if (S > E.wbits) {
              R.msg = "invalid window size", E.mode = 30;
              break;
            }
            E.dmax = 1 << S, R.adler = E.check = 1, E.mode = 512 & $ ? 10 : 12, W = $ = 0;
            break;
          case 2:
            for (; W < 16; ) {
              if (nt === 0)
                break t;
              nt--, $ += q[rt++] << W, W += 8;
            }
            if (E.flags = $, (255 & E.flags) != 8) {
              R.msg = "unknown compression method", E.mode = 30;
              break;
            }
            if (57344 & E.flags) {
              R.msg = "unknown header flags set", E.mode = 30;
              break;
            }
            E.head && (E.head.text = $ >> 8 & 1), 512 & E.flags && (Y[0] = 255 & $, Y[1] = $ >>> 8 & 255, E.check = s(E.check, Y, 2, 0)), W = $ = 0, E.mode = 3;
          case 3:
            for (; W < 32; ) {
              if (nt === 0)
                break t;
              nt--, $ += q[rt++] << W, W += 8;
            }
            E.head && (E.head.time = $), 512 & E.flags && (Y[0] = 255 & $, Y[1] = $ >>> 8 & 255, Y[2] = $ >>> 16 & 255, Y[3] = $ >>> 24 & 255, E.check = s(E.check, Y, 4, 0)), W = $ = 0, E.mode = 4;
          case 4:
            for (; W < 16; ) {
              if (nt === 0)
                break t;
              nt--, $ += q[rt++] << W, W += 8;
            }
            E.head && (E.head.xflags = 255 & $, E.head.os = $ >> 8), 512 & E.flags && (Y[0] = 255 & $, Y[1] = $ >>> 8 & 255, E.check = s(E.check, Y, 2, 0)), W = $ = 0, E.mode = 5;
          case 5:
            if (1024 & E.flags) {
              for (; W < 16; ) {
                if (nt === 0)
                  break t;
                nt--, $ += q[rt++] << W, W += 8;
              }
              E.length = $, E.head && (E.head.extra_len = $), 512 & E.flags && (Y[0] = 255 & $, Y[1] = $ >>> 8 & 255, E.check = s(E.check, Y, 2, 0)), W = $ = 0;
            } else
              E.head && (E.head.extra = null);
            E.mode = 6;
          case 6:
            if (1024 & E.flags && (nt < (dt = E.length) && (dt = nt), dt && (E.head && (S = E.head.extra_len - E.length, E.head.extra || (E.head.extra = new Array(E.head.extra_len)), n.arraySet(E.head.extra, q, rt, dt, S)), 512 & E.flags && (E.check = s(E.check, q, dt, rt)), nt -= dt, rt += dt, E.length -= dt), E.length))
              break t;
            E.length = 0, E.mode = 7;
          case 7:
            if (2048 & E.flags) {
              if (nt === 0)
                break t;
              for (dt = 0; S = q[rt + dt++], E.head && S && E.length < 65536 && (E.head.name += String.fromCharCode(S)), S && dt < nt; )
                ;
              if (512 & E.flags && (E.check = s(E.check, q, dt, rt)), nt -= dt, rt += dt, S)
                break t;
            } else
              E.head && (E.head.name = null);
            E.length = 0, E.mode = 8;
          case 8:
            if (4096 & E.flags) {
              if (nt === 0)
                break t;
              for (dt = 0; S = q[rt + dt++], E.head && S && E.length < 65536 && (E.head.comment += String.fromCharCode(S)), S && dt < nt; )
                ;
              if (512 & E.flags && (E.check = s(E.check, q, dt, rt)), nt -= dt, rt += dt, S)
                break t;
            } else
              E.head && (E.head.comment = null);
            E.mode = 9;
          case 9:
            if (512 & E.flags) {
              for (; W < 16; ) {
                if (nt === 0)
                  break t;
                nt--, $ += q[rt++] << W, W += 8;
              }
              if ($ !== (65535 & E.check)) {
                R.msg = "header crc mismatch", E.mode = 30;
                break;
              }
              W = $ = 0;
            }
            E.head && (E.head.hcrc = E.flags >> 9 & 1, E.head.done = !0), R.adler = E.check = 0, E.mode = 12;
            break;
          case 10:
            for (; W < 32; ) {
              if (nt === 0)
                break t;
              nt--, $ += q[rt++] << W, W += 8;
            }
            R.adler = E.check = m($), W = $ = 0, E.mode = 11;
          case 11:
            if (E.havedict === 0)
              return R.next_out = ft, R.avail_out = vt, R.next_in = rt, R.avail_in = nt, E.hold = $, E.bits = W, 2;
            R.adler = E.check = 1, E.mode = 12;
          case 12:
            if (L === 5 || L === 6)
              break t;
          case 13:
            if (E.last) {
              $ >>>= 7 & W, W -= 7 & W, E.mode = 27;
              break;
            }
            for (; W < 3; ) {
              if (nt === 0)
                break t;
              nt--, $ += q[rt++] << W, W += 8;
            }
            switch (E.last = 1 & $, W -= 1, 3 & ($ >>>= 1)) {
              case 0:
                E.mode = 14;
                break;
              case 1:
                if (I(E), E.mode = 20, L !== 6)
                  break;
                $ >>>= 2, W -= 2;
                break t;
              case 2:
                E.mode = 17;
                break;
              case 3:
                R.msg = "invalid block type", E.mode = 30;
            }
            $ >>>= 2, W -= 2;
            break;
          case 14:
            for ($ >>>= 7 & W, W -= 7 & W; W < 32; ) {
              if (nt === 0)
                break t;
              nt--, $ += q[rt++] << W, W += 8;
            }
            if ((65535 & $) != ($ >>> 16 ^ 65535)) {
              R.msg = "invalid stored block lengths", E.mode = 30;
              break;
            }
            if (E.length = 65535 & $, W = $ = 0, E.mode = 15, L === 6)
              break t;
          case 15:
            E.mode = 16;
          case 16:
            if (dt = E.length) {
              if (nt < dt && (dt = nt), vt < dt && (dt = vt), dt === 0)
                break t;
              n.arraySet(it, q, rt, dt, ft), nt -= dt, rt += dt, vt -= dt, ft += dt, E.length -= dt;
              break;
            }
            E.mode = 12;
            break;
          case 17:
            for (; W < 14; ) {
              if (nt === 0)
                break t;
              nt--, $ += q[rt++] << W, W += 8;
            }
            if (E.nlen = 257 + (31 & $), $ >>>= 5, W -= 5, E.ndist = 1 + (31 & $), $ >>>= 5, W -= 5, E.ncode = 4 + (15 & $), $ >>>= 4, W -= 4, 286 < E.nlen || 30 < E.ndist) {
              R.msg = "too many length or distance symbols", E.mode = 30;
              break;
            }
            E.have = 0, E.mode = 18;
          case 18:
            for (; E.have < E.ncode; ) {
              for (; W < 3; ) {
                if (nt === 0)
                  break t;
                nt--, $ += q[rt++] << W, W += 8;
              }
              E.lens[pt[E.have++]] = 7 & $, $ >>>= 3, W -= 3;
            }
            for (; E.have < 19; )
              E.lens[pt[E.have++]] = 0;
            if (E.lencode = E.lendyn, E.lenbits = 7, G = { bits: E.lenbits }, Z = o(0, E.lens, 0, 19, E.lencode, 0, E.work, G), E.lenbits = G.bits, Z) {
              R.msg = "invalid code lengths set", E.mode = 30;
              break;
            }
            E.have = 0, E.mode = 19;
          case 19:
            for (; E.have < E.nlen + E.ndist; ) {
              for (; N = (z = E.lencode[$ & (1 << E.lenbits) - 1]) >>> 16 & 255, st = 65535 & z, !((H = z >>> 24) <= W); ) {
                if (nt === 0)
                  break t;
                nt--, $ += q[rt++] << W, W += 8;
              }
              if (st < 16)
                $ >>>= H, W -= H, E.lens[E.have++] = st;
              else {
                if (st === 16) {
                  for (F = H + 2; W < F; ) {
                    if (nt === 0)
                      break t;
                    nt--, $ += q[rt++] << W, W += 8;
                  }
                  if ($ >>>= H, W -= H, E.have === 0) {
                    R.msg = "invalid bit length repeat", E.mode = 30;
                    break;
                  }
                  S = E.lens[E.have - 1], dt = 3 + (3 & $), $ >>>= 2, W -= 2;
                } else if (st === 17) {
                  for (F = H + 3; W < F; ) {
                    if (nt === 0)
                      break t;
                    nt--, $ += q[rt++] << W, W += 8;
                  }
                  W -= H, S = 0, dt = 3 + (7 & ($ >>>= H)), $ >>>= 3, W -= 3;
                } else {
                  for (F = H + 7; W < F; ) {
                    if (nt === 0)
                      break t;
                    nt--, $ += q[rt++] << W, W += 8;
                  }
                  W -= H, S = 0, dt = 11 + (127 & ($ >>>= H)), $ >>>= 7, W -= 7;
                }
                if (E.have + dt > E.nlen + E.ndist) {
                  R.msg = "invalid bit length repeat", E.mode = 30;
                  break;
                }
                for (; dt--; )
                  E.lens[E.have++] = S;
              }
            }
            if (E.mode === 30)
              break;
            if (E.lens[256] === 0) {
              R.msg = "invalid code -- missing end-of-block", E.mode = 30;
              break;
            }
            if (E.lenbits = 9, G = { bits: E.lenbits }, Z = o(l, E.lens, 0, E.nlen, E.lencode, 0, E.work, G), E.lenbits = G.bits, Z) {
              R.msg = "invalid literal/lengths set", E.mode = 30;
              break;
            }
            if (E.distbits = 6, E.distcode = E.distdyn, G = { bits: E.distbits }, Z = o(c, E.lens, E.nlen, E.ndist, E.distcode, 0, E.work, G), E.distbits = G.bits, Z) {
              R.msg = "invalid distances set", E.mode = 30;
              break;
            }
            if (E.mode = 20, L === 6)
              break t;
          case 20:
            E.mode = 21;
          case 21:
            if (6 <= nt && 258 <= vt) {
              R.next_out = ft, R.avail_out = vt, R.next_in = rt, R.avail_in = nt, E.hold = $, E.bits = W, a(R, mt), ft = R.next_out, it = R.output, vt = R.avail_out, rt = R.next_in, q = R.input, nt = R.avail_in, $ = E.hold, W = E.bits, E.mode === 12 && (E.back = -1);
              break;
            }
            for (E.back = 0; N = (z = E.lencode[$ & (1 << E.lenbits) - 1]) >>> 16 & 255, st = 65535 & z, !((H = z >>> 24) <= W); ) {
              if (nt === 0)
                break t;
              nt--, $ += q[rt++] << W, W += 8;
            }
            if (N && !(240 & N)) {
              for (et = H, J = N, K = st; N = (z = E.lencode[K + (($ & (1 << et + J) - 1) >> et)]) >>> 16 & 255, st = 65535 & z, !(et + (H = z >>> 24) <= W); ) {
                if (nt === 0)
                  break t;
                nt--, $ += q[rt++] << W, W += 8;
              }
              $ >>>= et, W -= et, E.back += et;
            }
            if ($ >>>= H, W -= H, E.back += H, E.length = st, N === 0) {
              E.mode = 26;
              break;
            }
            if (32 & N) {
              E.back = -1, E.mode = 12;
              break;
            }
            if (64 & N) {
              R.msg = "invalid literal/length code", E.mode = 30;
              break;
            }
            E.extra = 15 & N, E.mode = 22;
          case 22:
            if (E.extra) {
              for (F = E.extra; W < F; ) {
                if (nt === 0)
                  break t;
                nt--, $ += q[rt++] << W, W += 8;
              }
              E.length += $ & (1 << E.extra) - 1, $ >>>= E.extra, W -= E.extra, E.back += E.extra;
            }
            E.was = E.length, E.mode = 23;
          case 23:
            for (; N = (z = E.distcode[$ & (1 << E.distbits) - 1]) >>> 16 & 255, st = 65535 & z, !((H = z >>> 24) <= W); ) {
              if (nt === 0)
                break t;
              nt--, $ += q[rt++] << W, W += 8;
            }
            if (!(240 & N)) {
              for (et = H, J = N, K = st; N = (z = E.distcode[K + (($ & (1 << et + J) - 1) >> et)]) >>> 16 & 255, st = 65535 & z, !(et + (H = z >>> 24) <= W); ) {
                if (nt === 0)
                  break t;
                nt--, $ += q[rt++] << W, W += 8;
              }
              $ >>>= et, W -= et, E.back += et;
            }
            if ($ >>>= H, W -= H, E.back += H, 64 & N) {
              R.msg = "invalid distance code", E.mode = 30;
              break;
            }
            E.offset = st, E.extra = 15 & N, E.mode = 24;
          case 24:
            if (E.extra) {
              for (F = E.extra; W < F; ) {
                if (nt === 0)
                  break t;
                nt--, $ += q[rt++] << W, W += 8;
              }
              E.offset += $ & (1 << E.extra) - 1, $ >>>= E.extra, W -= E.extra, E.back += E.extra;
            }
            if (E.offset > E.dmax) {
              R.msg = "invalid distance too far back", E.mode = 30;
              break;
            }
            E.mode = 25;
          case 25:
            if (vt === 0)
              break t;
            if (dt = mt - vt, E.offset > dt) {
              if ((dt = E.offset - dt) > E.whave && E.sane) {
                R.msg = "invalid distance too far back", E.mode = 30;
                break;
              }
              Mt = dt > E.wnext ? (dt -= E.wnext, E.wsize - dt) : E.wnext - dt, dt > E.length && (dt = E.length), At = E.window;
            } else
              At = it, Mt = ft - E.offset, dt = E.length;
            for (vt < dt && (dt = vt), vt -= dt, E.length -= dt; it[ft++] = At[Mt++], --dt; )
              ;
            E.length === 0 && (E.mode = 21);
            break;
          case 26:
            if (vt === 0)
              break t;
            it[ft++] = E.length, vt--, E.mode = 21;
            break;
          case 27:
            if (E.wrap) {
              for (; W < 32; ) {
                if (nt === 0)
                  break t;
                nt--, $ |= q[rt++] << W, W += 8;
              }
              if (mt -= vt, R.total_out += mt, E.total += mt, mt && (R.adler = E.check = E.flags ? s(E.check, it, mt, ft - mt) : r(E.check, it, mt, ft - mt)), mt = vt, (E.flags ? $ : m($)) !== E.check) {
                R.msg = "incorrect data check", E.mode = 30;
                break;
              }
              W = $ = 0;
            }
            E.mode = 28;
          case 28:
            if (E.wrap && E.flags) {
              for (; W < 32; ) {
                if (nt === 0)
                  break t;
                nt--, $ += q[rt++] << W, W += 8;
              }
              if ($ !== (4294967295 & E.total)) {
                R.msg = "incorrect length check", E.mode = 30;
                break;
              }
              W = $ = 0;
            }
            E.mode = 29;
          case 29:
            Z = 1;
            break t;
          case 30:
            Z = -3;
            break t;
          case 31:
            return -4;
          default:
            return h;
        }
    return R.next_out = ft, R.avail_out = vt, R.next_in = rt, R.avail_in = nt, E.hold = $, E.bits = W, (E.wsize || mt !== R.avail_out && E.mode < 30 && (E.mode < 27 || L !== 4)) && k(R, R.output, R.next_out, mt - R.avail_out) ? (E.mode = 31, -4) : (ct -= R.avail_in, mt -= R.avail_out, R.total_in += ct, R.total_out += mt, E.total += mt, E.wrap && mt && (R.adler = E.check = E.flags ? s(E.check, it, mt, R.next_out - mt) : r(E.check, it, mt, R.next_out - mt)), R.data_type = E.bits + (E.last ? 64 : 0) + (E.mode === 12 ? 128 : 0) + (E.mode === 20 || E.mode === 15 ? 256 : 0), (ct == 0 && mt === 0 || L === 4) && Z === u && (Z = -5), Z);
  }, e.inflateEnd = function(R) {
    if (!R || !R.state)
      return h;
    var L = R.state;
    return L.window && (L.window = null), R.state = null, u;
  }, e.inflateGetHeader = function(R, L) {
    var E;
    return R && R.state && 2 & (E = R.state).wrap ? ((E.head = L).done = !1, u) : h;
  }, e.inflateSetDictionary = function(R, L) {
    var E, q = L.length;
    return R && R.state ? (E = R.state).wrap !== 0 && E.mode !== 11 ? h : E.mode === 11 && r(1, L, q, 0) !== E.check ? -3 : k(R, L, q, q) ? (E.mode = 31, -4) : (E.havedict = 1, u) : h;
  }, e.inflateInfo = "pako inflate (from Nodeca project)";
}, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./inffast": 48, "./inftrees": 50 }], 50: [function(i, t, e) {
  var n = i("../utils/common"), r = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], s = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], a = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], o = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
  t.exports = function(l, c, u, h, p, f, v, m) {
    var y, _, w, b, T, M, A, C, I, k = m.bits, R = 0, L = 0, E = 0, q = 0, it = 0, rt = 0, ft = 0, nt = 0, vt = 0, $ = 0, W = null, ct = 0, mt = new n.Buf16(16), dt = new n.Buf16(16), Mt = null, At = 0;
    for (R = 0; R <= 15; R++)
      mt[R] = 0;
    for (L = 0; L < h; L++)
      mt[c[u + L]]++;
    for (it = k, q = 15; 1 <= q && mt[q] === 0; q--)
      ;
    if (q < it && (it = q), q === 0)
      return p[f++] = 20971520, p[f++] = 20971520, m.bits = 1, 0;
    for (E = 1; E < q && mt[E] === 0; E++)
      ;
    for (it < E && (it = E), R = nt = 1; R <= 15; R++)
      if (nt <<= 1, (nt -= mt[R]) < 0)
        return -1;
    if (0 < nt && (l === 0 || q !== 1))
      return -1;
    for (dt[1] = 0, R = 1; R < 15; R++)
      dt[R + 1] = dt[R] + mt[R];
    for (L = 0; L < h; L++)
      c[u + L] !== 0 && (v[dt[c[u + L]]++] = L);
    if (M = l === 0 ? (W = Mt = v, 19) : l === 1 ? (W = r, ct -= 257, Mt = s, At -= 257, 256) : (W = a, Mt = o, -1), R = E, T = f, ft = L = $ = 0, w = -1, b = (vt = 1 << (rt = it)) - 1, l === 1 && 852 < vt || l === 2 && 592 < vt)
      return 1;
    for (; ; ) {
      for (A = R - ft, I = v[L] < M ? (C = 0, v[L]) : v[L] > M ? (C = Mt[At + v[L]], W[ct + v[L]]) : (C = 96, 0), y = 1 << R - ft, E = _ = 1 << rt; p[T + ($ >> ft) + (_ -= y)] = A << 24 | C << 16 | I | 0, _ !== 0; )
        ;
      for (y = 1 << R - 1; $ & y; )
        y >>= 1;
      if (y !== 0 ? ($ &= y - 1, $ += y) : $ = 0, L++, --mt[R] == 0) {
        if (R === q)
          break;
        R = c[u + v[L]];
      }
      if (it < R && ($ & b) !== w) {
        for (ft === 0 && (ft = it), T += E, nt = 1 << (rt = R - ft); rt + ft < q && !((nt -= mt[rt + ft]) <= 0); )
          rt++, nt <<= 1;
        if (vt += 1 << rt, l === 1 && 852 < vt || l === 2 && 592 < vt)
          return 1;
        p[w = $ & b] = it << 24 | rt << 16 | T - f | 0;
      }
    }
    return $ !== 0 && (p[T + $] = R - ft << 24 | 64 << 16 | 0), m.bits = it, 0;
  };
}, { "../utils/common": 41 }], 51: [function(i, t, e) {
  t.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
}, {}], 52: [function(i, t, e) {
  var n = i("../utils/common"), r = 0, s = 1;
  function a(z) {
    for (var Y = z.length; 0 <= --Y; )
      z[Y] = 0;
  }
  var o = 0, l = 29, c = 256, u = c + 1 + l, h = 30, p = 19, f = 2 * u + 1, v = 15, m = 16, y = 7, _ = 256, w = 16, b = 17, T = 18, M = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], A = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], C = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], I = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], k = new Array(2 * (u + 2));
  a(k);
  var R = new Array(2 * h);
  a(R);
  var L = new Array(512);
  a(L);
  var E = new Array(256);
  a(E);
  var q = new Array(l);
  a(q);
  var it, rt, ft, nt = new Array(h);
  function vt(z, Y, pt, ht, lt) {
    this.static_tree = z, this.extra_bits = Y, this.extra_base = pt, this.elems = ht, this.max_length = lt, this.has_stree = z && z.length;
  }
  function $(z, Y) {
    this.dyn_tree = z, this.max_code = 0, this.stat_desc = Y;
  }
  function W(z) {
    return z < 256 ? L[z] : L[256 + (z >>> 7)];
  }
  function ct(z, Y) {
    z.pending_buf[z.pending++] = 255 & Y, z.pending_buf[z.pending++] = Y >>> 8 & 255;
  }
  function mt(z, Y, pt) {
    z.bi_valid > m - pt ? (z.bi_buf |= Y << z.bi_valid & 65535, ct(z, z.bi_buf), z.bi_buf = Y >> m - z.bi_valid, z.bi_valid += pt - m) : (z.bi_buf |= Y << z.bi_valid & 65535, z.bi_valid += pt);
  }
  function dt(z, Y, pt) {
    mt(z, pt[2 * Y], pt[2 * Y + 1]);
  }
  function Mt(z, Y) {
    for (var pt = 0; pt |= 1 & z, z >>>= 1, pt <<= 1, 0 < --Y; )
      ;
    return pt >>> 1;
  }
  function At(z, Y, pt) {
    var ht, lt, yt = new Array(v + 1), O = 0;
    for (ht = 1; ht <= v; ht++)
      yt[ht] = O = O + pt[ht - 1] << 1;
    for (lt = 0; lt <= Y; lt++) {
      var V = z[2 * lt + 1];
      V !== 0 && (z[2 * lt] = Mt(yt[V]++, V));
    }
  }
  function H(z) {
    var Y;
    for (Y = 0; Y < u; Y++)
      z.dyn_ltree[2 * Y] = 0;
    for (Y = 0; Y < h; Y++)
      z.dyn_dtree[2 * Y] = 0;
    for (Y = 0; Y < p; Y++)
      z.bl_tree[2 * Y] = 0;
    z.dyn_ltree[2 * _] = 1, z.opt_len = z.static_len = 0, z.last_lit = z.matches = 0;
  }
  function N(z) {
    8 < z.bi_valid ? ct(z, z.bi_buf) : 0 < z.bi_valid && (z.pending_buf[z.pending++] = z.bi_buf), z.bi_buf = 0, z.bi_valid = 0;
  }
  function st(z, Y, pt, ht) {
    var lt = 2 * Y, yt = 2 * pt;
    return z[lt] < z[yt] || z[lt] === z[yt] && ht[Y] <= ht[pt];
  }
  function et(z, Y, pt) {
    for (var ht = z.heap[pt], lt = pt << 1; lt <= z.heap_len && (lt < z.heap_len && st(Y, z.heap[lt + 1], z.heap[lt], z.depth) && lt++, !st(Y, ht, z.heap[lt], z.depth)); )
      z.heap[pt] = z.heap[lt], pt = lt, lt <<= 1;
    z.heap[pt] = ht;
  }
  function J(z, Y, pt) {
    var ht, lt, yt, O, V = 0;
    if (z.last_lit !== 0)
      for (; ht = z.pending_buf[z.d_buf + 2 * V] << 8 | z.pending_buf[z.d_buf + 2 * V + 1], lt = z.pending_buf[z.l_buf + V], V++, ht === 0 ? dt(z, lt, Y) : (dt(z, (yt = E[lt]) + c + 1, Y), (O = M[yt]) !== 0 && mt(z, lt -= q[yt], O), dt(z, yt = W(--ht), pt), (O = A[yt]) !== 0 && mt(z, ht -= nt[yt], O)), V < z.last_lit; )
        ;
    dt(z, _, Y);
  }
  function K(z, Y) {
    var pt, ht, lt, yt = Y.dyn_tree, O = Y.stat_desc.static_tree, V = Y.stat_desc.has_stree, tt = Y.stat_desc.elems, gt = -1;
    for (z.heap_len = 0, z.heap_max = f, pt = 0; pt < tt; pt++)
      yt[2 * pt] !== 0 ? (z.heap[++z.heap_len] = gt = pt, z.depth[pt] = 0) : yt[2 * pt + 1] = 0;
    for (; z.heap_len < 2; )
      yt[2 * (lt = z.heap[++z.heap_len] = gt < 2 ? ++gt : 0)] = 1, z.depth[lt] = 0, z.opt_len--, V && (z.static_len -= O[2 * lt + 1]);
    for (Y.max_code = gt, pt = z.heap_len >> 1; 1 <= pt; pt--)
      et(z, yt, pt);
    for (lt = tt; pt = z.heap[1], z.heap[1] = z.heap[z.heap_len--], et(z, yt, 1), ht = z.heap[1], z.heap[--z.heap_max] = pt, z.heap[--z.heap_max] = ht, yt[2 * lt] = yt[2 * pt] + yt[2 * ht], z.depth[lt] = (z.depth[pt] >= z.depth[ht] ? z.depth[pt] : z.depth[ht]) + 1, yt[2 * pt + 1] = yt[2 * ht + 1] = lt, z.heap[1] = lt++, et(z, yt, 1), 2 <= z.heap_len; )
      ;
    z.heap[--z.heap_max] = z.heap[1], function(Tt, ot) {
      var St, It, xt, Ft, Kt, jt, qt = ot.dyn_tree, $t = ot.max_code, fe = ot.stat_desc.static_tree, Yt = ot.stat_desc.has_stree, te = ot.stat_desc.extra_bits, oe = ot.stat_desc.extra_base, ce = ot.stat_desc.max_length, Ve = 0;
      for (Ft = 0; Ft <= v; Ft++)
        Tt.bl_count[Ft] = 0;
      for (qt[2 * Tt.heap[Tt.heap_max] + 1] = 0, St = Tt.heap_max + 1; St < f; St++)
        ce < (Ft = qt[2 * qt[2 * (It = Tt.heap[St]) + 1] + 1] + 1) && (Ft = ce, Ve++), qt[2 * It + 1] = Ft, $t < It || (Tt.bl_count[Ft]++, Kt = 0, oe <= It && (Kt = te[It - oe]), jt = qt[2 * It], Tt.opt_len += jt * (Ft + Kt), Yt && (Tt.static_len += jt * (fe[2 * It + 1] + Kt)));
      if (Ve !== 0) {
        do {
          for (Ft = ce - 1; Tt.bl_count[Ft] === 0; )
            Ft--;
          Tt.bl_count[Ft]--, Tt.bl_count[Ft + 1] += 2, Tt.bl_count[ce]--, Ve -= 2;
        } while (0 < Ve);
        for (Ft = ce; Ft !== 0; Ft--)
          for (It = Tt.bl_count[Ft]; It !== 0; )
            $t < (xt = Tt.heap[--St]) || (qt[2 * xt + 1] !== Ft && (Tt.opt_len += (Ft - qt[2 * xt + 1]) * qt[2 * xt], qt[2 * xt + 1] = Ft), It--);
      }
    }(z, Y), At(yt, gt, z.bl_count);
  }
  function S(z, Y, pt) {
    var ht, lt, yt = -1, O = Y[1], V = 0, tt = 7, gt = 4;
    for (O === 0 && (tt = 138, gt = 3), Y[2 * (pt + 1) + 1] = 65535, ht = 0; ht <= pt; ht++)
      lt = O, O = Y[2 * (ht + 1) + 1], ++V < tt && lt === O || (V < gt ? z.bl_tree[2 * lt] += V : lt !== 0 ? (lt !== yt && z.bl_tree[2 * lt]++, z.bl_tree[2 * w]++) : V <= 10 ? z.bl_tree[2 * b]++ : z.bl_tree[2 * T]++, yt = lt, gt = (V = 0) === O ? (tt = 138, 3) : lt === O ? (tt = 6, 3) : (tt = 7, 4));
  }
  function Z(z, Y, pt) {
    var ht, lt, yt = -1, O = Y[1], V = 0, tt = 7, gt = 4;
    for (O === 0 && (tt = 138, gt = 3), ht = 0; ht <= pt; ht++)
      if (lt = O, O = Y[2 * (ht + 1) + 1], !(++V < tt && lt === O)) {
        if (V < gt)
          for (; dt(z, lt, z.bl_tree), --V != 0; )
            ;
        else
          lt !== 0 ? (lt !== yt && (dt(z, lt, z.bl_tree), V--), dt(z, w, z.bl_tree), mt(z, V - 3, 2)) : V <= 10 ? (dt(z, b, z.bl_tree), mt(z, V - 3, 3)) : (dt(z, T, z.bl_tree), mt(z, V - 11, 7));
        yt = lt, gt = (V = 0) === O ? (tt = 138, 3) : lt === O ? (tt = 6, 3) : (tt = 7, 4);
      }
  }
  a(nt);
  var G = !1;
  function F(z, Y, pt, ht) {
    mt(z, (o << 1) + (ht ? 1 : 0), 3), function(lt, yt, O, V) {
      N(lt), V && (ct(lt, O), ct(lt, ~O)), n.arraySet(lt.pending_buf, lt.window, yt, O, lt.pending), lt.pending += O;
    }(z, Y, pt, !0);
  }
  e._tr_init = function(z) {
    G || (function() {
      var Y, pt, ht, lt, yt, O = new Array(v + 1);
      for (lt = ht = 0; lt < l - 1; lt++)
        for (q[lt] = ht, Y = 0; Y < 1 << M[lt]; Y++)
          E[ht++] = lt;
      for (E[ht - 1] = lt, lt = yt = 0; lt < 16; lt++)
        for (nt[lt] = yt, Y = 0; Y < 1 << A[lt]; Y++)
          L[yt++] = lt;
      for (yt >>= 7; lt < h; lt++)
        for (nt[lt] = yt << 7, Y = 0; Y < 1 << A[lt] - 7; Y++)
          L[256 + yt++] = lt;
      for (pt = 0; pt <= v; pt++)
        O[pt] = 0;
      for (Y = 0; Y <= 143; )
        k[2 * Y + 1] = 8, Y++, O[8]++;
      for (; Y <= 255; )
        k[2 * Y + 1] = 9, Y++, O[9]++;
      for (; Y <= 279; )
        k[2 * Y + 1] = 7, Y++, O[7]++;
      for (; Y <= 287; )
        k[2 * Y + 1] = 8, Y++, O[8]++;
      for (At(k, u + 1, O), Y = 0; Y < h; Y++)
        R[2 * Y + 1] = 5, R[2 * Y] = Mt(Y, 5);
      it = new vt(k, M, c + 1, u, v), rt = new vt(R, A, 0, h, v), ft = new vt(new Array(0), C, 0, p, y);
    }(), G = !0), z.l_desc = new $(z.dyn_ltree, it), z.d_desc = new $(z.dyn_dtree, rt), z.bl_desc = new $(z.bl_tree, ft), z.bi_buf = 0, z.bi_valid = 0, H(z);
  }, e._tr_stored_block = F, e._tr_flush_block = function(z, Y, pt, ht) {
    var lt, yt, O = 0;
    0 < z.level ? (z.strm.data_type === 2 && (z.strm.data_type = function(V) {
      var tt, gt = 4093624447;
      for (tt = 0; tt <= 31; tt++, gt >>>= 1)
        if (1 & gt && V.dyn_ltree[2 * tt] !== 0)
          return r;
      if (V.dyn_ltree[18] !== 0 || V.dyn_ltree[20] !== 0 || V.dyn_ltree[26] !== 0)
        return s;
      for (tt = 32; tt < c; tt++)
        if (V.dyn_ltree[2 * tt] !== 0)
          return s;
      return r;
    }(z)), K(z, z.l_desc), K(z, z.d_desc), O = function(V) {
      var tt;
      for (S(V, V.dyn_ltree, V.l_desc.max_code), S(V, V.dyn_dtree, V.d_desc.max_code), K(V, V.bl_desc), tt = p - 1; 3 <= tt && V.bl_tree[2 * I[tt] + 1] === 0; tt--)
        ;
      return V.opt_len += 3 * (tt + 1) + 5 + 5 + 4, tt;
    }(z), lt = z.opt_len + 3 + 7 >>> 3, (yt = z.static_len + 3 + 7 >>> 3) <= lt && (lt = yt)) : lt = yt = pt + 5, pt + 4 <= lt && Y !== -1 ? F(z, Y, pt, ht) : z.strategy === 4 || yt === lt ? (mt(z, 2 + (ht ? 1 : 0), 3), J(z, k, R)) : (mt(z, 4 + (ht ? 1 : 0), 3), function(V, tt, gt, Tt) {
      var ot;
      for (mt(V, tt - 257, 5), mt(V, gt - 1, 5), mt(V, Tt - 4, 4), ot = 0; ot < Tt; ot++)
        mt(V, V.bl_tree[2 * I[ot] + 1], 3);
      Z(V, V.dyn_ltree, tt - 1), Z(V, V.dyn_dtree, gt - 1);
    }(z, z.l_desc.max_code + 1, z.d_desc.max_code + 1, O + 1), J(z, z.dyn_ltree, z.dyn_dtree)), H(z), ht && N(z);
  }, e._tr_tally = function(z, Y, pt) {
    return z.pending_buf[z.d_buf + 2 * z.last_lit] = Y >>> 8 & 255, z.pending_buf[z.d_buf + 2 * z.last_lit + 1] = 255 & Y, z.pending_buf[z.l_buf + z.last_lit] = 255 & pt, z.last_lit++, Y === 0 ? z.dyn_ltree[2 * pt]++ : (z.matches++, Y--, z.dyn_ltree[2 * (E[pt] + c + 1)]++, z.dyn_dtree[2 * W(Y)]++), z.last_lit === z.lit_bufsize - 1;
  }, e._tr_align = function(z) {
    mt(z, 2, 3), dt(z, _, k), function(Y) {
      Y.bi_valid === 16 ? (ct(Y, Y.bi_buf), Y.bi_buf = 0, Y.bi_valid = 0) : 8 <= Y.bi_valid && (Y.pending_buf[Y.pending++] = 255 & Y.bi_buf, Y.bi_buf >>= 8, Y.bi_valid -= 8);
    }(z);
  };
}, { "../utils/common": 41 }], 53: [function(i, t, e) {
  t.exports = function() {
    this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
  };
}, {}], 54: [function(i, t, e) {
  (function(n) {
    (function(r, s) {
      if (!r.setImmediate) {
        var a, o, l, c, u = 1, h = {}, p = !1, f = r.document, v = Object.getPrototypeOf && Object.getPrototypeOf(r);
        v = v && v.setTimeout ? v : r, a = {}.toString.call(r.process) === "[object process]" ? function(w) {
          process.nextTick(function() {
            y(w);
          });
        } : function() {
          if (r.postMessage && !r.importScripts) {
            var w = !0, b = r.onmessage;
            return r.onmessage = function() {
              w = !1;
            }, r.postMessage("", "*"), r.onmessage = b, w;
          }
        }() ? (c = "setImmediate$" + Math.random() + "$", r.addEventListener ? r.addEventListener("message", _, !1) : r.attachEvent("onmessage", _), function(w) {
          r.postMessage(c + w, "*");
        }) : r.MessageChannel ? ((l = new MessageChannel()).port1.onmessage = function(w) {
          y(w.data);
        }, function(w) {
          l.port2.postMessage(w);
        }) : f && "onreadystatechange" in f.createElement("script") ? (o = f.documentElement, function(w) {
          var b = f.createElement("script");
          b.onreadystatechange = function() {
            y(w), b.onreadystatechange = null, o.removeChild(b), b = null;
          }, o.appendChild(b);
        }) : function(w) {
          setTimeout(y, 0, w);
        }, v.setImmediate = function(w) {
          typeof w != "function" && (w = new Function("" + w));
          for (var b = new Array(arguments.length - 1), T = 0; T < b.length; T++)
            b[T] = arguments[T + 1];
          var M = { callback: w, args: b };
          return h[u] = M, a(u), u++;
        }, v.clearImmediate = m;
      }
      function m(w) {
        delete h[w];
      }
      function y(w) {
        if (p)
          setTimeout(y, 0, w);
        else {
          var b = h[w];
          if (b) {
            p = !0;
            try {
              (function(T) {
                var M = T.callback, A = T.args;
                switch (A.length) {
                  case 0:
                    M();
                    break;
                  case 1:
                    M(A[0]);
                    break;
                  case 2:
                    M(A[0], A[1]);
                    break;
                  case 3:
                    M(A[0], A[1], A[2]);
                    break;
                  default:
                    M.apply(s, A);
                }
              })(b);
            } finally {
              m(w), p = !1;
            }
          }
        }
      }
      function _(w) {
        w.source === r && typeof w.data == "string" && w.data.indexOf(c) === 0 && y(+w.data.slice(c.length));
      }
    })(typeof self > "u" ? n === void 0 ? this : n : self);
  }).call(this, bn !== void 0 ? bn : typeof self < "u" ? self : typeof window < "u" ? window : {});
}, {}] }, {}, [10])(10);
const dlt = Mp($z.exports), qw = async (i, { baseUrl: t, streamId: e, token: n }) => {
  if (!i)
    return null;
  const r = (async ({ baseUrl: o, streamId: l, token: c, blobIds: u }, h) => {
    const p = await await fetch(`${o}/api/stream/${l}/blobszip`, { method: "post", headers: { Authorization: `Bearer ${c}`, "Content-Type": "application/json" }, body: JSON.stringify({ blobIds: u }), responseType: "blob" });
    if (p.status !== 200 || !p.body)
      return !1;
    const f = Number(p.headers.get("Content-Length"));
    let v = 0;
    const m = p.body.getReader(), y = new ReadableStream({ start(_) {
      const w = () => m.read().then(({ done: b, value: T }) => b ? (_.close(), void (h == null ? void 0 : h(v, f, !0))) : (v += (T == null ? void 0 : T.length) || 0, h == null || h(v, f), _.enqueue(T), w()));
      return w();
    } });
    return await new Response(y).blob();
  })({ blobIds: i, baseUrl: t, streamId: e, token: n });
  if (!r)
    return null;
  const s = await (a = r, new Promise((o, l) => {
    new dlt().loadAsync(a).then((c) => {
      o(c.files);
    }).catch((c) => {
      l(c);
    });
  }));
  var a;
  return s ? Object.entries(s) : null;
}, aI = 10485760, plt = async (i, { baseUrl: t, streamId: e, token: n }) => {
  const r = await (async (a, { baseUrl: o, streamId: l, token: c }) => a ? (await fetch(`${o}/api/stream/${l}/blobs/meta`, { method: "post", headers: { Authorization: `Bearer ${c}`, "Content-Type": "application/json" }, body: JSON.stringify({ blobIds: a }) })).json() : null)(i, { baseUrl: t, streamId: e, token: n });
  if (r.reduce((a, o) => a += o.fileSize, 0) <= aI)
    return await qw(i, { baseUrl: t, streamId: e, token: n });
  const s = r.reduce((a, o) => {
    const l = a.lastSize + o.fileSize;
    return l <= aI ? (a.blobIdChunks.length === 0 ? a.blobIdChunks.push([o.id]) : a.blobIdChunks[a.blobIdChunks.length - 1].push(o.id), a.lastSize = l) : (a.blobIdChunks.push([o.id]), a.lastSize = o.fileSize), a;
  }, { lastSize: 0, blobIdChunks: [] }).blobIdChunks;
  return s.length === 1 ? await qw(s[0], { baseUrl: t, streamId: e, token: n }) : (await Promise.all(s.map((a) => qw(a, { baseUrl: t, streamId: e, token: n })))).reduce((a, o) => a.concat(o), []);
}, flt = function() {
  const i = {};
  return async function(t, e, n, { baseUrl: r, streamId: s, token: a, blobName: o, mapName: l, index: c }) {
    const u = ((t == null ? void 0 : t.userData[o]) || [])[0];
    if (!u)
      return;
    const h = (y) => {
      const _ = e.renderObject.material;
      Array.isArray(_) ? (e.renderObject.material[c][l] = y, e.renderObject.material[c].alphaToCoverage = !0) : e.renderObject.material[l] = y;
    };
    if (i[u])
      return void h(i[u]);
    const p = (n.find((y) => y[0].includes(u)) || [])[1], f = await (async (y) => new Promise((_, w) => {
      y.async("blob").then((b) => {
        _(b);
      }).catch((b) => {
        w(blob);
      });
    }))(p), v = await (m = f, new Promise((y, _) => {
      const w = URL.createObjectURL(m);
      new o0().load(w, function(b) {
        b.wrapS = 1e3, b.wrapT = 1e3, b.encoding = 3e3, y(b);
      }, void 0, (b) => {
        _(b);
      });
    }));
    var m;
    v && (i[u] = v, h(v));
  };
}(), Xw = { blobIds: "map", aoBlobIds: "aoMap", normalBlobIds: "normalMap", metalnessBlobIds: "metalnessMap", roughnessBlobIds: "roughnessMap", emissiveBlobIds: "emissiveMap", alphaBlobIds: "alphaMap", bumpBlobIds: "bumpMap" }, oI = async function(i, t) {
  var a, o, l;
  const e = ((a = i[0]) == null ? void 0 : a.subtreeId.split("/streams/")) || [], n = e[0], r = e[1].split("/")[0], { zipfiles: s } = await (async (c, { baseUrl: u, streamId: h, token: p }) => {
    var f, v, m;
    try {
      let y, _ = [];
      for (let w = 0; w < c.length; w++)
        if (y = (m = (v = (f = c[w]) == null ? void 0 : f.renderViews[0]) == null ? void 0 : v.renderData) == null ? void 0 : m.renderMaterial, Array.isArray(y))
          for (let b = 0; b < y.length; b++) {
            const T = y[b];
            Object.entries(Xw).forEach((M) => {
              const A = ((T == null ? void 0 : T.userData[M[0]]) || [])[0];
              A && !_.includes(A) && _.push(A);
            });
          }
        else
          Object.entries(Xw).forEach((b) => {
            const T = ((y == null ? void 0 : y.userData[b[0]]) || [])[0];
            T && !_.includes(T) && _.push(T);
          });
      return _.length < 1 ? void 0 : { zipfiles: await plt(_, { baseUrl: u, streamId: h, token: p }), blobIds: _ };
    } catch (y) {
      console.log(y);
    }
  })(i, { baseUrl: n, streamId: r, token: t }) || {};
  try {
    for (let c = 0; c < i.length; c++) {
      const u = i[c], h = (l = (o = u == null ? void 0 : u.renderViews[0]) == null ? void 0 : o.renderData) == null ? void 0 : l.renderMaterial;
      if (!h)
        continue;
      const p = async (f, v) => {
        const m = { baseUrl: n, streamId: r, token: t, index: v }, y = Object.entries(Xw);
        for (let _ = 0; _ < y.length; _++)
          await flt(f, u, s, { ...m, blobName: y[_][0], mapName: y[_][1] });
      };
      if (Array.isArray(h))
        for (let f = 0; f < h.length; f++) {
          const v = h[f];
          await p(v, f);
        }
      else
        await p(h);
    }
  } catch (c) {
    console.error(c), console.error("设置batch纹理异常！");
  }
};
class mlt {
  static setPivotPoint(t, e) {
    var l, c;
    if ((l = t == null ? void 0 : t.material) != null && l.isShaderMaterial || (c = t == null ? void 0 : t.material) != null && c.isRawShaderMaterial)
      throw new Error("material is null or material is shader type is not support!");
    t.material || (t.material = new ci()), t.onBeforeRender = function() {
      var h, p;
      const u = new Vt().makeRotationFromEuler(this.rotation);
      (p = (h = this.material) == null ? void 0 : h.uniforms) != null && p.rotationMatrix && (this.material.uniforms.rotationMatrix.value = u);
    };
    const n = e.clone(), r = t.getWorldPosition(new D()), s = n.clone().sub(r), a = r.clone().sub(n.clone()), o = { rotationMatrix: { value: new Vt() }, orginTranslation: { value: a }, backTranslation: { value: s } };
    (function(u, h, p) {
      u.onBeforeCompile = (f) => {
        f.__modified || (f.__modified = !0, Object.assign(f.uniforms, h), u.isMeshBasicMaterial ? f.vertexShader = `
        uniform mat4 rotationMatrix;
        uniform vec3 backTranslation;
        uniform vec3 orginTranslation;

        #include <common>
        #include <uv_pars_vertex>
        #include <envmap_pars_vertex>
        #include <color_pars_vertex>
        #include <fog_pars_vertex>
        #include <morphtarget_pars_vertex>
        #include <skinning_pars_vertex>
        #include <logdepthbuf_pars_vertex>
        #include <clipping_planes_pars_vertex>

        void main() {

            #include <uv_vertex>
            #include <color_vertex>
            #include <morphcolor_vertex>

            #if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )

                #include <beginnormal_vertex>
                #include <morphnormal_vertex>
                #include <skinbase_vertex>
                #include <skinnormal_vertex>
                #include <defaultnormal_vertex>

            #endif

            #include <begin_vertex>
            #include <morphtarget_vertex>
            #include <skinning_vertex>
            #include <project_vertex>
            #include <logdepthbuf_vertex>
            #include <clipping_planes_vertex>

            #include <worldpos_vertex>
            #include <envmap_vertex>
            #include <fog_vertex>

            vec4 transformedPosition =  vec4(position, 1.);
            transformedPosition.xyz += orginTranslation;
            transformedPosition = rotationMatrix * transformedPosition;
            transformedPosition.xyz += backTranslation;

            // 提取平移向量
            vec3 translationVector = vec3(modelMatrix[3][0], modelMatrix[3][1], modelMatrix[3][2]);
            transformedPosition.xyz += translationVector;

            transformedPosition = projectionMatrix * viewMatrix * transformedPosition;
            gl_Position = transformedPosition;

        }
    ` : u.isMeshStandardMaterial || u.isMeshPhysicalMaterial ? f.vertexShader = `
        #define STANDARD
        
        uniform mat4 rotationMatrix;
        uniform vec3 backTranslation;
        uniform vec3 orginTranslation;
        
        varying vec3 vViewPosition;
        
        #ifdef USE_TRANSMISSION
        
          varying vec3 vWorldPosition;
        
        #endif
        
        #include <common>
        #include <uv_pars_vertex>
        #include <displacementmap_pars_vertex>
        #include <color_pars_vertex>
        #include <fog_pars_vertex>
        #include <normal_pars_vertex>
        #include <morphtarget_pars_vertex>
        #include <skinning_pars_vertex>
        #include <shadowmap_pars_vertex>
        #include <logdepthbuf_pars_vertex>
        #include <clipping_planes_pars_vertex>
        
        void main() {
        
          #include <uv_vertex>
          #include <color_vertex>
          #include <morphcolor_vertex>
        
          #include <beginnormal_vertex>
          #include <morphnormal_vertex>
          #include <skinbase_vertex>
          #include <skinnormal_vertex>
          #include <defaultnormal_vertex>
          #include <normal_vertex>
        
          #include <begin_vertex>
          #include <morphtarget_vertex>
          #include <skinning_vertex>
          #include <displacementmap_vertex>
          #include <project_vertex>
          #include <logdepthbuf_vertex>
          #include <clipping_planes_vertex>
        
          vViewPosition = - mvPosition.xyz;
        
          #include <worldpos_vertex>
          #include <shadowmap_vertex>
          #include <fog_vertex>
        
        #ifdef USE_TRANSMISSION
        
          vWorldPosition = worldPosition.xyz;
        
        #endif
          
         vec4 transformedPosition =  vec4(position, 1.);
         
         // 提取平移向量
         vec3 translationVector = vec3(modelMatrix[3][0], modelMatrix[3][1], modelMatrix[3][2]);
         transformedPosition.xyz += translationVector;

          transformedPosition.xyz += orginTranslation;
          transformedPosition = rotationMatrix * transformedPosition;
          transformedPosition.xyz += backTranslation;
          
          transformedPosition = projectionMatrix * viewMatrix * transformedPosition;
          gl_Position = transformedPosition;
        }
        ` : u.isMeshPhongMaterial ? f.vertexShader = `
        #define PHONG
        uniform mat4 rotationMatrix;
        uniform vec3 backTranslation;
        uniform vec3 orginTranslation;

        varying vec3 vViewPosition;

        #include <common>
        #include <uv_pars_vertex>
        #include <displacementmap_pars_vertex>
        #include <envmap_pars_vertex>
        #include <color_pars_vertex>
        #include <fog_pars_vertex>
        #include <normal_pars_vertex>
        #include <morphtarget_pars_vertex>
        #include <skinning_pars_vertex>
        #include <shadowmap_pars_vertex>
        #include <logdepthbuf_pars_vertex>
        #include <clipping_planes_pars_vertex>

        void main() {

            #include <uv_vertex>
            #include <color_vertex>
            #include <morphcolor_vertex>

            #include <beginnormal_vertex>
            #include <morphnormal_vertex>
            #include <skinbase_vertex>
            #include <skinnormal_vertex>
            #include <defaultnormal_vertex>
            #include <normal_vertex>

            #include <begin_vertex>
            #include <morphtarget_vertex>
            #include <skinning_vertex>
            #include <displacementmap_vertex>
            #include <project_vertex>
            #include <logdepthbuf_vertex>
            #include <clipping_planes_vertex>

            vViewPosition = - mvPosition.xyz;

            #include <worldpos_vertex>
            #include <envmap_vertex>
            #include <shadowmap_vertex>
            #include <fog_vertex>

            vec4 transformedPosition =  vec4(position, 1.);
            transformedPosition.xyz += orginTranslation;
            transformedPosition = rotationMatrix * transformedPosition;
            transformedPosition.xyz += backTranslation;

            // 提取平移向量
            vec3 translationVector = vec3(modelMatrix[3][0], modelMatrix[3][1], modelMatrix[3][2]);
            transformedPosition.xyz += translationVector;

            transformedPosition = projectionMatrix * viewMatrix * transformedPosition;
            gl_Position = transformedPosition;
}
` : u.isMeshLambertMaterial ? f.vertexShader = `
            #define LAMBERT
            uniform mat4 rotationMatrix;
            uniform vec3 backTranslation;
            uniform vec3 orginTranslation;

            varying vec3 vViewPosition;

            #include <common>
            #include <uv_pars_vertex>
            #include <displacementmap_pars_vertex>
            #include <envmap_pars_vertex>
            #include <color_pars_vertex>
            #include <fog_pars_vertex>
            #include <normal_pars_vertex>
            #include <morphtarget_pars_vertex>
            #include <skinning_pars_vertex>
            #include <shadowmap_pars_vertex>
            #include <logdepthbuf_pars_vertex>
            #include <clipping_planes_pars_vertex>

            void main() {

                #include <uv_vertex>
                #include <color_vertex>
                #include <morphcolor_vertex>

                #include <beginnormal_vertex>
                #include <morphnormal_vertex>
                #include <skinbase_vertex>
                #include <skinnormal_vertex>
                #include <defaultnormal_vertex>
                #include <normal_vertex>

                #include <begin_vertex>
                #include <morphtarget_vertex>
                #include <skinning_vertex>
                #include <displacementmap_vertex>
                #include <project_vertex>
                #include <logdepthbuf_vertex>
                #include <clipping_planes_vertex>

                vViewPosition = - mvPosition.xyz;

                #include <worldpos_vertex>
                #include <envmap_vertex>
                #include <shadowmap_vertex>
                #include <fog_vertex>

                vec4 transformedPosition =  vec4(position, 1.);
                transformedPosition.xyz += orginTranslation;
                transformedPosition = rotationMatrix * transformedPosition;
                transformedPosition.xyz += backTranslation;

                // 提取平移向量
                vec3 translationVector = vec3(modelMatrix[3][0], modelMatrix[3][1], modelMatrix[3][2]);
                transformedPosition.xyz += translationVector;

                transformedPosition = projectionMatrix * viewMatrix * transformedPosition;
                gl_Position = transformedPosition;
            }
            ` : u.isMeshDepthMaterial ? f.vertexShader = `
            uniform mat4 rotationMatrix;
            uniform vec3 backTranslation;
            uniform vec3 orginTranslation;
            #include <common>
            #include <uv_pars_vertex>
            #include <displacementmap_pars_vertex>
            #include <morphtarget_pars_vertex>
            #include <skinning_pars_vertex>
            #include <logdepthbuf_pars_vertex>
            #include <clipping_planes_pars_vertex>

            // This is used for computing an equivalent of gl_FragCoord.z that is as high precision as possible.
            // Some platforms compute gl_FragCoord at a lower precision which makes the manually computed value better for
            // depth-based postprocessing effects. Reproduced on iPad with A10 processor / iPadOS 13.3.1.
            varying vec2 vHighPrecisionZW;

            void main() {

                #include <uv_vertex>

                #include <skinbase_vertex>

                #ifdef USE_DISPLACEMENTMAP

                    #include <beginnormal_vertex>
                    #include <morphnormal_vertex>
                    #include <skinnormal_vertex>

                #endif

                #include <begin_vertex>
                #include <morphtarget_vertex>
                #include <skinning_vertex>
                #include <displacementmap_vertex>
                #include <project_vertex>
                #include <logdepthbuf_vertex>
                #include <clipping_planes_vertex>

                vHighPrecisionZW = gl_Position.zw;

                vec4 transformedPosition =  vec4(position, 1.);
                transformedPosition.xyz += orginTranslation;
                transformedPosition = rotationMatrix * transformedPosition;
                transformedPosition.xyz += backTranslation;

                // 提取平移向量
                vec3 translationVector = vec3(modelMatrix[3][0], modelMatrix[3][1], modelMatrix[3][2]);
                transformedPosition.xyz += translationVector;

                transformedPosition = projectionMatrix * viewMatrix * transformedPosition;
                gl_Position = transformedPosition;

            }
            ` : f.vertexShader = `
            uniform mat4 rotationMatrix;
            uniform vec3 backTranslation;
            uniform vec3 orginTranslation;

            void main() {
                mat4 inverseRotationMatrix = transpose(modelMatrix);
                mat4 modelMatrixbak = modelMatrix * inverseRotationMatrix;
                vec4 transformedPosition = modelMatrixbak * vec4(position, 1.);

                // vec4 transformedPosition =  vec4(position, 1.);
                transformedPosition.xyz += orginTranslation;
                transformedPosition = rotationMatrix * transformedPosition;
                transformedPosition.xyz += backTranslation;

                // 提取平移向量
                vec3 translationVector = vec3(modelMatrix[3][0], modelMatrix[3][1], modelMatrix[3][2]);
                transformedPosition.xyz += translationVector;

                transformedPosition = projectionMatrix * viewMatrix * transformedPosition;
                gl_Position = transformedPosition;
            }
        `, p && p(f.uniforms));
      };
    })(t.material, o, (u) => {
      t.material.uniforms = u;
    });
  }
}
var pn = ((i) => (i[i.STREAM_CONTENT_MESH = 10] = "STREAM_CONTENT_MESH", i[i.STREAM_CONTENT_LINE = 11] = "STREAM_CONTENT_LINE", i[i.STREAM_CONTENT_POINT = 12] = "STREAM_CONTENT_POINT", i[i.STREAM_CONTENT = 1] = "STREAM_CONTENT", i[i.PROPS = 2] = "PROPS", i[i.SHADOWCATCHER = 3] = "SHADOWCATCHER", i))(pn || {});
class glt {
  constructor(t) {
    U(this, "SHOW_HELPERS", !1);
    U(this, "SHOW_BVH", !1);
    U(this, "container");
    U(this, "_renderer");
    U(this, "_scene");
    U(this, "_needsRender");
    U(this, "rootGroup");
    U(this, "batcher");
    U(this, "_intersections");
    U(this, "input");
    U(this, "sun");
    U(this, "sunTarget");
    U(this, "sunConfiguration", RB);
    U(this, "viewer");
    U(this, "filterBatchRecording");
    U(this, "pipeline");
    U(this, "lastSectionPlanes", []);
    U(this, "sectionPlanesChanged", []);
    U(this, "sectionBoxOutlines", null);
    U(this, "_shadowcatcher", null);
    U(this, "cancel", {});
    this._scene = new Tv(), this.rootGroup = new bi(), this.rootGroup.name = "ContentGroup", this.rootGroup.layers.set(1), this._scene.add(this.rootGroup), window._scene = this._scene, this.batcher = new Zz(), this._intersections = new Xot(), this.viewer = t, this.lastSectionPlanes.push(new Hn(), new Hn(), new Hn(), new Hn(), new Hn(), new Hn());
  }
  get renderer() {
    return this._renderer;
  }
  set needsRender(t) {
    this._needsRender || (this._needsRender = t);
  }
  set indirectIBL(t) {
    this._scene.environment = t;
  }
  set indirectIBLIntensity(t) {
    const e = this.batcher.getBatches(void 0, ae.MESH);
    for (let n = 0; n < e.length; n++) {
      let r = e[n].renderObject.material;
      r = Array.isArray(r) ? r : [r];
      for (let s = 0; s < r.length; s++)
        r[s].envMapIntensity = t;
    }
  }
  get allObjects() {
    return this._scene.getObjectByName("ContentGroup");
  }
  subtree(t) {
    return this._scene.getObjectByName(t);
  }
  get sceneBox() {
    return new ke().setFromObject(this.allObjects);
  }
  get sceneSphere() {
    return this.sceneBox.getBoundingSphere(new Mi());
  }
  get sceneCenter() {
    return this.sceneBox.getCenter(new D());
  }
  get sunLight() {
    return this.sun;
  }
  get camera() {
    return this.viewer.cameraHandler.activeCam.camera;
  }
  get scene() {
    return this._scene;
  }
  set pipelineOptions(t) {
    this.pipeline.pipelineOptions = t;
  }
  set showBVH(t) {
    this.SHOW_BVH = t, this.allObjects.traverse((e) => {
      e.name.includes("_bvh") && (e.visible = this.SHOW_BVH);
    });
  }
  get shadowcatcher() {
    return this._shadowcatcher;
  }
  get intersections() {
    return this._intersections;
  }
  get currentSectionBox() {
    return this.viewer.sectionBox.getCurrentBox();
  }
  create(t) {
    this._renderer = new Ub({ antialias: !0, alpha: !0, preserveDrawingBuffer: !0, stencil: !0 }), this._renderer.setClearColor(16777215, 0), this._renderer.setPixelRatio(window.devicePixelRatio), this._renderer.outputEncoding = 3e3, this._renderer.toneMapping = 1, this._renderer.toneMappingExposure = 0.3, this.renderer.shadowMap.enabled = !0, this.renderer.shadowMap.type = 3, this.renderer.shadowMap.autoUpdate = !1, this.renderer.shadowMap.needsUpdate = !0, this.renderer.autoClearStencil = !1, this.container = t, this._renderer.setSize(t.offsetWidth, t.offsetHeight), t.appendChild(this._renderer.domElement), this.pipeline = new eu(this._renderer, this.batcher), this.pipeline.configure(), this.pipeline.pipelineOptions = Kz, this.sectionBoxOutlines = new Ob();
    const e = new bi();
    if (e.name = "SectionBoxOutlines", this.scene.add(e), e.add(this.sectionBoxOutlines.getPlaneOutline(Cl.NEGATIVE_Z).renderable), e.add(this.sectionBoxOutlines.getPlaneOutline(Cl.POSITIVE_Z).renderable), e.add(this.sectionBoxOutlines.getPlaneOutline(Cl.POSITIVE_X).renderable), e.add(this.sectionBoxOutlines.getPlaneOutline(Cl.NEGATIVE_X).renderable), e.add(this.sectionBoxOutlines.getPlaneOutline(Cl.POSITIVE_Y).renderable), e.add(this.sectionBoxOutlines.getPlaneOutline(Cl.NEGATIVE_Y).renderable), this.input = new Wot(this._renderer.domElement, Got), this.input.on(tn.ObjectClicked, this.onObjectClick.bind(this)), this.input.on(tn.ObjectDoubleClicked, this.onObjectDoubleClick.bind(this)), this.addDirectLights(), this.SHOW_HELPERS) {
      const r = new bi();
      r.name = "Helpers", this._scene.add(r);
      const s = new oO(this.sceneBox, new Ht(255));
      s.name = "SceneBoxHelper", s.layers.set(2), r.add(s);
      const a = new sO(this.sun, 50, 16711680);
      a.name = "DirLightHelper", a.layers.set(2), r.add(a);
      const o = new aS(this.sun.shadow.camera);
      o.name = "CamHelper", o.layers.set(2), r.add(o);
    }
    let n;
    this.viewer.cameraHandler.controls.restThreshold = 1e-3, this.viewer.cameraHandler.controls.addEventListener("rest", () => {
      this._needsRender = !0, this.pipeline.onStationaryBegin();
    }), this.viewer.cameraHandler.controls.addEventListener("controlstart", () => {
      this._needsRender = !0, this.pipeline.onStationaryEnd();
    }), this.viewer.cameraHandler.controls.addEventListener("controlend", () => {
      this._needsRender = !0, this.viewer.cameraHandler.controls.hasRested && this.pipeline.onStationaryBegin();
    }), this.viewer.cameraHandler.controls.addEventListener("control", () => {
      this._needsRender = !0, this.pipeline.onStationaryEnd();
    }), this.viewer.cameraHandler.controls.addEventListener("update", () => {
      this.viewer.cameraHandler.controls.hasRested || this.pipeline.renderType !== wM.ACCUMULATION || (this._needsRender = !0, this.pipeline.onStationaryEnd());
    }), this._shadowcatcher = new Bb(3, [10], this.viewer.cameraHandler), this._shadowcatcher.shadowcatcherPass.onBeforeRender = () => {
      n = this.batcher.saveVisiblity();
      const r = this.batcher.getOpaque();
      this.batcher.applyVisibility(r);
    }, this._shadowcatcher.shadowcatcherPass.onAfterRender = () => {
      this.batcher.applyVisibility(n);
    }, this._scene.add(this._shadowcatcher.shadowcatcherMesh);
  }
  update(t) {
    var h, p, f, v, m, y, _;
    this.needsRender = (h = this.viewer.cameraHandler.controls) == null ? void 0 : h.update(t), this.batcher.update(t);
    const e = new D(), n = new D(), r = new D();
    e.set(this.sun.shadow.camera.matrixWorld.elements[12], this.sun.shadow.camera.matrixWorld.elements[13], this.sun.shadow.camera.matrixWorld.elements[14]), Nn.DoubleToHighLowVector(e, n, r);
    const s = new Vt();
    s.copy(this.sun.shadow.camera.matrixWorldInverse), s.elements[12] = 0, s.elements[13] = 0, s.elements[14] = 0;
    const a = this.batcher.getBatches(void 0, ae.MESH);
    for (let w = 0; w < a.length; w++) {
      const b = a[w].renderObject;
      if (b.isMesh) {
        const T = new Vt();
        T.copy(s), T.multiply(b.matrixWorld);
        const M = b.customDepthMaterial;
        M && (M.userData.uViewer_low.value.copy(n), M.userData.uViewer_high.value.copy(r), M.userData.rteModelViewMatrix.value.copy(T), M.needsUpdate = !0);
        const A = new Vt();
        A.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1), A.multiply(this.sun.shadow.camera.projectionMatrix), A.multiply(s);
        let C = b.material;
        C = Array.isArray(C) ? C : [C];
        for (let I = 0; I < C.length; I++)
          C[I] instanceof rs && ((f = (p = C[I].userData) == null ? void 0 : p.rteShadowMatrix) == null || f.value.copy(A), (m = (v = C[I].userData) == null ? void 0 : v.uShadowViewer_low) == null || m.value.copy(n), (_ = (y = C[I].userData) == null ? void 0 : y.uShadowViewer_high) == null || _.value.copy(r), C[I].needsUpdate = !0);
      }
    }
    const o = new D(), l = this.sceneBox, c = new D().copy(this.viewer.cameraHandler.activeCam.camera.position);
    let u = 0;
    o.set(l.min.x, l.min.y, l.min.z), u = Math.max(c.distanceTo(o), u), o.set(l.min.x, l.min.y, l.max.z), u = Math.max(c.distanceTo(o), u), o.set(l.min.x, l.max.y, l.min.z), u = Math.max(c.distanceTo(o), u), o.set(l.min.x, l.max.y, l.max.z), u = Math.max(c.distanceTo(o), u), o.set(l.max.x, l.min.y, l.min.z), u = Math.max(c.distanceTo(o), u), o.set(l.max.x, l.min.y, l.max.z), u = Math.max(c.distanceTo(o), u), o.set(l.max.x, l.max.y, l.min.z), u = Math.max(c.distanceTo(o), u), o.set(l.max.x, l.max.y, l.max.z), u = Math.max(c.distanceTo(o), u), this.viewer.cameraHandler.camera.far = u, this.viewer.cameraHandler.activeCam.camera.far = 2 * u, this.viewer.cameraHandler.activeCam.camera.updateProjectionMatrix(), this.viewer.cameraHandler.camera.updateProjectionMatrix(), this.pipeline.update(this), this.sunConfiguration.shadowcatcher && this._shadowcatcher.update(this._scene);
  }
  resetPipeline(t = !1) {
    this._needsRender = !0, (this.viewer.cameraHandler.controls.hasRested || t) && this.pipeline.reset();
  }
  render() {
    this._needsRender && (this.batcher.render(this.renderer), this._needsRender = this.pipeline.render(), this.sunConfiguration.shadowcatcher && this._shadowcatcher.render(this._renderer));
  }
  resize(t, e) {
    this.renderer.setSize(t, e), this.pipeline.resize(t, e), this._needsRender = !0;
  }
  async addRenderTree(t, e) {
    this.batcher.makeBatches(t, kD);
    const n = new bi();
    n.name = t, n.layers.set(1), this.rootGroup.add(n);
    const r = this.batcher.getBatches(t);
    console.time("setTexttime"), await oI(r, e), console.timeEnd("setTexttime");
    for (let s = 0; s < r.length; s++) {
      const a = r[s];
      this.addBatch(a, n);
    }
    this.updateDirectLights(), this.updateHelpers(), this.viewer.sectionBox.display.visible && this.viewer.setSectionBox(), this.updateShadowCatcher(), this._needsRender = !0, setTimeout(() => {
      this.viewer.emit("render-complete", t);
    }, 100);
  }
  async addRenderTreeAsync(t, e = 1, n) {
    this.cancel[t] = !1;
    const r = new bi();
    r.name = t, r.layers.set(1), this.rootGroup.add(r);
    const s = this.batcher.makeBatchesAsync(t, kD, void 0, e);
    for await (const a of s)
      if (await oI(a, n), this.addBatch(a, r), this.zoom(), a.geometryType === ae.MESH && (this.updateDirectLights(), this.updateShadowCatcher()), this._needsRender = !0, this.cancel[t]) {
        s.return(), this.removeRenderTree(t), delete this.cancel[t];
        break;
      }
    this.updateHelpers(), this.viewer.sectionBox.display.visible && this.viewer.setSectionBox(), delete this.cancel[t];
  }
  addBatch(t, e) {
    var r, s, a, o, l;
    const n = t.renderObject;
    if (!(Object.keys(((r = n == null ? void 0 : n.geometry) == null ? void 0 : r.morphAttributes) || {}).length > 0) && ((s = t == null ? void 0 : t.renderViews) == null ? void 0 : s.length) === 1 && ((l = (o = (a = t.renderViews[0]) == null ? void 0 : a._renderData) == null ? void 0 : o.renderMaterial) != null && l.trackName)) {
      const c = new D();
      t.renderViews[0].aabb.getCenter(c), mlt.setPivotPoint(t.renderObject, c);
    }
    if (e.add(t.renderObject), t.geometryType === ae.MESH) {
      const c = n.material;
      if (n.castShadow = !c.transparent, n.receiveShadow = !c.transparent, n.customDepthMaterial = new xp({ depthPacking: 3201 }, ["USE_RTE", "ALPHATEST_REJECTION"]), this.SHOW_BVH) {
        const u = new aM(n, 10);
        u.name = t.renderObject.id + "_bvh", u.traverse((h) => {
          h.layers.set(2);
        }), u.displayParents = !0, u.visible = !1, u.update(), e.add(u);
      }
    }
  }
  removeRenderTree(t) {
    this.rootGroup.remove(this.rootGroup.getObjectByName(t)), this.updateShadowCatcher(), this.batcher.purgeBatches(t), this.updateDirectLights(), this.updateHelpers();
  }
  cancelRenderTree(t) {
    this.cancel[t] !== void 0 && (this.cancel[t] = !0);
  }
  clearFilter() {
    this.batcher.resetBatchesDrawRanges(), this.filterBatchRecording = [];
  }
  applyFilter(t, e) {
    this.filterBatchRecording.push(...this.batcher.setObjectsFilterMaterial(t, e));
  }
  beginFilter() {
    this.filterBatchRecording = [];
  }
  endFilter() {
    this.batcher.autoFillDrawRanges(this.filterBatchRecording), this.updateClippingPlanes(this.viewer.sectionBox.planes), this.viewer.sectionBox.display.visible && this.updateSectionBoxCapper(), this.renderer.shadowMap.needsUpdate = !0, this.updateShadowCatcher();
  }
  updateClippingPlanes(t) {
    this.allObjects && (this.allObjects.traverse((e) => {
      const n = e.material;
      if (n)
        if (Array.isArray(n))
          for (let r = 0; r < n.length; r++)
            n[r].clippingPlanes = t;
        else
          n.clippingPlanes = t;
    }), this.pipeline.updateClippingPlanes(t), this.sectionBoxOutlines.updateClippingPlanes(t), this._shadowcatcher.updateClippingPlanes(t), this.renderer.shadowMap.needsUpdate = !0, this.resetPipeline());
  }
  setSectionPlaneChanged(t) {
    this.sectionPlanesChanged.length = 0;
    for (let e = 0; e < t.length; e++)
      Math.abs(this.lastSectionPlanes[e].constant - t[e].constant) > 1e-4 && this.sectionPlanesChanged.push(t[e]), this.lastSectionPlanes[e].copy(t[e]);
  }
  onSectionBoxDragStart() {
    this.sectionBoxOutlines.enable(!1);
  }
  onSectionBoxDragEnd() {
    const t = () => {
      this.setSectionPlaneChanged(this.viewer.sectionBox.planes), this.updateSectionBoxCapper(this.sectionPlanesChanged), this.updateShadowCatcher(), this.viewer.removeListener(tn.SectionBoxUpdated, t);
    };
    this.viewer.on(tn.SectionBoxUpdated, t);
  }
  updateSectionBoxCapper(t) {
    const e = performance.now();
    t || (t = this.viewer.sectionBox.planes);
    for (let n = 0; n < t.length; n++)
      this.sectionBoxOutlines.updatePlaneOutline(this.batcher.getBatches(void 0, ae.MESH), t[n]);
    this.sectionBoxOutlines.enable(this.viewer.sectionBox.display.visible), De.warn("Outline time: ", performance.now() - e);
  }
  enableSectionBoxCapper(t) {
    this.sectionBoxOutlines.enable(t);
  }
  updateShadowCatcher() {
    this._shadowcatcher.shadowcatcherMesh.visible = this.sunConfiguration.shadowcatcher, this.sunConfiguration.shadowcatcher && (this._shadowcatcher.bake(this.sceneBox, this._renderer.capabilities.maxTextureSize), this.resetPipeline());
  }
  addDirectLights() {
    this.sun = new ux(16777215, 5), this.sun.name = "sun", this.sun.layers.set(1), this._scene.add(this.sun), this.sun.castShadow = !0, this.sun.shadow.mapSize.width = 2048, this.sun.shadow.mapSize.height = 2048, this.sun.shadow.camera.left = -50, this.sun.shadow.camera.right = 50, this.sun.shadow.camera.top = 50, this.sun.shadow.camera.bottom = -50, this.sun.shadow.camera.near = 5, this.sun.shadow.camera.far = 350, this.sun.shadow.bias = -1e-3, this.sun.shadow.radius = 2, this.sunTarget = new Ue(), this._scene.add(this.sunTarget), this.sunTarget.position.copy(this.sceneCenter), this.sun.target = this.sunTarget;
    const t = new dx("#ffffff", 1);
    t.name = "ambient_light", this._scene.add(t);
  }
  updateDirectLights() {
    const t = this.sunConfiguration.elevation, e = this.sunConfiguration.azimuth, n = this.sunConfiguration.radius;
    this.sun.castShadow = this.sunConfiguration.castShadow, this.sun.intensity = this.sunConfiguration.intensity, this.sun.color = new Ht(this.sunConfiguration.color), this.sun.visible = this.sunConfiguration.enabled, this.sunTarget.position.copy(this.sceneCenter);
    const r = new rO(this.sceneSphere.radius + n, t, e);
    this.sun.position.setFromSpherical(r), this.sun.position.add(this.sunTarget.position), this.sun.updateWorldMatrix(!0, !0), this.sunTarget.updateMatrixWorld(), this.sun.shadow.updateMatrices(this.sun);
    const s = this.sceneBox, a = s.min, o = s.max, l = new D(a.x, a.y, a.z), c = new D(o.x, a.y, a.z), u = new D(a.x, o.y, a.z), h = new D(a.x, a.y, o.z), p = new D(o.x, o.y, a.z), f = new D(o.x, a.y, o.z), v = new D(a.x, o.y, o.z), m = new D(o.x, o.y, o.z);
    l.applyMatrix4(this.sun.shadow.camera.matrixWorldInverse), c.applyMatrix4(this.sun.shadow.camera.matrixWorldInverse), u.applyMatrix4(this.sun.shadow.camera.matrixWorldInverse), h.applyMatrix4(this.sun.shadow.camera.matrixWorldInverse), p.applyMatrix4(this.sun.shadow.camera.matrixWorldInverse), f.applyMatrix4(this.sun.shadow.camera.matrixWorldInverse), v.applyMatrix4(this.sun.shadow.camera.matrixWorldInverse), m.applyMatrix4(this.sun.shadow.camera.matrixWorldInverse);
    const y = new ke().setFromPoints([l, c, u, h, p, f, v, m]);
    this.sun.shadow.camera.left = y.min.x, this.sun.shadow.camera.right = y.max.x, this.sun.shadow.camera.top = y.min.y, this.sun.shadow.camera.bottom = y.max.y, this.sun.shadow.camera.near = Math.abs(y.max.z), this.sun.shadow.camera.far = Math.abs(y.min.z), this.sun.shadow.camera.updateProjectionMatrix(), this.renderer.shadowMap.needsUpdate = !0, this.needsRender = !0, this.updateHelpers(), this.resetPipeline();
  }
  setSunLightConfiguration(t) {
    Object.assign(this.sunConfiguration, t), t.indirectLightIntensity !== void 0 && (this.indirectIBLIntensity = t.indirectLightIntensity), this.updateDirectLights(), this.updateShadowCatcher();
  }
  updateHelpers() {
    this.SHOW_HELPERS && (this._scene.getObjectByName("CamHelper").update(), this._scene.getObjectByName("SceneBoxHelper").box.copy(this.sceneBox), this._scene.getObjectByName("DirLightHelper").update());
  }
  queryHits(t) {
    const e = [], n = [];
    for (let s = 0; s < t.length; s++) {
      const a = this.batcher.getRenderView(t[s].object.uuid, t[s].faceIndex !== void 0 ? t[s].faceIndex : t[s].index);
      a && (e.push(a), n.push(t[s].point));
    }
    if (e.length === 0)
      return null;
    const r = [];
    for (let s = 0; s < e.length; s++) {
      const a = e[s].renderData.id;
      let o = Qt.getInstance().findId(a);
      for (; !o.model.atomic && o.parent; )
        o = o.parent;
      r.push({ node: o, point: n[s] });
    }
    return r;
  }
  queryHitIds(t) {
    const e = [];
    for (let n = 0; n < t.length; n++) {
      const r = this.batcher.getRenderView(t[n].object.uuid, t[n].faceIndex !== void 0 ? t[n].faceIndex : t[n].index);
      r && e.push({ nodeId: r.renderData.id, point: t[n].point });
    }
    return e.length === 0 ? null : e;
  }
  onObjectClick(t) {
    const e = this._intersections.intersect(this._scene, this.viewer.cameraHandler.activeCam.camera, t, !0, this.viewer.sectionBox.getCurrentBox());
    if (!e)
      return this.viewer.emit(tn.ObjectClicked, null), void (this.SHOW_BVH && this.allObjects.traverse((a) => {
        a.name.includes("_bvh") && (a.visible = !0);
      }));
    let n = !1;
    t.multiSelect && (n = !0);
    const r = this.queryHits(e);
    if (!r)
      return void this.viewer.emit(tn.ObjectClicked, n ? { multiple: !0, event: t.event } : null);
    const s = { multiple: n, event: t.event, hits: r.map((a) => ({ guid: a.node.model.id, object: a.node.model.raw, point: a.point })) };
    this.viewer.emit(tn.ObjectClicked, s);
  }
  onObjectDoubleClick(t) {
    const e = this._intersections.intersect(this._scene, this.viewer.cameraHandler.activeCam.camera, t, !0, this.viewer.sectionBox.getCurrentBox());
    if (!e)
      return void this.viewer.emit(tn.ObjectDoubleClicked, null);
    let n = !1;
    t.multiSelect && (n = !0);
    const r = this.queryHits(e);
    if (!r)
      return void this.viewer.emit(tn.ObjectClicked, null);
    const s = { multiple: n, hits: r.map((a) => ({ guid: a.node.model.id, object: a.node.model.raw, point: a.point })) };
    this.viewer.emit(tn.ObjectDoubleClicked, s);
  }
  boxFromObjects(t) {
    let e = new ke();
    const n = [];
    t.length > 0 ? Qt.getInstance().walk((r) => !r.model.atomic || !r.model.raw || (t.indexOf(r.model.raw.id) !== -1 && n.push(...Qt.getRenderTree().getRenderViewsForNode(r, r)), !0)) : e = this.sceneBox;
    for (let r = 0; r < n.length; r++) {
      let s = null;
      (s = n[r].aabb) !== null && e.union(s);
    }
    return e.getSize(new D()).length() === 0 && console.error("object selection resulted in empty box"), e;
  }
  zoom(t, e, n) {
    if (!t)
      return this.zoomExtents(e, n), void this.pipeline.onStationaryEnd();
    this.zoomToBox(this.boxFromObjects(t), e, n), this.pipeline.onStationaryEnd();
  }
  zoomExtents(t = 1.2, e = !0) {
    if (this.viewer.sectionBox.display.visible)
      return void this.zoomToBox(this.viewer.sectionBox.cube.geometry.boundingBox, 1.2, !0);
    if (this.allObjects.children.length === 0) {
      const r = new ke(new D(-1, -1, -1), new D(1, 1, 1));
      return void this.zoomToBox(r, t, e);
    }
    const n = new ke().setFromObject(this.allObjects);
    this.zoomToBox(n, t, e);
  }
  zoomToBox(t, e = 1.2, n = !0) {
    t.max.x !== 1 / 0 && t.max.x !== -1 / 0 || (t = new ke(new D(-1, -1, -1), new D(1, 1, 1)));
    const r = e, s = t.getSize(new D()), a = new Mi();
    t.getBoundingSphere(a), a.radius = a.radius * r;
    const o = Math.max(s.x, s.y, s.z), l = this.viewer.cameraHandler.camera.fov ? this.viewer.cameraHandler.camera.fov : 55, c = this.viewer.cameraHandler.camera.aspect ? this.viewer.cameraHandler.camera.aspect : 1.2, u = o / (2 * Math.atan(Math.PI * l / 360)), h = u / c, p = r * Math.max(u, h);
    if (this.viewer.cameraHandler.controls.fitToSphere(a, n), this.viewer.cameraHandler.controls.minDistance = p / 100, this.viewer.cameraHandler.controls.maxDistance = 100 * p, this.viewer.cameraHandler.camera.near = Math.max(p / 100, 0.01), this.viewer.cameraHandler.camera.far = 100 * p, this.viewer.cameraHandler.camera.updateProjectionMatrix(), this.viewer.cameraHandler.activeCam.name === "ortho") {
      this.viewer.cameraHandler.orthoCamera.far = 100 * p, this.viewer.cameraHandler.orthoCamera.updateProjectionMatrix();
      const f = this.viewer.cameraHandler.orthoCamera.position;
      let v = a.distanceToPoint(f);
      v < 0 && (v *= -1, this.viewer.cameraHandler.controls.setPosition(f.x + v, f.y + v, f.z + v));
    }
  }
  isSpeckleView(t) {
    return t.name !== void 0;
  }
  isCanonicalView(t) {
    return typeof t == "string";
  }
  isInlineView(t) {
    return t.position !== void 0 && t.target !== void 0;
  }
  isPolarView(t) {
    return t.azimuth !== void 0 && t.polar !== void 0;
  }
  setView(t, e = !0) {
    this.isSpeckleView(t) && this.setViewSpeckle(t, e), this.isCanonicalView(t) && this.setViewCanonical(t, e), this.isInlineView(t) && this.setViewInline(t, e), this.isPolarView(t) && this.setViewPolar(t, e), this.pipeline.onStationaryEnd();
  }
  setViewSpeckle(t, e = !0) {
    this.viewer.cameraHandler.activeCam.controls.setLookAt(t.view.origin.x, t.view.origin.y, t.view.origin.z, t.view.target.x, t.view.target.y, t.view.target.z, e);
  }
  setViewCanonical(t, e = !0) {
    const n = 0.5 * Math.PI, r = Math.PI;
    switch (t) {
      case "front":
        this.viewer.cameraHandler.controls.rotateTo(0, n, e), this.viewer.cameraHandler.activeCam.name === "ortho" && this.viewer.cameraHandler.disableRotations();
        break;
      case "back":
        this.viewer.cameraHandler.controls.rotateTo(r, n, e), this.viewer.cameraHandler.activeCam.name === "ortho" && this.viewer.cameraHandler.disableRotations();
        break;
      case "up":
      case "top":
        this.viewer.cameraHandler.controls.rotateTo(0, 0, e), this.viewer.cameraHandler.activeCam.name === "ortho" && this.viewer.cameraHandler.disableRotations();
        break;
      case "down":
      case "bottom":
        this.viewer.cameraHandler.controls.rotateTo(0, r, e), this.viewer.cameraHandler.activeCam.name === "ortho" && this.viewer.cameraHandler.disableRotations();
        break;
      case "right":
        this.viewer.cameraHandler.controls.rotateTo(n, n, e), this.viewer.cameraHandler.activeCam.name === "ortho" && this.viewer.cameraHandler.disableRotations();
        break;
      case "left":
        this.viewer.cameraHandler.controls.rotateTo(-n, n, e), this.viewer.cameraHandler.activeCam.name === "ortho" && this.viewer.cameraHandler.disableRotations();
        break;
      default: {
        let s;
        s = this.allObjects.children.length === 0 ? new ke(new D(-1, -1, -1), new D(1, 1, 1)) : new ke().setFromObject(this.allObjects), s.max.x !== 1 / 0 && s.max.x !== -1 / 0 || (s = new ke(new D(-1, -1, -1), new D(1, 1, 1))), this.viewer.cameraHandler.controls.setPosition(s.max.x, s.max.y, s.max.z, e), this.zoomExtents(), this.viewer.cameraHandler.enableRotations();
        break;
      }
    }
  }
  setViewInline(t, e = !0) {
    this.viewer.cameraHandler.activeCam.controls.setLookAt(t.position.x, t.position.y, t.position.z, t.target.x, t.target.y, t.target.z, e);
  }
  setViewPolar(t, e = !0) {
    this.viewer.cameraHandler.controls.rotate(t.azimuth, t.polar, e);
  }
  screenToNDC(t, e, n, r) {
    const s = this._renderer.domElement, a = this.container.getBoundingClientRect(), o = n === void 0 ? (t - a.left) * s.width / a.width : t, l = r === void 0 ? (e - a.top) * s.height / a.height : e;
    return { x: o / (n === void 0 ? s.width : n) * 2 - 1, y: l / (r === void 0 ? s.height : r) * -2 + 1 };
  }
  NDCToScreen(t, e, n, r) {
    const s = this._renderer.domElement;
    return { x: (0.5 * t + 0.5) * (n = n !== void 0 ? n : s.width), y: (-0.5 * e + 0.5) * (r = r !== void 0 ? r : s.height) };
  }
  onObjectClickDebug(t) {
    const e = this._intersections.intersect(this._scene, this.viewer.cameraHandler.activeCam.camera, t, !0, this.viewer.sectionBox.getCurrentBox());
    if (!e)
      return void this.batcher.resetBatchesDrawRanges();
    const n = e[0], r = this.batcher.getRenderView(n.object.uuid, n.faceIndex !== void 0 ? n.faceIndex : n.index).renderData.id;
    this.batcher.resetBatchesDrawRanges(), this.batcher.isolateRenderViewBatch(r), this.SHOW_BVH && (this.allObjects.traverse((s) => {
      s.name.includes("_bvh") && (s.visible = !1);
    }), this.scene.getObjectByName(n.object.id + "_bvh").visible = !0);
  }
  debugShowBatches() {
    this.batcher.resetBatchesDrawRanges();
    for (const t in this.batcher.batches)
      this.batcher.batches[t].setDrawRanges({ offset: 0, count: 1 / 0, material: this.batcher.materials.getDebugBatchMaterial(this.batcher.batches[t].getRenderView(0)) });
  }
}
class vlt extends R0 {
  constructor(t, e) {
    let n;
    super(), this.viewer = t, this.raycaster = new iu(), this.raycaster.params.Line.threshold = 0.1, this.raycaster.params.Line2 = {}, this.raycaster.params.Line2.threshold = 1, this.raycaster.layers.set(pn.PROPS), this.subset = e !== void 0 && e.subset !== void 0 ? e.subset : null, this.pointerDown = !1, this.checkForSectionBoxInclusion = !0, e !== void 0 && e.checkForSectionBoxInclusion && (this.sectionBox = e.checkForSectionBoxInclusion), this.viewer.speckleRenderer.renderer.domElement.addEventListener("pointerdown", (r) => {
      r.preventDefault(), n = (/* @__PURE__ */ new Date()).getTime();
    }), this.viewer.speckleRenderer.renderer.domElement.addEventListener("pointerup", (r) => {
      if (r.preventDefault(), this.viewer.cameraHandler.orbiting)
        return;
      const s = (/* @__PURE__ */ new Date()).getTime() - n;
      if (this.pointerDown = !1, s > 250)
        return;
      const a = this.getClickedObjects(r);
      this.emit("object-clicked", a);
    }), this.tapTimeout, this.lastTap = 0, this.touchLocation, this.viewer.speckleRenderer.renderer.domElement.addEventListener("touchstart", (r) => {
      this.touchLocation = r.targetTouches[0];
    }), this.viewer.speckleRenderer.renderer.domElement.addEventListener("touchend", (r) => {
      if (r.targetTouches.length > 0)
        return;
      const s = (/* @__PURE__ */ new Date()).getTime(), a = s - this.lastTap;
      if (clearTimeout(this.tapTimeout), a < 500 && a > 0) {
        const o = this.getClickedObjects(this.touchLocation);
        this.emit("object-doubleclicked", o);
      } else
        this.tapTimeout = setTimeout(function() {
          clearTimeout(this.tapTimeout);
        }, 500);
      this.lastTap = s;
    }), this.viewer.speckleRenderer.renderer.domElement.addEventListener("dblclick", (r) => {
      const s = this.getClickedObjects(r);
      this.emit("object-doubleclicked", s);
    }), this.multiSelect = !1, document.addEventListener("keydown", (r) => {
      r.isComposing || r.keyCode === 229 || (r.key === "Shift" && (this.multiSelect = !0), r.key === "Escape" && this.unselect());
    }), document.addEventListener("keyup", (r) => {
      r.isComposing || r.keyCode === 229 || r.key === "Shift" && (this.multiSelect = !1);
    }), this.originalSelectionObjects = [];
  }
  unselect() {
    this.originalSelectionObjects = [];
  }
  getClickedObjects(t) {
    const e = this._getNormalisedClickPosition(t);
    this.raycaster.setFromCamera(e, this.viewer.cameraHandler.activeCam.camera);
    let n = [];
    return this.viewer.sectionBox.display.visible && this.checkForSectionBoxInclusion && (n = this.raycaster.intersectObject(this.viewer.sectionBox.cube)), n;
  }
  _getNormalisedClickPosition(t) {
    const e = this.viewer.speckleRenderer.renderer.domElement, n = this.viewer.speckleRenderer.renderer.domElement.getBoundingClientRect(), r = (t.clientX - n.left) * e.width / n.width, s = (t.clientY - n.top) * e.height / n.height;
    return { x: r / e.width * 2 - 1, y: s / e.height * -2 + 1 };
  }
  dispose() {
    super.dispose(), this.unselect(), this.originalSelectionObjects = null;
  }
}
const Ml = new iu(), xi = new D(), bo = new D(), Bn = new kn(), lI = { X: new D(1, 0, 0), Y: new D(0, 1, 0), Z: new D(0, 0, 1) }, Yw = { type: "change" }, cI = { type: "mouseDown" }, hI = { type: "mouseUp", mode: null }, uI = { type: "objectChange" };
class ylt extends Ue {
  constructor(t, e) {
    super(), e === void 0 && (console.warn('THREE.TransformControls: The second parameter "domElement" is now mandatory.'), e = document), this.isTransformControls = !0, this.visible = !1, this.domElement = e, this.domElement.style.touchAction = "none";
    const n = new Mlt();
    this._gizmo = n, this.add(n);
    const r = new Tlt();
    this._plane = r, this.add(r);
    const s = this;
    function a(_, w) {
      let b = w;
      Object.defineProperty(s, _, { get: function() {
        return b !== void 0 ? b : w;
      }, set: function(T) {
        b !== T && (b = T, r[_] = T, n[_] = T, s.dispatchEvent({ type: _ + "-changed", value: T }), s.dispatchEvent(Yw));
      } }), s[_] = w, r[_] = w, n[_] = w;
    }
    a("camera", t), a("object", void 0), a("enabled", !0), a("axis", null), a("mode", "translate"), a("translationSnap", null), a("rotationSnap", null), a("scaleSnap", null), a("space", "world"), a("size", 1), a("dragging", !1), a("showX", !0), a("showY", !0), a("showZ", !0);
    const o = new D(), l = new D(), c = new kn(), u = new kn(), h = new D(), p = new kn(), f = new D(), v = new D(), m = new D(), y = new D();
    a("worldPosition", o), a("worldPositionStart", l), a("worldQuaternion", c), a("worldQuaternionStart", u), a("cameraPosition", h), a("cameraQuaternion", p), a("pointStart", f), a("pointEnd", v), a("rotationAxis", m), a("rotationAngle", 0), a("eye", y), this._offset = new D(), this._startNorm = new D(), this._endNorm = new D(), this._cameraScale = new D(), this._parentPosition = new D(), this._parentQuaternion = new kn(), this._parentQuaternionInv = new kn(), this._parentScale = new D(), this._worldScaleStart = new D(), this._worldQuaternionInv = new kn(), this._worldScale = new D(), this._positionStart = new D(), this._quaternionStart = new kn(), this._scaleStart = new D(), this._getPointer = _lt.bind(this), this._onPointerDown = xlt.bind(this), this._onPointerHover = wlt.bind(this), this._onPointerMove = blt.bind(this), this._onPointerUp = Slt.bind(this), this.domElement.addEventListener("pointerdown", this._onPointerDown), this.domElement.addEventListener("pointermove", this._onPointerHover), this.domElement.addEventListener("pointerup", this._onPointerUp);
  }
  updateMatrixWorld() {
    this.object !== void 0 && (this.object.updateMatrixWorld(), this.object.parent === null ? console.error("TransformControls: The attached 3D object must be a part of the scene graph.") : this.object.parent.matrixWorld.decompose(this._parentPosition, this._parentQuaternion, this._parentScale), this.object.matrixWorld.decompose(this.worldPosition, this.worldQuaternion, this._worldScale), this._parentQuaternionInv.copy(this._parentQuaternion).invert(), this._worldQuaternionInv.copy(this.worldQuaternion).invert()), this.camera.updateMatrixWorld(), this.camera.matrixWorld.decompose(this.cameraPosition, this.cameraQuaternion, this._cameraScale), this.camera.isOrthographicCamera ? this.camera.getWorldDirection(this.eye).negate() : this.eye.copy(this.cameraPosition).sub(this.worldPosition).normalize(), super.updateMatrixWorld(this);
  }
  pointerHover(t) {
    if (this.object === void 0 || this.dragging === !0)
      return;
    Ml.setFromCamera(t, this.camera);
    const e = Jw(this._gizmo.picker[this.mode], Ml);
    this.axis = e ? e.object.name : null;
  }
  pointerDown(t) {
    if (this.object !== void 0 && this.dragging !== !0 && t.button === 0 && this.axis !== null) {
      Ml.setFromCamera(t, this.camera);
      const e = Jw(this._plane, Ml, !0);
      e && (this.object.updateMatrixWorld(), this.object.parent.updateMatrixWorld(), this._positionStart.copy(this.object.position), this._quaternionStart.copy(this.object.quaternion), this._scaleStart.copy(this.object.scale), this.object.matrixWorld.decompose(this.worldPositionStart, this.worldQuaternionStart, this._worldScaleStart), this.pointStart.copy(e.point).sub(this.worldPositionStart)), this.dragging = !0, cI.mode = this.mode, this.dispatchEvent(cI);
    }
  }
  pointerMove(t) {
    const e = this.axis, n = this.mode, r = this.object;
    let s = this.space;
    if (n === "scale" ? s = "local" : e !== "E" && e !== "XYZE" && e !== "XYZ" || (s = "world"), r === void 0 || e === null || this.dragging === !1 || t.button !== -1)
      return;
    Ml.setFromCamera(t, this.camera);
    const a = Jw(this._plane, Ml, !0);
    if (a) {
      if (this.pointEnd.copy(a.point).sub(this.worldPositionStart), n === "translate")
        this._offset.copy(this.pointEnd).sub(this.pointStart), s === "local" && e !== "XYZ" && this._offset.applyQuaternion(this._worldQuaternionInv), e.indexOf("X") === -1 && (this._offset.x = 0), e.indexOf("Y") === -1 && (this._offset.y = 0), e.indexOf("Z") === -1 && (this._offset.z = 0), s === "local" && e !== "XYZ" ? this._offset.applyQuaternion(this._quaternionStart).divide(this._parentScale) : this._offset.applyQuaternion(this._parentQuaternionInv).divide(this._parentScale), r.position.copy(this._offset).add(this._positionStart), this.translationSnap && (s === "local" && (r.position.applyQuaternion(Bn.copy(this._quaternionStart).invert()), e.search("X") !== -1 && (r.position.x = Math.round(r.position.x / this.translationSnap) * this.translationSnap), e.search("Y") !== -1 && (r.position.y = Math.round(r.position.y / this.translationSnap) * this.translationSnap), e.search("Z") !== -1 && (r.position.z = Math.round(r.position.z / this.translationSnap) * this.translationSnap), r.position.applyQuaternion(this._quaternionStart)), s === "world" && (r.parent && r.position.add(xi.setFromMatrixPosition(r.parent.matrixWorld)), e.search("X") !== -1 && (r.position.x = Math.round(r.position.x / this.translationSnap) * this.translationSnap), e.search("Y") !== -1 && (r.position.y = Math.round(r.position.y / this.translationSnap) * this.translationSnap), e.search("Z") !== -1 && (r.position.z = Math.round(r.position.z / this.translationSnap) * this.translationSnap), r.parent && r.position.sub(xi.setFromMatrixPosition(r.parent.matrixWorld))));
      else if (n === "scale") {
        if (e.search("XYZ") !== -1) {
          let o = this.pointEnd.length() / this.pointStart.length();
          this.pointEnd.dot(this.pointStart) < 0 && (o *= -1), bo.set(o, o, o);
        } else
          xi.copy(this.pointStart), bo.copy(this.pointEnd), xi.applyQuaternion(this._worldQuaternionInv), bo.applyQuaternion(this._worldQuaternionInv), bo.divide(xi), e.search("X") === -1 && (bo.x = 1), e.search("Y") === -1 && (bo.y = 1), e.search("Z") === -1 && (bo.z = 1);
        r.scale.copy(this._scaleStart).multiply(bo), this.scaleSnap && (e.search("X") !== -1 && (r.scale.x = Math.round(r.scale.x / this.scaleSnap) * this.scaleSnap || this.scaleSnap), e.search("Y") !== -1 && (r.scale.y = Math.round(r.scale.y / this.scaleSnap) * this.scaleSnap || this.scaleSnap), e.search("Z") !== -1 && (r.scale.z = Math.round(r.scale.z / this.scaleSnap) * this.scaleSnap || this.scaleSnap));
      } else if (n === "rotate") {
        this._offset.copy(this.pointEnd).sub(this.pointStart);
        const o = 20 / this.worldPosition.distanceTo(xi.setFromMatrixPosition(this.camera.matrixWorld));
        e === "E" ? (this.rotationAxis.copy(this.eye), this.rotationAngle = this.pointEnd.angleTo(this.pointStart), this._startNorm.copy(this.pointStart).normalize(), this._endNorm.copy(this.pointEnd).normalize(), this.rotationAngle *= this._endNorm.cross(this._startNorm).dot(this.eye) < 0 ? 1 : -1) : e === "XYZE" ? (this.rotationAxis.copy(this._offset).cross(this.eye).normalize(), this.rotationAngle = this._offset.dot(xi.copy(this.rotationAxis).cross(this.eye)) * o) : e !== "X" && e !== "Y" && e !== "Z" || (this.rotationAxis.copy(lI[e]), xi.copy(lI[e]), s === "local" && xi.applyQuaternion(this.worldQuaternion), this.rotationAngle = this._offset.dot(xi.cross(this.eye).normalize()) * o), this.rotationSnap && (this.rotationAngle = Math.round(this.rotationAngle / this.rotationSnap) * this.rotationSnap), s === "local" && e !== "E" && e !== "XYZE" ? (r.quaternion.copy(this._quaternionStart), r.quaternion.multiply(Bn.setFromAxisAngle(this.rotationAxis, this.rotationAngle)).normalize()) : (this.rotationAxis.applyQuaternion(this._parentQuaternionInv), r.quaternion.copy(Bn.setFromAxisAngle(this.rotationAxis, this.rotationAngle)), r.quaternion.multiply(this._quaternionStart).normalize());
      }
      this.dispatchEvent(Yw), this.dispatchEvent(uI);
    }
  }
  pointerUp(t) {
    t.button === 0 && (this.dragging && this.axis !== null && (hI.mode = this.mode, this.dispatchEvent(hI)), this.dragging = !1, this.axis = null);
  }
  dispose() {
    this.domElement.removeEventListener("pointerdown", this._onPointerDown), this.domElement.removeEventListener("pointermove", this._onPointerHover), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.domElement.removeEventListener("pointerup", this._onPointerUp), this.traverse(function(t) {
      t.geometry && t.geometry.dispose(), t.material && t.material.dispose();
    });
  }
  attach(t) {
    return this.object = t, this.visible = !0, this;
  }
  detach() {
    return this.object = void 0, this.visible = !1, this.axis = null, this;
  }
  reset() {
    this.enabled && this.dragging && (this.object.position.copy(this._positionStart), this.object.quaternion.copy(this._quaternionStart), this.object.scale.copy(this._scaleStart), this.dispatchEvent(Yw), this.dispatchEvent(uI), this.pointStart.copy(this.pointEnd));
  }
  getRaycaster() {
    return Ml;
  }
  getMode() {
    return this.mode;
  }
  setMode(t) {
    this.mode = t;
  }
  setTranslationSnap(t) {
    this.translationSnap = t;
  }
  setRotationSnap(t) {
    this.rotationSnap = t;
  }
  setScaleSnap(t) {
    this.scaleSnap = t;
  }
  setSize(t) {
    this.size = t;
  }
  setSpace(t) {
    this.space = t;
  }
}
function _lt(i) {
  if (this.domElement.ownerDocument.pointerLockElement)
    return { x: 0, y: 0, button: i.button };
  {
    const t = this.domElement.getBoundingClientRect();
    return { x: (i.clientX - t.left) / t.width * 2 - 1, y: -(i.clientY - t.top) / t.height * 2 + 1, button: i.button };
  }
}
function wlt(i) {
  if (this.enabled)
    switch (i.pointerType) {
      case "mouse":
      case "pen":
        this.pointerHover(this._getPointer(i));
    }
}
function xlt(i) {
  this.enabled && (document.pointerLockElement || this.domElement.setPointerCapture(i.pointerId), this.domElement.addEventListener("pointermove", this._onPointerMove), this.pointerHover(this._getPointer(i)), this.pointerDown(this._getPointer(i)));
}
function blt(i) {
  this.enabled && this.pointerMove(this._getPointer(i));
}
function Slt(i) {
  this.enabled && (this.domElement.releasePointerCapture(i.pointerId), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.pointerUp(this._getPointer(i)));
}
function Jw(i, t, e) {
  const n = t.intersectObject(i, !0);
  for (let r = 0; r < n.length; r++)
    if (n[r].object.visible || e)
      return n[r];
  return !1;
}
const Jg = new nu(), gn = new D(0, 1, 0), dI = new D(0, 0, 0), pI = new Vt(), Kg = new kn(), _v = new kn(), Xs = new D(), fI = new Vt(), Ad = new D(1, 0, 0), Pl = new D(0, 1, 0), Cd = new D(0, 0, 1), $g = new D(), vd = new D(), yd = new D();
class Mlt extends Ue {
  constructor() {
    super(), this.isTransformControlsGizmo = !0, this.type = "TransformControlsGizmo";
    const t = new ci({ depthTest: !1, depthWrite: !1, fog: !1, toneMapped: !1, transparent: !0 }), e = new Ar({ depthTest: !1, depthWrite: !1, fog: !1, toneMapped: !1, transparent: !0 }), n = t.clone();
    n.opacity = 0.15;
    const r = e.clone();
    r.opacity = 0.5;
    const s = t.clone();
    s.color.setHex(16711680);
    const a = t.clone();
    a.color.setHex(65280);
    const o = t.clone();
    o.color.setHex(255);
    const l = t.clone();
    l.color.setHex(16711680), l.opacity = 0.5;
    const c = t.clone();
    c.color.setHex(65280), c.opacity = 0.5;
    const u = t.clone();
    u.color.setHex(255), u.opacity = 0.5;
    const h = t.clone();
    h.opacity = 0.25;
    const p = t.clone();
    p.color.setHex(16776960), p.opacity = 0.25, t.clone().color.setHex(16776960);
    const f = t.clone();
    f.color.setHex(7895160);
    const v = new nr(0, 0.04, 0.1, 12);
    v.translate(0, 0.05, 0);
    const m = new zn(0.08, 0.08, 0.08);
    m.translate(0, 0.04, 0);
    const y = new _e();
    y.setAttribute("position", new Wt([0, 0, 0, 1, 0, 0], 3));
    const _ = new nr(75e-4, 75e-4, 0.5, 3);
    function w(q, it) {
      const rt = new $s(q, 75e-4, 3, 64, it * Math.PI * 2);
      return rt.rotateY(Math.PI / 2), rt.rotateX(Math.PI / 2), rt;
    }
    _.translate(0, 0.25, 0);
    const b = { X: [[new Nt(v, s), [0.5, 0, 0], [0, 0, -Math.PI / 2]], [new Nt(v, s), [-0.5, 0, 0], [0, 0, Math.PI / 2]], [new Nt(_, s), [0, 0, 0], [0, 0, -Math.PI / 2]]], Y: [[new Nt(v, a), [0, 0.5, 0]], [new Nt(v, a), [0, -0.5, 0], [Math.PI, 0, 0]], [new Nt(_, a)]], Z: [[new Nt(v, o), [0, 0, 0.5], [Math.PI / 2, 0, 0]], [new Nt(v, o), [0, 0, -0.5], [-Math.PI / 2, 0, 0]], [new Nt(_, o), null, [Math.PI / 2, 0, 0]]], XYZ: [[new Nt(new ea(0.1, 0), h.clone()), [0, 0, 0]]], XY: [[new Nt(new zn(0.15, 0.15, 0.01), u.clone()), [0.15, 0.15, 0]]], YZ: [[new Nt(new zn(0.15, 0.15, 0.01), l.clone()), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]], XZ: [[new Nt(new zn(0.15, 0.15, 0.01), c.clone()), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]] }, T = { X: [[new Nt(new nr(0.2, 0, 0.6, 4), n), [0.3, 0, 0], [0, 0, -Math.PI / 2]], [new Nt(new nr(0.2, 0, 0.6, 4), n), [-0.3, 0, 0], [0, 0, Math.PI / 2]]], Y: [[new Nt(new nr(0.2, 0, 0.6, 4), n), [0, 0.3, 0]], [new Nt(new nr(0.2, 0, 0.6, 4), n), [0, -0.3, 0], [0, 0, Math.PI]]], Z: [[new Nt(new nr(0.2, 0, 0.6, 4), n), [0, 0, 0.3], [Math.PI / 2, 0, 0]], [new Nt(new nr(0.2, 0, 0.6, 4), n), [0, 0, -0.3], [-Math.PI / 2, 0, 0]]], XYZ: [[new Nt(new ea(0.2, 0), n)]], XY: [[new Nt(new zn(0.2, 0.2, 0.01), n), [0.15, 0.15, 0]]], YZ: [[new Nt(new zn(0.2, 0.2, 0.01), n), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]], XZ: [[new Nt(new zn(0.2, 0.2, 0.01), n), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]] }, M = { START: [[new Nt(new ea(0.01, 2), r), null, null, null, "helper"]], END: [[new Nt(new ea(0.01, 2), r), null, null, null, "helper"]], DELTA: [[new Yr(function() {
      const q = new _e();
      return q.setAttribute("position", new Wt([0, 0, 0, 1, 1, 1], 3)), q;
    }(), r), null, null, null, "helper"]], X: [[new Yr(y, r.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]], Y: [[new Yr(y, r.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]], Z: [[new Yr(y, r.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]] }, A = { XYZE: [[new Nt(w(0.5, 1), f), null, [0, Math.PI / 2, 0]]], X: [[new Nt(w(0.5, 0.5), s)]], Y: [[new Nt(w(0.5, 0.5), a), null, [0, 0, -Math.PI / 2]]], Z: [[new Nt(w(0.5, 0.5), o), null, [0, Math.PI / 2, 0]]], E: [[new Nt(w(0.75, 1), p), null, [0, Math.PI / 2, 0]]] }, C = { AXIS: [[new Yr(y, r.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]] }, I = { XYZE: [[new Nt(new Va(0.25, 10, 8), n)]], X: [[new Nt(new $s(0.5, 0.1, 4, 24), n), [0, 0, 0], [0, -Math.PI / 2, -Math.PI / 2]]], Y: [[new Nt(new $s(0.5, 0.1, 4, 24), n), [0, 0, 0], [Math.PI / 2, 0, 0]]], Z: [[new Nt(new $s(0.5, 0.1, 4, 24), n), [0, 0, 0], [0, 0, -Math.PI / 2]]], E: [[new Nt(new $s(0.75, 0.1, 2, 24), n)]] }, k = { X: [[new Nt(m, s), [0.5, 0, 0], [0, 0, -Math.PI / 2]], [new Nt(_, s), [0, 0, 0], [0, 0, -Math.PI / 2]], [new Nt(m, s), [-0.5, 0, 0], [0, 0, Math.PI / 2]]], Y: [[new Nt(m, a), [0, 0.5, 0]], [new Nt(_, a)], [new Nt(m, a), [0, -0.5, 0], [0, 0, Math.PI]]], Z: [[new Nt(m, o), [0, 0, 0.5], [Math.PI / 2, 0, 0]], [new Nt(_, o), [0, 0, 0], [Math.PI / 2, 0, 0]], [new Nt(m, o), [0, 0, -0.5], [-Math.PI / 2, 0, 0]]], XY: [[new Nt(new zn(0.15, 0.15, 0.01), u), [0.15, 0.15, 0]]], YZ: [[new Nt(new zn(0.15, 0.15, 0.01), l), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]], XZ: [[new Nt(new zn(0.15, 0.15, 0.01), c), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]], XYZ: [[new Nt(new zn(0.1, 0.1, 0.1), h.clone())]] }, R = { X: [[new Nt(new nr(0.2, 0, 0.6, 4), n), [0.3, 0, 0], [0, 0, -Math.PI / 2]], [new Nt(new nr(0.2, 0, 0.6, 4), n), [-0.3, 0, 0], [0, 0, Math.PI / 2]]], Y: [[new Nt(new nr(0.2, 0, 0.6, 4), n), [0, 0.3, 0]], [new Nt(new nr(0.2, 0, 0.6, 4), n), [0, -0.3, 0], [0, 0, Math.PI]]], Z: [[new Nt(new nr(0.2, 0, 0.6, 4), n), [0, 0, 0.3], [Math.PI / 2, 0, 0]], [new Nt(new nr(0.2, 0, 0.6, 4), n), [0, 0, -0.3], [-Math.PI / 2, 0, 0]]], XY: [[new Nt(new zn(0.2, 0.2, 0.01), n), [0.15, 0.15, 0]]], YZ: [[new Nt(new zn(0.2, 0.2, 0.01), n), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]], XZ: [[new Nt(new zn(0.2, 0.2, 0.01), n), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]], XYZ: [[new Nt(new zn(0.2, 0.2, 0.2), n), [0, 0, 0]]] }, L = { X: [[new Yr(y, r.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]], Y: [[new Yr(y, r.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]], Z: [[new Yr(y, r.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]] };
    function E(q) {
      const it = new Ue();
      for (const rt in q)
        for (let ft = q[rt].length; ft--; ) {
          const nt = q[rt][ft][0].clone(), vt = q[rt][ft][1], $ = q[rt][ft][2], W = q[rt][ft][3], ct = q[rt][ft][4];
          nt.name = rt, nt.tag = ct, vt && nt.position.set(vt[0], vt[1], vt[2]), $ && nt.rotation.set($[0], $[1], $[2]), W && nt.scale.set(W[0], W[1], W[2]), nt.updateMatrix();
          const mt = nt.geometry.clone();
          mt.applyMatrix4(nt.matrix), nt.geometry = mt, nt.renderOrder = 1 / 0, nt.position.set(0, 0, 0), nt.rotation.set(0, 0, 0), nt.scale.set(1, 1, 1), it.add(nt);
        }
      return it;
    }
    this.gizmo = {}, this.picker = {}, this.helper = {}, this.add(this.gizmo.translate = E(b)), this.add(this.gizmo.rotate = E(A)), this.add(this.gizmo.scale = E(k)), this.add(this.picker.translate = E(T)), this.add(this.picker.rotate = E(I)), this.add(this.picker.scale = E(R)), this.add(this.helper.translate = E(M)), this.add(this.helper.rotate = E(C)), this.add(this.helper.scale = E(L)), this.picker.translate.visible = !1, this.picker.rotate.visible = !1, this.picker.scale.visible = !1;
  }
  updateMatrixWorld(t) {
    const e = (this.mode === "scale" ? "local" : this.space) === "local" ? this.worldQuaternion : _v;
    this.gizmo.translate.visible = this.mode === "translate", this.gizmo.rotate.visible = this.mode === "rotate", this.gizmo.scale.visible = this.mode === "scale", this.helper.translate.visible = this.mode === "translate", this.helper.rotate.visible = this.mode === "rotate", this.helper.scale.visible = this.mode === "scale";
    let n = [];
    n = n.concat(this.picker[this.mode].children), n = n.concat(this.gizmo[this.mode].children), n = n.concat(this.helper[this.mode].children);
    for (let r = 0; r < n.length; r++) {
      const s = n[r];
      let a;
      s.visible = !0, s.rotation.set(0, 0, 0), s.position.copy(this.worldPosition), a = this.camera.isOrthographicCamera ? (this.camera.top - this.camera.bottom) / this.camera.zoom : this.worldPosition.distanceTo(this.cameraPosition) * Math.min(1.9 * Math.tan(Math.PI * this.camera.fov / 360) / this.camera.zoom, 7), s.scale.set(1, 1, 1).multiplyScalar(a * this.size / 4), s.tag !== "helper" ? (s.quaternion.copy(e), this.mode === "translate" || this.mode === "scale" ? (s.name === "X" && Math.abs(gn.copy(Ad).applyQuaternion(e).dot(this.eye)) > 0.99 && (s.scale.set(1e-10, 1e-10, 1e-10), s.visible = !1), s.name === "Y" && Math.abs(gn.copy(Pl).applyQuaternion(e).dot(this.eye)) > 0.99 && (s.scale.set(1e-10, 1e-10, 1e-10), s.visible = !1), s.name === "Z" && Math.abs(gn.copy(Cd).applyQuaternion(e).dot(this.eye)) > 0.99 && (s.scale.set(1e-10, 1e-10, 1e-10), s.visible = !1), s.name === "XY" && Math.abs(gn.copy(Cd).applyQuaternion(e).dot(this.eye)) < 0.2 && (s.scale.set(1e-10, 1e-10, 1e-10), s.visible = !1), s.name === "YZ" && Math.abs(gn.copy(Ad).applyQuaternion(e).dot(this.eye)) < 0.2 && (s.scale.set(1e-10, 1e-10, 1e-10), s.visible = !1), s.name === "XZ" && Math.abs(gn.copy(Pl).applyQuaternion(e).dot(this.eye)) < 0.2 && (s.scale.set(1e-10, 1e-10, 1e-10), s.visible = !1)) : this.mode === "rotate" && (Kg.copy(e), gn.copy(this.eye).applyQuaternion(Bn.copy(e).invert()), s.name.search("E") !== -1 && s.quaternion.setFromRotationMatrix(pI.lookAt(this.eye, dI, Pl)), s.name === "X" && (Bn.setFromAxisAngle(Ad, Math.atan2(-gn.y, gn.z)), Bn.multiplyQuaternions(Kg, Bn), s.quaternion.copy(Bn)), s.name === "Y" && (Bn.setFromAxisAngle(Pl, Math.atan2(gn.x, gn.z)), Bn.multiplyQuaternions(Kg, Bn), s.quaternion.copy(Bn)), s.name === "Z" && (Bn.setFromAxisAngle(Cd, Math.atan2(gn.y, gn.x)), Bn.multiplyQuaternions(Kg, Bn), s.quaternion.copy(Bn))), s.visible = s.visible && (s.name.indexOf("X") === -1 || this.showX), s.visible = s.visible && (s.name.indexOf("Y") === -1 || this.showY), s.visible = s.visible && (s.name.indexOf("Z") === -1 || this.showZ), s.visible = s.visible && (s.name.indexOf("E") === -1 || this.showX && this.showY && this.showZ), s.material._color = s.material._color || s.material.color.clone(), s.material._opacity = s.material._opacity || s.material.opacity, s.material.color.copy(s.material._color), s.material.opacity = s.material._opacity, this.enabled && this.axis && (s.name === this.axis || this.axis.split("").some(function(o) {
        return s.name === o;
      })) && (s.material.color.setHex(16776960), s.material.opacity = 1)) : (s.visible = !1, s.name === "AXIS" ? (s.visible = !!this.axis, this.axis === "X" && (Bn.setFromEuler(Jg.set(0, 0, 0)), s.quaternion.copy(e).multiply(Bn), Math.abs(gn.copy(Ad).applyQuaternion(e).dot(this.eye)) > 0.9 && (s.visible = !1)), this.axis === "Y" && (Bn.setFromEuler(Jg.set(0, 0, Math.PI / 2)), s.quaternion.copy(e).multiply(Bn), Math.abs(gn.copy(Pl).applyQuaternion(e).dot(this.eye)) > 0.9 && (s.visible = !1)), this.axis === "Z" && (Bn.setFromEuler(Jg.set(0, Math.PI / 2, 0)), s.quaternion.copy(e).multiply(Bn), Math.abs(gn.copy(Cd).applyQuaternion(e).dot(this.eye)) > 0.9 && (s.visible = !1)), this.axis === "XYZE" && (Bn.setFromEuler(Jg.set(0, Math.PI / 2, 0)), gn.copy(this.rotationAxis), s.quaternion.setFromRotationMatrix(pI.lookAt(dI, gn, Pl)), s.quaternion.multiply(Bn), s.visible = this.dragging), this.axis === "E" && (s.visible = !1)) : s.name === "START" ? (s.position.copy(this.worldPositionStart), s.visible = this.dragging) : s.name === "END" ? (s.position.copy(this.worldPosition), s.visible = this.dragging) : s.name === "DELTA" ? (s.position.copy(this.worldPositionStart), s.quaternion.copy(this.worldQuaternionStart), xi.set(1e-10, 1e-10, 1e-10).add(this.worldPositionStart).sub(this.worldPosition).multiplyScalar(-1), xi.applyQuaternion(this.worldQuaternionStart.clone().invert()), s.scale.copy(xi), s.visible = this.dragging) : (s.quaternion.copy(e), this.dragging ? s.position.copy(this.worldPositionStart) : s.position.copy(this.worldPosition), this.axis && (s.visible = this.axis.search(s.name) !== -1)));
    }
    super.updateMatrixWorld(t);
  }
}
class Tlt extends Nt {
  constructor() {
    super(new Wa(1e5, 1e5, 2, 2), new ci({ visible: !1, wireframe: !0, side: 2, transparent: !0, opacity: 0.1, toneMapped: !1 })), this.isTransformControlsPlane = !0, this.type = "TransformControlsPlane";
  }
  updateMatrixWorld(t) {
    let e = this.space;
    switch (this.position.copy(this.worldPosition), this.mode === "scale" && (e = "local"), $g.copy(Ad).applyQuaternion(e === "local" ? this.worldQuaternion : _v), vd.copy(Pl).applyQuaternion(e === "local" ? this.worldQuaternion : _v), yd.copy(Cd).applyQuaternion(e === "local" ? this.worldQuaternion : _v), gn.copy(vd), this.mode) {
      case "translate":
      case "scale":
        switch (this.axis) {
          case "X":
            gn.copy(this.eye).cross($g), Xs.copy($g).cross(gn);
            break;
          case "Y":
            gn.copy(this.eye).cross(vd), Xs.copy(vd).cross(gn);
            break;
          case "Z":
            gn.copy(this.eye).cross(yd), Xs.copy(yd).cross(gn);
            break;
          case "XY":
            Xs.copy(yd);
            break;
          case "YZ":
            Xs.copy($g);
            break;
          case "XZ":
            gn.copy(yd), Xs.copy(vd);
            break;
          case "XYZ":
          case "E":
            Xs.set(0, 0, 0);
        }
        break;
      default:
        Xs.set(0, 0, 0);
    }
    Xs.length() === 0 ? this.quaternion.copy(this.cameraQuaternion) : (fI.lookAt(xi.set(0, 0, 0), Xs, gn), this.quaternion.setFromRotationMatrix(fI)), super.updateMatrixWorld(t);
  }
}
const Qz = "section-box-drag-start", t4 = "section-box-drag-end";
class Elt extends R0 {
  constructor(t) {
    super(), this.viewer = t, this.viewer.speckleRenderer.renderer.localClippingEnabled = !0, this.dragging = !1, this.display = new bi(), this.display.name = "SectionBox", this.display.layers.set(pn.PROPS), this.viewer.speckleRenderer.scene.add(this.display), this.boxGeometry = this._generateSimpleCube(5, 5, 5), this.material = new Ds({ color: 65535, opacity: 0, wireframe: !1, side: 2 }), this.cube = new Nt(this.boxGeometry, this.material), this.cube.visible = !1, this.cube.layers.set(pn.PROPS), this.display.add(this.cube), this.boxHelper = new aO(this.cube, 681727), this.boxHelper.material.opacity = 0.4, this.boxHelper.layers.set(pn.PROPS), this.display.add(this.boxHelper);
    const e = new Va(0.01, 10, 10);
    this.sphere = new Nt(e, new Ds({ color: 65535 })), this.sphere.layers.set(pn.PROPS), this.sphere.visible = !1, this.display.add(this.sphere), this.plane = new Wa(1, 1), this.hoverPlane = new Nt(this.plane, new Ds({ transparent: !0, side: 2, opacity: 0.1, wireframe: !1, color: 681727, metalness: 0.1, roughness: 0.75 })), this.hoverPlane.visible = !1, this.hoverPlane.layers.set(pn.PROPS), this.display.add(this.hoverPlane), this.dragging = !1, this._setupControls(), this.sidesSimple = { 256: { verts: [1, 2, 5, 6], axis: "x" }, 152: { verts: [1, 2, 5, 6], axis: "x" }, 407: { verts: [0, 3, 4, 7], axis: "x" }, 703: { verts: [0, 3, 4, 7], axis: "x" }, 327: { verts: [2, 3, 6, 7], axis: "y" }, 726: { verts: [2, 3, 6, 7], axis: "y" }, 450: { verts: [0, 1, 4, 5], axis: "y" }, "051": { verts: [0, 1, 4, 5], axis: "y" }, 312: { verts: [0, 1, 3, 2], axis: "z" }, "013": { verts: [0, 1, 3, 2], axis: "z" }, 546: { verts: [4, 5, 7, 6], axis: "z" }, 647: { verts: [4, 5, 7, 6], axis: "z" } }, this._generateOrUpdatePlanes(), this.currentRange = null, this.prevPosition = null, this.attachedToBox = !0, this.selectionHelper = new vlt(this.viewer, { subset: [this.cube], hover: !1, checkForSectionBoxInclusion: !1 }), this.selectionHelper.on(tn.ObjectClicked, this._clickHandler.bind(this)), this.selectionHelper.on("hovered", () => {
    }), document.addEventListener("keydown", (n) => {
      n.key === "Escape" && this.viewer.mouseOverRenderer && this._attachControlsToBox();
    }), this._attachControlsToBox(), this.viewer.on("projection-change", (function() {
      this._setupControls(), this._attachControlsToBox();
    }).bind(this));
  }
  _setupControls() {
    var t, e;
    (t = this.controls) == null || t.dispose(), (e = this.controls) == null || e.detach(), this.controls = new ylt(this.viewer.cameraHandler.activeCam.camera, this.viewer.speckleRenderer.renderer.domElement);
    for (let n = 0; n < this.controls.children.length; n++)
      this.controls.children[n].traverse((r) => {
        r.layers.set(pn.PROPS);
      });
    this.controls.getRaycaster().layers.set(pn.PROPS), this.controls.setSize(0.75), this.display.add(this.controls), this.controls.addEventListener("change", this._draggingChangeHandler.bind(this)), this.controls.addEventListener("dragging-changed", (n) => {
      if (!this.display.visible)
        return;
      const r = !!n.value;
      r ? (this.emit(Qz), this.dragging = r, this.viewer.cameraHandler.enabled = !r) : (this.emit(t4), setTimeout(() => {
        this.dragging = r, this.viewer.cameraHandler.enabled = !r;
      }, 100));
    }), this.viewer.needsRender = !0;
  }
  _draggingChangeHandler() {
    if (this.display.visible) {
      if (this.boxHelper.update(), this.dragging && this.currentRange) {
        this._generateOrUpdatePlanes(), this.prevPosition === null && (this.prevPosition = this.hoverPlane.position.clone()), this.prevPosition.sub(this.hoverPlane.position), this.prevPosition.negate();
        const t = this.boxGeometry.attributes.position.array;
        for (let e = 0; e < this.currentRange.length; e++) {
          const n = this.currentRange[e];
          t[3 * n] += this.prevPosition.x, t[3 * n + 1] += this.prevPosition.y, t[3 * n + 2] += this.prevPosition.z;
        }
        this.prevPosition = this.hoverPlane.position.clone(), this.boxGeometry.attributes.position.needsUpdate = !0, this.boxGeometry.computeVertexNormals(), this.boxGeometry.computeBoundingBox(), this.boxGeometry.computeBoundingSphere();
      }
      if (this.dragging && !this.currentRange) {
        this._generateOrUpdatePlanes(), this.prevPosition === null && (this.prevPosition = this.sphere.position.clone()), this.prevPosition.sub(this.sphere.position), this.prevPosition.negate();
        for (let t = 0; t < this.boxGeometry.attributes.position.array.length; t += 3)
          this.boxGeometry.attributes.position.array[t] += this.prevPosition.x, this.boxGeometry.attributes.position.array[t + 1] += this.prevPosition.y, this.boxGeometry.attributes.position.array[t + 2] += this.prevPosition.z;
        this.boxGeometry.attributes.position.needsUpdate = !0, this.boxGeometry.computeVertexNormals(), this.boxGeometry.computeBoundingBox(), this.boxGeometry.computeBoundingSphere(), this.prevPosition = this.sphere.position.clone();
      }
      this.viewer.needsRender = !0, this.viewer.emit("section-box-changed", this.getCurrentBox()), this.viewer.requestRender();
    }
  }
  _clickHandler(t) {
    if (this.viewer.cameraHandler.orbiting || this.dragging)
      return;
    if (t.length === 0 && !this.dragging)
      return this._attachControlsToBox(), this.boxHelper.material.opacity = 0.5, void (this.attachedToBox = !0);
    this.attachedToBox = !1, this.boxHelper.material.opacity = 0.3, this.hoverPlane.visible = !0;
    const e = this.sidesSimple[`${t[0].face.a}${t[0].face.b}${t[0].face.c}`];
    this.controls.showX = e.axis === "x", this.controls.showY = e.axis === "y", this.controls.showZ = e.axis === "z", this.currentRange = e.verts;
    const n = this.boxGeometry.attributes.position;
    let r = 0;
    const s = this.plane.attributes.position.array, a = new D(), o = [];
    for (let l = 0; l < s.length; l++)
      l % 3 == 0 ? o.push(n.getX(this.currentRange[r])) : l % 3 == 1 ? o.push(n.getY(this.currentRange[r])) : l % 3 == 2 && (o.push(n.getZ(this.currentRange[r])), a.add(new D(o[l - 2], o[l - 1], o[l])), r++);
    a.multiplyScalar(0.25), this.hoverPlane.position.copy(a.applyMatrix4(this.cube.matrixWorld)), this.prevPosition = this.hoverPlane.position.clone(), r = 0;
    for (let l = 0; l < s.length; l++)
      l % 3 == 0 ? s[l] = n.getX(this.currentRange[r]) - a.x : l % 3 == 1 ? s[l] = n.getY(this.currentRange[r]) - a.y : l % 3 == 2 && (s[l] = n.getZ(this.currentRange[r]) - a.z, r++);
    this.plane.applyMatrix4(this.cube.matrixWorld), this.plane.attributes.position.needsUpdate = !0, this.plane.computeBoundingSphere(), this.plane.computeBoundingBox(), this.controls.detach(), this.controls.attach(this.hoverPlane), this.controls.updateMatrixWorld();
  }
  _generateSimpleCube(t = 0.5, e = 0.5, n = 0.5) {
    const r = [[-1 * t, -1 * e, -1 * n], [1 * t, -1 * e, -1 * n], [1 * t, 1 * e, -1 * n], [-1 * t, 1 * e, -1 * n], [-1 * t, -1 * e, 1 * n], [1 * t, -1 * e, 1 * n], [1 * t, 1 * e, 1 * n], [-1 * t, 1 * e, 1 * n]], s = [];
    for (const o of r)
      s.push(...o);
    const a = new _e();
    return a.setAttribute("position", new Ze(new Float32Array(s), 3)), a.setIndex([0, 1, 3, 3, 1, 2, 1, 5, 2, 2, 5, 6, 5, 4, 6, 6, 4, 7, 4, 0, 7, 7, 0, 3, 3, 2, 7, 7, 2, 6, 4, 5, 0, 0, 5, 1]), a.computeVertexNormals(), a;
  }
  _generateOrUpdatePlanes() {
    this.planes = this.planes || [new Hn(), new Hn(), new Hn(), new Hn(), new Hn(), new Hn()];
    let t = 0;
    const e = this.boxGeometry.attributes.position, n = [0, 1, 3, 3, 1, 2, 1, 5, 2, 2, 5, 6, 5, 4, 6, 6, 4, 7, 4, 0, 7, 7, 0, 3, 3, 2, 7, 7, 2, 6, 4, 5, 0, 0, 5, 1];
    for (let r = 0; r < n.length; r += 6) {
      const s = new D(e.getX(n[r]), e.getY(n[r]), e.getZ(n[r])), a = new D(e.getX(n[r + 1]), e.getY(n[r + 1]), e.getZ(n[r + 1])), o = new D(e.getX(n[r + 2]), e.getY(n[r + 2]), e.getZ(n[r + 2]));
      this.planes[t].setFromCoplanarPoints(s, a, o), t++;
    }
    this.viewer.emit("section-box-updated", this.getCurrentBox());
  }
  _attachControlsToBox() {
    this.controls.detach();
    const t = new D(), e = this.boxGeometry.attributes.position.array;
    for (let n = 0; n < e.length; n += 3)
      t.add(new D(e[n], e[n + 1], e[n + 2]));
    t.multiplyScalar(1 / 8), this.sphere.position.copy(t), this.cube.geometry.computeBoundingSphere(), this.cube.geometry.computeBoundingBox(), this.controls.attach(this.sphere), this.currentRange = null, this.prevPosition = null, this.hoverPlane.visible = !1, this.controls.showX = !0, this.controls.showY = !0, this.controls.showZ = !0;
  }
  setBox(t, e = 0.05) {
    let n;
    n = t || new ke(new D(-1, -1, -1), new D(1, 1, 1)), n.min.x === 1 / 0 && (n = new ke(new D(-1, -1, -1), new D(1, 1, 1)));
    const r = n.min.x - (n.max.x - n.min.x) * e, s = n.min.y - (n.max.y - n.min.y) * e, a = n.min.z - (n.max.z - n.min.z) * e, o = n.max.x + (n.max.x - n.min.x) * e, l = n.max.y + (n.max.y - n.min.y) * e, c = n.max.z + (n.max.z - n.min.z) * e, u = [r, s, a, o, s, a, o, l, a, r, l, a, r, s, c, o, s, c, o, l, c, r, l, c], h = this.boxGeometry.attributes.position.array;
    for (let p = 0; p < u.length; p++)
      h[p] = u[p];
    this.boxGeometry.attributes.position.needsUpdate = !0, this.boxGeometry.computeVertexNormals(), this.boxGeometry.computeBoundingBox(), this.boxGeometry.computeBoundingSphere(), this._generateOrUpdatePlanes(), this._attachControlsToBox(), this.boxHelper.update(), this.viewer.emit("section-box-changed", this.getCurrentBox()), this.viewer.needsRender = !0;
  }
  toggle() {
    this.display.visible = !this.display.visible, this.viewer.speckleRenderer.renderer.localClippingEnabled = this.display.visible, this.viewer.emit("section-box-changed", this.getCurrentBox()), this.viewer.needsRender = !0;
  }
  disable() {
    this.display.visible = !1, this.viewer.speckleRenderer.renderer.localClippingEnabled = !1, this.viewer.emit("section-box-changed", this.getCurrentBox()), this.viewer.needsRender = !0;
  }
  enable() {
    this.display.visible = !0, this.viewer.speckleRenderer.renderer.localClippingEnabled = !0, this.viewer.emit("section-box-changed", this.getCurrentBox()), this.viewer.needsRender = !0;
  }
  displayOff() {
    this.display.visible = !1;
  }
  displayOn() {
    this.display.visible = !0;
  }
  getCurrentBox() {
    return this.display.visible ? new ke().setFromBufferAttribute(this.boxGeometry.attributes.position) : null;
  }
}
const e4 = function(i) {
  const t = {};
  for (const e in i) {
    if (["id", "__closure", "__parents", "bbox", "totalChildrenCount"].includes(e))
      continue;
    const n = i[e];
    if (n != null && !Array.isArray(n))
      if (n.constructor !== Object)
        ["string", "number", "boolean"].includes(typeof n) && (t[e] = n);
      else {
        const r = e4(n);
        for (const s in r)
          t[`${e}.${s}`] = r[s];
      }
  }
  return i.id && (t.id = i.id), t;
}, Ph = class Ph {
  static getProperties(t = null, e = !1) {
    let n = Ph.WT.root;
    if (!e && this.propCache[t || n.model.id])
      return this.propCache[t || n.model.id];
    if (t) {
      const a = n.children.find((o) => o.model.id === t);
      if (!a)
        throw new Error(`Could not find root node for ${t} - is it loaded?`);
      n = a;
    }
    const r = {};
    Ph.WT.walk((a) => {
      if (!a.model.atomic)
        return !0;
      const o = e4(a.model.raw);
      for (const l in o)
        Array.isArray(o[l]) || (r[l] || (r[l] = []), r[l].push({ value: o[l], id: o.id }));
    }, n);
    const s = [];
    for (const a in r) {
      const o = r[a], l = {};
      if (l.key = a, l.type = typeof o[0].value == "string" ? "string" : "number", l.objectCount = o.length, l.type === "string") {
        const c = l, u = {};
        for (const { value: h, id: p } of o)
          u[h] || (u[h] = []), u[h].push(p);
        c.valueGroups = [];
        for (const h in u)
          c.valueGroups.push({ value: h, ids: u[h] });
        c.valueGroups = c.valueGroups.sort((h, p) => h.value.localeCompare(p.value));
      }
      if (l.type === "number") {
        const c = l;
        c.min = Number.MAX_VALUE, c.max = Number.MIN_VALUE;
        for (const { value: u } of o)
          u < c.min && (c.min = u), u > c.max && (c.max = u);
        c.valueGroups = o.sort((u, h) => u.value - h.value);
      }
      s.push(l);
    }
    return this.propCache[n.model.id] = s, s;
  }
};
U(Ph, "WT", Qt.getInstance()), U(Ph, "propCache", {});
let zb = Ph;
class Alt {
  constructor() {
    U(this, "renderer");
  }
  setContext(t) {
    this.renderer = t;
  }
  solve(t) {
    switch (t.operation) {
      case "Occlusion":
        return this.solveOcclusion(t);
      case "Pick":
        return this.solvePick(t);
      default:
        De.error("Malformed query");
    }
  }
  solveOcclusion(t) {
    const e = new D(t.point.x, t.point.y, t.point.z), n = new D().copy(e).sub(this.renderer.camera.position);
    n.normalize();
    const r = new Uo(this.renderer.camera.position, n), s = this.renderer.intersections.intersectRay(this.renderer.scene, this.renderer.camera, r, !0, this.renderer.currentSectionBox, [pn.STREAM_CONTENT_MESH]);
    if (!s || s.length === 0)
      return { objects: null };
    const a = this.renderer.queryHitIds(s);
    if (!a)
      return { objects: null };
    let o = this.renderer.camera.position.distanceTo(e);
    return o -= t.tolerance, o < s[0].distance ? { objects: null } : { objects: [{ guid: a[0].nodeId, point: a[0].point }] };
  }
  solvePick(t) {
    const e = this.renderer.intersections.intersect(this.renderer.scene, this.renderer.camera, new wt(t.point.x, t.point.y), !0, this.renderer.currentSectionBox);
    return e ? { objects: this.renderer.queryHits(e).map((n) => ({ guid: n.node.model.id, object: n.node.model.raw, point: n.point })) } : null;
  }
}
class Clt {
  constructor() {
    U(this, "renderer");
  }
  setContext(t) {
    this.renderer = t;
  }
  solve(t) {
    switch (t.operation) {
      case "Project":
        return this.solveProjection(t);
      case "Unproject":
        return this.solveUnprojection(t);
      default:
        De.error("Malformed query");
    }
  }
  solveProjection(t) {
    const e = new D(t.point.x, t.point.y, t.point.z);
    return e.project(this.renderer.camera), { x: e.x, y: e.y, z: e.z };
  }
  solveUnprojection(t) {
    const e = new D(t.point.x, t.point.y, t.point.z);
    return e.unproject(this.renderer.camera), { x: e.x, y: e.y, z: e.z };
  }
}
class Ao {
  static isPointQuery(t) {
    return t.operation === "Project" || t.operation === "Unproject";
  }
  static isIntersectionQuery(t) {
    return t.operation === "Occlusion" || t.operation === "Pick";
  }
}
U(Ao, "DefaultPointQuerySolver", new Clt()), U(Ao, "DefaultIntersectionQuerySolver", new Alt());
class Plt {
  constructor(t) {
    U(this, "viewer");
    U(this, "raycaster");
    U(this, "mouse");
    U(this, "intersects");
    U(this, "drawingLine");
    U(this, "markers");
    U(this, "textDoms");
    U(this, "pointsDom");
    U(this, "lineId");
    U(this, "camera");
    U(this, "_anchorLayer");
    U(this, "adrees");
    U(this, "_onClick", (t) => {
      if (t.button === 0) {
        if (this.intersects = this.getInsert(), this.intersects.length === 0)
          return;
        if (this.drawingLine) {
          let e = this.markers[this.lineId][2];
          e.oldMaterial = e.material, e.material = new Ar({ color: 16733525, transparent: !0, depthTest: !1 }), this.updateLinePoint(e, this.intersects[0].point, 3);
          let [n, r] = this.pointsDom[this.lineId];
          n.style.pointerEvents = "unset", r.style.pointerEvents = "unset", this.draggablePoint(n, this.lineId), this.draggablePoint(r, this.lineId), this.lineId++, this.drawingLine = !1;
        } else {
          let e = document.createElement("span");
          e.style.position = "absolute", e.style.top = "0", e.style.color = "red", e.style.pointerEvents = "none";
          let n = e.cloneNode();
          document.body.appendChild(e), document.body.appendChild(n), this.textDoms[this.lineId] = [e, n];
          let r = document.createElement("div");
          r.style.position = "absolute", r.style.width = "10px", r.style.height = "10px", r.style.borderRadius = "50%", r.style.pointerEvents = "none", r.style.cursor = "pointer", r.style.transform = "translate(-50%,-50%)", r.style.top = "0", r.style.background = "orange";
          let s = r.cloneNode();
          document.body.appendChild(r), document.body.appendChild(s), this.pointsDom[this.lineId] = [r, s];
          let a = new Nt(new Va(0.1, 10, 20), new ci({ color: 16733525 })), o = a.clone();
          this.markers[this.lineId] = [a, o], this._anchorLayer.add(a, o);
          const l = new _e().setFromPoints([this.intersects[0].point, this.intersects[0].point.clone()]);
          let c = new Ts(l, new Jb({ color: 16733525, transparent: !0, depthTest: !1, dashSize: 0.1, gapSize: 0.1 }));
          c.layers.set(3), c.frustumCulled = !1, this.markers[this.lineId].push(c), this._anchorLayer.add(c), a.lineId = o.lineId = c.lineId = this.lineId, this.drawingLine = !0;
          let u = this.lineId;
          c.onBeforeRender = () => {
            const h = c.geometry.attributes.position.array, p = new D(h[0], h[1], h[2]), f = new D(h[3], h[4], h[5]), v = p.distanceTo(f);
            let [m, y] = this.textDoms[u];
            y.innerHTML = v.toFixed(2) + "m";
            let _ = new D().lerpVectors(p, f, 0), w = new D().lerpVectors(p, f, 1);
            _ = this.WorldtoScreenPosition(_), w = this.WorldtoScreenPosition(w), y.style.left = w.x + "px", y.style.top = w.y + 65 + "px";
            let [b, T] = this.pointsDom[u];
            _ = this.WorldtoScreenPosition(p), w = this.WorldtoScreenPosition(f), b.style.left = _.x + this.adrees.left + "px", b.style.top = _.y + this.adrees.top + "px", T.style.left = w.x + this.adrees.left + "px", T.style.top = w.y + this.adrees.top + "px";
          };
        }
      }
    });
    U(this, "_onMouseMove", (t) => {
      if (t.preventDefault(), this.adrees = this.viewer.speckleRenderer.container.getBoundingClientRect(), this.mouse.x = (t.clientX - this.adrees.left) / this.adrees.width * 2 - 1, this.mouse.y = -(t.clientY - this.adrees.top) / this.adrees.height * 2 + 1, this.drawingLine) {
        if (this.intersects = this.getInsert(), this.intersects.length === 0)
          return;
        let e = this.markers[this.lineId][2];
        e.computeLineDistances(), this.updateLinePoint(e, this.intersects[0].point, 3);
      }
    });
    this.viewer = t, this.camera = this.viewer.speckleRenderer.camera, this.raycaster = new iu(), this.mouse = new wt(), this._anchorLayer = new bi(), this._anchorLayer.layers.set(3), this.viewer.speckleRenderer.scene.add(this._anchorLayer), this.drawingLine = !1, this.markers = {}, this.textDoms = {}, this.pointsDom = {}, this.lineId = 0;
  }
  start() {
    this._bindEvent();
  }
  cancel() {
    this._unbindEvent(), this.viewer.speckleRenderer.scene.remove(this._anchorLayer);
    let t = [];
    for (let e of Object.values(this.textDoms))
      t = [...t, ...e];
    for (let e of Object.values(this.pointsDom))
      t = [...t, ...e];
    t.forEach((e) => e.remove()), t = [], this.markers = {}, this.textDoms = {}, this.pointsDom = {};
  }
  _bindEvent() {
    this.viewer.speckleRenderer.renderer.domElement.addEventListener("click", this._onClick, !1), document.addEventListener("mousemove", this._onMouseMove, !1);
  }
  _unbindEvent() {
    this.viewer.speckleRenderer.renderer.domElement.removeEventListener("click", this._onClick, !1), document.removeEventListener("mousemove", this._onMouseMove, !1);
  }
  draggablePoint(t, e) {
    let n = null, r = this.pointsDom[e].findIndex((l) => l === t), s = this.markers[e][2];
    t.addEventListener("mousedown", (l) => {
      n = setTimeout(() => {
        console.log("长按"), this.changeMaterial(s), n = null, document.addEventListener("mousemove", a);
      }, 100), document.addEventListener("mouseup", o);
    });
    const a = () => {
      if (this.intersects = this.getInsert(), this.intersects = this.intersects.filter((c) => !("lineId" in c.object)), this.intersects.length === 0)
        return;
      let l = r && 3;
      this.updateLinePoint(s, this.intersects[0].point, l);
    }, o = () => {
      n ? (console.log("点击"), clearTimeout(n), n = null) : this.changeMaterial(s), document.removeEventListener("mouseup", o), document.removeEventListener("mousemove", a);
    };
  }
  changeMaterial(t) {
    let e = t.oldMaterial;
    t.oldMaterial = t.material, t.material = e;
  }
  updateLinePoint(t, e, n) {
    const r = t.geometry.attributes.position.array;
    r[n] = e.x, r[n + 1] = e.y, r[n + 2] = e.z, t.geometry.attributes.position.needsUpdate = !0;
  }
  WorldtoScreenPosition(t) {
    const e = new D(t.x, t.y, t.z).project(this.camera), n = this.viewer.speckleRenderer.renderer.domElement.width / 2, r = this.viewer.speckleRenderer.renderer.domElement.height / 2;
    return { x: Math.round(e.x * n + n), y: Math.round(-e.y * r + r), z: 1 };
  }
  getInsert() {
    return this.viewer.speckleRenderer._intersections.intersect(this.viewer.speckleRenderer.scene, this.viewer.cameraHandler.activeCam.camera, this.mouse, !0) || [];
  }
}
class Dlt extends Qa {
  constructor(t, e) {
    super();
    const n = _M;
    this.map = t, this.opacity = e !== void 0 ? e : 1, this.uniforms = Jn.clone(n.uniforms), this.material = new Gn({ uniforms: this.uniforms, vertexShader: n.vertexShader, fragmentShader: n.fragmentShader, depthTest: !1, depthWrite: !1 }), this.needsSwap = !1, this.fsQuad = new oc(null);
  }
  render(t, e, n) {
    const r = t.autoClear;
    t.autoClear = !1, this.fsQuad.material = this.material, this.uniforms.opacity.value = this.opacity, this.uniforms.tDiffuse.value = this.map, this.material.transparent = this.opacity < 1, t.setRenderTarget(this.renderToScreen ? null : n), this.clear && t.clear(), this.fsQuad.render(t), t.autoClear = r;
  }
  dispose() {
    this.material.dispose(), this.fsQuad.dispose();
  }
}
const Kw = 1, mI = 2, gI = 1, Rlt = 2;
var Ul;
let I0 = (Ul = class extends R0 {
  constructor(e, n = Oi) {
    super();
    U(this, "container");
    U(this, "stats");
    U(this, "startupParams");
    U(this, "speckleRenderer");
    U(this, "filteringManager");
    U(this, "sectionBox");
    U(this, "cameraHandler");
    U(this, "inProgressOperations");
    U(this, "clock");
    U(this, "loaders", {});
    U(this, "utils");
    U(this, "measureDistance");
    U(this, "mixer");
    U(this, "clips");
    U(this, "viewe_mode", Kw);
    De.useDefaults(), De.setLevel(n.verbose ? De.TRACE : De.ERROR), As.keepGeometryData = n.keepGeometryData, this.container = e || document.getElementById("renderer"), n.showStats && (this.stats = FU(), this.container.appendChild(this.stats.dom)), this.loaders = {}, this.startupParams = n, this.clock = new Cv(), this.inProgressOperations = 0, this.cameraHandler = new Uot(this), this.speckleRenderer = new glt(this), this.speckleRenderer.create(this.container), window.addEventListener("resize", this.resize.bind(this), !1), new $l(this.speckleRenderer.renderer), this.filteringManager = new dat(this.speckleRenderer), this.sectionBox = new Elt(this), this.sectionBox.disable(), this.on(tn.SectionBoxUpdated, () => {
      this.speckleRenderer.updateClippingPlanes(this.sectionBox.planes);
    }), this.sectionBox.on(Qz, this.speckleRenderer.onSectionBoxDragStart.bind(this.speckleRenderer)), this.sectionBox.on(t4, this.speckleRenderer.onSectionBoxDragEnd.bind(this.speckleRenderer)), this.frame(), this.resize(), this.on(tn.LoadCancelled, (r) => {
      De.warn(`Cancelled load for ${r}`);
    }), this.on(tn.LoadComplete, (r) => {
    });
  }
  static get World() {
    return this.world;
  }
  get Utils() {
    return this.utils || (this.utils = { screenToNDC: this.speckleRenderer.screenToNDC.bind(this.speckleRenderer), NDCToScreen: this.speckleRenderer.NDCToScreen.bind(this.speckleRenderer) }), this.utils;
  }
  setSectionBox(e, n) {
    e || (e = this.speckleRenderer.sceneBox), this.sectionBox.setBox(e, n), this.speckleRenderer.updateSectionBoxCapper();
  }
  setSectionBoxFromObjects(e, n) {
    this.setSectionBox(this.speckleRenderer.boxFromObjects(e), n);
  }
  getCurrentSectionBox() {
    return this.sectionBox.getCurrentBox();
  }
  resize() {
    const e = this.container.offsetWidth, n = this.container.offsetHeight;
    this.speckleRenderer.resize(e, n);
  }
  requestRender() {
    this.speckleRenderer.needsRender = !0, this.speckleRenderer.resetPipeline();
  }
  frame() {
    this.update(), this.render();
  }
  update() {
    const e = this.clock.getDelta();
    this.mixer && this.mixer.update(e), this.speckleRenderer.update(e), requestAnimationFrame(this.frame.bind(this));
  }
  render() {
    this.speckleRenderer._needsRender = !0, this.speckleRenderer.render();
  }
  async init() {
    const e = new Yd(this.speckleRenderer.renderer);
    e.compileEquirectangularShader();
    const n = e.fromScene(new UU(), 1).texture;
    this.speckleRenderer.indirectIBL = n;
  }
  initWateMark() {
    const e = new Dlt();
    new o0().load("https://3dx.nsdt.cloud/download/nstdtest.png", function(n) {
      e.map = n, e.opacity = 0.6;
    }), this.speckleRenderer.pipeline.insertPass(e, 0);
  }
  on(e, n) {
    super.on(e, n);
  }
  getObjectProperties(e = null, n = !0) {
    return zb.getProperties(e, n);
  }
  selectObjects(e) {
    return new Promise((n) => {
      n(this.filteringManager.selectObjects(e));
    });
  }
  resetSelection() {
    return new Promise((e) => {
      e(this.filteringManager.resetSelection());
    });
  }
  hideObjects(e, n = null, r = !1, s = !1) {
    return new Promise((a) => {
      a(this.filteringManager.hideObjects(e, n, r, s));
    });
  }
  showObjects(e, n = null, r = !1) {
    return new Promise((s) => {
      s(this.filteringManager.showObjects(e, n, r));
    });
  }
  isolateObjects(e, n = null, r = !1, s = !0) {
    return new Promise((a) => {
      a(this.filteringManager.isolateObjects(e, n, r, s));
    });
  }
  unIsolateObjects(e, n = null, r = !1) {
    return new Promise((s) => {
      s(this.filteringManager.unIsolateObjects(e, n, r));
    });
  }
  highlightObjects(e, n = !1) {
    return new Promise((r) => {
      r(this.filteringManager.highlightObjects(e, n));
    });
  }
  resetHighlight() {
    return new Promise((e) => {
      e(this.filteringManager.resetHighlight());
    });
  }
  setColorFilter(e, n = !0) {
    return new Promise((r) => {
      r(this.filteringManager.setColorFilter(e, n));
    });
  }
  removeColorFilter() {
    return new Promise((e) => {
      e(this.filteringManager.removeColorFilter());
    });
  }
  setUserObjectColors(e) {
    return new Promise((n) => {
      n(this.filteringManager.setUserObjectColors(e));
    });
  }
  resetFilters() {
    return new Promise((e) => {
      e(this.filteringManager.reset());
    });
  }
  async applyFilter(e) {
  }
  getDataTree() {
    return Qt.getDataTree();
  }
  query(e) {
    return Ao.isPointQuery(e) ? (Ao.DefaultPointQuerySolver.setContext(this.speckleRenderer), Ao.DefaultPointQuerySolver.solve(e)) : Ao.isIntersectionQuery(e) ? (Ao.DefaultIntersectionQuerySolver.setContext(this.speckleRenderer), Ao.DefaultIntersectionQuerySolver.solve(e)) : void 0;
  }
  queryAsync(e) {
    return null;
  }
  toggleSectionBox() {
    this.sectionBox.toggle(), this.speckleRenderer.updateSectionBoxCapper();
  }
  sectionBoxOff() {
    this.sectionBox.disable(), this.speckleRenderer.updateSectionBoxCapper();
  }
  sectionBoxOn() {
    this.sectionBox.enable(), this.speckleRenderer.updateSectionBoxCapper();
  }
  zoom(e, n, r) {
    this.speckleRenderer.zoom(e, n, r);
  }
  setProjectionMode(e) {
    this.cameraHandler.activeCam = e;
  }
  toggleCameraProjection() {
    this.cameraHandler.toggleCameras(), this.speckleRenderer.resetPipeline(!0);
  }
  toggleZXAxisUpFixed() {
    this.cameraHandler.setZUpOrYUp(), this.speckleRenderer.resetPipeline(!0), this.speckleRenderer.updateShadowCatcher();
  }
  setLightConfiguration(e) {
    this.speckleRenderer.setSunLightConfiguration(e);
  }
  getViews() {
    return Qt.getInstance().findAll((e) => {
      var n;
      return ((n = e.model.renderView) == null ? void 0 : n.speckleType) === li.View3D;
    }).map((e) => ({ name: e.model.raw.applicationId, id: e.model.id, view: e.model.raw }));
  }
  setView(e, n = !0) {
    this.speckleRenderer.setView(e, n);
  }
  screenshot() {
    return new Promise((e) => {
      const n = this.sectionBox.display.visible;
      n && this.sectionBox.displayOff();
      const r = this.speckleRenderer.renderer.domElement.toDataURL("image/png");
      n && this.sectionBox.displayOn(), e(r);
    });
  }
  async downloadObject(e, n = null, r = !0) {
    try {
      ++this.inProgressOperations == 1 && this.emit(tn.Busy, !0);
      const s = new NR(this, e, n, r);
      this.loaders[e] = s, await s.load();
    } finally {
      --this.inProgressOperations == 0 && this.emit(tn.Busy, !1);
    }
  }
  static async testLoad(e, n = null, r = !0) {
    const s = new NR(new Ul(), e, n, r);
    this.loaders[e] = s, await s.load(), await this.downloadObject(e, n, r), Qt.getRenderTree(e).buildRenderTree(), new Zz().makeBatches(e, SpeckleTypeAllRenderables);
  }
  async loadObject(e, n = null, r = !0) {
    var a, o, l, c, u, h;
    await this.downloadObject(e, n, r);
    let s = performance.now();
    Qt.getRenderTree(e).buildRenderTree(), De.log("SYNC Tree build time -> ", performance.now() - s), s = performance.now(), await this.speckleRenderer.addRenderTree(e, n), De.log("SYNC batch build time -> ", performance.now() - s), this.zoom(), this.speckleRenderer.resetPipeline(!0), this.emit(tn.LoadComplete, e), this.loaders[e].dispose(), delete this.loaders[e];
    try {
      this.startupParams.animationType !== Rlt && this.startupParams.animationType !== gI || this.initAnimationClips(), ((h = (u = (c = (l = (o = (a = Qt.getInstance()) == null ? void 0 : a._root) == null ? void 0 : o.children[0]) == null ? void 0 : l.model) == null ? void 0 : c.raw) == null ? void 0 : u.up) == null ? void 0 : h.y) === 1 && this.toggleZXAxisUpFixed(), this.initWateMark();
    } catch (p) {
      console.error(p);
    }
  }
  async loadObjectAsync(e, n = null, r = !0, s = 1) {
    await this.downloadObject(e, n, r);
    let a = performance.now();
    const o = await Qt.getRenderTree(e).buildRenderTreeAsync(s);
    De.log("ASYNC Tree build time -> ", performance.now() - a), o && (a = performance.now(), await this.speckleRenderer.addRenderTreeAsync(e, s, n), De.log("ASYNC batch build time -> ", performance.now() - a), this.speckleRenderer.resetPipeline(!0), this.emit(tn.LoadComplete, e)), this.loaders[e].dispose(), delete this.loaders[e];
  }
  async cancelLoad(e, n = !1) {
    this.loaders[e].cancelLoad(), Qt.getRenderTree(e).cancelBuild(e), this.speckleRenderer.cancelRenderTree(e), n && await this.unloadObject(e);
  }
  async unloadObject(e) {
    try {
      ++this.inProgressOperations == 1 && this.emit(tn.Busy, !0), delete this.loaders[e], this.speckleRenderer.removeRenderTree(e), Qt.getRenderTree(e).purge(), Qt.getInstance().purge(e);
    } finally {
      --this.inProgressOperations == 0 && (this.emit(tn.Busy, !1), De.warn(`Removed subtree ${e}`), this.emit(tn.UnloadComplete, e));
    }
  }
  async unloadAll() {
    try {
      ++this.inProgressOperations == 1 && this.emit(tn.Busy, !0);
      for (const e of Object.keys(this.loaders))
        delete this.loaders[e];
      this.filteringManager.reset(), Qt.getInstance().root.children.forEach((e) => {
        this.speckleRenderer.removeRenderTree(e.model.id), Qt.getRenderTree().purge();
      }), Qt.getInstance().purge();
    } finally {
      --this.inProgressOperations == 0 && (this.emit(tn.Busy, !1), De.warn("Removed all subtrees"), this.emit(tn.UnloadAllComplete));
    }
  }
  dispose() {
  }
  startMeasureDistance() {
    setTimeout(() => {
      this.measureDistance = new Plt(this), this.measureDistance.start();
    }, 400);
  }
  cancleMeansureDistance() {
    this.measureDistance && this.measureDistance.cancel(), this.measureDistance = null;
  }
  initAnimationClips() {
    let e = Qt.getAnimationsClips();
    if (e && !(e.length < 1)) {
      this.mixer && (this.mixer.stopAllAction(), this.mixer.uncacheRoot(_this.mixer.getRoot()), this.mixer = null), this.mixer = new nO(this.speckleRenderer.rootGroup);
      for (let n = 0; n < e.length; n++) {
        const r = e[n];
        r.uuid = r.id;
        const s = Ih.parse(r);
        this.clips || (this.clips = []), s.resetDuration(), this.clips.push(s);
      }
      if (this.startupParams.animationType !== gI) {
        const n = this.clips[0], r = this.mixer.clipAction(n);
        r.setEffectiveTimeScale(1), r.play();
      }
    }
  }
  playAllClips() {
    this.clips.forEach((e) => {
      this.mixer.clipAction(e).reset().play();
    });
  }
  stopClip(e) {
    this.clips.forEach((n) => {
      n.name === e && this.mixer.clipAction(n).stop();
    });
  }
  playClip(e) {
    this.clips.forEach((n) => {
      n.name === e && this.mixer.clipAction(n).reset().play();
    });
  }
  stopAllClips() {
    this.mixer.stopAllAction();
  }
  getClips() {
    return this.clips;
  }
  toggleViewerMode() {
    this.viewe_mode = this.viewe_mode === Kw ? mI : Kw, this.cameraHandler.setMiddleMouse(this.viewe_mode), this.viewe_mode === mI ? (this.cameraHandler.camera.up.y === 1 && this.toggleZXAxisUpFixed(), this.setView("top"), this.cameraHandler.cameras[0].active && this.toggleCameraProjection(), this.container.children[0].style.backgroundColor = "#212830") : (this.cameraHandler.camera.up.y !== 1 && this.toggleZXAxisUpFixed(), this.cameraHandler.cameras[0].active || this.toggleCameraProjection(), this.container.children[0].style.backgroundColor = null);
  }
}, U(Ul, "world", new gM()), U(Ul, "Assets"), Ul);
class Olt extends I0 {
  constructor(e, n) {
    if (!e)
      throw new Error("viewer element not found.");
    let r;
    if (typeof e == "string" && (r = document.getElementById(e), !r))
      throw new Error("viewer element not found.");
    super(r, { showStats: (n == null ? void 0 : n.showStats) || (Oi == null ? void 0 : Oi.showStats), verbose: (n == null ? void 0 : n.verbose) || (Oi == null ? void 0 : Oi.verbose), keepGeometryData: (n == null ? void 0 : n.keepGeometryData) || (Oi == null ? void 0 : Oi.keepGeometryData), environmentSrc: (n == null ? void 0 : n.environmentSrc) || (Oi == null ? void 0 : Oi.environmentSrc), animationType: n == null ? void 0 : n.animationType, showWaterMark: n == null ? void 0 : n.showWaterMark });
    U(this, "token");
    U(this, "baseUrl", "https://tumo.nsdt.cloud");
    this.token = (n == null ? void 0 : n.token) || "15a665afd755a9ab75e28fe6a332409b6daf8a5750", n != null && n.baseUrl && (this.baseUrl = n == null ? void 0 : n.baseUrl);
  }
  setToken(e) {
    this.token = e;
  }
  setBaseUrl(e) {
    this.baseUrl = e;
  }
  async init() {
    await super.init(), this.setLightConfiguration(RB);
  }
  __getUrl(e, n) {
    if (!e || !n)
      throw new Error("streamId or objectId is undefied");
    return `${this.baseUrl}/streams/${e}/objects/${n}`;
  }
  async loadObject(e, n, r = !1) {
    Qt.clear();
    const s = this.__getUrl(e, n);
    await super.loadObject(s, this.token, r);
  }
  async loadObjectByFileId(e, n = { enableCaching: !1, streamId: "3fe0ed8b68" }) {
    if (!e)
      throw Error("fileId is need!");
    const r = `${this.baseUrl}/api/file/filecommit/${e}`, s = await fetch(r);
    let a = n.streamId || "fbdb0ea035", o = n.enableCaching || !1;
    const { referencedObject: l } = await s.json();
    await this.loadObject(a, l, o);
  }
  async loadObjectAsync(e, n, r = !1, s = 1) {
    Qt.clear();
    const a = this.__getUrl(e, n);
    await super.loadObjectAsync(a, this.token, r, s);
  }
  getObjectProps(e) {
    var n;
    if (!e) {
      const r = (n = Qt.getInstance().modeList[0]) == null ? void 0 : n.id;
      return Qt.getInstance().modeList.find((s) => {
        var a, o;
        return s.id === r && ((o = (a = s == null ? void 0 : s.raw) == null ? void 0 : a.vertices) == null ? void 0 : o.length) > 0;
      });
    }
    return Qt.getInstance().modeList.find((r) => {
      var s, a;
      return r.raw.id === e && ((a = (s = r == null ? void 0 : r.raw) == null ? void 0 : s.vertices) == null ? void 0 : a.length) > 0;
    });
  }
  startMeasureDistance() {
    super.startMeasureDistance();
  }
  stopMeasureDistance() {
    super.cancleMeansureDistance();
  }
}
export {
  Olt as default
};
